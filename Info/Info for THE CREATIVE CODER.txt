 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
   ROMANESCO PROJECT    ADVICES TO CODE
/////////////////////////////////////////

/////////////
INTRODUCTION
\\\\\\\\\\\\\
The main sketch is the Prescene, it receive slider information from Contrôleur, mouse, leapmotion, midi-controller, pen apply this one
and send a major part of the result to Scene or Miroir, who're just a slave !





// GLOBAL CODE
//////////////


///////////////////////////////
boolean testRomanesco = false ;
///////////////////////////////
Give the permit to work directly with sketch, without the launcher...
\\\\\\\\\\\\\\\\\\\\\\\\\\
this true by default when you code, don't forget change to false when you ** EXPORT ** your app, 
if you don't do that, the Prescene will not open the Scene.





// when you work only with "Prescene" boolean presceneOnly must be true to give at the Prescene the internet acces
boolean presceneOnly = false ;











 // ROMANESCO CODE
/////////////////

int IDfamily = # ;
 and give too the family ID
 1 for simple
 2 for texture
 3 for typo

 // SLIDER
 remove the slider you don't want display
 romanescoSlider = "Hue fill,Saturation fill,Brightness fill,Alpha fill,Hue stroke,Saturation stroke,Brightness stroke,Alpha stroke,Thickness,Width,Height,Depth,Canvas X,Canvas Y,Canvas Z,Quantity,Speed,Direction,Angle,Amplitude,Analyze,Family,Life,Force" ;

 there is TWO MAINS VOID in class ROMANESCO
 void setting()
 and 
 void display()
 if you use other void you must call this one in one of them






////////////////////////////
// WHERE are Romanesco work
// if you want use a different rendering on the scene or prescene, you can use this boolean.
indicate if your work on scene or prescene
boolean scene 
boolean prescene





//
boolean internet // say if internet is available
boolean modeP3D  // say if P3D render is available

int IDfamilly ;  // 1 is the simple object first sliders
                 // 2 is the texture family second group of sliders
                 // 3 is typo family third groud of sliders



//LIBRARY OR EXTERNAL CLASSES
// when you code in the class romanesco and call external class or library need (this) you must write (callingClass) :
example 
* name = new LibraryOrClass(this);) >>>
>>> become >>>
<<< name = new LibraryOrClass(callingClass);)


//CAMERA
travelling(PVector targetPos) ; // the camera go to a specific point in the scene


//OBJECT
boolean setting[IDobj] to block the setting at the beggining and when you came back to the button setting to don't go immediatly on the value slider...not finish in progress
void startPosition(int IDobj, int x, int y, int z) // give the starting position of the object on the scene, WRITE IN THE void display()


//MOTION
boolean motion[IDobj] boolean use for the move activate or desactivate by the "m" key - booleann mTouch - 

//Alignement
boolean horizon[IDobj] boolean use for the move activate or desactivate by the "h" key - booleann hTouch -

//reverse direction
boolean reverse[IDobj] use to reverse direction or what you want, activa by "r" key - boolean rTouch -

// INFO display on Prescen
boolean objectInfoDisplay[IDobj] use to display info or what you want show on Prescene or Scene from your object, activate by "i" key - boolean iTouch

//RESET
// to empty the list or reset object activate by backspace and delete
boolean resetAction(IDobj) when the Action button is On
boolean resetParameter(IDobj) when the Parameter button is On
Suggestion use Action Button for the particle and the list
and Parameter for the other reset. But it's just a suggestion












//COMMON ASSOCIATION between the controler and the prescene
// with action button
// add obj
if(actionButton[IDobj] == 1 && nTouch ) { /* yourList.add( new YourClass ()); */ }
or
int spawnFrequency = 3 ; 
if(actionButton[IDobj] == 1 && nLongTouch && frameCount % spawnFrequency == 0 ) { /* yourList.add( new YourClass ()); */ }
// motion
if(actionButton[IDobj] == 1 && mTouch ) { }
// change stuff like color palette....
if(actionButton[IDobj] == 1 && xTouch ) { }
// stop, move the mouse inside the object
if(actionButton[IDobj] == 1 && spaceTouch ) { }

//with parametter button
open folder
if ( parameterButton[IDobj] == 1 && oTouch ) { }









// INFO OBJECT
String objectName[IDobj] return the name of your object
String objectInfo[IDobj]  can be use to add info who can be display in the info option when you push "i" on the prescene
int objectID[IDobj] return the ID of the object








//STARTING POSITION
give the position of the object at the opening app
PVector startingPos[IDobj] by default this value is equal to (width/2, height/2, 0)
this void give the XYZ to
PVector startingPosition[IDobj] ;






// SOUND 
////////
float left[IDobj]  return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float right[IDobj] return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float mix[IDobj]   return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1

float beat[IDobj]    return value from 1 to 10 when the button sound is ON, the value keep the last value if the button is OFF 
float kick[IDobj]    return value from 1 to 10 when the button sound is ON, the value keep the last value if the button is OFF 
float snare[IDobj]   return value from 1 to 10 when the button sound is ON, the value keep the last value if the button is OFF 
float hat[IDobj]     return value from 1 to 10 when the button sound is ON, the value keep the last value if the button is OFF 
float allBeats(IDobj) is a some of the four beats, return value from 1 to 40 when the button sound is ON, the value keep the last value if the button is OFF 

float tempo[IDobj]      return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float tempoBeat[IDobj]  return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float tempoKick[IDobj]  return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float tempoSnare[IDobj] return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1
float tempoHat[IDobj]   return value from 0 to 1 when the sound button is ON, if it's OFF the value is 1

float getTimeTrack()  if the track is ON return the time elapse from the beginning play to now, if the track is OFF return value < 0.2

float band [IDobj][whichBand] // whichBand give the information of the band where catch the info
usualy there is 16 bands, to know the number :
bandSpectrum.length ;

////////////
// END SOUND





// MOUSE
//////////////////////
PVector mouse[IDobj] refresh with space touch
mouse[0].x // mouse[0].y // absolute position of the mouse
mouse[0].z // return info from the z axis when the leapmotion is active
mouse[IDobj].x // mouse[IDobj].y // mouse[IDobj].z // same info tha mouse[IDobj] but this one is refresh when you press the space
// MOUSE WHEEL
int wheel[IDobj]
wheel[0] and wheel[IDobj]
or use the void zoom() and take the float value getCountZoom...this value is more reactive !
// PMOUSE
PVector pmouse[IDobj]
pmouse[0] and pmouse[IDobj]


// PEN
////////////////////
PVector pen[IDobj] or pen[0] refresh with space touch
pen[IDobj].x pen[IDobj].y   // information from the tablet tilt : orientation of the pen 
pen[IDobj].z - value to 0 to 1 - information from tablet : pressure pen 


// MOUSE CLICK BOOLEAN
//////////////////////
//short click just for one shot
boolean clickShortLeft[IDobj] ;
boolean clickShortRight[IDobj] ;
//active after one mousePressed, be inactive after the mouse Released
boolean clickLongLeft[IDobj] ;
boolean clickLongLeft[IDobj] ;


//END MOUSE, PEN, LEAPMOTION
////////////////////////////



// VAR from Slider or shortcut var
/////////////////

  
VAR object from slider
color fillObj[IDobj] ; you can separate with hue, saturation, brightness and alpha
color strokeObj[IDobj] ; you can separate with hue, saturation, brightness and alpha
float thicknessObj[IDobj] ; value from 0.1 to height/3

float sizeXObj[IDobj] ; sizeYObj[IDobj] ; sizeZObj[IDobj] ; value from 0.1 to width

float canvasXObj[IDobj] ; canvasYObj[IDobj] ; canvasZObj[IDobj] value from width/10  to width

float quantityObj = new float[numObj] ; value from 1 to 100 ;

float speedObj[IDobj] ; value from 0 to 1
float directionObj[IDobj] ; value from 0 to 360
float angleObj[IDobj] ; value from 0 to 360
float amplitudeObj[IDobj] ; value from 0 to 1
float analyzeObj[IDobj] ; value from 0 to 1
float familyObj[IDobj] ; value from 1 to 118, it's atomic choice 118 is the last atom knew in 2006!
float lifeObj[IDobj] ; value from 0 to 1
float forceObj[IDobj] ; value from 0 to 1

// shortcut var
float fontSizeObj[IDobj] ; 3 to height in the release 25 work with the slider sizeXObj

void aspect(int ID) give the fill, stroke and strokeWeight

//END SLIDER
////////////






////////// UTIL /////////////////
////////////////////////////////

// UTIL MATH
float distance(PVector p0, PVector p1 ) calcul distance between two PVectors

float deg360 (PVector dir) // return a 360 direction from PVector direction value between -1 to 1 ;

PVector rotation(PVector ref, PVector lattice, float angle) // return a PVector position, for rotation around an axes

float roots(float valueToRoots, int n) // return the roots value with "n" dimension

float mapLocked(float value, float sourceMin, float sourceMax, float targetMin, float targetMax) // the return value is lock between the min and the max

float mapStartSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the begin of the curve is smoothed by the level

float mapEndSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the end of the curve is smoothed by the level

float mapEndStartSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the begin and the end of the curve is smoothed by the level


// UTIL PVECTOR
PVector gotoTarget(PVector origin,  PVector finish, float speed) 






// UTIL GEOMETRY
PVector [] circle (PVector pos, int d, int num) // return a list of points xyz to realize a circle, the first param is the position of circle, the second is the diameter, the third is the num of points to do this circle
PVector [] circle (PVector pos, int d, int num, float jitter) // same function with jitter variation

PVector pointOnCirlcle(int r, float angle) // return the position of the point on the perimeter of the circle. The first param is the radius, the second is the angle in radian (PI scale)

float perimeterCircle (int r) return perimeter

float radiusSurface(int s) return the radius with a speficic surface

float angle(PVector p0, PVector p1) calcul the angle between two PVectors

PVector normalDir(int direction) // return a direction between -1 / 1 from 360° direction






// UTIL TIME
float cycle(float add) // return value between -1 et 1 , nice to try with vzlue like 0.1

int timer(float tempo) // return an add value from float <1 ;

int minClock() // return the time of the day in minutes





// UTIL COLOR
PVector HSBtoRGB(float hue, float saturation, float brightness) convert color in the HSB world








//CLASS PIXEL
/////////////
this class is define by a lot of parameter and work in HSB, 360,100,100,100
PVector size (x,y,z)
PVector pos (x,y,z)

color colour, newColour ;

PVector wind I must define ?
float field : define the field of life (action) of the pixel, it use like a radius around the origin of the pixel
float life = 1 ; 
float timePast = 0.01 ; // this value is use to remove time from the life.

// parameter use to find the pixel in the mess
PVector gridPos(x,y) in matrix 2D // this value is use to find a specific pixel in the array
int rank
int ID


there is few different construtors
Pixel(PVector pos)
Pixel(PVector pos, color colour)
Pixel(PVector pos, PVector size)
Pixel(PVector pos, PVector size, color colour)
// INK CONTRUCTOR
Pixel(PVector pos, float field, float timePast, color colour)
Pixel(PVector pos, float field, float timePast) 
// RANK CONSTRUCTOR
Pixel(int rank, PVector gridPos) // this one is use to rank the pixel in the array
Pixel(int rank)

// FUNCTION
// must define what the role
void displayPixel(int diam) 
void displayPixel(int diam, PVector effectColor)

// UPDATE
void drying(float var)





// END CLASS PIXEL
//////////////////



// METEO
////////
boolean meteo, is false by default. If you want use in your object write this one is true.

More info check the Tab X_Module in the Meteo part in the sketch Prescene or Scene.


// END METEO
////////////








//KEYBOARD BOOLEAN command
//ATTENTION////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Don't use DELETE and the letter 'i' and 's' from the keyboard this touch is use for the main CODE for empty  all the list, display information and save picture
//ATTENTION////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//// Dedicaced and reserved key ////
///////////////////////
// P3D move
boolean cLongTouch //  use to move the camera in P3D world with the mouse function
boolean vLongTouch // use to move the object in P3D world with the mouse function
//ADD objects
boolean nTouch, nLongTouch // ADD OBJECT use this keyboard touch it's suggestion for sure !

// generaric keyborad command, it's better to don't use for others commands
boolean spaceTouch      // give the boolean condition of the space touch to active the XY mouse, pen and Leap coordinate

// backspace and delete it's better to use resetAction(ID) or resetParameter(ID)
boolean backspaceTouch  // generaly to empty a specific list of object or to reset object
boolean deleteTouch  //  specific to empty list or reset object or to reset object

boolean nTouch 			- generaly use to add a new particule like a clic depends what you want
boolean nLongTouch		- generaly use to add a new particule like a clic depends what you want
boolean mTouch		- boolean motion[IDobj] 	- generaly use to move the object, close to spaceTouch but different.
boolean oTouch 			- genrally open folder to choice a file for a specific object
boolean pTouch 			- to open an other folder, if the object already use "oTouch"
boolean hTouch 		- boolean horizon[IDobj] 	- generaly use to change the ground position for the P3D object, for example test it on the Boxolyzer object.
boolean rTouch 			- generaly use to reverse value, or to change the canvas size of object.
boolean xTouch 			- generaly use to change the coloour palette

// Free touch
boolean aTouch, bTouch, cTouch, dTouch, eTouch, fTouch, gTouch,  jTouch, kTouch, lTouch, qTouch, tTouch, uTouch, vTouch, wTouch, yTouch, zTouch,
leftTouch, rightTouch, upTouch, downTouch, 
touch0, touch1, touch2, touch3, touch4, touch5, touch6, touch7, touch8, touch9, 
enterTouch, returnTouch, shiftTouch, altTouch, escTouch ;

//END of KEYBOARD
/////////////////






// IMAGE
////////
loadImg(IDobj) void use to load and update the image
String imagePath[whichImage] ; image jpg from the dropdown menu
PImage img[IDobj] image slected from dropdown menu and confirm by the Parameter buttof of the Object

// END IMAGE
///////////







// TEXT
///////

loadText(IDobj) use to load and update the text

String textImport[IDobj] raw text selected from the folder preferences/Karaoke

textPath[whichText] ; text from the dropdown menu

int numChapters(String textImport[IDobj]) give the number of the chapter of your raw text

int numMaxSentencesByChapter(String textImport[IDobj]) give the number of sentences of the chapter have the most sentences

String whichSentence(String txt, int whichChapter, int whichSentence) return String

Romanesco call fileText.txt from the folder Karaoke from the preferences folder,
so you can write on it when you use Romanesco split function
"*" to separate the chapter 
"/" to separate the sentence





** When you code take a care to save the karaoke.txt in each folder of dev (Scene, Prescene, Mirroir) **

// END TEXT
///////////










//SECURITY LAG
///////////////
int levelSecurity = 100 ; is not finish, this value can be use to block the function, this value must be control from the Controler
////////////////////////








///////////////////////
// DISPLAY MODE render
Usualy Romanesco work in P3D mode, if one of the object is in P3D mode all the rendering is in P3D


for P3D 
if (displayMode.equals("P3D") ) {}
or
boolean modeP3D

for P2D
if (displayMode.equals("P2D") ) {}

for OPENGL
if (displayMode.equals("OPENGL") ) {}

for CLASSIC rendering
if (displayMode.equals("Classic") ) {}

//END DISPLAY MODE
//////////////////
















