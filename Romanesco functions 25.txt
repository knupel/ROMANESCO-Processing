 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
   ROMANESCO PROJECT    ADVICES TO CODE
/////////////////////////////////////////

/////////////
INTRODUCTION
\\\\\\\\\\\\\
The main sketch is the Prescene, it receive slider information from Contrôleur, mouse, leapmotion, midi-controller, pen apply this one
and send a major part of the result to Scene or Miroir, who're just a slave !

// INFORMATION
You can Romanesco with PROCESSING 211, but you must export with the 203...there is problem with few library

When you add a new object from Startcoding to the Prescene and Scene, don't forget to copy the new 



 // GLOBAL CODE
//////////////////////////
At the top of the Prescene Sketch
you find one important boolean : 
* boolean testRomanesco * Give the permit to work directly with sketch, without the launcher...
\\\\\\\\\\\\\\\\\\\\\\\\\\
this true by default when you code, don't forget change to false when you ** EXPORT ** your app, 
if you don't do that, the Prescene will not open the Scene.

// The other is more cosmetic !
boolean Controleur = true ;
boolean Scene = true ;
boolean Miroir = true ;

//to opening app
boolean openScene = true ;
boolean openMiroir = true ;
boolean openControleur = true ;

//send the information to the final app : Scene or Miroir
boolean youCanSendToScene = true ;
boolean youCanSendToMiroir = true ;

// when you work only with "Prescene" boolean presceneOnly must be true to give at the Prescene the internet acces
boolean presceneOnly = false ;

//SECURITY LAG
int levelSecurity = 100 ; is not finish, this value can be use to block the function, this value must me control from the Controler






 // ROMANESCO CODE
/////////////////

int IDfamily = # ;
 and give too the family ID
 1 for simple
 2 for texture
 3 for typo

 there is TWO MAINS VOID in class ROMANESCO
 void setting()
 and 
 void display()
 if you use other void you must call this one in one of them










boolean internet // say if internet is available
boolean modeP3D  // say if P3D render is available

int IDfamilly ;  // 1 is the simple object first sliders
                 // 2 is the texture family second group of sliders
                 // 3 is typo family third groud of sliders



//LIBRARY OR EXTERNAL CLASSES
// when you code in the class romanesco and call external class or library need (this) you must write (callingClass) :
example 
* name = new LibraryOrClass(this);) >>>
>>> become >>>
<<< name = new LibraryOrClass(callingClass);)


//CAMERA
travelling(PVector targetPos) ; // the camera go to a specific point in the scene


//OBJECT
boolean startingPosition[IDobj] // to check if it's a first use of the object, work with the void startPosition(int,int,int,int)
void startPosition(int IDobj, int x, int y, int z) // give the starting position of the object on the scene, WRITE IN THE void display()


//MOTION
boolean motion[IDobj] boolean use for the move activate or desactivate by the "m" key

//Alignement
boolean horizon[IDobj] boolean use for the move activate or desactivate by the "h" key

//LIST 
//empty the list of particules activate by backspace and delete
boolean romanescoEmptyList(IDobj)




// DISPLAY MODE render
for P3D 
if (displayMode.equals("P3D") ) {}
or
boolean modeP3D

for P2D
if (displayMode.equals("P2D") ) {}

for OPENGL
if (displayMode.equals("OPENGL") ) {}

for CLASSIC rendering
if (displayMode.equals("Classic") ) {}

//END DISPLAY MODE
//////////////////







//COMMON ASSOCIATION between the controler and the prescene
// with action button
// add obj
if(actionButton[IDobj] == 1 && nTouch ) { /* yourList.add( new YourClass ()); */ }
or
int spawnFrequency = 3 ; 
if(actionButton[IDobj] == 1 && nLongTouch && frameCount % spawnFrequency == 0 ) { /* yourList.add( new YourClass ()); */ }
// motion
if(actionButton[IDobj] == 1 && mTouch ) { }
// change stuff like color palette....
if(actionButton[IDobj] == 1 && xTouch ) { }
// stop, move the mouse inside the object
if(actionButton[IDobj] == 1 && spaceTouch ) { }

//with parametter button
open folder
if ( parameterButton[IDobj] == 1 && oTouch ) { }









//KEYBOARD BOOLEAN command
//ATTENTION////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Don't use DELETE and the letter 'i' and 's' from the keyboard this touch is use for the main CODE for empty  all the list, display information and save picture
//ATTENTION////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//// Dedicaced and reserved key ////
///////////////////////
// P3D move
boolean cLongTouch //  use to move the camera in P3D world with the mouse function
boolean vLongTouch // use to move the object in P3D world with the mouse function
//ADD objects
boolean nTouch, nLongTouch // ADD OBJECT use this keyboard touch it's suggestion for sure !

// generaric keyborad command, it's better to don't use for others commands
boolean spaceTouch      // give the boolean condition of the space touch to active the XY mouse, pen and Leap coordinate
boolean backspaceTouch  // generaly to empty a specific list of object
boolean nTouch         // generaly use to add a new particule like a clic depends what you want
boolean nLongTouch     // generaly use to add a new particule like a clic depends what you want
boolean mTouch         // generaly use to move the object, close to spaceTouch but different, linked with the boolean motion[IDobj]
boolean oTouch       //  genrally open folder to choice a file for a specific object
boolean pTouch       // to open an other folder, if the object already use "oTouch"

// Free touch
boolean aTouch, bTouch, cTouch, dTouch, eTouch, fTouch, gTouch, hTouch, jTouch, kTouch, lTouch, qTouch, rTouch, tTouch, uTouch, vTouch, wTouch, xTouch, yTouch, zTouch,
leftTouch, rightTouch, upTouch, downTouch, 
touch0, touch1, touch2, touch3, touch4, touch5, touch6, touch7, touch8, touch9, 
enterTouch, returnTouch, shiftTouch, altTouch, escTouch ;

//END of KEYBOARD
/////////////////





// TEXT
///////

Romanesco call karaoke.txt from the main directory in real time,
so you can write on it when you use Romanesco
"*" to separate the chapter 
"/" to separate the sentence

String [][] sentencesByChapter  ;
To use this text in your object you can use this String array 
the first array of the String index the Chapter who was separated by "*"
the second is the specific sentence in each Chapter.

String textRaw ; is the import text but with the "*" and "/"

** When you code take a care to save the karaoke.txt in each folder of dev (Scene, Prescene, Mirroir) **

// END TEXT
///////////









// SOUND 
////////

float left[IDobj]  is volume left /  float value(0,1)
float right[IDobj]   is volume right / /  float value(0,1)
float mix[IDobj]     is average volume between the left and the right / float value(0,1)

float beat[IDobj]    is beat : value 1,10 
float kick[IDobj]    is beat kick : value 1,10 
float snare[IDobj]   is beat snare : value 1,10 
float hat[IDobj]     is beat hat : value 1,10 

float tempo[IDobj]        // global speed of track  / float value(0,1)
float tempoBeat[IDobj]   // speed of track calculate on the beat
float tempoKick[IDobj]  / / speed of track calculate on the kick
float tempoSnare[IDobj] // speed of track calculate on the snare
float tempoHat[IDobj] // speed of track calculte on the hat

float getTimeTrack()  // return the time elapse from the beginning play to now

float band [IDobj][whichBand] // whichBand give the information of the band where catch the info
usualy there is 16 bands, to know the number :
bandSpectrum.length ;

////////////
// END SOUND





// MOUSE
//////////////////////
PVector mouse[IDobj]
mouse[0].x // mouse[0].y // absolute position of the mouse
mouse[0].z // return info from the z axis when the leapmotion is active
mouse[IDobj].x // mouse[IDobj].y // mouse[IDobj].z // same info tha mouse[IDobj] but this one is refresh when you press the space
// MOUSE WHEEL
int wheel[IDobj]
wheel[0] and wheel[IDobj]
or use the void zoom() and take the float value getCountZoom...this value is more reactive !
// PMOUSE
PVector pmouse[IDobj]
pmouse[0] and pmouse[IDobj]


// PEN
////////////////////
PVector pen[IDobj]
pen[IDobj].x pen[IDobj].y   // information from the tablet tilt : orientation of the pen 
pen[IDobj].z // information from tablet : pressure pen 


// MOUSE CLICK BOOLEAN
//////////////////////
//short click just for one shot
boolean clickShortLeft[IDobj] ;
boolean clickShortRight[IDobj] ;
//active after one mousePressed, be inactive after the mouse Released
boolean clickLongLeft[IDobj] ;
boolean clickLongLeft[IDobj] ;


//END MOUSE, PEN, LEAPMOTION
////////////////////////////



// VAR from Slider
/////////////////

  
VAR object
color fillObj[IDobj] ; you can separate with hue, saturation, brightness and alpha
color strokeObj[IDobj] ; you can separate with hue, saturation, brightness and alpha

float thicknessObj[IDobj] ; value from 0.1 to height/3
float sizeXObj[IDobj] ; sizeYObj[IDobj] ; sizeZObj[IDobj] ; value from 0.1 to width
float canvasXObj[IDobj] ; value from width /10  to (5 * width)
float canvasYObj[IDobj] ; value from height /10  to (5 *height )
float canvasZObj[IDobj] ; value from width /10 to (5 * width)
float quantityObj = new float[numObj] ; value from 1 to 100 ;

float speedObj[IDobj] ; value from 0 to 100
float directionObj[IDobj] ; value from 0 to 360 ;
float angleObj[IDobj] ; value from 0 to 360 ;
float amplitudeObj[IDobj] ; value from 1 to height.
float analyzeObj[IDobj] ; value from 0 to 100.
float familyObj[IDobj] ; value from 1 to 100, it's an atomic and arbitory choice !
float lifeObj[IDobj] ; value from 1 to 100.
float forceObj[IDobj] ; value from 1 to 100.

//END SLIDER
////////////



// UTIL MATH
float perimeterCircle (int r) return perimeter
float radiusSurface(int s) return the radius with a speficic surface

float distance(PVector p0, PVector p1 ) calcul distance between two PVectors
float angle(PVector p0, PVector p1) calcul the angle between two PVectors

PVector normalDir(int direction) // return a direction between -1 / 1 from 360° direction
float deg360 (PVector dir) // return a 360 direction from PVector direction value between -1 to 1 ;
PVector rotation(PVector ref, PVector lattice, float angle) // return a PVector position, for rotation around an axes

float roots(float valueToRoots, int n) // return the roots value with "n" dimension


float mapLocked(float value, float sourceMin, float sourceMax, float targetMin, float targetMax) // the return value is lock between the min and the max
float mapStartSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the begin of the curve is smoothed by the level
float mapEndSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the end of the curve is smoothed by the level
float mapEndStartSmooth(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) // the begin and the end of the curve is smoothed by the level


// UTIL TIME

float cycle(float add) // return value between -1 et 1 , nice to try with vzlue like 0.1
int timer(float tempo) // return an add value from float <1 ;
int minClock() // return the time of the day in minutes




//CLASS PIXEL
/////////////
this class is define by a lot of parameter and work in HSB, 360,100,100,100
PVector size (x,y,z)
PVector pos (x,y,z)

color colour, newColour ;

PVector wind I must define ?
float field : define the field of life (action) of the pixel, it use like a radius around the origin of the pixel
float life = 1 ; 
float timePast = 0.01 ; // this value is use to remove time from the life.

// parameter use to find the pixel in the mess
PVector gridPos(x,y) in matrix 2D // this value is use to find a specific pixel in the array
int rank
int ID


there is few different construtors
Pixel(PVector pos)
Pixel(PVector pos, color colour)
Pixel(PVector pos, PVector size)
Pixel(PVector pos, PVector size, color colour)
// INK CONTRUCTOR
Pixel(PVector pos, float field, float timePast, color colour)
Pixel(PVector pos, float field, float timePast) 
// RANK CONSTRUCTOR
Pixel(int rank, PVector gridPos) // this one is use to rank the pixel in the array
Pixel(int rank)

// FUNCTION
// must define what the role
void displayPixel(int diam) 
void displayPixel(int diam, PVector effectColor)

// UPDATE
void drying(float var)





// END CLASS PIXEL
//////////////////



// METEO
////////
boolean meteo, is false by default. If you want use in your object write this one is true.

More info check the Tab X_Module in the Meteo part in the sketch Prescene or Scene.


// END METEO
////////////

















