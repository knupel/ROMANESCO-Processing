import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import codeanticode.tablet.*; 
import java.awt.event.KeyEvent; 
import com.leapmotion.leap.*; 
import rope.costume.R_Primitive; 
import toxi.geom.*; 
import toxi.geom.mesh2d.*; 
import toxi.util.*; 
import toxi.util.datatypes.*; 
import toxi.processing.*; 
import geomerative.*; 
import java.util.Date; 
import java.sql.Timestamp; 
import java.net.*; 
import java.io.*; 
import java.util.*; 
import java.awt.*; 
import java.util.Iterator; 
import java.lang.reflect.*; 
import java.awt.image.*; 
import processing.video.*; 
import oscP5.*; 
import netP5.*; 
import processing.net.*; 
import processing.pdf.*; 
import codeanticode.syphon.*; 
import java.util.Date; 
import java.sql.Timestamp; 
import ddf.minim.*; 
import ddf.minim.analysis.*; 
import java.nio.ByteBuffer; 
import java.nio.ByteOrder; 
import processing.pdf.*; 
import rope.core.*; 
import rope.vector.*; 
import java.util.Arrays; 
import java.util.Iterator; 
import java.util.Random; 
import java.awt.image.BufferedImage; 
import java.awt.Color; 
import java.awt.Font; 
import java.awt.image.BufferedImage; 
import java.awt.FontMetrics; 
import java.io.FileNotFoundException; 
import java.io.FileOutputStream; 
import javax.imageio.ImageIO; 
import javax.imageio.IIOImage; 
import javax.imageio.ImageWriter; 
import javax.imageio.ImageWriteParam; 
import javax.imageio.metadata.IIOMetadata; 
import java.lang.reflect.Field; 
import java.awt.Graphics; 
import java.awt.GraphicsEnvironment; 
import java.awt.GraphicsDevice; 
import java.awt.Rectangle; 
import rope.costume.R_Primitive; 
import rope.costume.R_Circle; 
import rope.costume.R_Bezier; 
import rope.costume.R_Star; 
import rope.costume.R_Virus; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class A___rendering_33 extends PApplet {

/**
ROMANESCO
romanesco dui rendering
2013–2019
release 33
Processing 3.5.3
*/

/**
* WARNING
* Is not possible to use method print when the prescene is used because the rendering prescene and scene is from the same sketch
* Using in print in DEV_MOD cause a crash.
*/

/**
2015 may 15_000 lines of code
2016 may 27_500 lines of code
2017 March 40_000 lines of code
*/



/**
BUG with warp on MacBook Pro 2018 or HighSierra / Mojave
*/



/**
* DEVELOPER SETTING
*/
// boolean USE_LAYER = false;
// boolean DEV_MODE = true; // inter alia, path preferences folder, curtain
// String IAM = "prescene";
// boolean LIVE = false;
// boolean FULL_RENDERING = true;

// PRESCENE LIVE
// boolean USE_LAYER = false;
// boolean DEV_MODE = true; // inter alia, path preferences folder, curtain
// String IAM = "prescene";
// boolean LIVE = true;
// boolean FULL_RENDERING = false;


// SCENE LIVE
// boolean USE_LAYER = false;
// boolean DEV_MODE = true; // inter alia, path preferences folder, curtain
// String IAM = "scene";
// boolean LIVE = false;
// boolean FULL_RENDERING = true;































/**
* EXPORT SETTING
* Here you can choice between the three common rendering mode
*/
// PRESCENE FULL RENDERING
// APP: prescene_## > change for size(124,124)
// boolean USE_LAYER = false;
// boolean DEV_MODE = false; // inter alia, path preferences folder, curtain
// String IAM = "prescene";
// boolean LIVE = false;
// boolean FULL_RENDERING = true;


// PRESCENE LIVE PREVIEW
// APP: prescene_##_live > change for size(124,124) in settings()
// boolean USE_LAYER = false;
// boolean DEV_MODE = false; // inter alia, path preferences folder, curtain
// String IAM = "prescene";
// boolean LIVE = true;
// boolean FULL_RENDERING = false;


// SCENE LIVE
// for the scene live export, two export set in void settings() 
// APP: scene_##_live_fullscreen  > change for  fullScreen() in settings()
// APP: scene_##_live > change for size(124,124) in settings()
boolean USE_LAYER = false;
boolean DEV_MODE = false; // inter alia, path preferences folder, curtain
String IAM = "scene";
boolean LIVE = false; 
boolean FULL_RENDERING = true;

















/* 
Use false when you want:
used sound & maximum possibility of the object
*/
boolean USE_SOUND = true; 
boolean MIROIR = false;

boolean FULL_SCREEN = false;
boolean TABLET = false; // now tablet library don't work in OPENGL renderer
/**
LIVE must change from the launcher, the info must be write in the external loading preference app
*/

// DEV_MODE : rank folder, curtain, OSC thread




public void settings() {
  // size(900,550,P3D); // DEV MODE PARAM
  
  // EXPORTING PARAM 
  // size(124,124,P3D);

  fullScreen(P3D); // original
  FULL_SCREEN = true;

  syphon_settings();

  if(IAM.equals("prescene")) {
    scene = false;
    prescene = true;
  } else if(IAM.equals("scene")) {
    OPEN_APP = true;
    scene = true;
    prescene = false;
  }
}



PApplet p5;
public void setup() {
  p5 = this;
  path_setting();
  // shader_folder_filter(preference_path+"shader/filter/");
  load_save(preference_path+"setting/defaultSetting.csv");
  media_init_path();
  version();
  set_system_specification();
  OSC_setup();
 
  int num_layer = 3;
  int frame_rate = 60;
  display_setup(frame_rate,num_layer); // the int value is the frameRate

  romanesco_build_item();

  create_variable();

  camera_setup();

  if(IAM.equals("prescene")){
    prescene_setup(); 
    leapmotion_setup();
  } else if(IAM.equals("scene")) {
    scene_variables_setup();
  }

  color_setup();
  syphon_setup();

  init_variable_item_min_max();
  init_variable_item();
  init_slider_variable_world();
  load_system_font();
  create_font();
  init_font();
  update_font_item();
  
  if(USE_SOUND) sound_setup();

  light_position_setup();
  light_setup();

  init_fx_post();
  init_background();
  init_fx_background();
  init_masking();
}






boolean init_app;
public void draw() {
  if(init_app) { 
    String title = nameVersion + " " +prettyVersion+"."+version+ " | "+ IAM + " | FPS: "+round(frameRate);
    if(MIROIR) title = nameVersion + " " +prettyVersion+"."+version+ " | "+ "miroir" + " | FPS: "+round(frameRate);
    surface.setTitle(title);
    if(!FULL_SCREEN) update_window_location();
    // script
    if(frameCount%180 == 0) {
      rom_manager.historic();
      int size = rom_manager.historic_size();
      //rom_manager.print_historic();
    }


    romanesco();

    if(width == 1 || height == 1) {
      printErr("width:",width,"heigh:",height, "this window size is not usable the process is stoped,\nplease set preference size via the launcher or directly in file sceneProperty.csv");
      // exit();
    }
  } else {
    if(FULL_RENDERING) {
      shader_setup();
    }
    init_app = items_loaded_is(); 
  }
}


public void romanesco() {
  init_romanesco();
  if(FULL_RENDERING) {
    start_PNG("screenshot Romanesco prescene", "Romanesco_"+year()+"_"+month()+"_"+day()+"_"+hour()+"_"+minute()+"_"+second());
  }

  syphon_draw();

  if(USE_SOUND) {
    sound_draw();
  }

  OSC_update();

  update_raw_item_value();

  
  if(IAM.equals("prescene")) {
    updateCommand();
    leapMotionUpdate();
  } 

  rendering();




  // save screenshot
  if(FULL_RENDERING) {
    save_PNG();
  }
  // this method is outside de bracket (FULL_RENDERING) to give the possibility to send the order to Scene
  if(key_p) event_PNG();

  // misc
  puppet_master(false); // use to resset puppet for the force field
  update_slider_ref();
  media_update(180);
  change_slider_ref();
  load_dial_controller();
  reset_button_alert();


  if(IAM.equals("scene")) {
    init_value_temp_prescene();
    if (!miroir_on_off && OPEN_APP) {
      opening();
    }
  } else if(IAM.equals("prescene")) {
    device_update();
    if(LIVE) {
      if(send_message_is()) {
        OSC_send();
        send_message(false);
      }
    }
  }

  
  if(IAM.equals("prescene")) {
    // change to false if the information has be sent to Scene...but how ????
    key_false();
  }

  if(!controller_osc_is && FULL_RENDERING) {
    if(USE_LAYER) {
      select_layer(0);
      begin_layer();
      opening_display_message();
      end_layer();
    } else {
      opening_display_message();
    }
  }


  // final display
  if(USE_LAYER) {
    for(int i = 0 ; i < get_layer_num() ; i++) {
      g.image(get_layer(i),0,0);
    }
  }
  // mask
  if(FULL_RENDERING) {
    masking(set_mask_is());
  }

  // cursor
  if(IAM.equals("scene")) {
    if(set_mask_is() || displayInfo) {
      cursor();
    } else {
      noCursor();
    }
  }  
}



















/**
EVENT
v 1.0.0
2014-2018
*/
public void keyPressed () {
  if (key == 'i') displayInfo = !displayInfo;
  if (key == 'g') show_info_camera = !show_info_camera;

  if(IAM.equals("prescene")) {
    if(LIVE) {
      send_message(true);
    }
     keyboard[keyCode] = true ;
    // shortcuts_prescene();
    key_true();
  }


  keyPressed_mask_set('M');
  keyPressed_mask_border_hide('H');
  keyPressed_mask_save('S');
  keyPressed_mask_load('L');
  warp_force_keyPressed('N');
}


public void keyReleased() {
  if(IAM.equals("prescene")) {
    if(LIVE) {
      send_message(true);
    }
    key_long_false();
    keyboard[keyCode] = false;
  }
}




public void mousePressed() {
  if(IAM.equals("prescene")) {
    if(LIVE) {
      send_message(true);
    }
    if(mouseButton == LEFT ) {
      clickShortLeft[0] = true;
      clickLongLeft[0] = true;
    }
    if (mouseButton == RIGHT ) {
      clickShortRight[0] = true;
      clickLongRight[0] = true;
    }
  }
}

public void mouseReleased() {
  if(IAM.equals("prescene")){
    if(LIVE) {
      send_message(true);
    }
    clickLongLeft[0] = false;
    clickLongRight[0] = false;
  }
}

// Mouse in or out of the sketch
public void mouseEntered(MouseEvent e) {
  if(IAM.equals("prescene")){
    if(LIVE) {
      send_message(true);
    }
    MOUSE_IN_OUT = true ;
  }
}

public void mouseExited(MouseEvent e) {
  if(IAM.equals("prescene")) {
    if(LIVE) {
      send_message(true);
    }
    MOUSE_IN_OUT = false ;
  }
}

public void mouseWheel(MouseEvent e) {
  if(IAM.equals("prescene")) {
    if(LIVE) {
      send_message(true);
    }
    wheel[0] = e.getCount() *speedWheel;
  } 
}



/**
* Core Romanesco
* common code for CONTROLLER and RENDERER
* 2018-2019
* v 0.3.11
*/
int NUM_COL_SLIDER = 4;
int NUM_SLIDER_ITEM_BY_COL = 16;
int NUM_SLIDER_ITEM = NUM_SLIDER_ITEM_BY_COL *NUM_COL_SLIDER;
int NUM_MOLETTE_ITEM = NUM_SLIDER_ITEM;

int KEY_CTRL_OS = 157; // it's macOS CMD // for MAC 


int NUM_DROPDOWN_GENERAL = 7;
// the MIDI BUTTON is not count because is not use in the OSC bridge
int NUM_BUTTON_MISC = 3; // with out MIDI button.
int NUM_BUTTON_RESET = 3;
int NUM_TOP_BUTTON = NUM_BUTTON_MISC + NUM_BUTTON_RESET;

int NUM_BUTTON_BACKGROUND = 1;
int NUM_BUTTON_FX = 3;
int NUM_BUTTON_LIGHT = 6;
int NUM_BUTTON_TRANSIENT = 4;
int NUM_MID_BUTTON = NUM_BUTTON_BACKGROUND 
                      + NUM_BUTTON_FX 
                      + NUM_BUTTON_LIGHT 
                      + NUM_BUTTON_TRANSIENT;

int NUM_BUTTON_GENERAL = NUM_TOP_BUTTON + NUM_MID_BUTTON;

int NUM_SLIDER_BACKGROUND = 14;
int NUM_SLIDER_FX = 14;
int NUM_SLIDER_LIGHT = 9;
int NUM_SLIDER_SOUND = 2;
int NUM_SLIDER_SOUND_SETTING = 5; // 5
int NUM_SLIDER_CAMERA = 10;

int NUM_SLIDER_GENERAL  = NUM_SLIDER_BACKGROUND 
                        + NUM_SLIDER_FX 
                        + NUM_SLIDER_LIGHT 
                        + NUM_SLIDER_SOUND 
                        + NUM_SLIDER_SOUND_SETTING 
                        + NUM_SLIDER_CAMERA;

// for the case where the slider is a multislider, important for the sending and receiving OSC data
int NUM_MOLETTE_BACKGROUND = NUM_SLIDER_BACKGROUND;
int NUM_MOLETTE_FX = NUM_SLIDER_FX;
int NUM_MOLETTE_LIGHT = NUM_SLIDER_LIGHT;
int NUM_MOLETTE_SOUND = NUM_SLIDER_SOUND;
int NUM_MOLETTE_SOUND_SETTING = 11; // here the value is different because it's slider with few molette
int NUM_MOLETTE_CAMERA = NUM_SLIDER_CAMERA;

int NUM_MOLETTE_GENERAL = NUM_MOLETTE_BACKGROUND 
                        + NUM_MOLETTE_FX 
                        + NUM_MOLETTE_LIGHT 
                        + NUM_MOLETTE_SOUND 
                        + NUM_MOLETTE_SOUND_SETTING 
                        + NUM_MOLETTE_CAMERA;

int NUM_GROUP_SLIDER = 2; // '0' for general / '1' for the item

int ITEM_GROUP = 1;

String preference_path;
String import_path;
String font_path;
String items_path;
String autosave_path;
public void path_setting() {
  int folder_position = 1;
  if(!DEV_MODE) folder_position = 0;
  preference_path = sketchPath(folder_position)+"/preferences/";
  import_path = sketchPath(folder_position)+"/import/";
  font_path = "/Users/"+System.getProperty("user.name")+"/library/Fonts";
  File file = new File(font_path);
  if(!file.isDirectory()) {
    font_path = import_path+"font/typo_OTF_TTF";
  }
  items_path = sketchPath(folder_position)+"/items/";
  autosave_path = sketchPath(folder_position)+"/autosave.csv";
}

String version = "";
String prettyVersion = "";
String nameVersion = "";
public void version() {
  String [] s = loadStrings(preference_path+"version.txt");
  String [] v = split(s[0],"/");
  prettyVersion = v[0];
  version = v[1];
  nameVersion = v[2];
}


public String system() {
  return System.getProperty("os.name");
}

public void set_system_specification() {
  String system = system();
  println("System:",system);
  if(system.equals("Mac OS X")) {
    KEY_CTRL_OS = 157;
  } else {
    KEY_CTRL_OS = CONTROL;
  }
}




/**
MISC
*/
public File [] list_files(String path) {
  File file = new File(path);
  if (file.isDirectory()) {
    File[] files = file.listFiles();
    return files;
  } else {
    // If it's not a directory
    return null;
  }
}











/**
FONT LOADING
0.0.4
*/
ROFont [] font;
public void create_font() {
  int size_font = 200;
  String[] path_list = alphabetical_font_path(font_path);

  font = new ROFont[path_list.length]; 
  for(int i = 0 ; i < path_list.length ; i++) {
    if(extension_font(path_list[i])) {
      font[i] = new ROFont(path_list[i],size_font);
    } 
  }
}

public String [] alphabetical_font_path(String folder_path) {
  File [] file = list_files(folder_path);
  // check if the file is a font or not
  int num = 0 ;
  for(int i = 0 ; i < file.length ; i++) {
    if(extension_font(file[i].getAbsolutePath())) {
      num++;
    }
  }

  String[] path_list = new String[num];
  int target= 0;
  for(int i = 0 ; i < file.length ; i++) {
    if(extension_font(file[i].getAbsolutePath())) {
      path_list[target] = file[i].getAbsolutePath();
      target++;
    } 
  }
  Arrays.sort(path_list);
  return path_list;
}




public boolean extension_font(String path) {
  return extension_is(path,"ttf","TTF","otf","OTF");
}




/**
ROFont
v 0.2.0
2018-2018
*/
class ROFont {
  PFont font;
  String path;
  String type;
  int size;

  ROFont(String path, int size) {
    //if(extension_is(path,"ttf","TTF","otf","OTF")) {
    if(extension_font(path)) {
      this.font = createFont(path,size);
      this.path = path;
      this.size = size;
      this.type = extension(path);
      //println(path,type);
    } else {
      printErr("class ROFont: path don't match with any font type >",path);
    }
  }

  public PFont get_font() {
    return font;
  }

  public String get_path() {
    return path;
  }

  public String get_type() {
    return type;
  }

  public int get_size() {
    return size;
  }

  public String get_name() {
    return font.getName();
  }
}











































/**
MEDIA
2014-2018
v 0.1.4
*/
ArrayList<File> text_files = new ArrayList<File>();
ArrayList<File> bitmap_files = new ArrayList<File>();
ArrayList<File> svg_files = new ArrayList<File>();
ArrayList<File> movie_files = new ArrayList<File>();
ArrayList<File> media_files = new ArrayList<File>();




String ref_path;
public void add_media(String path) {
  if(path != null && !path.equals(ref_path)) {
    ref_path = path;
    // movie case
    if(ext(path,"mov") || ext(path,"MOV") || ext(path,"avi") || ext(path,"AVI") || ext(path,"mp4") || ext(path,"MP4") || ext(path,"mkv") || ext(path,"MKV")) {
      add_input(movie_files,path);
    } else if(ext(path,"jpeg") || ext(path,"JPEG") || ext(path,"jpg") || ext(path,"jpeg") || ext(path,"tif") || ext(path,"TIF") || ext(path,"tiff") || ext(path,"TIFF") || ext(path,"tga") || ext(path,"TGA") || ext(path,"gif") || ext(path,"GIF")) {
      add_input(bitmap_files,path);
    } else if(ext(path,"txt") || ext(path,"TXT")) {
      add_input(text_files,path);
    } else if(ext(path,"svg") || ext(path,"SVG")) {
      add_input(svg_files,path);
    }
  }
}


public boolean ext(String path, String extension) {
  return extension(path).equals(extension);
}


/**
add movie path
*/
public void add_input(ArrayList<File> media_file_by_type, String path) {
  File file = new File(path);
  if(!check_already_existing_path(path)) {
    media_file_by_type.add(file);
    media_files.add(file);
  }
}

public boolean check_already_existing_path(String path) {
  boolean existing = false;
  for(File f : media_files) {
    String existing_path = f.getAbsolutePath();
    if(existing_path.equals(path)) {
      existing = true;
      break;
    }
  }
  return existing;
}


















/**
Manage window position
v 0.0.2
*/
ivec2 ref_window_location;
public void update_window_location() {
  if(ref_window_location == null) {
    ref_window_location = get_sketch_location().copy();
    write_window_location();
    // println(ref_window_location,frameCount);
  } else {
    if(!ref_window_location.equals(get_sketch_location())) {
      ref_window_location.set(get_sketch_location());
      write_window_location();
    }
  }
}


public void write_window_location() {
  String loc [] = new String[2];
  loc[0] = Integer.toString(ref_window_location.x);
  loc[1] = Integer.toString(ref_window_location.y);
  saveStrings("data/location.loc",loc);
}



public void load_window_location() {
  load_window_location(ivec2(width,height));
}

public void load_window_location(ivec2 window) {
  String[] location = loadStrings("location.loc");
  ivec2 loc = ivec2();
  loc.x = Integer.parseInt(location[0]);
  loc.y = Integer.parseInt(location[1]);
  // check if the save position can be used and don't display the sketch in a innaccessible place
  // First check the num of screen device
  println("location loaded from save file",loc);
  if(get_screen_num() < 2) {
    if(loc.x < 0 || loc.x > get_screen_size().x -window.x || loc.y < 0 || loc.y > get_screen_size().y -window.y) {
      center_sketch(loc);
    }
  } else if (get_screen_num() >= 2) {
    int begin_x = 0;
    int begin_y = 0;
    int end_x = get_screen_size(0).x; // master screen
    int end_y = get_screen_size(0).y; // master screen
    for(int i = 0 ; i < get_screen_num(); i++) {
      // x part
      if(get_screen_location(i).x < begin_x) {
        begin_x = get_screen_location(i).x;
      } 

      if (get_screen_location(i).x > 0) {
        end_x += get_screen_size(i).x;
      }

      // y part
      if(get_screen_location(i).y < begin_y) {
        begin_y = get_screen_location(i).y;
      }

      if (get_screen_location(i).y > 0) {
        end_y += get_screen_size(i).y;
      }
    }
    if(loc.x < begin_x || loc.x > (end_x -window.x) || loc.y < begin_y || loc.y > (end_y - window.y)) {
      center_sketch(loc);
    }
  }
  surface.setLocation(loc.x,loc.y);
}

public void center_sketch(ivec2 loc) {
  int term_x_0 = get_screen_size().x /2;
  int term_x_1 = width/2;
  loc.x = term_x_0 - term_x_1;
  int term_y_0 = get_screen_size().y /2;
  int term_y_1 = height/2;
  loc.y = term_y_0 - term_y_1;
}





















float rotate_x,rotate_y,rotate_z;
public void debug_shape() {
	rotate_x += .01f;
	rotate_y += .02f;
  println("shape debug",frameCount);
  
  fill(0,100,100);
  stroke(0,100,0);
  strokeWeight(2);
  pushMatrix();
  
  translate(width/2,height/2,height/3);
  rotateX(rotate_x);
  rotateZ(rotate_y);

  box(100);
  popMatrix();
}


public void debug_background() {
	println("background debug",frameCount);
	background_rope(0,100,0);
}


public void test_set_pix_density() {
  background(0);
  for(int i = 0 ; i < 200000 ; i++) {
    int x = (int)random(width);
    int y = (int)random(height);
    int c = r.WHITE;
    set(x,y,c);
  }
}




/**
Core Prescene
v 1.3.1
2013-2019
* Here you find
* variable Prescene
* update command for the mouse, cursor...
* tablet
* open method for the scene and controller
* keyboard command
*/

//to opening app
boolean openScene = true ;
boolean openMiroir = true ;
boolean openControleur = true ;
//send to the other sketches
boolean youCanSendToScene = true ;
// boolean youCanSendToMiroir = true ;


// CURSOR SPEED
int speedWheel = 4 ; // 5 is too quick
float speedLeapmotion = .15f ; // between 0.000001 and 1 : can be good between 0.1 and 0.4

float mouse_reactivity = .8f;






Tablet tablet;

public void prescene_setup() {
  leap = new com.leapmotion.leap.Controller();
  if(TABLET) tablet = new Tablet(this);
  if(FULL_RENDERING) show_info_camera = false ; else show_info_camera = true;
}



/**
command
*/
public void updateCommand() {
  // move the object
  if(clickLongLeft[0] || finger.activefingers == 1 ) {
    ORDER_ONE = true ; 
    ORDER_TWO = false ;
    ORDER_THREE = false ;
  }
  // rotate the object
  else if(clickLongRight[0] || finger.activefingers == 2) {
    ORDER_ONE = false ; 
    ORDER_TWO = true ;
    ORDER_THREE = false ;
  }
  // move and rotate
  else if(finger.activefingers == 3) {
    ORDER_ONE = false ; 
    ORDER_TWO = false ;
    ORDER_THREE = true ;
  }

  if(!clickLongLeft[0] && !clickLongRight[0] && finger.activefingers != 2 && finger.activefingers != 1 && finger.activefingers != 3)  {
  // false
    ORDER_ONE = false ;
    ORDER_TWO = false ;
    ORDER_THREE = false ;
  }
}



/**
update cursor 1.2.0
*/
vec3 mouse_ref;
int mouseZ ;
public void device_update() {
  update_leap_command();
  update_wheel();
  
  //mousePressed
  if(ORDER_ONE || ORDER_TWO || ORDER_THREE) {
    ORDER = true; 
  } else {
    ORDER = false;
  }
  
  update_tablet();

  if(orderOneLeap || orderTwoLeap) {
    update_leapmotion();
  } else if (mouse_ref == null || mouse_ref.x != mouseX || mouse_ref.y != mouseY) {
    update_mouse();
  }

  //re-init the wheel value to be sure this one is stopped
  wheel[0] = 0;
  //re-init the mouse button for the short click
  clickShortLeft[0] = false; 
  clickShortRight[0] = false;
}


// ANNEXE VOID
public void update_wheel() {
  mouseZ -= wheel[0];
}

public void update_tablet() {
  if(pen[0] == null) {
    pen[0] = vec3(0,0,.02f);
  }

  if(TABLET) {
    float x = tablet.getTiltX();
    float y = tablet.getTiltY();
    float z = tablet.getPressure();
    pen[0].set(x,y,z);
  } else {
    pen[0].set(0,0,.02f);
  }
}

public void update_mouse() {
  if(mouse[0] == null) {
    mouse[0] = follow(mouseX,mouseY,0,mouse_reactivity);
  } else {
    mouse[0].set(follow(mouseX,mouseY,0,mouse_reactivity));
  }

  if(mouse_ref == null) {
    mouse_ref = vec3(mouse[0]);
  } else mouse_ref.set(mouse[0]);
}

public void update_leapmotion() {
  float x = averageTranslatePosition(speedLeapmotion).x;
  float y = -averageTranslatePosition(speedLeapmotion).y;
  float z = averageTranslatePosition(speedLeapmotion).z;
  if(mouse[0] == null) {
    mouse[0] = vec3(x,y,z);
  } else mouse[0].set(x,y,z);
}













/**
KEYBOARD & SHORTCUTS
*/

boolean[] keyboard = new boolean[526];


public boolean check_keyboard(int c) {
  if (keyboard.length >= c) {
    return keyboard[c];  
  }
  return false;
}


     
public void key_true() {
  if (key == ' ') key_space = true ; 
  
  if (key == 'a') key_a = true;
  if (key == 'b') key_b = true;
  if (key == 'c') key_c = true;
  if (key == 'd') key_d = true;
  if (key == 'e') key_e = true;
  if (key == 'f') key_f = true;
  if (key == 'g') key_g = true;
  if (key == 'h') key_h = true;
  if (key == 'i') key_i = true;
  if (key == 'j') key_j = true;
  if (key == 'k') key_k = true;
  if (key == 'l') key_l = true;
  if (key == 'm') key_m = true;
  if (key == 'n') key_n = true;
  if (key == 'o') key_o = true;
  if (key == 'p') key_p = true;
  if (key == 'q') key_q = true;
  if (key == 'r') key_r = true;
  if (key == 's') key_s = true;
  if (key == 't') key_t = true;
  if (key == 'u') key_u = true;
  if (key == 'v') key_v = true;
  if (key == 'w') key_w = true;
  if (key == 'x') key_x = true;
  if (key == 'y') key_y = true;
  if (key == 'z') key_z = true;

  if (key == 'A') key_A = true;
  if (key == 'B') key_B = true;
  if (key == 'C') key_C = true;
  if (key == 'D') key_D = true;
  if (key == 'E') key_E = true;
  if (key == 'F') key_F = true;
  if (key == 'G') key_G = true;
  if (key == 'H') key_H = true;
  if (key == 'I') key_I = true;
  if (key == 'J') key_J = true;
  if (key == 'K') key_K = true;
  if (key == 'L') key_L = true;
  if (key == 'M') key_M = true;
  if (key == 'N') key_N = true;
  if (key == 'O') key_O = true;
  if (key == 'P') key_P = true;
  if (key == 'Q') key_Q = true;
  if (key == 'R') key_R = true;
  if (key == 'S') key_S = true;
  if (key == 'T') key_T = true;
  if (key == 'U') key_U = true;
  if (key == 'V') key_V = true;
  if (key == 'W') key_W = true;
  if (key == 'X') key_X = true;
  if (key == 'Y') key_Y = true;
  if (key == 'Z') key_Z = true;
  
  if (key == '0') key_0 = true;
  if (key == '1') key_1 = true;
  if (key == '2') key_2 = true;
  if (key == '3') key_3 = true;
  if (key == '4') key_4 = true;
  if (key == '5') key_5 = true;
  if (key == '6') key_6 = true;
  if (key == '7') key_7 = true;
  if (key == '8') key_8 = true;
  if (key == '9') key_9 = true;
  
  if (keyCode == SHIFT) key_shift = true ;
  if (keyCode == BACKSPACE) key_backspace = true ;
  if (keyCode == DELETE) key_delete = true ;

  if (keyCode == ALT) key_alt = true ;
  if (keyCode == RETURN) key_return = true ;
  if (keyCode == ENTER) key_enter = true ;
  if (keyCode == CONTROL) key_ctrl = true ;
  if (keyCode == 157) key_cmd = true ;
  
  if (keyCode == LEFT) key_left = true ;
  if (keyCode == RIGHT) key_right = true ;
  if (keyCode == UP) key_up = true ;
  if (keyCode == DOWN) key_down = true ;

  // long
  if (key == ' ') key_space_long = true; 

  if (key == 'c') key_c_long = true; 
  if (key == 'l') key_l_long = true; 
  if (key == 'n') key_n_long = true; 
  if (key == 'v') key_v_long = true; 
 
  if (keyCode == SHIFT) key_shift_long = true;
}

public void key_long_false() {
  if (key == ' ') key_space_long = false; 
  if (key == 'c') key_c_long = false;
  if (key == 'l') key_l_long = false;
  if (key == 'n') key_n_long = false;
  if (key == 'v') key_v_long = false;

  if (keyCode == SHIFT) key_shift_long = false;
}


public void key_false() {
  /** 
  check for the key and put false here, but it's less reactive that put false just after the use the boolean...here you display false three time !
  */
  // we add modulo to be sure the information about the boolean is transmit to the scene
  if(key_a) key_space = false;

  if(key_a) key_a = false;
  if(key_b) key_b = false;
  if(key_c) key_c = false;
  if(key_d) key_d = false;
  if(key_e) key_e = false;
  if(key_f) key_f = false;
  if(key_g) key_g = false;
  if(key_h) key_h = false;
  if(key_i) key_i = false;
  if(key_j) key_j = false;
  if(key_k) key_k = false;
  if(key_l) key_l = false;
  if(key_m) key_m = false;
  if(key_n) key_n = false;
  if(key_o) key_o = false;
  if(key_p) key_p = false;
  if(key_q) key_q = false;
  if(key_r) key_r = false;
  if(key_s) key_s = false;
  if(key_t) key_t = false;
  if(key_u) key_u = false;
  if(key_v) key_v = false;
  if(key_w) key_w = false;
  if(key_x) key_x = false;
  if(key_y) key_y = false;
  if(key_z) key_z = false;

  if(key_A) key_A = false;
  if(key_B) key_B = false;
  if(key_C) key_C = false;
  if(key_D) key_D = false;
  if(key_E) key_E = false;
  if(key_F) key_F = false;
  if(key_G) key_G = false;
  if(key_H) key_H = false;
  if(key_I) key_I = false;
  if(key_J) key_J = false;
  if(key_K) key_K = false;
  if(key_L) key_L = false;
  if(key_M) key_M = false;
  if(key_N) key_N = false;
  if(key_O) key_O = false;
  if(key_P) key_P = false;
  if(key_Q) key_Q = false;
  if(key_R) key_R = false;
  if(key_S) key_S = false;
  if(key_T) key_T = false;
  if(key_U) key_U = false;
  if(key_V) key_V = false;
  if(key_W) key_W = false;
  if(key_X) key_X = false;
  if(key_Y) key_Y = false;
  if(key_Z) key_Z = false;
  
  if(key_0) key_0 = false;
  if(key_1) key_1 = false;
  if(key_2) key_2 = false;
  if(key_3) key_3 = false;
  if(key_4) key_4 = false;
  if(key_5) key_5 = false;
  if(key_6) key_6 = false;
  if(key_7) key_7 = false;
  if(key_8) key_8 = false;
  if(key_9) key_9 = false;
  
  if (key_backspace) key_backspace = false;
  if (key_delete) key_delete = false; 
  if (key_enter) key_enter = false;
  if (key_return) key_return = false;
  if (key_shift) key_shift = false;
  if (key_alt) key_alt = false; 
  if (key_esc) key_esc = false;
  if (key_ctrl) key_ctrl = false;
  if (key_cmd) key_cmd = false;
  
  if (key_up) key_up = false;
  if (key_down) key_down = false;
  if (key_left) key_left = false;
  if (key_right) key_right = false;
}



/** 
Core_scene 
v 1.5.0
2013-2017
*/


/**
OPENING
*/
boolean open_controller = false ;
boolean open_prescene = true ;
int count_to_open_controller = 0 ;
int time_int_second_to_open_controller = 12  ; // the scene run and run slow at the beginning like at 15 frame / second.


public void opening() {
// open prescene
  if (open_prescene) {
    if (open_prescene) {
      launch(sketchPath("")+"PreScene_"+version+"_preview.app") ; 
      open_prescene = false ; 
      open_controller = true ;
    } 
  }

  // open controller
  if(open_controller) {
    count_to_open_controller += 1 ;
    int time_factor_to_open = 60 ;
    if (open_controller && count_to_open_controller > (time_int_second_to_open_controller *time_factor_to_open) ) { 
      launch(sketchPath("")+"Controleur_"+version+".app") ; 
      open_controller = false ; 
    }
  }
}






/**
We use this void to re-init the temp value of SHORT EVENT from the Préscène, because this one is not refresh at the same framerate than the Scene.
Prescene have a 15 fps and the 60 fps, so the resulte when you press a key on the Prescene, this one is only refresh on the Scène after 4 frames.
*/
public void init_value_temp_prescene() {
  // to change the value of the keyboard "a" to "z" to false
  for(int i = 1 ; i < 27 ;i++) {
    if(data_osc_prescene[i].equals("1")) {
      data_osc_prescene[i] = "0" ;
    }
  }
  // to change the value of the special touch of keyboard like ENTER, BACKSPACE to false
  for(int i = 30 ; i < 38 ;i++) {
    if(data_osc_prescene[i].equals("1")) data_osc_prescene[i] = "0" ;
  }
  // to change the value of the special num touch of keyboard from '0' to '9'
  for(int i = 51 ; i < 61 ;i++) {
    if(data_osc_prescene[i].equals("1")) data_osc_prescene[i] = "0" ;
  }
}










/**
* MANAGE DIALOGUE SCENE
*/
public void save_dial_scene(String path) {
  Table save_dial = new Table();
  save_dial.addColumn("fx active");
  save_dial.addColumn("fx slider active");
  TableRow table_row = save_dial.addRow();

  // slider fx
  String list_slider = "";
  String list_fx = "";
  if(active_fx != null && active_fx.size() > 0) {  
    for(Integer i : active_fx) {
      int target = i - num_special_fx;
      if(target >= 0) {
        String [] names = get_fx(fx_manager,target).get_name_slider();
        list_fx += get_fx(fx_manager,target).get_name() + "/";
        if(names != null && names.length > 0) {
          for(int k = 0 ; k < names.length ; k++) {
            list_slider += names[k] + "/";    
          }
        }
      }
    }
  }
  table_row.setString("fx active",list_fx);
  table_row.setString("fx slider active",list_slider);
  saveTable(save_dial,path+"/dialogue_from_scene.csv");
}




// Tab: B_leapmotion
///////////////
boolean orderOneLeap, orderTwoLeap ;


public void update_leap_command() {
  // move the object
  if(finger.activefingers == 1 ) {
    orderOneLeap = true ; 
    orderTwoLeap = false ;
  }
  // rotate the object
  else if(finger.activefingers == 2) {
    orderOneLeap = false ; 
    orderTwoLeap = true ;
  }
  // move and rotate
  else if(finger.activefingers == 3) {
    orderOneLeap = true ; 
    orderTwoLeap = true ;
  } else if(finger.activefingers != 1 || finger.activefingers != 2 || finger.activefingers != 3) {
    orderOneLeap = false ; 
    orderTwoLeap = false ;
  }
    
}






/////////////////////////////
// VOID & FUNCTION LEAPMOTION
// LEAP MOTION
FingerLeap finger ;

public void leapmotion_setup() {
  finger = new FingerLeap() ;
}

public void leapMotionUpdate() {
  finger.updateLeap() ;
  LEAPMOTION_DETECTED = false ;
  if(fingerVisibleCheck()) LEAPMOTION_DETECTED = true ; else LEAPMOTION_DETECTED = false ;
}

public boolean fingerVisibleCheck() {
  if (finger.activefingers > 0) return true ; else return false ;
}


// DIRECT POS of the fingers in the LEAP FIELD DETECTION
// CLASSIC WORLD
public PVector averageFingerPos() {
  PVector pos = new PVector() ;
  if(finger.fingerCheck) {
    for(int i = 0; i < finger.num ; i++) {
      pos = new PVector(finger.averagePos.x *width, height -finger.averagePos.y *height,finger.averagePos.z  *(width+height) -((width+height)/2)) ;
    }
  }
  return pos ;
}


// GIVE the size of your world
public PVector averageFingerPos(PVector canvas) {
  PVector pos = new PVector() ;
  if(finger.fingerCheck) {
    for(int i = 0; i < finger.num ; i++) {
      pos = new PVector(finger.averagePos.x *canvas.x, canvas.y -finger.averagePos.y *canvas.y,finger.averagePos.z  *canvas.z -(canvas.z/2)) ;
    }
  }
  return pos ;
}



// POSITION from a direction, by adding info from the leap direction
PVector translatePosition = new PVector() ;
public PVector averageTranslatePosition(float speed) {
  if(finger.fingerCheck) {
    for(int i = 0; i < finger.num ; i++) {
      PVector tempDir = new PVector(finger.averageDir.x *speed, finger.averageDir.y *speed, finger.averageDir.z *speed) ; 
      translatePosition.add(tempDir) ;
    }
    return translatePosition ; 
  } else return translatePosition ;
}




///////////////////
//CLASS LEAPMOTION

com.leapmotion.leap.Controller leap;


class FingerLeap {
  //global
  // speed reactivity to update the position of the pointer - cursor in XYZ world - 
  float speed = .05f ;
  // Minimum value to accept finger in the count. The value must be between 0 to 1 ;
  float minValueToCountFinger = .95f ; 
  // range value around the first finger to accepted in the finger count 
  float rangeAroundTheFirstFinger = .2f ;
  //check if the fingers is present or no
  boolean fingerCheck ;
  boolean [] fingerVisible ;
  //for each finger
  int num ;
  int activefingers ;
  int [] ID ;
  int [] IDleap ;
  PVector [] pos ;
  PVector [] dir ;
  float [] magnitude, roll, pitch, yaw ;
  
  // average data
  PVector averagePos, averageDir ;
  PVector addPos = new PVector() ;
  float rangeMin = 0 ; 
  float rangeMax = 0 ;
  PVector findAveragePos = new PVector() ;
  
  FingerLeap() {
    leap = new com.leapmotion.leap.Controller();
  }
  
  
  public void updateLeap() {
    InteractionBox iBox = leap.frame().interactionBox();
    PointableList objectNum = leap.frame().pointables();
    //check finger
    fingerCheck = !objectNum.isEmpty() ;
    // create and init var ;
    num = objectNum.count() ;
    IDleap = new int[num] ;
    ID = new int[num] ;
    activefingers = 0 ;
    fingerVisible = new boolean [num] ;
    pos = new PVector[num] ;
    dir = new PVector[num] ;
    magnitude = new float [num] ; 
    roll= new float [num] ; 
    pitch= new float [num] ; 
    yaw = new float [num] ;
    
    // give info to variables for each finger display or not
    for(int i = 0; i < objectNum.count(); i++) {
      
      //initialization
      Pointable object = objectNum.get(i);
      com.leapmotion.leap.Vector normalPos = iBox.normalizePoint(object.stabilizedTipPosition());
      fingerVisible[i] = false ;
      
      // catch info
      IDleap[i] = object.id() ;
      ID[i] = i  ;
      // return normal position value between 0 to 1 
      pos[i] = new PVector(normalPos.getX(),normalPos.getY(),normalPos.getZ()) ;
      // return normal direction between - 1 to 1
      dir[i] = new PVector(normalPos.getX() *2 -1.0f, normalPos.getY() *2 -1.0f, normalPos.getZ() *2 -1.0f ) ;
      
      // misc value
      magnitude[i] = normalPos.magnitude() ; 
      roll[i] = normalPos.roll() ; 
      pitch[i] = normalPos.pitch() ; 
      yaw[i] = normalPos.yaw() ;
      
      
      //Find average position of all visible fingers
      findAveragePos(pos[i], i) ; 
    }
    // write the result
    averagePos = averagePos(addPos).copy() ;
    averageDir = new PVector(averagePos.x *2 -1.0f, averagePos.y *2 -1.0f,averagePos.z *2 -1.0f) ;
  }
  
  
  
  // ANNEXE
  
  //check if the finger is visible or not
  public void findAveragePos(PVector normalPos, int whichOne) {
    if(activefingers < 1) {
      if(normalPos.z < minValueToCountFinger) {
        addPos = normalPos.copy() ;
        rangeMin = addPos.z -rangeAroundTheFirstFinger ; 
        rangeMax = addPos.z +rangeAroundTheFirstFinger ;
        activefingers += 1 ;
        fingerVisible[whichOne] = true ;
      }
    // if there is one finger, we compare if the others are close of the firsts fingers  
    } else {
      // check if the next finger is in the range
      if(normalPos.z > rangeMin && normalPos.z < rangeMax) {
        // create a range from the average position Z
        rangeMin = addPos.z -rangeAroundTheFirstFinger ; 
        rangeMax = addPos.z +rangeAroundTheFirstFinger ;
        // check if the finger detected is in the range or not, we must do that because the detection of the finger is not perfect and add finger when the hand is deepness in detector
        // if it's ok we add a visible finger in the count
        // check if the finger detected is in the range or not, we must do that because the detection of the finger is not perfect and add finger when the hand is deepness in detector
        activefingers += 1 ;
        // if it's ok we add value
        addPos.add(normalPos.x,normalPos.y,normalPos.z) ;
        // after we divide by 2 because we've added a value at the end of this checking.
        addPos.div(2) ;
        fingerVisible[whichOne] = true ;
      }
    } 
  }

  
  
  // Function to calcul the average position and smooth this one
  public PVector averagePos(PVector infoPos) {
    PVector pos = new PVector() ;
    /*
    Average position of all visible fingers
    Finalize the calcule, and dodge the bad value
    */
    if(infoPos.x > 1.0f) infoPos.x /= 2.0f ;
    if(infoPos.y > 1.0f) infoPos.y /= 2.0f ;
    if(infoPos.z > 1.0f) infoPos.z /= 2.0f ;
    //smooth the result
    pos = follow(infoPos, speed).copy() ;
    // pos = infoPos.copy() ;
    return pos ;
  }
}
/**

DEPRECATED

*/

public void crossPoint3D(PVector pos, PVector size, int colorCross, float e ) {
  if (e <0.1f) e = 0.1f ;
  stroke(colorCross) ;
  strokeWeight(e) ;
  //horizontal
  line(pos.x, pos.y -size.x,0, pos.x, pos.y +size.x,0) ;
  //vertical
  line(pos.x +size.y, pos.y,0, pos.x -size.y, pos.y,0) ;
  //depth
  line(pos.x, pos.y,size.z, pos.x, pos.y,-size.z) ;
}









/**
CLASS PIXEL
*/

class Old_Pixel {
  int colour, newColour ;
  PVector newC = new PVector (0,0,0) ; ;
  PVector pos ;
  PVector newPos = new PVector(0,0,0) ; // absolute pos in the display size : horizontal sytem of pixel system
  PVector gridPos ; // position with cols and rows system : vertical system of ArrayList
  PVector size = new PVector (1,1,1) ;
  float field = 1.0f ;
  PVector wind ; // the wind force who can change the position of the pixel
  float life = 1.0f ;
  int rank = -1 ;
  int ID = 0 ;
  
  //DIFFERENT CONSTRUCTOR
  
  //classic pixel
  Old_Pixel(PVector pos) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
  }
  
  Old_Pixel(PVector pos, int colour) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
    this.colour = colour ;
  }
  
  Old_Pixel(PVector pos, PVector size) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
    this.size = new PVector(size.x, size.y, size.z) ;
  }
  
  //pixel with size
  Old_Pixel(PVector pos, PVector size, int colour) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
    this.size = new PVector(size.x, size.y, size.z) ;
    this.colour = colour ;
  }
  
  //INK CONSTRUCTOR
  Old_Pixel(PVector pos, float field, int colour) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
    this.field = field ;
    this.colour = colour ;
  }
  Old_Pixel(PVector pos, float field) {
    this.pos = new PVector(pos.x, pos.y, pos.z) ;
    this.field = field ;
  }
  
  //RANK PIXEL CONSTRUCTOR
  Old_Pixel(int rank, PVector gridPos) {
    this.rank = rank ;
    this.gridPos = gridPos ;
  }
  Old_Pixel(int rank) {
    this.rank = rank ;
  }
  
  
  
  
  //DISPLAY
    //without effect
  public void displayPixel(int diam) {
    strokeWeight(diam) ;
    stroke(this.colour) ;
    if (newPos.x == 0 && newPos.y == 0 && newPos.z == 0) newPos = pos ; // else newPos = newPos ;
    //test display with ID
    if (ID == 1 ) point(newPos.x, newPos.y) ;
  }
  //with effect
  public void displayPixel(int diam, PVector effectColor) {
    strokeWeight(diam) ;
    
    stroke(hue(newColour), effectColor.x *saturation(newColour), effectColor.y *brightness(newColour), effectColor.z) ;
    if (newPos.x == 0 && newPos.y == 0 && newPos.z == 0) newPos = pos ; // else newPos = newPos ;
    point(newPos.x, newPos.y) ;
  }

  //change ID after analyze if this one is good
  public void changeID(int newID) {  ID = newID ; }
  
  // END DISPLAY
  
  
  
  // UPDATE
  //drying is like jitter but with time effect, it's very subtil so we use a float timer.
    // classic
  public void drying(float timePast) {
    if (field > 0 ) { 
      field -= timePast ;
      float rad;
      float angle;
      rad = random(-1,1) *field;
      angle = random(-1,1) * TAU;
      pos.x += rad * cos(angle);
      pos.y += rad * sin(angle);
    }
  }
  // with external var
  public void drying(float var, float timePast) {
    if (field > 0 ) { 
      field -= timePast ;
      float rad;
      float angle;
      rad = random(-1,1) *field *var;
      angle = random(-1,1) * TAU;
      pos.x += rad * cos(angle);
      pos.y += rad * sin(angle);
    }
  }
  
  
  
  
  
  //CHANGE COLOR 
  // hue from Range
  public void changeHue(vec4 HSBinfo, int[] newHue,  int[] start, int[] end) {
    float h = hue(this.colour) ;
    
    for( int i = 0 ; i < newHue.length ; i++) {
      if (start[i] < end[i] ) {
        if( h >= start[i] && h <= end[i] ) h = newHue[i] ; 
      } else if ( start[i] > end[i] ) {
        if( (h >= start[i] && h <= HSBinfo.x) || h <= end[i] ) { 
          if( h >= newHue[newHue.length -1] ) h = newHue[newHue.length -1] ; 
          else h = newHue[i] ; 
        }
      }        
    }
    newC.x = h ;
  }
  
  // saturation from Range
  public void changeSat(vec4 HSBinfo, int[] newSat,  int[] start, int[] end) {
    float s = saturation(this.colour) ;
    
    for( int i = 0 ; i < newSat.length ; i++) {
      if (start[i] < end[i] ) {
        if( s >= start[i] && s <= end[i] ) s = newSat[i] ; 
      } else if ( start[i] > end[i] ) {
        if( (s >= start[i] && s <= HSBinfo.y) || s <= end[i] ) { 
          if( s >= newSat[newSat.length -1] ) s = newSat[newSat.length -1] ;
          else s = newSat[i] ;
        }
      }        
    }
    newC.y = s ;
  }
  
  // saturation from Range
  public void changeBright(vec4 HSBinfo, int[] newBright,  int[] start, int[] end) {
    float b = brightness(this.colour) ;

    
    for( int i = 0 ; i < newBright.length ; i++) {
      if (start[i] < end[i] ) {
        if( b >= start[i] && b <= end[i] ) b = newBright[i] ; 
      } else if ( start[i] > end[i] ) {
        if( (b >= start[i] && b <= HSBinfo.z) || b <= end[i] ) { 
          if( b >= newBright[newBright.length -1] ) b = newBright[newBright.length -1] ;
          else b = newBright[i] ;
        }
      }        
    }
    newC.z = b ;
  }
  
  
  
  //change color of pixel for single color
  // void changeColor(color nc) { color c = nc ; }
  
  public void updatePalette() { 
    int h = (int)newC.x ;
    int s = (int)newC.y ;
    int b = (int)newC.z ;

    newColour = color(h,s,b) ;
  }
  
  
  //UPDATE POSITION with the wind
  public void updatePosPixel(PVector effectPosition, PImage pic) {
    PVector dir = normal_direction((int)effectPosition.x) ;
    
    wind = new PVector (1.0f *dir.x *effectPosition.y  + random(-effectPosition.z, effectPosition.z) ,   1.0f *dir.y *effectPosition.y  + random(-effectPosition.z, effectPosition.z))   ;
    pos.add(wind) ;
    //keep the pixel in the scene
    if (pos.x< 0)          pos.x= pic.width;
    if (pos.x> pic.width)  pos.x=0;
    if (pos.y< 0)          pos.y= pic.height;
    if (pos.y> pic.height) pos.y=0;
  }
  
  
  
  //return position with display size
  public PVector posPixel(PVector effectPosition, PImage pic) {
    PVector dir = normal_direction((int)effectPosition.x) ;

    newPos = pos ;
    
    wind = new PVector (1.0f *dir.x *effectPosition.y  + random(-effectPosition.z, effectPosition.z) ,   1.0f *dir.y *effectPosition.y  + random(-effectPosition.z, effectPosition.z))   ;
    newPos.add(wind) ;
    //keep the pixel in the scene
    if (newPos.x< 0)          newPos.x= pic.width;
    if (newPos.x> pic.width)  newPos.x=0;
    if (newPos.y< 0)          newPos.y= pic.height;
    if (newPos.y> pic.height) newPos.y=0;
    
    return new PVector (newPos.x, newPos.y) ;
  }
}
// END CLASS PIXEL
/////////////////



















/**
 OLD Method deprecated
*/
//////////////////////////////////////////////
// THIS PART MUST BE DEPRECATED in the future
public PVector rotation (PVector ref, PVector lattice, float angle) {
  float a = angle(lattice, ref) + angle;
  float d = distance( lattice, ref );
  float x = lattice.x + cos( a ) * d;
  float y = lattice.y + sin( a ) * d;
  return new PVector(x,y);
}
public float distance( PVector p0, PVector p1) {
  return sqrt((p0.x - p1.x) *(p0.x - p1.x) +(p0.y - p1.y ) *(p0.y - p1.y ) );
}
public float angle( PVector p0, PVector p1) {
  return atan2( p1.y -p0.y, p1.x -p0.x );
}


// CALCULATE THE POS of PVector Traveller
public PVector gotoTarget(PVector origin,  PVector finish, float speed) {
  PVector pos = new PVector() ;
  if(origin.x > finish.x) pos.x = origin.x  -distanceDone(origin, finish, speed).x ; else pos.x = origin.x  +distanceDone(origin, finish, speed).x ; 
  if(origin.y > finish.y) pos.y = origin.y  -distanceDone(origin, finish, speed).y ; else pos.y = origin.y  +distanceDone(origin, finish, speed).y ; 
  if(origin.z > finish.z) pos.z = origin.z  -distanceDone(origin, finish, speed).z ; else pos.z = origin.z  +distanceDone(origin, finish, speed).z ; 
  return pos ;
}
// end calcultate




// DISTANCE DONE
PVector distance, distanceToDo ;
PVector distanceDone = new PVector() ;

public PVector distanceDone(PVector origin,  PVector finish, float speedRef) {
  PVector dist = new PVector() ;
  PVector distance = new PVector() ;
  boolean stopX = false ;
  boolean stopY = false ;
  boolean stopZ = false ;
  distance.x = abs(finish.x - origin.x) ;
  distance.y = abs(finish.y - origin.y) ;
  distance.z = abs(finish.z - origin.z) ;
  //calcul the speed for XYZ
  PVector speed = new PVector(speedMoveTo(distance.x, speedRef), speedMoveTo(distance.y, speedRef), speedMoveTo(distance.z, speedRef)) ;
  // for the X
  dist.x = distance.x -distanceDone.x ;
  if(dist.x <= 0 ) stopX = true ; else stopX = false ;
  if(speed.x > dist.x ) speed.x = dist.x ;
  if(!stopX) distanceDone.x += speed.x ; else distanceDone.x = distance.x ;
  // for the Y
  dist.y = distance.y -distanceDone.y ;
  if(dist.y <= 0 ) stopY = true ; else stopY = false ;
  if(speed.y > dist.y ) speed.y = dist.y ;
  if(!stopY) distanceDone.y += speed.y ; else distanceDone.y = distance.y ;
  // for the Z
  dist.z = distance.z -distanceDone.z ;
  if(dist.z <= 0 ) stopZ = true ; else stopZ = false ;
  if(speed.z > dist.z ) speed.z = dist.z ;
  if(!stopZ) distanceDone.z += speed.z ; else distanceDone.z = distance.z ;
  //
  return distanceDone ;
}


public float speedMoveTo(float distance, float speed) {
  return distance *1 *speed ;
}



// PVector goToPosFollow = = new PVector() ;
// CALCULATE THE POS of PVector Traveller, give the target pos and the speed to go.
public PVector follow(PVector target, float speed) {
  PVector goToPosFollow = new PVector() ;
  // calcul X pos
  float targetX = target.x;
  float dx = targetX - goToPosFollow.x;
  if(abs(dx) != 0) {
    goToPosFollow.x += dx * speed;
  }
  // calcul Y pos
  float targetY = target.y;
  float dy = targetY - goToPosFollow.y;
  if(abs(dy) != 0) {
    goToPosFollow.y += dy * speed;
  }
  // calcul Z pos
  float targetZ = target.z;
  float dz = targetZ - goToPosFollow.z;
  if(abs(dz) != 0) {
    goToPosFollow.z += dz * speed;
  }
  return goToPosFollow ;
}







































// CANVAS
/////////////////
/* Canvas 1.c by Stan le Punk february 2015 */
class Canvas {
  PVector pos, size ;
  PVector [] points  ;
    // X coord
  float left, right ;
  // Y coord
  float top, bottom ;
  // Z coord
  float front, back ;
  
  Canvas(PVector pos, PVector size) {
    this.pos = pos ;
    this.size = size ;
    update() ;
  }
  
  
  public void update() {
    // X coord
    this.left = pos.x -(size.x *.5f) ;
    this.right = pos.x +(size.x *.5f) ;
   // Y coord
   this.top = pos.y -(size.y *.5f) ;
   this.bottom = pos.y +(size.y *.5f) ;
   // Z coord
   this.front = pos.z +(size.z *.5f) ;
   this.back =  pos.z -(size.z *.5f) ;
    
    if(size.y != 0) {
      points = new PVector[8] ;
      points[0] = new PVector(left,top,front) ;
      points[1] = new PVector(right,top,front) ;
      points[2] = new PVector(right,bottom,front) ;
      points[3] = new PVector(left,bottom,front) ;
      points[4] = new PVector(left,top,back) ;
      points[5] = new PVector(right,top,back) ;
      points[6] = new PVector(right,bottom,back) ;
      points[7] = new PVector(left,bottom,back) ;
    } else {
      points = new PVector[4] ;
      points[0] = new PVector(left,top) ;
      points[1] = new PVector(right,top) ;
      points[2] = new PVector(right,bottom) ;
      points[3] = new PVector(left,bottom) ;
    }
  }
  
  
  
  
  public void canvasLine() {
    if(points.length > 4) {
      for(int i = 1 ; i < 4 ; i++) {
        // draw line box
        line(points[i-1].x, points[i-1].y,points[i-1].z, points[i].x,points[i].y, points[i-1].z) ;
        line(points[i+3].x, points[i+3].y,points[i+3].z, points[i+4].x,points[i+4].y, points[i+4].z) ;
      }
      // special line
      line(points[0].x, points[0].y,points[0].z, points[3].x,points[3].y, points[3].z) ;
      line(points[4].x, points[4].y,points[4].z, points[7].x,points[7].y, points[7].z) ;
      
      
      for(int i = 0 ; i < 4 ; i++) {
        line(points[i].x,points[i].y, points[i].z, points[i+4].x, points[i+4].y,points[i+4].z) ;
      }
    } else {
      // draw line rect
      for(int i = 1 ; i < 4 ; i++) {
         line(points[i-1].x, points[i-1].y, points[i].x,points[i].y) ;
      }
      // close
      line(points[3].x, points[3].y, points[0].x,points[0].y) ;
    }
  }
}
// END CANVAS
/////////////














/**
The ABBYSS
2014
v 2.1.5
*/


// boolean useBackdrop = false;
// CreatureManager creatureManager ;

//object one
class The_Abbyss extends Romanesco {
  CreatureManager creatureManager ;

  public The_Abbyss() {
    //from the index_objects.csv
    item_name = "The Abbyss" ;
    item_author  = "Andreas Gysin";
    item_version = "version 2.1.5";
    item_pack = "Base 2014-2018" ;
    item_costume = "";
    item_mode = "Box Fish/Cubus/Floater/Radio/Worm/Sea Fly/Breather/Spider/Manta/Father/Super Nova" ;// separate the name by a slash and write the next mode immadialtly after this one.

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = false;
    size_y_is = false;
    size_z_is = false;
    diameter_is = false;
    canvas_x_is = false;
    canvas_y_is = false;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = false;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = false;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
  //GLOBAL
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    creatureManager = new CreatureManager(this);
  }
  //DRAW
  public void draw() {

    if(alpha(get_stroke()) == 0) set_thickness_raw(0,0,0); // this line is dangerous...direct access to something resrved for the slider ????
   //  pushMatrix();
    creatureManager.loop(get_fill(), get_stroke(), get_thickness(), get_speed_x() *100.0f);
    // popMatrix();
    // resetMatrix();
    
    
    
    
    //CHANGE MODE DISPLAY
    /////////////////////
    int whichCreature ; 
    if (get_mode_id() == 0 || get_mode_id() == 255 ) whichCreature = 0 ;
    else if (get_mode_id() == 1 ) whichCreature = 1 ;
    else if (get_mode_id() == 2 ) whichCreature = 2 ;
    else if (get_mode_id() == 3 ) whichCreature = 3 ;
    else if (get_mode_id() == 4 ) whichCreature = 4 ;
    else if (get_mode_id() == 5 ) whichCreature = 5 ;
    else if (get_mode_id() == 6 ) whichCreature = 6 ;
    else if (get_mode_id() == 7 ) whichCreature = 7 ;
    else if (get_mode_id() == 8 ) whichCreature = 8 ;
    else if (get_mode_id() == 9 ) whichCreature = 9 ;
    else if (get_mode_id() == 10 ) whichCreature = 10 ;
    else if (get_mode_id() == 11 ) whichCreature = 11 ;
    else if (get_mode_id() == 12 ) whichCreature = 12 ;
    else whichCreature = 0 ;
    
    if(action_is()) {
      if (key_n_long && frameCount % 3 == 0) creatureManager.addCurrentCreature(whichCreature);
      //to cennect the creature to the camera
      if(key_c_long) {
        if (key_up )    creatureManager.nextCameraCreature();
        else if (key_down )  creatureManager.prevCameraCreature();
      }
    }
    //
    if (reset(this)) creatureManager.killAll(whichCreature);
    
    // info display
    info("Creatures "+ creatureManager.creatures.size()) ;

  }



  

  private class CreatureManager {
    private ArrayList<SuperCreature>creatures;
    private ArrayList<Class>creatureClasses;

    int currentCameraCreature =-1;
    PVector releasePoint;

    SuperCreature previewCreature;  
    Romanesco parent;
    String infoText;

    // int currentCreature = -1;
    int currentCreature = 5; // the breather object is display when you start this object
    boolean showCreatureInfo = false;
    boolean showCreatureAxis = false;
    boolean showAbyssOrigin  = false;
    boolean showManagerInfo = false;
    //boolean highTextQuality = false;
    
    CreatureManager(Romanesco parent) {
      this.parent = parent;
      releasePoint = PVector.random3D();
      releasePoint.mult(100);
      creatures = new ArrayList<SuperCreature>();

      creatureClasses = scanClasses(parent, "SuperCreature");
      if (creatureClasses.size() > 0) selectNextCreature();
    }

    private ArrayList<Class> scanClasses(Romanesco parent, String superClassName) {
      ArrayList<Class> classes = new ArrayList<Class>();  
      infoText = "";
      Class[] c = parent.getClass().getDeclaredClasses();
      for (int i=0; i<c.length; i++) {
        if (c[i].getSuperclass() != null && (c[i].getSuperclass().getSimpleName().equals(superClassName) )) {
          classes.add(c[i]);
          int n = classes.size()-1;
          String numb = str(n);
          if (n < 10) numb = " " + n;
          infoText += numb + "         " + c[i].getSimpleName() + "\n";
        }
      }
      return classes;
    }

    public ArrayList<SuperCreature> getCreatures() {
      return creatures;
    }

    public SuperCreature addCreature( int i) {
      if (i < 0 || i >= creatureClasses.size()) return null;

      SuperCreature f = null;
      try {
        Class c = creatureClasses.get(i);
        Constructor[] constructors = c.getConstructors();
        f = (SuperCreature) constructors[0].newInstance(parent);
      } 

      catch (InvocationTargetException e) {
        System.out.println(e);
      } 
      catch (InstantiationException e) {
        System.out.println(e);
      } 
      catch (IllegalAccessException e) {
        System.out.println(e);
      } 

      if (f != null) {
        releasePoint = PVector.random3D();
        releasePoint.mult(100);
        addCreature(f);
      }
      return f;
    }

    private void addCreature(SuperCreature c) {
      c.setManagerReference(this);
      creatures.add(c);
      tellAllThatCreatureHasBeenAdded(c);
    }

    private void tellAllThatCreatureHasBeenAdded(SuperCreature cAdded) {
      for (SuperCreature c : creatures) {
        c.creatureHasBeenAdded(cAdded);
      }
    }

    public void killCreature(SuperCreature c) {
      c.kill();
    }

    public void killAll(int whichCreature) {
      creatures.clear();
      // TODO:
      // the previewCreature needs to get out from the main array 
      // to avoid code like this:
      currentCreature--;
      selectNextCreature(whichCreature);
    }

    public void killCreatureByName(String creatureName) {
      for (SuperCreature c : creatures) {
        String name = c.creatureName;
        if (creatureName.equals(name)) creatures.remove(creatures.indexOf(c));
      }
    }
    
    // main void
    public void loop(int colorIn, int colorOut, float thickness, float speed) {
      if (showAbyssOrigin) {
        noFill();
        stroke(255, 0, 0);
        repere(200) ;
      }
      if (previewCreature != null) {
        previewCreature.setPos(releasePoint);
        previewCreature.energy = 200.0f;
      }
      for (SuperCreature c : creatures) { 
        c.preDraw();
        c.move(speed);      
        c.draw(colorIn, colorOut, thickness);
        c.postDraw();
      }
      //
      cleanUp();
    }

    public void cleanUp() {
      //remove dead cratures
      Iterator<SuperCreature> itr = creatures.iterator();
      while (itr.hasNext ()) {
        SuperCreature c = itr.next();
        if (c.getEnergy() <= 0) itr.remove();
      }
    }
    
    //add random creature
    public void addRandomCreature() {
      int r = floor(random(creatureClasses.size()));
      addCreature(r);
    }

    
    
    //add creature
    public SuperCreature addCurrentCreature() {
      if (currentCreature != -1) {
        previewCreature = addCreature(currentCreature);
      }
      return previewCreature;
    }
      // add specific creature
    public SuperCreature addCurrentCreature(int which) {
      if (which != -1) {
        previewCreature = addCreature(which);
      }
      return previewCreature;
    }

    public void setCurrentCreature(int i) {
      currentCreature = i;  
      if (currentCreature < -1 || currentCreature > creatureClasses.size()) {
        currentCreature = -1;
      }
      if (currentCreature > -1) {
        if (previewCreature != null) {
          previewCreature.kill();
          previewCreature = null;
        }
        if (currentCreature > -1) {
          previewCreature = addCreature(currentCreature);
        } 
        else {
          if (previewCreature != null) previewCreature.kill();
          previewCreature = null;
        }
      }
      else {
        if (previewCreature != null) {
          previewCreature.kill();
          previewCreature = null;
        }
      }
    }
    
    public void selectNextCreature() {
      if (creatureClasses.size() > 0) {
        currentCreature = ++currentCreature % creatureClasses.size();     
        setCurrentCreature(currentCreature);
      }
    }
    // we use this function when we kill all creature to show by default the creature select by the dropdown
    public void selectNextCreature(int which) {
      if (creatureClasses.size() > 0) {
        // currentCreature = ++currentCreature % creatureClasses.size();     
        setCurrentCreature(which);
      }
    }

    public void selectPrevCreature() {
      if (creatureClasses.size() > 0) {
        currentCreature--;
        if (currentCreature < 0) currentCreature = creatureClasses.size()-1;
        setCurrentCreature(currentCreature);
      }
    }

    public void toggleManagerInfo() {
      showManagerInfo = !showManagerInfo;
    }

    public void toggleCreatureInfo() {
      showCreatureInfo = !showCreatureInfo;
    }

    public void toggleAbyssOrigin() {
      showAbyssOrigin = !showAbyssOrigin;
    }

    public void toggleCreatureAxis() {
      showCreatureAxis = !showCreatureAxis;
    }
    
    //CAMERA
    ///////
    public void prevCameraCreature() {
      if (creatures.size() > 0) {
        
        currentCameraCreature--;
        //security for the arraylist !
        if (currentCameraCreature < 0) currentCameraCreature = creatures.size()-1;
        travelling(vec3(creatures.get(currentCameraCreature).getPos())) ;
      } else {
        currentCameraCreature = -1;
      }
    }
    public void nextCameraCreature() {
      if (creatures.size() > 0) {
        
        currentCameraCreature = ++currentCameraCreature % creatures.size();
        travelling(vec3(creatures.get(currentCameraCreature).getPos())) ;
      } else {
        currentCameraCreature = -1;
      }
    }
    // END CAMERA
    
  }


  //SUPER CREATURE
  ////////////////
   // The SuperCreature class
   // Every creature will extend this class.
  abstract class SuperCreature {
    protected PVector pos, rot, sca;
    private PVector projectedPos;
    public float energy ; 
    private float power;
    String creatureName, creatureAuthor, creatureVersion;
    //CreatureDate creatureDate;
    CreatureManager cm;

    public SuperCreature() {
      creatureName = "Unknown";
      creatureAuthor = "Anonymous";
      creatureVersion = "Alpha";

      //energy = 100.0;
      power = 0.02f;
      pos = new PVector();
      projectedPos = new PVector();
      rot = new PVector();
      sca = new PVector(1, 1, 1);
    }

    public void setManagerReference(CreatureManager cm) {
      this.cm = cm;
    }

    public abstract void move(float s);
    public abstract void draw(int cIn, int cOut, float t);

    //applies the default transforms... can be used as a shortcut
    public void applyTransforms() {
      translate(pos.x, pos.y, pos.z);
      rotateX(rot.x);
      rotateY(rot.y);
      rotateZ(rot.z);
      scale(sca.x, sca.y, sca.z);
    }

    private void preDraw() {
      energy = max(0, energy - power); //creatures with energy == 0 will be removed
      pushStyle();
      strokeWeight(1); //apparently a pushStyle bug?
      pushMatrix();     
      // transforms are handled by the creature 
      // this allows greater flexibility for example for particle based creatures 
      // which don't use matrix transforms
      // we don't pre-translate, rotate and scale:
      // translate(pos.x, pos.y, pos.z);
      // rotateX(rot.x);
      // rotateY(rot.y);
      // rotateZ(rot.z);
      // scale(sca.x, sca.y, sca.z);
    };  


    private void postDraw() {
      popMatrix(); 
      popStyle();
      /*
      projectedPos.x = screenX(pos.x, pos.y, pos.z);
      projectedPos.y = screenY(pos.x, pos.y, pos.z);
      */
    };

    public PVector getPos() {
      return pos.copy();
    }

    public void setPos(PVector pos) {
      this.pos = pos.copy();
    }

    public void creatureHasBeenAdded(SuperCreature c) {
    }

    public SuperCreature getNearest() {
      return getNearest("");
    }

    public SuperCreature getNearest(String creatureName) {
      float d = MAX_FLOAT;
      SuperCreature nearest = null;
      for (SuperCreature c : cm.getCreatures()) {
        if (c != this && (c.creatureName != creatureName)) {
          PVector p = c.getPos();
          PVector m = PVector.sub(pos, p);
          float s = m.x * m.x + m.y * m.y + m.z * m.z;//m.mag();
          if (s < d) {
            d = s; 
            nearest = c;
          }
        }
      }
      return nearest;
    }



    public float getEnergy() {
      return energy;
    }

    public void kill() {
      energy = 0.0f;
    }
  }
  //END SUPERCREATURE










  //CREATURE CATALOGUE
  //BOXFISH
   // A simple box-like fish.
   // Just swims around following it's heartbeat.
  class AGBoxFish extends SuperCreature {
    PMatrix3D mat;
    PVector dimBox, dimR, dimF;
    float fF, fR, aF, aR, fRot, aRot;
    float eye;
    float spd;

    public AGBoxFish() {
      creatureAuthor  = "Andreas Gysin";
      creatureName    = "BoxFish";
      creatureVersion = "Beta";
      //energy = 0 ;

      mat = new PMatrix3D();
      mat.rotateY(random(TWO_PI));
      mat.rotateZ(random(-0.1f, 0.1f));

      dimR = new PVector(random(10, 30), random(10, 30));
      dimF = new PVector(random(5, 50), random(5, 20));
      dimBox = new PVector(random(20, 80), random(20, 80), random(15, 40));
      fF = random(0.1f, 0.3f);
      aF = random(0.6f, 1.0f);
      fR = random(0.8f, 0.9f);
      aR = random(0.6f, 1.0f);
      fRot = fF;//random(0.05, 0.1);
      aRot = random(0.02f, 0.05f);
      spd = fRot * 10;
      eye = random(1, 3);
    }

    public void move(float speed) {
      float s = sin(frameCount *fRot);
      mat.rotateY(s * aRot + (noise(pos.z * 0.01f, frameCount * 0.01f) -0.5f) * 0.1f);
      mat.rotateZ(s * aRot * 0.3f);
      mat.translate(-spd, 0, 0);
      mat.mult(new PVector(), pos);
    }

    public void setPos(PVector p) {
      float[] a = mat.get(null);
      a[3] = p.x;
      a[7] = p.y;
      a[11] = p.z;
      mat.set(a);
    }

    public void draw(int colorIn, int colorOut, float thickness) {
      applyMatrix(mat);
      pushMatrix();
      sphereDetail(5);
      scale(min(getEnergy() * 0.1f, 1)); //it's possible to animate a dying creature...
      translate(dimBox.x/4, 0, 0);
      float f = sin(frameCount * fF) * aF;  
      float r = sin(frameCount * fR) * aR;
      //float h = sin(frameCount * fF * 0.5 + aF);
      //float a = map(h, -1, 1, 20, 100);  

      //noStroke();
      //fill(255,0,0 a);
      //float hr = dimBox.z * 0.15 + h * dimBox.z * 0.03;
      //sphere(hr/2);
      //sphere(hr);

      fill(colorIn);
      stroke(colorOut);
      strokeWeight(thickness) ;
      
      box(dimBox.x, dimBox.y, dimBox.z);

      pushMatrix();
      translate(-dimBox.x/2, dimBox.y/2, dimBox.z/2);
      rotateZ(HALF_PI);
      rotateY(f - 1);
      rect(0, 0, dimF.x, dimF.y);
      popMatrix();

      pushMatrix();
      translate(-dimBox.x/2, dimBox.y/2, -dimBox.z/2);
      rotateZ(HALF_PI);
      rotateY(-f + 1);
      rect(0, 0, dimF.x, dimF.y);
      popMatrix();

      pushMatrix();
      translate(dimBox.x/2, dimBox.y/2, dimBox.z/2);
      rotateY(r);
      rect(0, 0, dimR.x, dimR.y);
      popMatrix();

      pushMatrix();
      translate(dimBox.x/2, dimBox.y/2, -dimBox.z/2);
      rotateY(-r);
      rect(0, 0, dimR.x, dimR.y);
      popMatrix();
      //eye of the fish
      noStroke();
      fill(colorOut);
      pushMatrix();
      translate(-dimBox.x/2 + eye, dimBox.y/3, -dimBox.z/2);
      sphere(eye);
      translate(0, 0, dimBox.z);
      sphere(eye);
      popMatrix();

      popMatrix();
    }
  }
  //END BOXFISH


   //A creature with four tentacles.
   //Floats it's life away in the Abyss.
  class AGCubus extends SuperCreature {
    PVector fPos, fAng;
    float cSize;
    int segments;
    float bLen;
    float aFreq;
    float bOffs;
    float angRange;

    public AGCubus() {
      creatureAuthor  = "Andreas Gysin";
      creatureName    = "Cubus";
      creatureVersion = "Beta";

      cSize = random(6, 30);
      fPos = new PVector(random(-0.002f, 0.002f), random(-0.002f, 0.002f), random(-0.002f, 0.002f));
      fAng = new PVector(random(-0.005f, 0.005f), random(-0.005f, 0.005f), random(-0.005f, 0.005f));
      
      segments = PApplet.parseInt(random(5,9));
      bLen = random(4, 10);
      aFreq = random(0.01f, 0.1f);
      bOffs = random(5);
      angRange = random(0.3f, 0.6f);
    }

    public void move(float speed) {
      pos.x += sin(frameCount *fPos.x);
      pos.y += sin(frameCount *fPos.y );
      pos.z += cos(frameCount *fPos.y);

      rot.x = sin(frameCount*fAng.x) * TWO_PI;
      rot.y = sin(frameCount*fAng.y) * TWO_PI;
      rot.z = sin(frameCount*fAng.z) * TWO_PI; 
    }

    public void draw(int colorIn, int colorOut, float thickness) {    
      applyTransforms(); //shortcut   
      fill(colorIn) ;
      stroke(colorOut);

      // the body
      strokeWeight(thickness);
      box(cSize); 
      
      //the four tentacles
      strokeWeight(thickness);
      for (int j=0; j<4; j++) {
        PVector p = new PVector(bLen, 0); 
        PVector pos = new PVector(cSize/2, 0); 
        float ang = sin(frameCount*aFreq + j%2 * bOffs) * angRange;
        float l = bLen;
        beginShape();
        for (int i=0; i<segments+1; i++) {
          vertex(pos.x, pos.y);
          pos.x += p.x;
          pos.y += p.y;
          p = rotateVec(p, ang);
          p.limit(l);
          l *= 0.93f; //scale a bit, this factor could also be randomized.
        }
        endShape();
        rotateY(HALF_PI);
      }
    }

    public PVector rotateVec(PVector v, float angle) {
      float c = cos(angle);
      float s = sin(angle);
      return new PVector(v.x*c - v.y*s, v.x*s + v.y*c);
    }    
  }



   //A floating fish.
   //Position is calculated with Perlin noise.
  class AGFloater extends SuperCreature {

    PMatrix3D mat;
    float offset;
    float ampBody, ampWing;
    float freqBody, freqWing;
    float wBody, hBody, wWing;
    float noiseScale, noiseOffset;
    float speedMin, speedMax;

    public AGFloater() {
      creatureAuthor  = "Andreas Gysin";
      creatureName    = "Floater";
      creatureVersion = "Beta";

      mat = new PMatrix3D();
      mat.rotateY(random(TWO_PI));
      mat.rotateZ(random(-0.2f, 0.2f));

      freqBody = random(0.1f, 0.2f);
      freqWing = freqBody;
      offset = 1.2f + random(-0.1f,0.2f);
      float s = 0.9f;
      ampBody = random(10, 30)*s;
      ampWing = random(0.6f, 1.2f)*s;
      wBody = random(20, 40)*s;
      hBody = random(30, 90)*s;
      wWing = random(20, 50)*s;
      speedMin = random(2.5f,3.5f)*s;
      speedMax = random(4.5f,5.5f)*s;
      
      noiseScale = 0.012f;
      noiseOffset = random(1); 
    }

    public void move(float speedValue) {
      mat.rotateY(map(noise(frameCount * noiseScale + noiseOffset), 0, 1, -0.1f, 0.1f));
      float speed = map(sin(frameCount * freqBody), -1, 1, speedMin , speedMax ); 
      mat.translate(0 , 0, speed);
      mat.mult(new PVector(), pos); //update the position vector
    }

    public void setPos(PVector p) {
      float[] a = mat.get(null);
      a[3] = p.x;
      a[7] = p.y;
      a[11] = p.z;
      mat.set(a);
    }

    public void draw(int colorIn, int colorOut, float thickness) {
      applyMatrix(mat);
      //stroke(255);
      stroke(colorOut);
      fill(colorIn);
      strokeWeight(thickness) ;
      rotateX(-HALF_PI);
      scale(min(getEnergy() * 0.1f, 1));

      float h1 = sin(frameCount * freqBody) * ampBody;
      float h2 = sin(frameCount * freqWing + offset) * ampWing;

      translate(0, 0, h1);
      rectMode(CENTER);
      rect(0, 0, wBody, hBody);

      rectMode(CORNER);
      pushMatrix();
      translate(-wBody/2, -hBody/2, 0);
      rotateY(PI - h2);
      rect(0, 0, wWing, hBody);
      popMatrix();

      pushMatrix();
      translate(wBody/2, -hBody/2, 0);
      rotateY(h2);
      rect(0, 0, wWing, hBody);
      popMatrix();
    }
  }




  // An attempt of a radiolaria-like creature.
  // Uses vertex colors for gradients.
  class AGRadio extends SuperCreature {

    PVector pVel, rVel;
    int num, spikes;
    float freq;
    float rad, rFact;

    public AGRadio() {
      creatureAuthor  = "Andreas Gysin";
      creatureName    = "Radio";
      creatureVersion = "Alpha";

      pVel = new PVector( random(-1, 1), random(-1, 1), random(-1, 1) );
      rVel = new PVector( random(-0.01f, 0.01f), random(-0.01f, 0.01f), random(-0.01f, 0.01f) );
      num = round(random(20, 100));
      spikes = ceil(random(3, 12));
      freq = random(0.02f, 0.06f);
      rad = random(30, 60);
      rFact = random(0.2f, 0.4f);
    }

    public void move(float speed) {
      pos.add(pVel); 
      rot.add(rVel);  
      applyTransforms();
    }

    public void draw(int colorIn, int colorOut, float thickness) {  
      stroke(colorOut);
      fill(colorIn);
      strokeWeight(thickness);
      hint(DISABLE_DEPTH_TEST); 
      float arc = TWO_PI / num;    
      float f = frameCount * freq;
      float a = arc * spikes;
      beginShape(QUAD_STRIP);
      for (int i=0; i<num+1; i++) { 
        int j = i % num;
        float len = (sin(f + a * j)) * 0.2f;
        float c = cos(arc * j); 
        float s = sin(arc * j);
        float x = c * (rad + len * rad);
        float y = s * (rad + len * rad);
        float z = len * rad;
        fill(hue(colorIn), saturation(colorIn), brightness(colorIn), i % 2 * alpha(colorIn)  ); 
        vertex(x*rFact, y*rFact, z);
        fill(255, 0); 
        vertex(x, y, 0);
      }
      endShape();
      hint(ENABLE_DEPTH_TEST);
    }
  }




  // An example creature with simple spring and node classes.
  // Moves randomly trough the deep waters in search for meaning.
  class AGWorm extends SuperCreature {
    ArrayList<Node> nodes;
    ArrayList<Spring> springs;

    PVector dest;
    float nervosismo;
    float radius;
    float rSpeed, rDamp;
    float freq1, freq2;

    public AGWorm() {
      creatureAuthor = "Andreas Gysin";
      creatureName = "El Worm";
      creatureVersion = "Alpha";

      int num = PApplet.parseInt(random(7,22));
      float len = random(2, 15);
      float damp = random(0.85f, 0.95f);
      float k = random(0.15f,0.3f);
      radius = random(1.5f, 2.5f);   
      rSpeed = random(50,150);
      rDamp = random(0.005f, 0.02f);
      nervosismo = random(0.01f, 0.3f);
      freq1 = random(0.05f, 0.2f);
      freq2 = random(0.08f, 1.1f);

      nodes = new ArrayList<Node>();

      springs = new ArrayList<Spring>();
      for (int i=0; i<num; i++) {
        PVector p = PVector.add(pos, new PVector(random(-1,1),random(-1,1),random(-1,1)));
        Node n = new Node(p, damp);
        nodes.add(n);
      }
      
      for (int i=0; i<num-1; i++) {
        Spring s = new Spring(nodes.get(i), nodes.get(i+1), len, k);
        springs.add(s);
      }
      
      dest = new PVector();
    }

    public void move(float speed) {
      if (random(1) < nervosismo) {
        dest.add(new PVector(random(-rSpeed,rSpeed),random(-rSpeed,rSpeed),random(-rSpeed,rSpeed)));
      }
      pos.x += (dest.x - pos.x) * rDamp;
      pos.y += (dest.y - pos.y) * rDamp;
      pos.z += (dest.z - pos.z) * rDamp;
      nodes.get(0).setPos(pos);
      for (Spring s : springs) s.step();
      for (Node n : nodes) n.step();
    }

    public void draw(int colorIn, int colorOut, float thickness) {
      fill(colorIn);
      stroke(colorOut);
      strokeWeight(thickness) ;
      for (Spring s : springs) {
        line(s.a.x, s.a.y, s.a.z, s.b.x, s.b.y, s.b.z);
      }

      int i=0;
      //noStroke();
      sphereDetail(3);
      //fill(colorIn);  
      float baseFreq = frameCount * freq1;
      for (Node n : nodes) {
        float d = map( sin(baseFreq - i*freq2), -1, 1, radius, radius * 2);
        pushMatrix();
        translate(n.x, n.y, n.z);
        //if ((i + frameCount/5) % 4 == 0) d *= 0.5;
        sphere(d);      
        popMatrix();
        i++;
      }
    }

    class Node extends PVector {

      float damp;
      PVector vel;

      Node(PVector v, float damp) {
        super(v.x, v.y, v.z);
        this.damp = damp;
        vel = new PVector();
      }

      public void step() {
        add(vel);
        vel.mult(damp);
      }

      public void applyForce(PVector f) {
        vel.add(f);
      }

      public void setPos(PVector p) {
        this.x = p.x;
        this.y = p.y;
        this.z = p.z;
        vel = new PVector();
      }
    }
    
    class Spring {
      float len;
      float scaler;
      Node a, b;

      Spring(Node a, Node b, float len, float scaler) {
        this.a = a;
        this.b = b;
        this.len = len;
        this.scaler = scaler;
      }

      public void step() {

        PVector v = PVector.sub(b, a);
        float m = (v.mag() - len) / 2 * scaler;
        v.normalize();

        v.mult(m);    
        a.applyForce(v);

        v.mult(-1);    
        b.applyForce(v);
      }
    }
  }



  //SEA FLY
  class EPSeaFly extends SuperCreature {

    PVector freqMulPos, freqMulAng;
    int count;

    public EPSeaFly() {
      creatureName = "EPSeaFly";
      creatureAuthor = "Edoardo Parini";
      creatureVersion = "1.0";

      freqMulPos = new PVector();
      freqMulPos.x = random(-0.002f, 0.002f); 
      freqMulPos.y = random(-0.002f, 0.002f); 
      freqMulPos.z = random(-0.002f, 0.002f);

      freqMulAng = new PVector();
      freqMulAng.x = random(-0.005f, 0.005f); 
      freqMulAng.y = random(-0.005f, 0.005f); 
      freqMulAng.z = random(-0.005f, 0.005f);
    }

    public void move(float speed) {
      count++;
      pos.x += sin(count *freqMulPos.x);
      pos.y += sin(count *freqMulPos.y);
      pos.z += cos(count *freqMulPos.y);

      rot.x = sin(count*freqMulAng.x) * TWO_PI;
      rot.y = sin(count*freqMulAng.y) * TWO_PI;
      rot.z = sin(count*freqMulAng.z) * TWO_PI;
      
      applyTransforms();
    }

    public void draw(int colorIn, int colorOut, float thickness) {

      stroke(colorOut);
      fill(colorIn); 
      strokeWeight(thickness) ; 
      // float dimR = 20;
      // float dimF = 10;  

      scale(0.2f);
      translate(count * 0.018f, count * 0.008f); 
      rotateX(count * 0.008f);

      PVector dim = new PVector(100, 60, 30);
      sphereDetail(3); 
      sphere(25);

      float aF = sin(count * 0.15f) * 0.8f;  
      float aR = sin(count * 0.25f) * 0.8f;

      pushMatrix();                            
      translate(-dim.x/2, dim.y/2, dim.z/2);
      rotateZ(aF/2 + 1.2f);
      rotateY(aF - 1);
      fill(hue(colorIn), saturation(colorIn), brightness(colorIn),alpha(colorIn)*.3f);
      quad(0, 0, 86, 20, 69, 63, 30, 76);
      noFill();
      quad(0, 0, 96, 23, 79, 73, 40, 86);
      popMatrix();

      pushMatrix();                          
      translate(-dim.x/2, dim.y/2, -dim.z/2);
      rotateZ(aF/2 + 1.2f);
      rotateY(-aF + 1);
      fill(hue(colorIn), saturation(colorIn), brightness(colorIn),alpha(colorIn)*.3f);
      quad(0, 0, 86, 20, 69, 63, 30, 76);
      noFill();
      quad(0, 0, 96, 23, 79, 73, 40, 86);
      popMatrix();

      pushMatrix();                          
      translate(dim.x/2, dim.y/2, dim.z/2);
      rotateY(aR);
      quad(0, 0, 96, 23, 79, 73, 40, 86);
      fill(hue(colorIn), saturation(colorIn), brightness(colorIn),alpha(colorIn)*.3f);
      quad(0, 0, 86, 20, 69, 63, 30, 76);
      popMatrix();

      pushMatrix();                  
      translate(dim.x/2, dim.y/2, -dim.z/2);
      rotateY(-aR);
      quad(0, 0, 86, 20, 69, 63, 30, 76);
      noFill();
      quad(0, 0, 96, 23, 79, 73, 40, 86);
      popMatrix();
    }
  }






  //BREATHER
  class FFBreather extends SuperCreature {

    PVector oldPosition;
    PVector acc = new PVector(0,0);
    float xoff = 0.1f, yoff = 10.45f;
    float xadd = 0.001f, yadd = 0.005f;
    float xNoise = 0, yNoise = 0;
    PVector inside = new PVector(0,0);
    PVector center = new PVector(0,0);
    float sizeIt = 0, addSizeIt = 00.01f;
    float sizeItCos, breath, breathoff, breathadd;
    PVector one,two,three, len, newCenter;
    ArrayList<PVector >points  = new ArrayList <PVector>();
    float start = 0.0f;
    
    PVector rVel, pVel;

    int creatureSize, creatureWidth, realCreatureSize;
    float moveAroundCircle;

    public FFBreather() {
      creatureName = "The Breather";
      creatureAuthor = "Fabian Frei";
      creatureVersion = "1";
      
      randomStart();

      // math the shit out of it
      for(int i = 0;i < realCreatureSize;i++)
      {
        points.add(new PVector(cos(start)*creatureWidth,sin(start)*creatureWidth) );
        start += moveAroundCircle;
      }
    }

    public void randomStart() 
    {
      creatureSize = (int)random(3,11);
      if(creatureSize%2 != 0)
      {
        creatureSize++;
      }
      realCreatureSize = 3*creatureSize;
      creatureWidth = (int)random(10,100);
      moveAroundCircle = TWO_PI/realCreatureSize;

      pos = new PVector(random(0,width),random(0,height));
      oldPosition = pos;

      sizeIt = 0;
      addSizeIt = random(0.001f,0.1f);
      breathoff = random(0.001f,0.01f);
      breathadd = random(0.0001f,0.001f);
      xoff = random(0.001f,0.1f);
      yoff = random(10,100);
      xadd = random(0.00001f,0.01f);
      yadd = random(0.00001f, 0.01f);

       pVel = PVector.random3D();
      rVel = PVector.random3D();
      rVel.mult(random(0.01f, 0.03f));
      float s = random(0.5f, 1);
      sca.set(s,s,s);
    }


    public void move(float speed) {
      breath = noise(breathoff);
      breathoff += breathadd;

      sizeItCos = map(cos(sizeIt),-1,1,breath,1);
      sizeIt = sizeIt + addSizeIt;

      pos.add(pVel); 
      rot.add(rVel);  
      applyTransforms();
    }


    public void draw(int colorIn, int colorOut, float thickness) {
      stroke(colorOut);
      fill(colorIn);
      strokeWeight(thickness) ;

      for(int i = 0; i < points.size()-1;i+=2)
      {
        one = points.get(i);
        two =  points.get(i+1);

        if( i+2 < points.size() )
        {
          three = points.get(i+2);
        } 
        else {
          three = points.get(0);
        }

        len = PVector.sub(center,two);
        newCenter = PVector.add(PVector.mult(len,sizeItCos),two);

        beginShape(); 
        vertex(one.x,one.y,0);
        vertex(newCenter.x,newCenter.y,15+breath*75);
        vertex(three.x,three.y,0);
        endShape(CLOSE);
      }
    }
  }




  //HUBERT alias Spider
  class LPHubert extends SuperCreature {

    PVector freqMulPos, freqMulAng;
    int num;
    int count;
    
    float cSize;
    float bLen;
    float aFreq;
    float bOffs;
    float angRange;
    float angT, scaR;

    int numberT, numberSeg, elSize, val2div;

    boolean isAngry = false;

    public LPHubert() {
      creatureAuthor ="Laura Perrenoud";
      creatureName ="Hubert";
      creatureVersion ="1.0";

      //////////////Mouvement alétoire
      freqMulPos = new PVector();
      freqMulPos.x = random(-0.002f, 0.002f); 
      freqMulPos.y = random(-0.002f, 0.002f); 
      freqMulPos.z = random(-0.002f, 0.002f);

      freqMulAng = new PVector();
      freqMulAng.x = random(-0.005f, 0.005f); 
      freqMulAng.y = random(-0.005f, 0.005f); 
      freqMulAng.z = random(-0.005f, 0.005f);
      /////////////////

      ///////////////Créature random
      num = 10;
      cSize = random(6, 30);
      bLen = random(5, 15);
      aFreq = random(0.01f, 0.02f);
      bOffs = random(5);
      angRange = random(0.3f, 0.6f);
      numberT = PApplet.parseInt(random(3, 20));
      numberSeg = PApplet.parseInt(random(3, 7));
      elSize = 5;
      val2div = PApplet.parseInt(random(1, 3));
      scaR = (random(0.3f, 1.52f));
      sca.x = scaR;
      sca.y = scaR;
      sca.z = scaR;
      ////////////////
    }

    public void move(float speed) {
      count++;
      ////////////////
      pos.x += sin(count *freqMulPos.x);
      pos.y += sin(count *freqMulPos.y);
      pos.z += sin(count *freqMulPos.z);

      rot.x = sin(count*freqMulAng.x) * TWO_PI;
      rot.y = sin(count*freqMulAng.y) * TWO_PI;
      rot.z = sin(count*freqMulAng.z) * TWO_PI;

      applyTransforms();

    }

    public void draw(int colorIn, int colorOut, float thickness) {

      strokeWeight(thickness);
      fill(colorIn);
      stroke(colorOut);
      float val2 = sin(count*aFreq*3)*2;
      
      float a1 = sin(count*aFreq + bOffs) * angRange;
      float a2 = sin(count*aFreq) * angRange;

      for (int j=0; j<numberT; j++) {

        PVector p = new PVector(bLen, 0); 
        PVector pos = new PVector(cSize/6, 0); 
        float ang = (j % 2 == 0) ? a1 : a2;
        float l = bLen;

        for (int i=0; i<numberSeg; i++) {
          if (i<numberSeg-2) {
            pushMatrix();
            translate(pos.x + p.x, pos.y + p.y, 0);
            box(3+val2);
            popMatrix();
          }

          line(pos.x, pos.y, pos.x + p.x, pos.y + p.y);
          pos.x += p.x;
          pos.y += p.y;
          p = rotateVec(p, ang+(val2 * 0.1f));
          p.limit(l);
          l *= 0.99f;
          //l *= 0.93;
        }
        rotateY(PI*2/numberT);
      }
    }

    public PVector rotateVec(PVector v, float angle) {
      float c = cos(angle);
      float s = sin(angle);
      return new PVector(v.x*c - v.y*s, v.x*s + v.y*c);
    }
  }


  //MANTA
  class MCManta extends SuperCreature {

    int sz, lgth, nb;
    float ang;
    float vel, freqY, ampY;
    //PVector colorF;
    PVector wingsAmp;
    int count;

    public MCManta() {
      creatureAuthor  = "Maxime Castelli";
      creatureName    = "Manta";
      creatureVersion = "Beta";

      freqY = random(0.01f, 0.03f);
      ampY = random(30, 90);
      //    colorF = new PVector();
      //    colorF.x = random(0.001, 0.004); 
      //    colorF.y = random(0.001, 0.004); 
      //    colorF.z = random(0.001, 0.004);

      ang = random(TWO_PI);
      vel = random(1, 2);

      wingsAmp = new PVector();
      wingsAmp.x = random(0.01f, 0.15f);
      wingsAmp.y = random(0.01f, 0.15f);
    }

    public void move(float speed) {
      count++;
      pos.x += cos(ang) *vel;
      pos.y = cos(count *freqY) *ampY;
      pos.z += sin(ang) *vel;
      rot.y = -ang;
      applyTransforms();
    }

    public void draw(int colorIn, int colorOut, float thickness) {

      sz = 25;
      lgth = 300;
      nb = lgth /sz ;

      fill(colorIn);
      stroke(colorOut);
      strokeWeight(thickness);
      rotateY(PI);

      //TETE
      sphereDetail(2);
      for (int i=0; i<2; i++) {
        pushMatrix();
        translate(40 +i*15, 0 +(sin(i+count*0.1f)));
        scale(2, i*0.8f);
        sphere(15);
        popMatrix();
      }

      //AILE 1
      pushMatrix();
      rotateX(0.6f*sin(count * wingsAmp.x) + radians(90));
      beginShape(TRIANGLE_STRIP);
      for (int l1=0; l1<10; l1++) {
        vertex(pow(l1, 2), l1*10, sin(count*wingsAmp.y)*5);
        vertex(75, 25, cos(count*wingsAmp.x)*10);
      }
      vertex(120, 0);
      endShape(CLOSE);  
      popMatrix();

      //AILE 2
      pushMatrix();
      rotateX(-0.6f*sin(count * wingsAmp.x) - radians(90));
      beginShape(TRIANGLE_STRIP);
      vertex(0, 0);
      for (int l2=0; l2<10; l2++) {
        vertex(pow(l2, 2), l2*10, sin(count*wingsAmp.y)*5);
        vertex(75, 25, -cos(count*wingsAmp.x)*10);
      }
      vertex(120, 0);
      endShape(CLOSE);
      popMatrix();

      //QUEUE
      translate(80, 0);
      beginShape(TRIANGLE_STRIP); 
      for (int j=0; j<15;j++) {
        vertex(j*10, sin(j-(count* wingsAmp.x))*(j), cos(j-(count* wingsAmp.y))*(j));
      }
      endShape();
    }
  }



  //SONAR
  class PXPSonar extends SuperCreature {

    int time;
    int count;
    int bold = 2;
    int freq = 300;
    float fadeSpeed = 5;
    PVector freqMulRot, freqMulSca, freqMulPos;

    public PXPSonar() {
      creatureAuthor  = "Pierre-Xavier Puissant";
      creatureName    = "Sonar";
      creatureVersion = "1.0";

      freqMulRot = new PVector();
      freqMulRot.x = random(-0.0005f, 0.0005f);
      freqMulRot.y = random(-0.001f, 0.001f);
      freqMulRot.z = random(-0.0015f, 0.0015f);

      freqMulPos = new PVector();
      freqMulPos.x = random(-0.002f, 0.002f); 
      freqMulPos.y = random(-0.002f, 0.002f); 
      freqMulPos.z = random(-0.002f, 0.002f);

      // freqMulSca = new PVector();
       // freqMulSca.x = random(-0.005, 0.005);
      //  freqMulSca.y = random(-0.005, 0.005);
      // freqMulSca.z = random(-0.005, 0.005);
    }

    public void move(float speed) {
      rot.x = sin(frameCount*freqMulRot.x) * TWO_PI;
      rot.y = sin(frameCount*freqMulRot.y) * TWO_PI;
      rot.z = sin(frameCount*freqMulRot.z) * TWO_PI;

      pos.x += sin(frameCount *freqMulPos.x);
      pos.y += sin(frameCount *freqMulPos.y);
      pos.z += cos(frameCount *freqMulPos.z);

      applyTransforms();
    }

    public void draw(int colorIn, int colorOut, float thickness) {
      time++;
      count++;
      float changeWH;
      float changeAL;
      float changeSca = map(sin(count*0.15f), -1,1, 1, 1.5f);
      
      fill(colorIn);
      for (int i = 0; i < bold; i++) { 
        changeAL = (freq-time*fadeSpeed)*(sin((PI/bold)*i));
        stroke(hue(colorOut), saturation(colorOut), brightness(colorOut), changeAL*2);
        changeWH = exp(sqrt(time*0.75f))+i;
        ellipse (0, 0, changeWH, changeWH);
      }
      if (time > freq) {
        time = 0;
      }

      rotateX(count*0.011f);
      rotateX(count*0.012f);
      rotateZ(count*0.013f);

      stroke (colorOut, alpha(colorOut) *.3f);    
      sphereDetail(6);
      sphere(30);    
      scale(changeSca, changeSca, changeSca);
      stroke (colorOut);
      sphereDetail(1);
      sphere(10);
    }
  }


  //FATHER
  class OTFather extends SuperCreature {
    int count;
    int numSegmenti;
    int numTentacoli;
    int numPinne;
    float distPinne;
    float l;

    //TRIGO
    float sm1, sm2;
    float rx, ry;
    PVector pVel, rVel, noiseVel;

    public OTFather() {
      creatureName = "Father";
      creatureAuthor = "Oliviero Tavaglione";
      creatureVersion = "Beta";


      numSegmenti = floor(random(10, 20));
      numTentacoli = 1;
      numPinne = floor(random(2, 6));
      distPinne = random(0.2f, 0.5f);
      l = random(20, 40);

      sm1 = random(-0.005f, 0.005f);
      sm2 = random(-0.005f, 0.005f);    


      pVel = PVector.random3D();
      rVel = PVector.random3D();
      rVel.mult(random(0.01f, 0.03f));
      noiseVel =PVector.random3D();
      noiseVel.mult(random(0.005f, 0.03f));
      float s = random(0.5f, 1);
      sca.set(s,s,s);
    }

    public void move(float speed) {
      count++;
      pos.add(pVel); 
      rot.add(rVel);  
      applyTransforms();
    }


    public void draw(int colorIn, int colorOut, float thickness) {
      sphereDetail(8);

      //TESTA
      fill(colorIn);
      stroke(colorOut);
      strokeWeight(thickness) ;
      sphere(l);

      //ANTENNE

      //float ly = sin(frameCount * 0.01) * 30;
      //float lz = -sin(frameCount * 0.01) * 30;
      // float ly = random(l/2, sin(count * 0.01) * l);
      // float lz = random(l, l + (l/1.5));


      line(0, 0, 0, -l*2, 10, 30);
      line(0, 0, 0, -l*2, 10, -30);

      //PINNE  
      rotateY(-(numPinne-1) * distPinne / 2);
      //rotateY(-(numPinne-1) * distPinne / (distPinne - TWO_PI));
      for (int k=0; k<numPinne; k++) {

        float s = (cos(TWO_PI / (numPinne-1) * k));
        s = map(s, 1, -1, 0.9f, 1);
        pushMatrix();
        scale(s);
        
        for (int j=0; j<numTentacoli; j++) {
          pushMatrix();
          float a = (noise(count*noiseVel.x + j+k+1)-0.4f)*0.782f; 
          float b = (noise(count*noiseVel.y + j+k+1)-0.5f)*0.582f; 
          float c = (noise(count*noiseVel.z + j+k+1)-0.6f)*0.682f;

          for (int i=0; i<numSegmenti; i++) {
            rotateZ(a);
            rotateY(b);
            rotateX(c);
            translate(l*0.9f, 0, 0);
            scale(0.85f, 0.85f, 0.85f);
            box(l, l/2, l); 
            //ellipse(l/2, l, l, l);
          }


          popMatrix();


          //rotateY(TWO_PI/numTentacoli);
        }
        popMatrix();
        rotateY(distPinne);
      }
    }
  }
  //END CATALOGUE

}













/**
* ARBRE 
* 2012-2019
* v 1.4.5
*/
class ArbreRomanesco extends Romanesco {
  Arbre arbre ;
  public ArbreRomanesco() {
    //from the index_objects.csv
    item_name = "Arbre" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 1.4.5";
    item_pack = "Base 2012-2019" ;
    item_costume = "ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "";
    // define slider
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    //influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  float speed;
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/3, 0) ;
    arbre = new Arbre () ;
  }
  
  //DRAW
  public void draw() {
    // printTempo(60,"arbre: h",get_fill_hue(),"s",get_fill_sat(),"b",get_fill_bright(),"a",get_fill_alpha());
    int maxFork ;
    if(FULL_RENDERING) maxFork = 8 ; else maxFork = 4 ; // we can go beyond but by after the calcul slowing too much the computer... 14 is a good limit
    // int maxNode = 32 ; // 
    // num fork for the tree
    ivec2 fork = ivec2(maxFork);
  
    int n = PApplet.parseInt(map(get_quantity(),0,1,2,maxFork*2)) ;
    
    float epaisseur = get_thickness() ;
    float ratioLeft = map(left[ID_item], 0, 1, .5f, 2) ;
    float ratioRight = map(right[ID_item], 0, 1, .5f, 2) ;
    if(!FULL_RENDERING) {
      ratioLeft = .75f ;
      ratioRight = .75f ;
    }
    float ratioMix = ratioLeft + ratioRight ;

    //size of the shape
    vec2 div = vec2(.66f);
    if(sound_is()) {
      div.set(ratioLeft,ratioRight);
    } 

      
    //size
    int div_size = 20 ;
    float x = map(get_size_x(),.1f,width,.1f,width /div_size) ;
    float y = map(get_size_y(),.1f,width,.1f,width /div_size) ;
    float z = map(get_size_z(),.1f,width,.1f,width /div_size) ;
    x = x *x *ratioMix ;
    y = y *y *ratioMix ;
    z = z *z *ratioMix ;

    vec3 size  = vec3(x,y,z) ;
    //orientation
    float direction = get_dir_x() ;
    //amplitude
    vec2 amplitude = vec2(get_canvas_x() *.5f,get_canvas_y() *.5f) ;
    if(FULL_RENDERING) {
      amplitude.mult(all_transient(ID_item));
    }
    



    // angle
    float angle = 90 ; // but this function must be remove because it give no effect
    // speed
    if(motion_is() && FULL_RENDERING) {
      float s = map(get_speed_x(),0,1,0,2) ;
      s *= s;
      speed = s *tempo[ID_item]; 
    } else if (!motion_is() && FULL_RENDERING){ 
      speed = 0.f;
    } else {
      speed = 1.f;
    }
    
    
    boolean bool_link = false ;
    if(wire_is()) bool_link = true ; else bool_link = false ;
    arbre.show(direction);
    arbre.update(epaisseur,size,div,fork,amplitude,n,get_costume(),bool_link,angle,speed,ID_item) ;
    if(horizon_is()) {
      arbre.set_horizon(0) ; 
    } else {
      arbre.set_horizon(map(get_alignment(),0,1,-1,1));
    }
    
    //info
    info("Nodes ",(n-1),"- Amplitude ",amplitude.x,",",amplitude.y,"- Orientation ",direction," - Speed ",(int)map(speed,0,4,0,100) );
    
  }

  // CLASS ARBRE
  private class Arbre {
    float theta, angleDirection;
    float rotation = 90.f;
    float direction = 0;
    float deep = 0;

    Arbre() {}

   
  //::::::::::::::::::::  
    public void show(float d) {
      direction = d ;
    }

    public void set_horizon(float deep) {
      this.deep = deep ;
    }
  //::::::::::::::::::::::::::::  
    public void update(float e, vec3 size, vec2 div, ivec2 fork, vec2 amplitude, int n, Costume costume, boolean bool_line, float angle, float speed, int ID) {
      rotation += speed ;
      if (rotation > angle +90) speed*=-1 ; else if ( rotation < angle ) speed*=-1 ; 
      angle = rotation ; // de 0 à 180
      // Convert it to radians
      theta = radians(angle);
      angleDirection = radians (direction) ;
      pushMatrix () ;
      // Start the recursive branching
      rotate (angleDirection) ;
      branch(e,size,div,fork,amplitude,n,costume,bool_line,ID);
      popMatrix () ;

      
    }
    
    
    //float fourche = 10.0 ; 
    public void branch(float thickness, vec3 size, vec2 div, ivec2 fork, vec2 amplitude, int n, Costume costume, boolean bool_line,int ID) {
      vec3 newSize = size.copy();
      newSize.x = size.x *div.x;
      newSize.y = size.y *div.y;
      newSize.z = size.z *(div.sum() *.5f);
      if(newSize.x < 0.1f ) {
        newSize.x = 0.1f ;
      }
      
      thickness *= .66f ;
      
      // recursive need an happy end!
      n = n-1 ;
      if (n >0) {
       int branch_ID = 0;
       displayBranch(thickness,newSize,div,fork,amplitude,n,-theta,costume,bool_line,ID,branch_ID); 
       branch_ID = 1;
       displayBranch(thickness,newSize,div,fork,amplitude,n,theta,costume,bool_line,ID,branch_ID);
      }
    }
    
    //annexe branch
    public void displayBranch(float thickness, vec3 size, vec2 div, ivec2 fork, vec2 amplitude, int n, float t, Costume costume, boolean bool_line, int ID, int branch_ID) {
      float factor = 0.0f ;
      if(key_v_long && pen[0].z != 0) {
        factor = deep * map(pen[0].z,0.01f,1, 1.2f,-1.2f); 
      } else {
        factor = deep ;
      }

      start_matrix();    // Save the current state of transformation (i.e. where are we now)
      rotate(t);   // Rotate by theta

      aspect_is(fill_is(),stroke_is());
      aspect(get_fill(),get_stroke(),thickness);
      vec3 pos_a = vec3();
      vec3 pos_b = vec3(0, -amplitude.x, -amplitude.y *factor);
      
      if (bool_line && n > 1) {
         line(pos_a, pos_b) ;
      } 

      // Draw the branch
      set_ratio_costume_size(map(get_area(),width*.1f, width*TAU,0,1));
      int offset_z = branch_ID;
      costume(vec3(0,0,offset_z),size,costume);
      
      // horizon   
      translate(pos_b) ;
       
      branch(thickness,size,div,fork,amplitude,n,costume,bool_line,ID); // Ok, now call myself to draw two new branches!!
      stop_matrix();     // Whenever we get back here, we "pop" in order to restore the previous matrix state
    }
  }
}
//end object two














/**
* ATOME 
* 2012-2019
* v 1.3.12
*/
ArrayList<Atom> atomList;

//object one
class Atome extends Romanesco {
  public Atome() {
    //from the index_objects.csv
    item_name = "Atome" ;
    item_author  = "Stan le Punk";
    item_version = "version 1.3.12";
    item_pack = "Base 2012-2019" ;
    item_costume = "";
    item_mode = "Chemical Name/File text/Electronic cloud/Ellipse circle/Ellipse triangle/Ellipse cloud/Triangle circle/Triangle triangle/Triangle cloud/Rectangle rectangle/Rectangle cloud" ;

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = true;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = true;
    variety_is = true;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = true;
    angle_is = true;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
  
  //GLOBAL
  int KelvinUnivers  ; // Kelvin degree influent on the mouvement of the Atom, at 0°K there is no move !!! 273K° give 273/Kelvin = 1.0 multi reference when the water became ice ! 
  int atomTemperature ;
  float pressure = 1.0f ; // Atmospheric pressure. "1" is earth reference
  // wall of screen
  float restitution = 0.5f ;

  float bottom =    restitution ;
  float top =       restitution ;
  float wallRight = restitution ;
  float wallLeft =  restitution ;

  //Molecule.Atom
  boolean cloud = true ; // To swith ON/OFF phycic of the cloud

  float atomX = 0 ; float atomY = 0 ;
  
  //beat var
  float beatSizeProton = 1 ;
  float beatThicknessCloud = 1 ;
  float beatSizeCloud = 1 ;
  // var for the beat range reactivity
  int rangeA = 0 , rangeB = 0, rangeC  =0  ;
  
  //direction of atome
  PVector newDirection ;
  
  // 3D mode for the objects
  boolean threeDimension ;
  

  
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ; 
    atomList = new ArrayList<Atom>();

    //add one atom to the start
    PVector pos = new PVector (random(width), random(height), 0) ;
    PVector vel = new PVector (random(-1, 1), random(-1, 1), random(-1, 1) ) ;
    int Z = 1 ; // 1 is the hydrogen ID, you can choice between 1 to 118 the last atom knew
    int ion = round(random(0,0));
    float rebound = 0.5f ;
    int diam = 5 ;
    int Kstart = PApplet.parseInt(abs( mix[ID_item]) *1000) ; // Temperature of Atom, influence the mouvement behavior
    //motion
    Atom atm = new Atom(p5,pos, vel, Z, ion, rebound, diam,  Kstart) ; 
    atomList.add(atm) ;
  }

  //DRAW
  public void draw() {
    // SETTING PARAMETER
    load_txt(ID_item) ;
    // 3D or 2D
    if(parameter_is() & key_d) threeDimension = !threeDimension ;
    
    //speed
    float speed = (get_speed_x() *100) *(get_speed_x() *100) ;
    float velLimit = tempo[ID_item] *5.0f ; // max of speed Atom
    if (velLimit < 1.1f ) velLimit = 1.1f ;
    //the atom temperature give the speed 
    if(sound_is()) atomTemperature =  floor(speed *tempo[ID_item]) ; else atomTemperature = round(speed) ;
    //ratio evolution for atom temperature...give an idea to change the speed of this one
    //because the temp of atom is linked with velocity of this one.
    float tempAbs = 10.0f ;
    
    //VELOCITY and DIRECTION of atom
    if(motion_is()) {
      if(key_space_long && action_is()) {
        newDirection = new PVector (-pen[ID_item].x, -pen[ID_item].y ) ;
      } else { 
        newDirection = normal_direction(PApplet.parseInt(get_dir_x())) ;
      }
    } else {
      newDirection = new PVector () ;
    }
    
    PVector newVelocity = new PVector (sq(tempo[ID_item]) *1000.f, sq(tempo[ID_item]) *1000.f);
    //security if the value is null to don't stop the move
    float acceleration ; 
    if(pen[ID_item].z == 0 ) acceleration = 1.f ; else acceleration = pen[ID_item].z *1000.f ;
    
    
    PVector soundDirection = new PVector() ;
    if(sound_is()) soundDirection = new PVector(right[ID_item], left[ID_item]) ; else soundDirection = new PVector(0, 0) ;

    float velocityX = newDirection.x *newVelocity.x *acceleration ;
    float velocityY = newDirection.y *newVelocity.y *acceleration ;
    PVector changeVelocity = new PVector (velocityX, velocityY) ;
    
    // FACTOR SOUND REACTIVITY
    float maxBeat = map(get_swing_x(),0,1,1,15) ;
    transient_value[1][ID_item] = map(transient_value[1][ID_item],1,10, 1,maxBeat) ;
    transient_value[2][ID_item] = map(transient_value[2][ID_item],1,10, 1,maxBeat) ;
    transient_value[3][ID_item] = map(transient_value[3][ID_item],1,10, 1,maxBeat) ;
    transient_value[4][ID_item] = map(transient_value[4][ID_item],1,10, 1,maxBeat) ;
    
    // thickness
    float thickness = map(get_thickness(),0, width/3, 0, width/20) ;
    
    // TEXT

    PVector posText = new PVector (0,0,0) ;

    //Canvas
    PVector marge = new PVector(map(get_canvas_x(), width/10, width, width/20, width *3) , map(get_canvas_y(), height/10, height, height/20, height *3) ) ;
    
    // SIZE
    float sizeFont = get_size_x() ;
    int sizeTextName = PApplet.parseInt(sizeFont) ;
    int sizeTextInfo = PApplet.parseInt(sizeFont *.5f) ;

    float sizeAtomeRawX = map (get_size_x(), .1f, width, .2f, width *.05f) ;
    float sizeAtomeRawY = map (get_size_y(), .1f, width, .2f, width *.05f) ;
    float sizeAtomeRawZ = map (get_size_z(), .1f, width, .2f, width *.05f) ;
    float sizeAtomeX = sizeAtomeRawX *beatSizeProton ;
    float sizeAtomeY = sizeAtomeRawY *beatSizeProton ;
    float sizeAtomeZ = sizeAtomeRawZ *beatSizeProton ;
    
    //diameter
    float factorSizeField = sizeAtomeX *1.2f ; // factor size of the electronic Atom's Cloud
     //width
    float posTextInfo = map(get_size_y(), .1f, width,sizeAtomeRawX*.2f, width*.2f) + (transient_value[1][ID_item] *2.0f)  ; 
      
      
    
    // DISPLAY and UPDATE ATOM
    for (Atom atm : atomList) {
      // main method
      atm.update (atomTemperature, velLimit, changeVelocity, tempAbs, soundDirection) ; // obligation to use this void, in the atomic univers
      atm.covalentCollision (atomList);
      PVector sizeAtomeXYZ = new PVector(sizeAtomeX,sizeAtomeY,sizeAtomeZ) ;

      //DISPLAY
      //PARAMETER FROM ROMANESCO
      //the proton change the with the beat of music
      int max = 118 ;
      if( (key_n && action_is()) || rangeA == 0 ) {
        rangeA = round(random(0,max-80)) ;
        rangeB = round(random(rangeA,max-40)) ;
        rangeC = round(random(rangeB,max)) ;
      }
      

      if ( atm.getProton() < rangeA ) { 
        beatSizeProton = transient_value[1][ID_item] ;
      } else if ( atm.getProton() > rangeA && atm.getProton() < rangeB ) {
        beatSizeProton = transient_value[2][ID_item] ;
      } else if ( atm.getProton() > rangeB && atm.getProton() < rangeC ) {
        beatSizeProton = transient_value[3][ID_item] ;
      } else if ( atm.getProton()  > rangeC ) {
        beatSizeProton = transient_value[4][ID_item] ;
      }
      /////////////////CLOUD///////////////////////////////////////
      if ( atm.getProton() < 41 ) { 
        beatThicknessCloud = transient_value[1][ID_item] ;
      } else if ( atm.getProton() > 40 && atm.getProton() < 66 ) {
        beatThicknessCloud = transient_value[2][ID_item] ;
      } else if ( atm.getProton() > 65 && atm.getProton() < 91 ) {
        beatThicknessCloud = transient_value[3][ID_item] ;
      } else if ( atm.getProton()  > 90 ) {
        beatThicknessCloud = transient_value[4][ID_item] ;
      }

      

      //MODE OF DISPLAY
      //item_mode = "Chemical Name/File text/Electronic cloud/Ellipse schema/Ellipse cloud/Triangle schema/Triangle cloud/Rectangle schema/Rectangle cloud/Box schema/Box cloud/Sphere schema/Sphere cloud" ;
      if (get_mode_id() == 0 || get_mode_id() == 255 ) {
        atm.titleAtom2D (get_fill(), get_stroke(), get_font(), sizeTextName, sizeTextInfo, posTextInfo, get_angle()) ; // (color name, color Info, PFont, int sizeTextName,int  sizeTextInfo )
      } else if (get_mode_id() == 1 ) { 
        atm.title2D(get_fill(), get_font(), sizeTextName, posText, get_angle()) ;
      } else if (get_mode_id() == 2 ) {
        atm.display("", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 3 ) {
        if(threeDimension) atm.display("SPHERE", "ELLIPSE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("ELLIPSE", "ELLIPSE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 4 ) {
        if(threeDimension) atm.display("SPHERE", "TRIANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("ELLIPSE", "TRIANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 5 ) {
        if(threeDimension) atm.display("SPHERE", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("ELLIPSE", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 6 ) {
        if(threeDimension) atm.display("TETRA", "ELLIPSE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("TRIANGLE", "ELLIPSE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 7 ) {
        if(threeDimension) atm.display("TETRA", "TRIANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("TRIANGLE", "TRIANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 8 ) {
        if(threeDimension) atm.display("TETRA", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("TRIANGLE", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 9 ) {
        if(threeDimension) atm.display("BOX", "RECTANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("RECTANGLE", "RECTANGLE", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      } else if (get_mode_id() == 10 ) {
        if(threeDimension) atm.display("BOX", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
        else atm.display("RECTANGLE", "POINT", sizeAtomeXYZ, get_fill(), get_stroke(), thickness, get_angle()) ;
      }
 

      
      //UNIVERS
      ////////////////////////////////////////////////////////////////////////////////////////////
      atm.universWall2D( bottom, top, wallRight, wallLeft, false, marge) ; // obligation to use this void
      ////////////////////////////////////////////////////////////////////////////////////////////
    }
    
    // info display
    item_info[ID_item] = ("Atoms "+atomList.size()) ;
    

    //CLEAR
    if (reset(this)) atomList.clear() ;
    //ADD ATOM
    int maxValueReproduction = 25 ;
    if(FULL_RENDERING) maxValueReproduction = 1 ; else maxValueReproduction = 25 ;
    int speedReproduction = round(map(get_quantity(),0, 1, 30, maxValueReproduction));
    if(action_is() && key_n_long && clickLongLeft[ID_item] && frameCount % speedReproduction == 0) atomAdd(giveNametoAtom(), item_setting_position[0][ID_item]) ;
    
    if(atomList.size()<1) {
      int num = PApplet.parseInt(random(1,9)) ;
      for(int i = 0 ; i < num ; i++ ) {
        atomAdd(giveNametoAtom(), item_setting_position[0][ID_item]) ;
      }
    }

  }
  //END DRAW
  /////////
  
  
  
  
  
  //ANNEXE
  
  //give name to the atom from the file.txt in the source repository
  public String giveNametoAtom() {
    String s = ("") ;
    int whichChapter = floor(random(numChapters(text_import[ID_item]))) ;
    int whichSentence = floor(random(numMaxSentencesByChapter(text_import[ID_item]))) ;
    //give a random name, is this one is null in the array, give the tittle name of text
    if(whichSentence(text_import[ID_item], whichChapter, whichSentence) != null ) s = whichSentence(text_import[ID_item], whichChapter, whichSentence) ; else s = whichSentence(text_import[ID_item], 0, 0) ;
    return s ;
  }
  

  //Add atom with a specific name
  public void atomAdd(String name, vec3 newPos) {
    //data
    //amplitude
    //give the field of type of atome must be create
    float numP = map(get_variety(), 0,1,1,118) ; //
    int Z = PApplet.parseInt(random (1,numP)) ; // Z is the number of protons give the number of electrons max knew is 118
    int ion = round(random(0,0)); // number of electron(s) less(Anion)   more(Cation)   / give the magnetism & conductivity of the atome cannot be equal or sup to "Z"proton
    
    int Kstart = PApplet.parseInt(abs( mix[ID_item]) *1000) ; // Temperature of Atom, influence the mouvement behavior

    if (Kstart > 500 ) Kstart = 500 ;
    // physic action & display in the Univers
    float rebound = 0.5f ;
    int diam = 5 ;
    // Atom motion
    float startVel = 1.0f ;
    PVector posA = new PVector (mouse[0].x -newPos.x, mouse[0].y -newPos.y, 0.0f) ;
    PVector velA = new PVector (random(-startVel, startVel ), random(-startVel, startVel ), random(-startVel, startVel ) ) ;
    
    for (Atom atm : atomList) {
      if(atm.insideField()) return;
    }
    Atom atm = new Atom(p5,name, posA, velA, Z, ion, rebound, diam,  Kstart) ; 
    atomList.add(atm) ;
  }

}



















///////////
//CLASS ATOM
class Atom {
  PApplet p5;
  String [] nameAtom = { "Atom", "H",                                                                                                                                                                                         "He", 
                                 "Li", "Be",                                                                                                                                                 "B",  "C",   "N",   "O",  "F",   "Ne", 
                                 "Na", "Mg",                                                                                                                                                 "Al", "Si",  "P",   "S",  "Cl",  "Ar",
                                 "K",  "Ca",                                                                                     "Sc", "Ti", "V",  "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge",  "As",  "Se", "Br",  "Kr",
                                 "Rb", "Sr",                                                                                     "Y",  "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn",  "Sb",  "Te", "I",   "Xe",
                                 "Cs", "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu", "Hf", "Ta", "W",  "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb",  "Bi",  "Po", "At",  "Rn",
                                 "Fr", "Ra", "Ac", "Th", "Pa", "U",  "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg", "Cn", "Uut", "Fl", "Uup", "Lv", "Uus", "Uuo"  } ;
  float [] Pauling = { 0.0f,      2.20f,                                                                                                                                                                                         0.00f, 
                                 0.98f, 1.57f,                                                                                                                                                 2.04f, 2.55f,  3.04f,  3.44f,  3.98f,  0.00f, 
                                 0.93f, 1.31f,                                                                                                                                                 1.61f, 1.90f,  2.19f,  2.58f,  3.16f,  0.00f,
                                 0.82f, 1.00f,                                                                                     1.36f, 1.54f, 1.63f, 1.66f, 1.55f, 1.83f, 1.88f, 1.91f, 1.90f, 1.65f, 1.81f, 2.01f,  2.18f,  2.55f,  2.96f,  0.00f,
                                 0.82f, 0.95f,                                                                                     1.22f, 1.33f, 1.60f, 2.16f, 2.10f, 2.20f, 2.28f, 2.20f, 1.93f, 1.69f, 1.78f, 1.96f,  2.05f,  2.10f,  2.66f,  2.60f,
                                 0.79f, 0.90f, 1.10f, 1.12f, 1.13f, 1.14f, 1.13f, 1.17f, 1.20f, 1.20f, 1.20f, 1.22f, 1.23f, 1.24f, 1.25f, 1.10f, 1.27f, 1.30f, 1.50f, 1.70f, 1.90f, 2.20f, 2.20f, 2.20f, 2.40f, 1.90f, 1.80f, 1.80f,  1.90f,  2.00f,  2.20f,  0.00f,
                                 0.70f, 0.90f, 1.10f, 1.30f, 1.50f, 1.70f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 1.30f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f, 0.00f,  0.00f,  0.00f,  0.00f,  0.00f  } ;
  
  Univers nvrs ;
  //Univers data
  float K_atom  ;
  float pressure = 1.0f ;  
  // Atom data
  ArrayList<Electron> listE; // list of electron for each Atom
  PVector pos ;    // position of the atom
  PVector vel ;    // velocity of the atom
  float diamAtom ;
  float mass, rebound ; // diameter and answer on the wall
  
  //Atomic property
  int  neutron, proton, electron, ion, valenceElectron, missingElectron, freeElectronicSpace ;
  int n = 1 ; // number of electronic shell
  int electronLayer = 0 ; // number of electronic shell
  float screenEffect = 1.0f  ; 
  float electroNegativity = 0.0f ; // Electronegativity of atom 

  float mgt ; // ionic load : give the magnetism atom
  float amplitudeElectrocField = 1.0f ; // default parameter of the amplitude of electronic field
  float ampInfo = 1.0f ; // default parameter of the amplitude of electronic field
  
  boolean insideA, insideF, lock, collision, cloud ;
  
  // Bond variable for link atom
  int freeBond ;
  int bondLink = 0 ; // number of link between two atoms (1 to 3 is useful )
  boolean bond ;
  boolean [] covalentBond = new boolean [9] ;
  boolean covalentBondLast = true, mole = false ;
 
  
  int inAtom = color (360,100,100) ; // blanc
  
  String c = "" ; // empty field to give the information of bond capacity of atom
  
  // give by default the title of the text import
  String nickName = ("ATOM") ;
 
  /////////////////////CONSTRUCTOR ATOM////////////////////////////////////////////////////////////////
  //simple constructor
  Atom (PApplet p5,PVector pos_, PVector vel_, float rebound_, int d_ ) {
    this.p5 = p5;
    pos = pos_  ;
    vel = vel_  ;
    rebound = rebound_ ; 
    diamAtom = d_ ;
    mass = d_ ;
    // UNIVERS
    nvrs = new Univers() ;
  }
  //Atomic constructor  
  Atom (PApplet p5,PVector pos_, PVector vel_, int proton_, int ion_, float rebound_,int d_, int Kelvin_ ) {
    this.p5 = p5;
    pos = pos_  ;
    vel = vel_  ;
    proton = proton_;
    if (proton < 21 ) neutron = proton_ ;
    if (proton > 20 && proton < 103 ) neutron = round(proton_  * 1.765f) -20  ; // behind 20 proton, the quantity of neutron is more important than proton.
    if (proton > 102 && proton < 111 ) neutron = round(proton_ * 0.54f)  +102 ;
    if (proton > 110 && proton < 116 ) neutron = round(proton_ * 2.475f) -110 ;  
    if (proton > 115  ) neutron = round(proton_ * 0.53f) +115 ; 
    
    mass = proton + neutron ; ion = ion_ ;
    electroNegativity = Pauling[proton_] ; // Give the electroNagativity of Atom whith Pauling board
    rebound = rebound_ ; 
    diamAtom = d_ ;
    K_atom = Kelvin_ ;
    float Ka = Kelvin_ / 273.0f ;
     
    vel.x = vel.x * Ka ;
    vel.y = vel.y * Ka ;
    vel.z = vel.z * Ka ;
    
    listE = new ArrayList<Electron>();
    // UNIVERS
    nvrs = new Univers() ;
    // initialize the covalent level
    electronicCovalentBond() ;
  }
  
  //Atomic constructor with nickname  
  Atom (PApplet p5,String name, PVector pos_, PVector vel_, int proton_, int ion_, float rebound_,int d_, int Kelvin_) {
    nickName = name ;
    pos = pos_  ;
    vel = vel_  ;
    proton = proton_;
    if (proton < 21 ) neutron = proton_ ;
    if (proton > 20 && proton < 103 ) neutron = round(proton_  * 1.765f) -20  ; // behind 20 proton, the quantity of neutron is more important than proton.
    if (proton > 102 && proton < 111 ) neutron = round(proton_ * 0.54f)  +102 ;
    if (proton > 110 && proton < 116 ) neutron = round(proton_ * 2.475f) -110 ;  
    if (proton > 115  ) neutron = round(proton_ * 0.53f) +115 ; 
    
    mass = proton + neutron ; ion = ion_ ;
    electroNegativity = Pauling[proton_] ; // Give the electroNagativity of Atom whith Pauling board
    rebound = rebound_ ; 
    diamAtom = d_ ;
    K_atom = Kelvin_ ;
    float Ka = Kelvin_ / 273.0f ;
     
    vel.x = vel.x * Ka ;
    vel.y = vel.y * Ka ;
    vel.z = vel.z * Ka ;
    
    listE = new ArrayList<Electron>();
    // UNIVERS
    nvrs = new Univers() ;
    // initialize the covalent level
    electronicCovalentBond() ;
  }
  
  
  
  
  //UPDATE
  // classic update
  public void update(float velLimit) { 
    vel.limit(velLimit) ;
    // if (!collision || listA.size() < 2 ) pos.add(vel) ;
    if (!collision ) pos.add(vel) ;
  }
  
  // update Atom
  public void update(int Kelvin_univers, float velLimit, PVector changeVel, float tempAbs, PVector jitterDirection) { 
    float jitterX = map(random(jitterDirection.x), 0, 1, -1, 1) ;
    float jitterY = map(random(jitterDirection.y), 0, 1, -1, 1) ;
    vel.x = changeVel.x *jitterX ;
    vel.y = changeVel.y *jitterY;
    
    //update atom temperature
    if (K_atom < Kelvin_univers ) K_atom += tempAbs ;
    if (K_atom > Kelvin_univers ) K_atom -= tempAbs ; 
    
    float Kfactor =  K_atom / 273.0f ;
    float pressureFactor = 1.0f / pressure ;
    vel.limit(velLimit *Kfactor *pressureFactor) ; // limit of velocity, the K° is very important factor.
    
    // check if collision's void is true or not, if it's false the position is caculate here
    if (!collision ) pos.add(vel) ;
    
    // update electron 
    int eBond = 0 ;
    if (bond) eBond = 1 ;

    electron = proton + ion + eBond ;
    if (electron < 0 ) electron = 0 ; // keep the number of electron equal to zero or positive
    mgt = ion ;
   // update display capacity
   if ( covalentBond[1]  )  c = "height places";
   if (!covalentBond[1]  )  c = "seven places" ;
   if (!covalentBond[2]  )  c = "six places";
   if (!covalentBond[3]  )  c = "five places" ;
   if (!covalentBond[4]  )  c = "four places"  ;
   if (!covalentBond[5]  )  c = "three places" ;
   if (!covalentBond[6]  )  c = "two places" ;
   if (!covalentBond[7]  )  c = "one place" ;
   if (!covalentBondLast )  c = "full";   
  }
  

////////////////////////////////////COLLISION/////////////////////////////////////////////////////////adapted from Ira Greenberg///////////////
//////////////////////////COLLISION SIMPLE//////////////////////////////////////////////////////////
  public void collision(ArrayList<Atom> listA ) {
    collision = true ; // this boolean give the hand at this collison() void for update the velocity
    for (Atom target : listA) {
      if (target != this) {
        /////////////////////////\\\\\\\\\\\\\\\\\\\
        //:::::::::Code for angle collision::::::::::
        // get distances between the "atoms" components
        PVector atomVect = new PVector();
        atomVect.x = target.pos.x - pos.x;
        atomVect.y = target.pos.y - pos.y;
        ////////////////////////////////////////////
        if (collide(target, target.radius(), radius()) ) {
          contact(target, atomVect) ; 
        } else {
          noContact(target) ;
        }
      } 
    }
  }
  //::::::::::::::::::::::::Resolve Collision::::::::::::::::::::::::::::
  public void contact(Atom target , PVector atomVect)  {
    resolveCollision(target, atomVect) ;
  }
  //::::::::::::
  public void noContact (Atom target)  {
    // global code for collsion
    collision = false ; // this boolean give the control of the velocity to the update() void
  }
  
  
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////COVALENT COLLISION//////////////////////////////////////////////////
  public void covalentCollision(ArrayList<Atom> listA ) {
    for (Atom target : listA) {
      if (target != this) {    // don't collide with ourselves. that would be weird.
        /////////////////////////\\\\\\\\\\\\\\\\\\\
        //:::::::::Code for angle collision::::::::::
        // get distances between the "atoms" components
        PVector atomVect = new PVector();
        atomVect.x = target.pos.x - pos.x;
        atomVect.y = target.pos.y - pos.y;
        ////////////////////////////////////////////
        if (collide( target, target.radiusElectronicField(), radiusElectronicField() ) ) {
          contactCovalentEN(target, atomVect) ;
          if (collide( target, target.radiusElectronicFieldCovalent(), radiusElectronicFieldCovalent() ) ) {
            contactCovalent(target, atomVect) ;
            statementCovalent(target) ;
          } else {
            noContactCovalent () ;
          }     
        } else {
          noContactCovalent () ;
        }     
      }
    }
  }
  //::::::::::::::::::::::::Resolve Collision::::::::::::::::::::::::::::
  //COVALENT COLLISION ////// the result depend of the covalent number ///////////////////
  public void contactCovalentEN(Atom target, PVector atomVect)  {
    if (target.electroNegativity == 0 || electroNegativity == 0) {
      resolveCollision(target , atomVect) ;
    }
  }
   
   
  public void contactCovalent(Atom target, PVector atomVect)  {
    if (!target.covalentBondLast || !covalentBondLast ) {
      resolveCollision(target , atomVect) ;
      resolveCollision(target , atomVect) ;
    }  else {
      // new motion of atom when is lock together//
      float factorAddMotion = 2.0f ; // 2.0 is average motion factor
      PVector newVel = new PVector ( (vel.x + target.vel.x) /factorAddMotion , (vel.y + target.vel.y) /factorAddMotion ) ;
      target.vel = newVel ;
      vel  = newVel ;
    }
   }
   
   
   
  //::::::::::::
  public void statementCovalent(Atom target) {
    if(target.covalentBond[1] && covalentBondLast) freeBond = 0 ;
    if(!target.covalentBond[1])  freeBond = 1 ;
    if(!target.covalentBond[2])  freeBond = 2 ;
    if(!target.covalentBond[3])  freeBond = 3 ;
    if(!target.covalentBond[4])  freeBond = 4 ;
    if(!target.covalentBond[5])  freeBond = 5 ;
    if(!target.covalentBond[6])  freeBond = 6 ;
    if(!target.covalentBond[7])  freeBond = 7 ;
    if(!target.covalentBondLast) freeBond = 8 ;
    
    switch(freeBond) {
      case 0 : target.covalentBond[1]  = false ;
      break ;
      case 1 : target.covalentBond[2]  = false ;
      break ;
      case 2 : target.covalentBond[3]  = false ;
      break ;
      case 3 : target.covalentBond[4]  = false ;
      break ;
      case 4 : target.covalentBond[5]  = false ;
      break ;
      case 5 : target.covalentBond[6]  = false ;
      break ;
      case 6 : target.covalentBond[7]  = false ;
      break ;
      case 7 : target.covalentBondLast = false ;
      break ;
      
      case 8 : break ;
    }
  }
  //::::::::::::::::::::::
  
  public void noContactCovalent() { // internal
    collision = false ; // this boolean give the control of the velocity to the update() void
    //for the covalent collision
    electronicCovalentBond() ;
  }
  
  // Update the bond of each atom
  public void electronicCovalentBond() { // internal
    if (proton < 3 ) { 
      covalentBond[0] = true ;
      if (valenceElectron == 0 ) { covalentBond[1] = false ; covalentBondLast = false ;  }
      if (valenceElectron == 1 ) { covalentBond[1] = false ; covalentBondLast = true ; }
      if (valenceElectron == 2 ) { covalentBond[1] = false ; covalentBondLast = false ; }
    }
    if (proton > 2 ) {      
      covalentBond[0] = true ;
      //if (valenceElectron == 0 ) { covalentBond[1] = true ; covalentBond[2] = true ; covalentBond[3] = true ; covalentBond[4] = true ; covalentBond[5] = true ; covalentBond[6] = true ; covalentBond[7] = true ;  covalentBondLast = true ; }// height place, but is full
      if (valenceElectron == 0 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = false ; covalentBond[6] = false ; covalentBond[7] = false ;  covalentBondLast = false ; }// height place, but is full
      if (valenceElectron == 1 ) { covalentBond[1] = false ; covalentBond[2] = true  ; covalentBond[3] = true  ; covalentBond[4] = true  ; covalentBond[5] = true  ; covalentBond[6] = true  ; covalentBond[7] = true  ; covalentBondLast = true   ; }     // seven places
      if (valenceElectron == 2 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = true  ; covalentBond[4] = true  ; covalentBond[5] = true  ; covalentBond[6] = true  ; covalentBond[7] = true  ; covalentBondLast = true   ; }    // six places
      if (valenceElectron == 3 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = true  ; covalentBond[5] = true  ; covalentBond[6] = true  ; covalentBond[7] = true  ; covalentBondLast = true   ; }      // five places
      if (valenceElectron == 4 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = true  ; covalentBond[6] = true  ; covalentBond[7] = true  ; covalentBondLast = true   ; }     // four places
      if (valenceElectron == 5 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = false ; covalentBond[6] = true  ; covalentBond[7] = true  ; covalentBondLast = true   ; }    // three places
      if (valenceElectron == 6 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = false ; covalentBond[6] = false ; covalentBond[7] = true  ; covalentBondLast = true   ; }     // two places
      if (valenceElectron == 7 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = false ; covalentBond[6] = false ; covalentBond[7] = false ; covalentBondLast = true   ; } // else {  covalentBondLast = false ; }   // one place
      if (valenceElectron == 8 ) { covalentBond[1] = false ; covalentBond[2] = false ; covalentBond[3] = false ; covalentBond[4] = false ; covalentBond[5] = false ; covalentBond[6] = false ; covalentBond[7] = false ; covalentBondLast = false  ; } // no place
    }
  }
  
 
///////////////////////////////////////////////////////////////////////////////
////////////////////////IONIC COLLISION////////////////////////////////////////
//:::::::::::::::::::::::the result depend of the positiv or negativ atom load.
  public void electronicCollision(ArrayList<Atom> listA, boolean ionicEffect ) {
    for (Atom target : listA) {
      if(ionicEffect) {
        if ( target.ion != 0 && ion !=0 ) {
          if (target != this) {    // don't collide with ourselves. that would be weird.
            /////////////////////////\\\\\\\\\\\\\\\\\\\
            //:::::::::Code for angle collision::::::::::
            // get distances between the "atoms" components
            PVector atomVect = new PVector();
            atomVect.x = target.pos.x - pos.x;
            atomVect.y = target.pos.y - pos.y;
            ////////////////////////////////////////////
            if (fieldCollide( target, 
                              target.radius(),                 radius(), 
                              target.radiusElectronicField(),  radiusElectronicField() )) {
              contactElectronic(target) ; // when a collision is found, add it to a list for later use.
            }
          }
        }
      } else if (target != this ) {
                /////////////////////////\\\\\\\\\\\\\\\\\\\
        //:::::::::Code for angle collision::::::::::
        // get distances between the "atoms" components
        PVector atomVect = new PVector();
        atomVect.x = target.pos.x - pos.x;
        atomVect.y = target.pos.y - pos.y;
        ////////////////////////////////////////////
        if (collide(target, target.radiusElectronicField(),  radiusElectronicField())) {
          contact(target, atomVect) ;
        }
      }
    }
  }
  //////////IONIC CONTACT///with anion or cation, negative or positive atom load////////
  public void contactElectronic(Atom target)  {
    // listA_electronicCollision.add(target); // when a collision is found, add it to a list for later use.
    // float forceMgt = abs(ion) + abs(target.ion) ;
    
    if (target.ion < 0) target.ion = -1 ;
    if (target.ion > 0) target.ion =  1 ;
    if (ion < 0) ion = -1 ;
    if (ion > 0) ion =  1 ;
    
    int mgt = ion + target.ion ;
    
    if ( mgt != 0 ) {
      target.vel.x = -target.vel.x ;
      target.vel.y = -target.vel.y ;
    } else {
      PVector newVel = new PVector(target.pos.x - pos.x, target.pos.y - pos.y , target.pos.z - pos.z);
      target.vel.x = -newVel.x;
      target.vel.y = -newVel.y;
      vel.x = newVel.x ;
      vel.y = newVel.y ;
    }
  }
//////////////////////COLLISION GLOBALE VOID//////////////////////////////////
//////////////////////RESOLVE COLLISION/////////////////////////////////
  public void resolveCollision(Atom target , PVector atomVect) {
    if (target.vel.x == 0 ) target.vel.x = vel.x ; 
    if (target.vel.y == 0 ) target.vel.y = vel.y ;
    
    /////////////////////////\\\\\\\\\\\\\\\\\\\\\\
    //:::::::::Code for angle collision::::::::::::
    // calculate magnitude of the vector separating the atoms
    float theta  = atan2(atomVect.y, atomVect.x);
    // precalculate trig values
    float sinus = sin(theta);
    float cosinus = cos(theta);
  /* atomTemp will hold rotated ball positions. You 
    just need to worry about atomTemp[1] position*/
    Ref[] atomTemp = {  new Ref(), new Ref() } ;
       /* "target.atom's" position is relative to "atom's"
    so you can use the vector between them (atomVect) as the 
    reference point in the rotation expressions.
    atomTemp[0].x and atomTemp[0].y will initialize
    automatically to 0.0, which is what you want
    since "target.atom" will rotate around "atom" */
    atomTemp[1].x  = cosinus * atomVect.x + sinus * atomVect.y;
    atomTemp[1].y  = cosinus * atomVect.y - sinus * atomVect.x;
    
    // rotate Temporary velocities
    PVector[] velTemp = {  new PVector(), new PVector() };
    velTemp[0].x  = cosinus * vel.x + sinus * vel.y;
    velTemp[0].y  = cosinus * vel.y - sinus * vel.x;
    velTemp[1].x  = cosinus * target.vel.x + sinus * target.vel.y;
    velTemp[1].y  = cosinus * target.vel.y - sinus * target.vel.x;
    
    /* Now that velocities are rotated, you can use 1D
    conservation of momentum equations to calculate 
    the final velocity along the x-axis. */
    PVector[] velFinal = {  new PVector(), new PVector() };
    // final rotated velocity for b[0]
    velFinal[0].x = ((mass - target.mass) * velTemp[0].x + 2 * target.mass * velTemp[1].x) / (mass + target.mass);
    velFinal[0].y = velTemp[0].y;
    // final rotated velocity for b[1]
    velFinal[1].x = ((target.mass - mass) * velTemp[1].x + 2 * mass * velTemp[0].x) / (mass + target.mass);
    velFinal[1].y = velTemp[1].y;
    
    // hack to avoid clumping
    atomTemp[0].x += velFinal[0].x;
    atomTemp[1].x += velFinal[1].x;
    
    /* Rotate ball positions and velocities back
    Reverse signs in trig expressions to rotate 
    in the opposite direction */
    // rotate Atom
    Ref[] atomFinal = { new Ref(), new Ref() };
    atomFinal[0].x = cosinus * atomTemp[0].x - sinus * atomTemp[0].y;
    atomFinal[0].y = cosinus * atomTemp[0].y + sinus * atomTemp[0].x;
    atomFinal[1].x = cosinus * atomTemp[1].x - sinus * atomTemp[1].y;
    atomFinal[1].y = cosinus * atomTemp[1].y + sinus * atomTemp[1].x;
    
    // update atom to screen position
    target.pos.x = pos.x + atomFinal[1].x;
    target.pos.y = pos.y + atomFinal[1].y;
    pos.x += atomFinal[0].x;
    pos.y += atomFinal[0].y;
    // update velocities
    vel.x = cosinus * velFinal[0].x - sinus * velFinal[0].y;
    vel.y = cosinus * velFinal[0].y + sinus * velFinal[0].x;
    target.vel.x = cosinus * velFinal[1].x - sinus * velFinal[1].y;
    target.vel.y = cosinus * velFinal[1].y + sinus * velFinal[1].x;
  }
  //////////
  
 
  //ELECTRON
  // number of missing electron
 
  public void electronicInfo() {

    // give the period of the atom, the period is call "n"
    if (proton < 3 )                  { n = 1 ; }
    if (proton > 2 && proton < 11 )   { n = 2 ; }
    if (proton > 10 && proton < 19 )  { n = 3 ; }
    if (proton > 18 && proton < 37 )  { n = 4 ; }
    if (proton > 36 && proton < 55 )  { n = 5 ; }
    if (proton > 54 && proton < 87 )  { n = 6 ; }
    if (proton > 86 && proton < 119 ) { n = 7 ; }
    
    // maxE is max of electron by layer "n". 32 is limit of electron by layer, this law is strange because is different of the periodic layer max ?????
    int e = electron  -electronLayer ;
    int maxE = 0 ;
    int mE = 0 ;
    int newN = 1 ;
    // may be it's better to don't use a loop and give the maxE with the number "n" to liberate the computer of this calcul.
    for ( int i = 0 ; i < n ; i++ ) {
      mE = constrain(round( 2*sq(newN)), 0, 32) ;
      maxE += mE ;
      newN += 1 ;
    }
    missingElectron = maxE -e  ; 
    
    //Valence shell, give the number of free place to connect atoms together
    if (n == 1 ) valenceElectron = 2 - missingElectron ;
    if (n == 2 ) valenceElectron = 8 - missingElectron ;
    if (n == 3 ) valenceElectron = 8 - (missingElectron -10) ;
    if (n == 4 ) valenceElectron = 8 - (missingElectron -24) ;
    if (n == 5 ) valenceElectron = 8 - (missingElectron -6) ; 
    if (n == 6 ) valenceElectron = 8 - (missingElectron -6) ;
    if (n == 7 ) valenceElectron = 8 - (missingElectron -6) ;
    //exception with rule
    if (proton > 20 && proton < 28 ) valenceElectron = proton%9 ; 
    if (proton > 38 && proton < 46 ) valenceElectron = proton%9 ;
    
    if (proton > 27 && proton < 31 ) valenceElectron = (proton%9) -1 ; 
    if (proton > 45 && proton < 49 ) valenceElectron = (proton%9) -1 ;
    if (proton > 48 && proton < 55 ) valenceElectron = valenceElectron +32 ;  
    
    if (proton > 56 && proton < 72 )   valenceElectron = 3 ; // lanthanides
    if (proton > 71 && proton < 77 )   valenceElectron = valenceElectron +42 ;
    if (proton > 76 && proton < 87 )   valenceElectron = valenceElectron +32 ;  
    if (proton > 88 && proton < 104 )  valenceElectron = 3 ; // actinides
    if (proton > 103 && proton < 109 ) valenceElectron = valenceElectron +42 ;
    if (proton > 108 && proton < 119 ) valenceElectron = valenceElectron +32 ;  
    
    //exception without rule
    //if (proton == 2  ) valenceElectron = 8 ;
    if (proton == 77 || proton == 109 ) valenceElectron = 8 ;
    if (proton == 19 || proton == 37 || proton == 55 || proton == 87 ) valenceElectron = 1 ;
    if (proton == 20 || proton == 38 || proton == 56 || proton == 88 ) valenceElectron = 2 ;
    
     if ( valenceElectron == 0 ) valenceElectron = 8 ; 
    
    //::::::::
    // To give the energy of atom
    if (proton < 3 ) freeElectronicSpace = 2 - valenceElectron ;
    if (proton > 2 ) freeElectronicSpace = 8 - valenceElectron ; 
  
     // ScreenEffect = 13.6 / (sq(n)) *freeElectronicSpace ; 
     screenEffect = 13.6f / (sq(n)) ; 
   }


  //add electron
  // create a list, to show the electronic cloud
  public void addElectron() {
    int i ;
    Electron lctrn = new Electron();
    for ( i = 0 ; i < electron ; i++) {
      if (listE.size() < electron ) {
        listE.add(lctrn) ;
      }
    }
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  ////////////////////
  //DISPLAY
  public void display(String core, String cloud, PVector size, int colorFill, int colorStroke, float thickness, float orientation) {
    aspect(colorFill, colorStroke, thickness) ;
    //check size
    PVector temp_size = size.copy();
    temp_size.mult(diamAtom);
    size.set(temp_size);
    
    
    pushMatrix() ;
    translate(pos.x, pos.y) ;
    rotateX(radians(orientation)) ;
    // CORE
    if(core.equals("ELLIPSE")) coreEllipse(size) ;
    if(core.equals("RECTANGLE")) coreRect(size) ;
    if(core.equals("TRIANGLE")) coreTriangle(p5,size);
    if(core.equals("SPHERE")) coreSphere(size) ;
    if(core.equals("BOX")) coreBox(size) ;
    if(core.equals("TETRA")) coreTetra(size) ;
    
    //CLOUD
    if(cloud.equals("ELLIPSE")) cloudEllipse(size.x *.2f) ;
    if(cloud.equals("RECTANGLE")) cloudRectangle(size.x *.2f) ;
    if(cloud.equals("TRIANGLE")) cloudTriangle(size.x *.2f) ;
    if(cloud.equals("POINT")) {
      // special appearance for the point because Processing use the stroke for the point
      stroke(colorFill) ;
      strokeWeight(thickness *2.f) ;
      cloudPoint(size.x *.2f) ;
      aspect(colorFill, colorStroke,thickness) ;
    }
    
    popMatrix() ;   
  }
  
  

  // DISPLAY TEXT and MISC
  ////////////////////////
  // text from main program
  /*
  void title2D(String title, color cName, PFont p, int sizeText, PVector posText, float orientation) {
    if (alpha(cName) != 0 ) {
      fill(cName); textFont(p, sizeText);
      textAlign(CENTER);
      text(title , pos.x +posText.x , pos.y +posText.y );
    }
  }
  */
  public void title2D(int colorText, PFont p, int sizeText, PVector posText, float orientation) {
    if ( alpha(colorText) != 0 ) {
      fill(colorText); textFont(p, sizeText);
      textAlign(CENTER) ;
      
      pushMatrix() ;
      translate(pos.x, pos.y) ;
      rotateX(radians(orientation)) ;
      text(nickName ,posText.x,posText.y);
      popMatrix() ;
    }
  }
  /////////////////////DISPLAY PROPERTY of ATOM////////////////////////////////////////////
  public void titleAtom2D (int colorText, int colorInfo, PFont p, int sizeTextName, int sizeTextInfo, float amp_, float orientation) {
    ampInfo = amp_ ;
    float posXtext = (n *diamAtom *ampInfo) *0.35f ;
    float posYtext = sizeTextName *0.25f *(ampInfo/10.0f) ;
    pushMatrix() ;
    translate(pos.x, pos.y) ;
    rotateX(radians(orientation)) ;
      
    if ( alpha(colorText) != 0 ) {
      fill(colorText); textFont(p, sizeTextName);
      textAlign(CENTER);

      text(nameAtom[proton] ,0 , posYtext );
    }
    //Info
    if ( alpha(colorInfo) != 0 ) {
      fill(colorInfo); textFont(p, sizeTextInfo);
      textAlign (LEFT) ; 
      text(ion,              posXtext , -posYtext );
      text(valenceElectron,  posXtext ,  2.3f *posYtext);
      textAlign (RIGHT) ; 
      text(proton,           -posXtext , 2.3f *posYtext);
      text(round(mass),      -posXtext , -posYtext); 

    }
    popMatrix() ;
  } 
  
  
  
  
  
  // ANNEXE DISPLAY
  // CORE 2D
  public void coreTriangle(PApplet p5, PVector size) {
    //new R_Primitive().draw(vec2(),size.x,3);
    R_Primitive prim = new R_Primitive(p5,3);
    prim.pos(vec2());
    prim.size((int)size.x);
    prim.show();
  }
  public void coreEllipse(PVector size) {
    ellipse(0,0,size.x, size.y) ;
  }
  
  public void coreRect(PVector size) {
    rectMode(CENTER) ;
    rect(0,0,size.x, size.y) ;
    rectMode(CORNER) ;
  }
  
  // CORE 3D
  public void coreSphere(PVector size) {
    int minFace = 10 ;
    int maxFace = 25 ;
    sphere(size.x *.4f) ;
    int face ;
    face = PApplet.parseInt(size.x * .2f) ;
    if(face < minFace) face = minFace; else if(face > maxFace ) face = maxFace ;
    sphereDetail(face) ;
  }
  
  public void coreBox(PVector size) {
    box(size.x, size.y, size.z) ;
  }
  
  public void  coreTetra(PVector size) {
    int diam = (int)size.x ;
    polyhedron("TETRAHEDRON", "VERTEX", diam) ;
  }
  
  
  
  
  //CLOUD 
  
  
  public void cloudEllipse(float newAmplitudeElectrocField) {
    electronicInfo() ;
    noFill() ;
    ellipse (0, 0, radiusElectronicFieldCovalent() *newAmplitudeElectrocField, radiusElectronicFieldCovalent() *newAmplitudeElectrocField ) ;
    ellipse (0, 0, radiusElectronicField() *newAmplitudeElectrocField,     radiusElectronicField() *newAmplitudeElectrocField ) ;
  }
  
  public void cloudRectangle(float newAmplitudeElectrocField) {
    electronicInfo() ;
    noFill() ;
    rect(0, 0, radiusElectronicFieldCovalent() *newAmplitudeElectrocField, radiusElectronicFieldCovalent() *newAmplitudeElectrocField ) ;
    rect(0, 0, radiusElectronicField() *newAmplitudeElectrocField,     radiusElectronicField() *newAmplitudeElectrocField ) ;
  }
  
  public void cloudTriangle(float newAmplitudeElectrocField) {
    electronicInfo() ;
    noFill() ; 
    float radius = radiusElectronicFieldCovalent() *newAmplitudeElectrocField ;

    R_Primitive prim = new R_Primitive(p5,3);
    prim.pos(vec2());
    prim.size((int)radius);
    prim.show();
  }
  
  // CLOUD POINT
  public void cloudPoint(float newAmplitudeElectrocField) {
    addElectron() ;
    electronicInfo() ;
    cloud = true ;
    PVector posElectron = new PVector() ; 
    float ElectronicCloud = radiusElectronicField() *.5f *newAmplitudeElectrocField;
    
    //
    for (Electron electron : listE) {
      float randomEx = random( -ElectronicCloud, ElectronicCloud ) ;
      float randomEy = random( -ElectronicCloud, ElectronicCloud ) ;
      
      // check if the electron are in the diameter
      
      if (sqrt(sq(randomEx) + sq(randomEy)) > ElectronicCloud) {
        posElectron.x = -ElectronicCloud ;
        posElectron.y = -ElectronicCloud ;
      } else {
        
        posElectron.x = randomEx ;
        posElectron.y = randomEy ;
        point(posElectron.x,posElectron.y) ;
        // electron.displayPoint2D(posElectron, thickness, colorFill) ; 
      }
    }
  }
  // END DISPLAY
  //////////////
  

  /////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////EXTERNAL INFLUENCE///////////////////////////////////////////////////
  // Wall border
  public void universWall2D(float restitutionBottom_, float restitutionTop_, float restitutionRight_, float restitutionLeft_, boolean wallOnOff_, PVector marge) {
    nvrs.physicWall2D(restitutionBottom_, restitutionTop_, restitutionRight_, restitutionLeft_, wallOnOff_) ;
    nvrs.wall2D(pos, vel, radius(), radiusElectronicField(), rebound, cloud, marge ) ;
  }  
  //

   
  ////////////////////////////////////////////////////////////////////////////////////////////////  
  //////////////////////////////////////RETURN///////////////////////////////////////////////////

  //////DETECT COLLISION\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // Detection the cursor is on the atom
  public boolean radiusCursor2D() {
    return dist(pos.x, pos.y, mouseX, mouseY) < radius();
  }
    // Detection the cursor is on the atom
  public boolean radiusElectronicFieldCursor2D() {
    return dist(pos.x, pos.y, mouseX, mouseY) < radiusElectronicField();
  }
  
  //:::::::::detect a collision with the other proton
  public boolean collide(Atom target, float targetRadius, float radius) {
    float distance = target.pos.dist(pos); // distance between our center and the other ball center
    float thresh = targetRadius + radius; // thresh is our radius plus their radius
    if (distance < thresh) { // if the distance is less than the threshold, we are colliding!
      return true;
    } else {
      return false;
    }
  }
  //:::::::::detect a collision in field around
  public boolean fieldCollide(Atom target, float targetRadiusMin, float radiusMin, float targetRadiusMax, float radiusMax) {  
    float distance = target.pos.dist(pos); // distance between our center and the other ball center
    float minThresh = targetRadiusMin + radiusMin; // thresh is our radius plus their radius
    float maxThresh = targetRadiusMax + radiusMax;
    if (distance > minThresh && distance < maxThresh) { // if the distance is in the field there is effect  
      return true;
    } else {
      return false;
    }
  }
  //////RETURN MISC\\\\\\\\\\\\\\\\\\\\\
  //:::::::::::::::return detection cursor
  public boolean inside() {
    if (insideA) return true ; else return false ;
  }
  //
  public boolean insideField() {
    if (insideF) return true ; else return false ;
  }
  //::::::::::::::::: Calculate the surface of Atom
  public float surface() {
    return  PI*sq(diamAtom/2) ;   
  }
  //:::::::::::::::RADIUS:::::::::::::::::::
  //:::::::::::::::Return the radius of atom
  public float radius() { 
    return diamAtom / 2;
  }
  //:::::::::::::::Return the radius of the atom's electronic field
  public float radiusElectronicField() { 
    float REF ;
    float base = 1.0f ;
    float ratioPeriodic = 1.0f ;
    float ratioSizeAtom = 1.0f ;
    int maxPos = 0 ; // max position of the atom in the line line of periodic border
    int posAtom = 0 ; // position of the atom in the periodic border
    if (n == 1 ) { base = 1.0f ;  ratioPeriodic = 1.7f  ; maxPos = 2  ; posAtom = abs( proton -2)   ;  }
    if (n == 2 ) { base = 1.22f ; ratioPeriodic = 4.41f ; maxPos = 8  ; posAtom = abs( proton -10)  ;  }
    if (n == 3 ) { base = 2.29f ; ratioPeriodic = 2.67f ; maxPos = 8  ; posAtom = abs( proton -18)  ;  }
    if (n == 4 ) { base = 2.83f ; ratioPeriodic = 2.76f ; maxPos = 18 ; posAtom = abs( proton -36)  ;  }
    if (n == 5 ) { base = 3.48f ; ratioPeriodic = 2.45f ; maxPos = 18 ; posAtom = abs( proton -54)  ;  }
    if (n == 6 ) { base = 3.87f ; ratioPeriodic = 2.48f ; maxPos = 32 ; posAtom = abs( proton -86)  ;  }
    if (n == 7 ) { base = 4.55f ; ratioPeriodic = 2.50f ; maxPos = 32 ; posAtom = abs( proton -118) ;  }
    
    float newPosAtom = norm( posAtom, 0.0f, maxPos -1 ) ;
    if (newPosAtom == 0 ) { ratioSizeAtom = newPosAtom ; } else { ratioSizeAtom = newPosAtom / ((3.0f - pow(newPosAtom, 5)  ) -newPosAtom) ; }
    
    ratioSizeAtom = 1 + ( ratioSizeAtom *ratioPeriodic *base ) ;
    
    REF = diamAtom *amplitudeElectrocField *ratioSizeAtom  ;
    return REF ;
  }
  //:::::::::::::::Return the radius of the atom's electronic valence bond field 
  public float radiusElectronicFieldCovalent() {
    float REFC ;
    float base = 1.0f ;
    float ratioPeriodic = 1.0f ;
    float ratioSizeAtom = 1.0f ;
    int maxPos = 0 ; // max position of the atom in the line line of periodic border
    int posAtom = 0 ; // position of the atom in the periodic border
    if (n == 1 ) { base = 1.0f ;  ratioPeriodic = 1.7f  ; maxPos = 2  ; posAtom = abs( proton -2)   ;  }
    if (n == 2 ) { base = 1.22f ; ratioPeriodic = 4.41f ; maxPos = 8  ; posAtom = abs( proton -10)  ;  }
    if (n == 3 ) { base = 2.29f ; ratioPeriodic = 2.67f ; maxPos = 8  ; posAtom = abs( proton -18)  ;  }
    if (n == 4 ) { base = 2.83f ; ratioPeriodic = 2.76f ; maxPos = 18 ; posAtom = abs( proton -36)  ;  }
    if (n == 5 ) { base = 3.48f ; ratioPeriodic = 2.45f ; maxPos = 18 ; posAtom = abs( proton -54)  ;  }
    if (n == 6 ) { base = 3.87f ; ratioPeriodic = 2.48f ; maxPos = 32 ; posAtom = abs( proton -86)  ;  }
    if (n == 7 ) { base = 4.55f ; ratioPeriodic = 2.50f ; maxPos = 32 ; posAtom = abs( proton -118) ;  }
    
    float newPosAtom = norm( posAtom, 0.0f, maxPos -1 ) ;
    if (newPosAtom == 0 ) ratioSizeAtom = newPosAtom ; else ratioSizeAtom = newPosAtom / ((3.0f - pow(newPosAtom, 5)  ) -newPosAtom) ; 
    
    ratioSizeAtom = 1 + ( ratioSizeAtom *ratioPeriodic *base ) ;
    
    REFC = diamAtom *amplitudeElectrocField *ratioSizeAtom *0.8f ;
    return REFC ;
  }

  //::::::::::::::ELECTRONIC INFO:::::::::::::::::::::::::::::
  //::::::::::::::Return the number Valence
  public int valenceE() {
    electronicInfo() ;
    return valenceElectron ;
  }
  //:::::::::Return the quantity of free place in the last electronic valence shell
  public int freeE() {
    electronicInfo() ;
    return freeElectronicSpace ;
  }
  //return the proton
  public int getProton() {
    return proton ;
  }
  
  
  
  
  
  
  
  // ANNEXE
  //Optional void atom

  public void drag2D() {
    //strokeWeight(d) ;
    insideA = radiusCursor2D() ;
    insideF = radiusElectronicFieldCursor2D() ;
    if(mousePressed && insideA) lock = true;
    if(!mousePressed)           lock = false;
    if (lock) { 
      pos.x = mouseX; 
      pos.y = mouseY;
    }
  }
  //:::::::drag Atom
  public void drag2D(float inertia) {
    //strokeWeight(d) ;
    insideA = radiusCursor2D() ;
    insideF = radiusElectronicFieldCursor2D() ;
    if( mousePressed && insideA) lock = true ;
    if(!mousePressed)            lock = false ;
    if (lock) { 
      pos.x = mouseX; 
      pos.y = mouseY;
      vel.x = (mouseX -pmouseX) * inertia; 
      vel.y = (mouseY -pmouseY) * inertia;
      if (vel.x == 0 && vel.y == 0 ) 
      {
        vel.x = random(-1,1) ;
        vel.x = random(-1,1) ;
      }   
    }
  }
  // END ANNEXE
  
}

// END CLASS ATOM
/////////////////









//////////////////////////
//SUPER CLASS ELECTRON to create a list of electron
class Electron {
  Electron() {}
}

///////////////////////////////////////////////////
//Special class creat like reference for the rotate
class Ref {
  float x, y;
  Ref() { }
}
/////////////






/////////
//UNIVERS
/////////
class Univers {
  PVector newPos ;
  PVector newVel ;
  // PVector mvt ;
  
 // float nx, ny ;
 // float mvtx, mvty ; 
  
  float r, restitutionBottom, restitutionTop , restitutionRight ,  restitutionLeft  ;
  boolean wallOnOff ;
  
  Univers() {
    newVel = new PVector (1 , 1, 1 ) ; 
  }
  /*
  Univers(float mvtx, float mvty)
  {
    mvtx_ = mvtx ; mvty_ = mvty ; 
  }
  */
  public void physicWall2D(float restitutionBottom_, float restitutionTop_, float restitutionRight_, float restitutionLeft_, boolean wallOnOff_ ) {
    restitutionTop    = restitutionTop_ ;  
    restitutionBottom = restitutionBottom_ ; 
    restitutionRight  = restitutionRight_ ;  
    restitutionLeft   = restitutionLeft_ ;
    wallOnOff = wallOnOff_ ;
  }
  
  //void wall(float x_, float y_, float z_, float w_, float h_, float mvtx_, float mvty_)
  public void wall2D(PVector pos, PVector vel,  float radiusProton, float radiusElectronicCloud, float rebond_, boolean cloud_, PVector marge ) {
    newPos = pos ;
    newVel = vel ;
    boolean cloud = cloud_ ;  
    if (!cloud ) {
      r = radiusProton ;
    } else {
      r = radiusElectronicCloud ;
    }
    
    //float renderTop = restitutionTop + rebond_ ;
    float renderBottom = restitutionBottom + rebond_ ;
    float renderRight = restitutionRight + rebond_ ;
    //float renderLeft = restitutionLeft + rebond_ ;
    //::::::WALL ON
    if ( wallOnOff ) {
      if (pos.x > -r +marge.x || pos.x < r -marge.x ) {
      newVel.x = -newVel.x *renderRight ;        
      } else if (pos.y > -r +marge.y ||pos.y < r -marge.y ) {
        newVel.y = -newVel.y *renderBottom ;    
      }
    }
    
    //::::::WALL OFF
    //wall right
    if ( !wallOnOff ) {
      if (pos.x > +r + marge.x ) {
        newPos.x = -r -marge.x;
        newVel.x *=+1 ;
        //wall left
      } else if (pos.x < -r -marge.x  ) {
        newPos.x = +r + marge.x;
        newVel.x *=+1 ;
        //ground  
      } else if (pos.y > +r + marge.y ) {
        newPos.y = -r -marge.y;
        newVel.x *=+1 ;
        //roof  
      } else if (pos.y < -r -marge.y ) {
        newPos.y =  +r +marge.y;
        newVel.x *=+1 ;
      }
    }
  }
}
//END UNIVERS
/////////////



























// info num Chapters
public int numChapters(String txt) {
  String chapters [] = split(txt, "*") ;
  return chapters.length ;
}

// info num Sentences
public int numMaxSentencesByChapter(String txt) {
  String chapters [] = split(txt, "*") ;
  // find the quantity of chapter and sentences by chapter to create the final double array String
  int numChapter = chapters.length ;
  int maxSentencesByChapter = 0 ;  
  for ( int i = 0 ; i < numChapter ; i++) {
    String sentences [] = split(chapters[i], "/") ;
    if ( sentences.length > maxSentencesByChapter ) maxSentencesByChapter = sentences.length ; 
  }
  return maxSentencesByChapter ;
}



public String whichSentence(String txt, int whichChapter, int whichSentence) {
  String chapters [] = split(txt, "*") ;
  String  [][] repartition ;
  
  // find the quantity of chapter and sentences by chapter to create the final double array String
  int numChapter = chapters.length ;
  int maxSentencesByChapter = 0 ;  
  for ( int i = 0 ; i < numChapter ; i++) {
    String sentences [] = split(chapters[i], "/") ;
    if ( sentences.length > maxSentencesByChapter ) maxSentencesByChapter = sentences.length ; 
  }
  //create the final double array string
  repartition = new String [numChapter][maxSentencesByChapter] ;
  //put the sentences in the double String by chapter
  for ( int i = 0 ; i < numChapter ; i++) {
    String sentences [] = split(chapters[i], "/") ;
    for ( int j = 0 ; j <  sentences.length ; j++) {
      repartition [i][j] = sentences[j] ;
    }
  }
  //security
  if(whichChapter > chapters.length ) whichChapter = 0 ;
  if(whichSentence > maxSentencesByChapter ) whichSentence = 0 ;
  
  return repartition[whichChapter][whichSentence] ;
}














/**
* BALISE
* 2011-2019
* v 1.3.8
*/
Balise balise ;
//object three
class BaliseRomanesco extends Romanesco {
  public BaliseRomanesco() {
    //from the index_objects.csv
    item_name = "Balise" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.3.8";
    item_pack = "Base 2011-2018" ; 
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12" ;
    // item_mode = "Disc/Rectangle/Box/Box Snake" ;
    item_mode = "" ;

    // item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Stroke hue,Stroke sat,Stroke bright,Stroke alpha,Thickness,Size X,Size Y,Size Z,Quantity,Speed X,Canvas X,Repulsion" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
   // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  float speed =0;
  boolean change_rotation_direction ;
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    balise = new Balise() ;
  }
  //DRAW
  public void draw() {
    // authorization to make something with the sound in Prescene mode
    boolean authorization = false ;
    float tempo_balise = 1 ;
    if(sound_is() && FULL_RENDERING) {
      authorization = true ;
      tempo_balise = tempo[ID_item] *.01f;
    } else {
      tempo_balise = 1.f ;
    }

    //reverse
    int rotation_direction = 1;
    if(reverse_is()) {
      rotation_direction = 1; 
    } else {
      rotation_direction = -1;
    }



    if (motion_is()) {
      float speed_base = map(get_speed_x(), 0,1, 0,20);
      speed = speed_base *tempo_balise *rotation_direction ; 
    } else {
      speed = 0.f;
    }

    //amplitude
    float amp = map(get_canvas_x(),get_canvas_x_min(),get_canvas_x_max(),1,width*10);
    
    //factor size
    float factor_base = map(get_repulsion(),0,1,1,height/4);
    float factor = 1;
    if(sound_is()) {
      factor = factor_base *(all_transient(ID_item) *.2f);
    } 
    if(factor < 1.0f ) factor = 1.0f ;

    // snake mode
    boolean snake_mode = false ;
    if(special_is()) {
      snake_mode = true ; 
    } else {
      snake_mode = false ;
    }

    // aspect
    aspect(get_fill(), get_stroke(), get_thickness(), get_costume());

    
    

    // SIZE
    float ratio = .5f ;
    float tempo_effect = 1 + ((transient_value[0][ID_item] *ratio) + (transient_value[2][ID_item] *ratio) + (transient_value[3][ID_item] *ratio) + (transient_value[4][ID_item] *ratio));

    vec3 size = vec3(get_size_x(),get_size_y(),get_size_z());
    size.mult(15);

    vec2 left_right_sound = vec2(1) ;
    if(authorization) {
      size.mult(tempo_effect,tempo_effect,1);
      left_right_sound = vec2(left[ID_item] *5,right[ID_item] *5) ;
    }
    
    if(left_right_sound.x <= 0) {
      left_right_sound.x = .1f;
    }

    if(left_right_sound.y <= 0) {
      left_right_sound.y = .1f;
    } 
    //quantity
    int maxBalise = 511 ;
    if(!FULL_RENDERING) maxBalise = 64 ;
    float radiusBalise = map(get_quantity(), 0,1, 2, maxBalise); // here the value max is 511 because we work with buffersize with 512 field
    float ratio_size = map(get_area(),width*.1f, width*TAU,0,1);
    
    vec3 pos = vec3();
    balise.update(pos,speed);

    balise.display(amp, left_right_sound, size, factor, PApplet.parseInt(radiusBalise), authorization, get_costume(), snake_mode,ratio_size) ;
    
    
    item_info[ID_item] = ("Size "+(int)size.x + " / " + (int)size.y + " / " + (int)size.z  + " Radius " + PApplet.parseInt(radiusBalise) ) ;
  }
}






/**
CLASS BALISE
*/
class Balise {  
  float rotation ;
  float angle  ;

  Balise () { }

  public void update(vec pos_temp, float speed) {
    vec3 pos = vec3() ;
    if(pos_temp instanceof vec2) {
      vec2 p = (vec2) pos_temp ;
      pos.set(p.x, p.y, 0) ;
    } else if(pos_temp instanceof vec3) {
      vec3 p = (vec3) pos_temp ;
      pos.set(p) ;
    }
    Float s = speed ;
    if(!s.isNaN()) rotation += speed;
    
    if (rotation > 360) {
      rotation = 0 ; 
    } else if (rotation < 0 ) {
      rotation = 360 ;
    }
    float angle = rotation ;
    //translate (pos) ;
    rotate(radians(angle) ) ;
  }


  
  public void display(float amp, vec2 sound_input, vec3 size, float factor, int max, boolean authorization, Costume costume, boolean snake_mode, float ratio_size) {

    pushMatrix() ;
    rectMode(CENTER) ;
    
    if (max > 512) {
      max = 512;
    }

    for(int i = 0 ; i < max ; i++) {
      vec2 var = vec2(input(i,max,sound_input,authorization).x, input(i,max,sound_input,authorization).y) ;
      vec2 pos = vec2(amp *var.x, amp *var.y);
      
      var.set(abs(var.x *factor), abs(var.y *factor));

      vec3 final_size = vec3(size.x *var.x, size.y *var.y, size.z *((var.x +var.y)*.5f));
      if(snake_mode) {
        //println("snake");
        start_matrix();
        translate(pos);
      }

      // ellipse(pos.x,pos.y,final_size.x,final_size.y);
      set_ratio_costume_size(ratio_size);
      costume(pos,final_size,costume) ;
      if(snake_mode) {
        stop_matrix() ;
      }
       /*
      }
      if (mode == 0 ) ellipse(posBalise.x, posBalise.y, newSize.x, newSize.y) ;
      if (mode == 1 ) rect   (posBalise.x, posBalise.y, newSize.x, newSize.y) ;
      */
      /*
      if (mode == 2 ) snake_mode(posBalise, newSize, true) ;
      if (mode == 3 ) snake_mode(posBalise, newSize, false) ;
      */
    }
    rectMode(CORNER) ;
    popMatrix() ;
    noStroke() ;
  }
  
  /*
  void snake_mode(PVector pos, PVector size, boolean snake) {
    if(snake) pushMatrix() ;
    translate(pos.x, pos.y, pos.z) ;
    box(size.x, size.y, size.z) ;
    if(snake) popMatrix() ;
  }
  */
  
  //calculate and return the position for each brick of the balise
  public vec2 input(int whichOne, int max, vec2 var, boolean authorization) {
    vec2 value = vec2(1) ;
    if(authorization) {
      value = vec2((get_left(whichOne)*var.x), (get_right(whichOne)*var.y) ) ; 
    } else {
      float n = (float)whichOne ;
      n = n - (max/2) ;
      value = vec2( n*var.x *.01f, n*var.y *.01f); 
    } 
    return value ;
  }
}
/**
BOIDS
2015-2019
V 1.0.6
*/

class Boids extends Romanesco {
  public Boids() {
    item_name = "Boids" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.0.6";
    item_pack = "Base 2015-2019" ;
    item_costume = "";
    item_mode = "Tetra monochrome/Tetra camaieu" ; // separate the differentes mode by "/"

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = false;
    size_z_is = false;
    diameter_is = false;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = true;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = true;
    repulsion_is = true;
    attraction_is = true;
    density_is = false;
    influence_is = true;
    calm_is = false;
    spectrum_is = false;
  }
  
  Flock flock;
  Canvas myCanvas ;
  PVector birthPlace ;
  int maxColorRef = 360 ; // here we are in HSB 360
  int rangeAroundYourColor = 70 ;
  int numOfBoid ;
  // Main method
  // setup
  public void setup() {
   setting_start_position(ID_item, width/2, height/2, -width) ;

   // build the canvas where the boid can move
   PVector pos = new PVector (0, 0, 0) ;
   PVector size = new PVector(width,width,width) ;
   // PVector size = new PVector(get_canvas_x(),get_canvas_y(),get_canvas_z()) ;
   myCanvas = new Canvas(pos, size) ;
   // color colorBoid = color(80,100,100) ;
   birthPlace = pos.copy() ;
   flock = new Flock() ;

   // tetrahedronAdd() : weird why this method is here ?
   // tetrahedron_add();

  }
  
  // draw
  public void draw() {
    // MAIN method
    float thickness = map(get_thickness(),0,width/3,0,width/30 ) ;
    int size = (int)map(get_size_x(),.1f,width, 2,width/10) ;
    float alignment = map(get_alignment(),0,1,0,10) ;
    float cohesion = map(get_attraction(),0,1,0,10) ;
    float separation = map(get_repulsion(),0,1,0,10) ;
    PVector unity = new PVector(cohesion, separation) ;
    if(flock.listBoid.size() > 0 )flock.run(alignment, unity);
    
    // ANNEXE methods
    
    // GOAL of the boids
    if(key_space_long) {
      float depthGoal =sin(frameCount *.002f) *width ;
      float pos_x = map(mouse[ID_item].x,0,width, -get_canvas_x(), get_canvas_x() ) ;
      float pos_y = map(mouse[ID_item].y,0,height, -get_canvas_y(), get_canvas_y() ) ;
      flock.goal(pos_x,pos_y, depthGoal);
    }

    int beat_sensibility = 5 ;
    if(all_transient(ID_item) > beat_sensibility) {      
      float depthGoal =sin(frameCount *.003f) *width ;
      float pos_x = sin(frameCount *.003f) *get_canvas_x() ;
      float pos_y = cos(frameCount *.003f) *get_canvas_y() ;
      flock.goal(pos_x,pos_y, depthGoal);
    }


    
    // INFLUENCE of the boid around him
    float ratioInfluence = get_influence() *400 +1 ;
    float influenceArea =  abs(sin(frameCount *.001f) *ratioInfluence) ;
    flock.influence(influenceArea);
    
    // SPEED
    float speed = map(get_speed_x(),0,1,.1f,7) ;
    speed *= speed ;
    if(sound_is() )speed *= (map(mix[ID_item],0,1,.00000001f,7)) ;
    if(!motion_is() || (sound_is() && get_time_track() < .2f)) speed = .00000001f ;
    flock.speed(speed) ;
    
    // cage size
    myCanvas.size.x = get_canvas_x() *10 ;
    myCanvas.size.y = get_canvas_y() *10 ;
    myCanvas.size.z = get_canvas_z() *10 ;
    myCanvas.update() ;
  
    flock.canvasSetting(myCanvas.left, myCanvas.right, myCanvas.top, myCanvas.bottom, myCanvas.front, myCanvas.back) ;
    
    // quantity of boids
    numOfBoid = PApplet.parseInt(get_quantity() *700 +30); //amount of boids to start the program with
    if(!FULL_RENDERING) numOfBoid /= 15 ;
    
    // change the setting of the boid
    for(Boid b : flock.listBoid) {
      b.fillBoid = color(hue(b.fillBoid), saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
      b.strokeBoid = color(hue(b.strokeBoid), saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
      b.size = size ;
      b.thickness = thickness;
    }
    
    
    if(flock.listBoid.size() < 1 ) {
      flock.add(birthPlace, numOfBoid, get_fill(), get_stroke(), maxColorRef, rangeAroundYourColor) ;
    }
    
    // clear the boids list
    // flock.clear() ;
    if(key_n && action_is()) {
      flock.add(birthPlace, numOfBoid, get_fill(), get_stroke(), maxColorRef, rangeAroundYourColor) ;
    }
    
    // INFO
    item_info[ID_item] = ("There is " + numOfBoid + " boids") ;
    if(displayInfo) {
      strokeWeight(1) ;
      stroke(255) ;
      myCanvas.canvasLine() ;
    }
  }
}













// FLOCK
class Flock {
  ArrayList<Boid> listBoid = new ArrayList<Boid>(); //will hold the boids in this BoidList
  // float h; //for color
 //  color colorBoid ;
  // Univers
  float left, right, top, bottom, front, back ;
  // 
  PVector birthPlace ;
  
  // Constructor just to init
  Flock() {}
  
  
  // CONSTRUCTOR
  Flock(int n, int fillBoid, int strokeBoid) {
   birthPlace = new PVector(width/2,height/2,0) ;
    for(int i = 0; i < n ; i++) {
      listBoid.add(new Boid(birthPlace, fillBoid, strokeBoid));
    }
  }
  
  
  // 
  Flock(PVector birthPlace, int n, int fillBoid, int strokeBoid) {
    this.birthPlace = birthPlace.copy() ;
    for(int i = 0; i < n ; i++) {
      listBoid.add(new Boid(birthPlace, fillBoid, strokeBoid));
    }
  }
  
  
  // Flock Camaieu constructor
  Flock(PVector birthPlace, int n, int fillBoid, int strokeBoid, int max, int range) {
     this.birthPlace = birthPlace.copy() ;
     
     float refFill = hue(fillBoid) ;
     float refStroke = hue(strokeBoid) ;
     for(int i = 0; i < n ; i++) {
      float newHueFill = camaieu(max, refFill, range) ;
      float newHueStroke = camaieu(max, refStroke, range) ;
      fillBoid = color (newHueFill, saturation(fillBoid), brightness(fillBoid)) ;
      strokeBoid = color (newHueStroke, saturation(strokeBoid), brightness(strokeBoid)) ;
      listBoid.add(new Boid(birthPlace, fillBoid, strokeBoid));
    }
  }
  
  

  
  
  // SETUP
  public void canvasSetting() {
    right = width ;
    left = 0 ;
    bottom = height ;
    top = 0 ;
    back = -300 ; 
    front = 300 ;
  }
  
  public void canvasSetting(float left, float right, float top, float bottom, float front, float back) {
    this.left = left ;
    this.right = right ;
    this.top = top ;
    this.bottom = bottom ;
    this.front = front ;
    this.back = back ;
  }
  
  
  // DRAW
  public void run(float ratioAlignment, PVector unity) {
    //iterate through the list of boids 
    for(Boid b : listBoid) {
     // Boid tempBoid = (Boid)listBoid.get(i); //create a temporary boid to process and make it the current boid in the list
    //  b.colorBoid = colorBoid;
      b.settingBounds (left, right, top, bottom, front, back);
      b.run (listBoid, ratioAlignment, unity); //tell the temporary boid to execute its run method
    }
  }
  
  // ANNEXE and EXTERNAL
  
   public void goal(float x, float y, float z) {
     for(Boid b : listBoid) b.goal(x,y,z);
   }
   
   public void influence(float neighborhoodRadius) {
     for(Boid b : listBoid) b.influence(neighborhoodRadius);
   }
   
   
 public void speed(float maxSpeed) {
    for(Boid b : listBoid) b.speed(maxSpeed);
  }
  
  // ADD and REMOVE boids
  
  // different rebirth
  public void add(int n) {
    listBoid.clear() ;
    for(int i = 0; i < n ; i++) listBoid.add(new Boid(birthPlace));
  }
  
  public void add(int n, int fillBoid, int strokeBoid) {
    listBoid.clear() ;
    for(int i = 0; i < n ; i++) listBoid.add(new Boid(birthPlace, fillBoid, strokeBoid));
  }
  
 public void add(PVector birthPlace, int n, int fillBoid, int strokeBoid, int max, int range) {
   listBoid.clear() ;
    float refFill = hue(fillBoid) ;
    float refStroke = hue(strokeBoid) ;
    for(int i = 0; i < n ; i++) {
      float newHueFill = camaieu(max, refFill, range) ;
      float newHueStroke = camaieu(max, refStroke, range) ;
      fillBoid = color (newHueFill, saturation(fillBoid), brightness(fillBoid)) ;
      strokeBoid = color (newHueStroke, saturation(strokeBoid), brightness(strokeBoid)) ;
      listBoid.add(new Boid(birthPlace,fillBoid,strokeBoid));
    }
  }
  
  
  
  
  public void clear(){
    listBoid.clear() ;
  }
  
  public void add() {
    listBoid.add(new Boid(new PVector(birthPlace.x,birthPlace.y,birthPlace.z)));
  }
  
  public void addBoid(Boid b) {
    listBoid.add(b);
  }
  
  // remove specific boid
  public void remove(int n) {
    if(n < listBoid.size())
      listBoid.remove(n);
  }
  
  // remove the last boid
  public void remove() {
    if(listBoid.size() > 0)
      listBoid.remove(listBoid.size()-1);
  }
}
// END FLOCK
///////////









// BOID
////////
class Boid {
  //fields
  PVector pos = new PVector() ;
  PVector acc = new PVector() ;
  PVector velNorm = new PVector() ;
  PVector ali = new PVector() ;
  PVector coh = new PVector() ;
  PVector sep = new PVector() ; 
  
  float neighborhoodRadius = 100 ; //radius in which it looks for fellow boids, we give 100 for default value
  float maxSpeed = 4; //maximum magnitude for the velocity vector
  float maxSteerForce = .1f; //maximum magnitude of the steering vector
  int fillBoid = color(255) ;
  int strokeBoid = color(255) ;
  float thickness = 1 ;
  int size = 1 ;
  
  
  
  // Canvas where the boids can move
  float left, right, top, bottom, front, back ;
  
  //constructors
    Boid(PVector pos) {
    this.pos = pos.copy() ;
    velNorm = new PVector(random(-1,1),random(-1,1),random(1,-1));
  }
  
  Boid(PVector pos, int fillBoid, int strokeBoid) {
    this.fillBoid = fillBoid ;
    this.strokeBoid = strokeBoid ;
    this.pos = pos.copy() ;
    velNorm = new PVector(random(-1,1),random(-1,1),random(1,-1));
  }
  
  Boid(PVector pos,PVector velNorm, float neighborhoodRadius) {
    this.pos = pos.copy() ;
    this.velNorm = velNorm.copy() ;
    this.neighborhoodRadius =neighborhoodRadius;
  }
  
  
  // DRAW
  public void run(ArrayList boidList, float ratioAlignment, PVector unity) {

    
    //acc.add(new PVector(0,.05,0));

    flock(boidList, ratioAlignment, unity);
    move();
    checkBounds();
    
    //display
    display();
  }
  
  
  // ANNEXE EXTERNAL METHOD
  public void goal(float x, float y, float z) {
    acc.add(steer(new PVector(x,y,z),true));
  }
  
  
  public void influence(float neighborhoodRadius) {
    this.neighborhoodRadius = neighborhoodRadius;
  }
  
  public void speed(float maxSpeed) {
    this.maxSpeed = maxSpeed ;
  }
  
  
  
  
  
  
  
  
  // ANNEXE INTERNAL METHOD
  // BEHAVIOR
  public void flock(ArrayList listBoids, float ratioAlignment, PVector unity) {
    ali = alignment(listBoids);
    coh = cohesion(listBoids);
    sep = seperation(listBoids);
   //  float ratioAlignment = 1 ; // original 1
    float ratioCohesion = unity.x ; // original 3
    float ratioSeparation = unity.y ; // original 1
    acc.add(PVector.mult(ali,ratioAlignment));
    acc.add(PVector.mult(coh,ratioCohesion));
    acc.add(PVector.mult(sep,ratioSeparation));
  }
  
  public void move() {
    velNorm.add(acc); // add acceleration to velocity
    velNorm.limit(maxSpeed); // make sure the velocity vector magnitude does not exceed maxSpeed
    pos.add(velNorm); // add velocity to position
    acc.mult(0); // reset acceleration
  }
  
  
  
  // UNIVERS
  // seeting in the Flock Class
  public void settingBounds(float left, float right, float top, float bottom, float front, float back) {
    this.left = left ;
    this.right = right ;
    this.top = top ;
    this.bottom = bottom ;
    this.front = front ;
    this.back = back ;
  }

  // check bound
  public void checkBounds() {
    // width
    if(pos.x > right) pos.x = left ;
    if(pos.x < left) pos.x = right ;
    //height
    if(pos.y > bottom) pos.y = top ;
    if(pos.y < top) pos.y = bottom ;
    // depth
    if(pos.z > front) pos.z = back ;
    if(pos.z < back) pos.z = front ;
  }
  
  
  
  
  
  
  // ENGINE
  
  /* STEERING, If arrival==true, the boid slows to meet the target. Credit to Craig Reynolds */
  public PVector steer(PVector target,boolean arrival) {
    PVector steer = new PVector(); //creates vector for steering
    if(!arrival) {
      steer.set(PVector.sub(target,pos)); //steering vector points towards target (switch target and pos for avoiding)
      steer.limit(maxSteerForce); //limits the steering force to maxSteerForce
    } else {
      PVector targetOffset = PVector.sub(target, pos);
      float distance=targetOffset.mag();
      float rampedSpeed = maxSpeed *(distance *.01f);
      float clippedSpeed = min(rampedSpeed,maxSpeed);
      PVector desiredVelocity = PVector.mult(targetOffset, (clippedSpeed /distance));
      steer.set(PVector.sub(desiredVelocity, velNorm));
    }
    return steer;
  }
  
  // DODGE. If weight == true avoidance vector is larger the closer the boid is to the target
  public PVector dodge(PVector target,boolean weight) {
    PVector steer = new PVector(); //creates vector for steering
    steer.set(PVector.sub(pos, target)); //steering vector points away from target
    if(weight)
      steer.mult(1/sq(PVector.dist(pos, target)));
    //steer.limit(maxSteerForce); //limits the steering force to maxSteerForce
    return steer;
  }
  
  
  // SEPARATION
  public PVector seperation(ArrayList <Boid> list) {
    PVector posSum = new PVector();
    PVector repulse;
    for(Boid b : list) {
      float d = PVector.dist(pos,b.pos);
      if(d > 0 && d <= neighborhoodRadius) {
        repulse = PVector.sub(pos,b.pos);
        repulse.normalize();
        repulse.div(d);
        posSum.add(repulse);
      }
    }
    return posSum;
  }
  
  
  // ALIGNMENT
  public PVector alignment(ArrayList <Boid> list) {
    PVector velSum = new PVector();
    int count = 0;
    for(Boid b : list) {
      float d = PVector.dist(pos,b.pos);
      if(d > 0 && d<= neighborhoodRadius) {
        velSum.add(b.velNorm);
        count++;
      }
    }
    if(count>0) {
      velSum.div((float)count);
      velSum.limit(maxSteerForce);
    }
    return velSum;
  }
  
  
  // COHESION
  public PVector cohesion(ArrayList <Boid> list) {
    PVector posSum = new PVector();
    PVector steer = new PVector();
    int count = 0;
    for(Boid b : list) {
      float d = dist(pos.x,pos.y,b.pos.x,b.pos.y);
      if(d > 0 && d <= neighborhoodRadius) {
        posSum.add(b.pos);
        count++;
      }
    }
    if(count>0) posSum.div((float)count);

    steer = PVector.sub(posSum,pos);
    steer.limit(maxSteerForce); 
    return steer;
  }
  // END ENGINE
  
  
  
  
  
  
  
  
  // DISPLAY
  public void display() {
    pushMatrix();
    translate(pos.x, pos.y, pos.z);
    rotateY(atan2(-velNorm.z, velNorm.x));
    rotateZ(asin(velNorm.y /velNorm.mag()));
    strokeWeight(thickness) ;
    if(thickness <= 0 || alpha(strokeBoid) == 0 ) noStroke() ; else stroke(strokeBoid);
    if(alpha(fillBoid) == 0 ) noFill() ; else  fill(fillBoid);
    // costume(vec3(),vec3(size),TRIANGLE_ROPE);
    // polyhedron(String type, String style, int size)
    // tetrahedron(size) ;
    polyhedron("TETRAHEDRON","VERTEX",(int)size);

    
    endShape();
    //box(10);
    popMatrix();
  }
}
/**
* Boum Boum / Transient detection
* 2018-2019
* v 0.0.8
*/
class BoumBoum extends Romanesco {
	public BoumBoum() {
		item_name = "BoumBoum";
		item_author  = "Stan le Punk";
		item_version = "Version 0.0.7";
		item_pack = "Base 2018-2019";
    item_costume = "ellipse/triangle/rect/cross/pentagon/flower 5/flower 7/flower 9/flower 12/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = true;
    speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }





  public void setup() {
    setting_start_position(ID_item,0,0,0);
  }


  vec3 [] size ;
  vec3 speed ;
	public void draw() {
    int shape_num = 4 ;
    // size shape
    if(size == null || size.length != shape_num) {
      size = new vec3 [shape_num];
      for(int i = 0 ; i < size.length ; i++) {
        size[i] = vec3(get_size_x(),get_size_y(),get_size_z());
        size[i].mult(.3f);
      }
    } else {
      for(int i = 0 ; i < size.length ; i++) {
        size[i].set(get_size_x(),get_size_y(),get_size_z());
      }
    }

    
    float dist_between_shape = get_canvas_x() /(shape_num+1);
    // give position for the shapes centered 
    float offset_x = (get_canvas_x() /2) -(width/2);
    vec3 pos = vec3(-offset_x,height/2,0);
    vec3 dir = vec3(get_dir());

    
    // speed
    if(motion_is()) {
      vec3 inc_speed = vec3(get_speed_x(),get_speed_y(),get_speed_z());
      inc_speed.mult(inc_speed);
      if(speed == null) {
        speed = vec3(inc_speed);
      } else {
        speed.add(inc_speed);
      }   
    }
    dir.add(speed);


    for(int i = 0 ; i < shape_num ;i++) {
      int step = (i+1);
      vec3 temp_pos = pos.copy();
      temp_pos.x += PApplet.parseInt(dist_between_shape *step);
      vec3 temp_size = size[i].copy();
      temp_size.mult(transient_value[i+1][ID_item]);
      fill(get_fill());
      stroke(get_stroke());
      strokeWeight(get_thickness());
      set_ratio_costume_size(map(get_area(),width*.1f, width*TAU,0,1));
      costume(temp_pos, temp_size, dir,get_costume());
    }
  }
}












/**
* BOXOLYZER
* 2012-2019
* v 2.0.4
*/

  
class Boxolyzer extends Romanesco {
  ArrayList<Equalyzer> box_list ;
  public Boxolyzer() {
    //from the index_objects.csv
    item_name = "Boxolyzer" ;
    item_author  = "Stan le Punk";
    item_version = "Version 2.0.4";
    item_pack = "Base 2012-2019";

    item_costume = "ellipse/triangle/rect/cross/pentagon/flower 5/flower 7/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "Line/Circle";

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is  = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    //diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;

    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;

  }
  boolean new_distribution;
  int num_box_ref;

  //SETUP
  public void setup() {
    setting_start_position(ID_item,width/2,height/2,0);
    boitesSetting();
  }
  
  //DRAW
  public void draw() {
    //CLASSIC DISPLAY
    int num_box = PApplet.parseInt(map(get_quantity(),0,1,1,NUM_BANDS));
    if (num_box != num_box_ref) {
      new_distribution = true;
    }
    num_box_ref = num_box;
    vec3 size = get_size().copy();

    // color and thickness
    
    aspect(get_fill(), get_stroke(), get_thickness());
    aspect_is(fill_is(),stroke_is()); 
    //
    distribution(num_box, new_distribution);
    
    // MODE DISPLAY with the dropdown menu of controler
    if (get_mode_id() == 0) {
      boxolyzer_line(horizon_is());
    } else if (get_mode_id() == 1) {
      boxolyzer_circle((int)get_canvas_x(),horizon_is());
    }



    // INFO
    info("There is ",num_box," bands analyzed");
    
  }
  
  //ANNEXE VOID
  public void distribution(int n, boolean newOne) {
     if (newOne) newDistributionBoite(n) ;
     new_distribution = false ;
   }
  
  boolean orientation ;
  // BOXLIZER CIRCLE
  public void boxolyzer_circle(int diam, boolean groundPosition) {
    if( action_is() && key_r ) orientation = !orientation ;
    int surface = diam*diam ; // surface is equale of square surface where is the cirlcke...make sens ?
    int radius = ceil(radius_from_circle_surface(surface)) ;
    
    int n = box_list.size() ;
    float factorSpectrum = 0 ;
    vec3 pos = vec3() ;
    for(int i=0; i < n; i++) {
      if(i < band_length()) {
        factorSpectrum = band [ID_item][i] ;
      }
      float stepAngle = map(i, 0, n, 0, 2*PI) ; 
      float angle =  2*PI - stepAngle;
      if(orientation) {
        pos.set(projection(angle,radius).x +pos.x, projection(angle, radius).y +pos.y, pos.z);
      } else {
        pos.set(projection(angle, radius).x +pos.x, 0, projection(angle, radius).y +pos.z);
      }

      Equalyzer boxolyzer = (Equalyzer) box_list.get(i);
      boxolyzer.set_pos(pos);
      boxolyzer.set_size(get_size());
      boxolyzer.set_dir(get_dir());
      boxolyzer.set_ratio_spectrum(factorSpectrum);
      boxolyzer.set_ratio_costume(get_area());
      boxolyzer.set_costume(get_costume().get_type());
      boxolyzer.show(groundPosition);
    }
  }



  // EQUALIZER CLASSIC
  public void boxolyzer_line(boolean groundPosition) {
    vec3 pos = vec3(0,height *.5f,0);
    float factorSpectrum = 0;
    int num = box_list.size();
    int canvasFinal = (int)map(get_canvas_x(), width/10, width, width/2,width*3)  ;
    int displacement_symetric = PApplet.parseInt(width *.5f -canvasFinal *.5f) ;
    vec3 displacement = vec3(width/2, height/2, 0) ;
    for(int i = 0 ; i < num ; i++) {
      pos.x = (i *canvasFinal /num) + (canvasFinal /(num *2)) +displacement_symetric ;
      if(i < band_length()) {
        factorSpectrum = get_band(i);
      }
      Equalyzer boxolyzer = (Equalyzer) box_list.get(i) ;
      if(!FULL_RENDERING) {
        factorSpectrum = .5f ;
      }
      boxolyzer.set_pos(sub(pos,displacement));
      boxolyzer.set_size(get_size());
      boxolyzer.set_dir(get_dir());
      boxolyzer.set_ratio_spectrum(factorSpectrum);
      boxolyzer.set_ratio_costume(get_area());
      boxolyzer.set_costume(get_costume().get_type());
      boxolyzer.show(groundPosition);
    }
  }
 
  
  
  // GLOBAL VOID
  public void boitesSetting() {
    box_list = new ArrayList<Equalyzer>();
  }
  //
  public void newDistributionBoite(int n) {
    box_list.clear() ;
    for (int i = 0 ; i < n ; i++ ) addBoite(i) ;
  }
  //
  public void addBoite(int ID) {
    vec3 size = vec3(1) ;
    Equalyzer boxolyzer = new Equalyzer(size, ID) ; 
    box_list.add(boxolyzer) ;
  }
  // END GLOBAL VOID
  private class Equalyzer {
    vec3 size;
    int ID;
    vec3 pos;
    vec3 dir;
    float ratio_spectrum;
    int costume;
    float ratio_costume;

    Equalyzer(vec3 size, int ID) {
      this.ID = ID ;
      this.size = size ;
    }

    public void set_size(vec3 size) {
      if(this.size == null) {
        this.size = size.copy();
      } else {
        this.size.set(size);
      }
    }

    public void set_pos(vec3 pos) {
      if(this.pos == null) {
        this.pos = pos.copy();
      } else {
        this.pos.set(pos);
      }
    }

    public void set_dir(vec3 dir) {
      if(this.dir == null) {
        this.dir = dir.copy();
      } else {
        this.dir.set(dir);
      }
    }

    public void set_ratio_spectrum(float ratio_spectrum) {
      this.ratio_spectrum = ratio_spectrum;
    }

    public void set_costume(int costume) {
      this.costume = costume;
    }

    public void set_ratio_costume(float ratio_costume) {
      this.ratio_costume = ratio_costume;
    }
    
    public void show(boolean ground_line) {
      size.mult(ratio_spectrum);

      if(ground_line) {
        float horizon = pos.y -(size.z *.5f);
        pos.set(pos.x,horizon,pos.z);
      }
      set_ratio_costume_size(map(ratio_costume,width*.1f, width*TAU,0,1));
      costume(pos,size,dir,costume);
    }
  }
}















/**
* Cellular Automata
* 2018-2019
* v 0.0.5
*/
class Cellular_automata extends Romanesco {
	public Cellular_automata() {
		item_name = "Automata";
		item_author  = "Stan le Punk";
    item_references = "Item based on Daniel Shiffman code\nand behavior from Stephen Wolfram\nhttps://natureofcode.com/";
		item_version = "Version 0.0.5";
		item_pack = "Nature of Code 2018-2019";
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "rules 30/rules 110/rules 190/rules 222";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;

    grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;
  }
  


  CA ca;
  int delay = 0;




  public void setup() {
    setting_start_position(ID_item,0,0,0);
    
  }
  
  int cell_size_ref = 5;
  ivec2 canvas_ref;
  int ref_mode;
  public void draw() {
    int cell_size = (int)map(get_grid(),get_grid_min(),get_grid_max(),height/10,1);
    ivec2 canvas = ivec2((int)get_canvas_x(),(int)get_canvas_y());

    if(ca == null || cell_size != cell_size_ref || !canvas_ref.equals(canvas) || ref_mode != get_mode_id()) {
      int[] ruleset = {0,1,1,1,1,0,0,0}; // rule 30
      int[] ruleset_30 = {0,1,1,1,1,0,0,0}; 
      int[] ruleset_110 = {0,1,1,1,0,1,1,0}; 
      int[] ruleset_190 = {0,1,1,1,1,1,0,1};   
      int[] ruleset_222 = {0,1,1,1,1,0,1,1}; 

      if(get_mode_id() == 0) {
        ruleset = ruleset_30;
      } else if(get_mode_id() == 1) {
         ruleset = ruleset_110;
      } else if(get_mode_id() == 2) {
         ruleset = ruleset_190;
      } else if(get_mode_id() == 3) {
         ruleset = ruleset_222;
      }
      // ref part
      ref_mode = get_mode_id();
      cell_size_ref = cell_size;
      if(canvas_ref == null) {
        canvas_ref = canvas.copy();
      } else {
        canvas_ref.set(canvas);
      }
      ca = new CA(ruleset,canvas,cell_size_ref);
    }

    aspect_is(fill_is(),stroke_is());
    aspect(get_fill(),get_stroke(),get_thickness());

    vec3 size = map(get_size(),get_size_x_min(),get_size_x_max(),0.01f,cell_size*4);
    float area = get_area();

    ca.show(get_costume(),size,area);
    int mod = (int)map(get_speed_x(),0,1,60,1);
    if(motion_is() && frameCount%mod == 0) {
      ca.generate();
    }
  }


  private class CA {
    int generation;  // How many generations?
    int[] ruleset;   // An array to store the ruleset, for example {0,1,1,0,1,1,0,1}
    int cell_size = 5;
    int[][] matrix;  // Store a history of generations in 2D array, not just one
    ivec2 canvas;

    int cols;
    int rows;


    CA(int[] r, ivec2 canvas,int cell_size) {
      this.canvas = canvas.copy();
      this.cell_size = cell_size;
      ruleset = r;
      cols = canvas.x/cell_size;
      rows = canvas.y/cell_size;
      matrix = new int[cols][rows];
      restart();
    }

    // Make a random ruleset
    public void randomize() {
      for (int i = 0; i < 8; i++) {
        ruleset[i] = PApplet.parseInt(random(2));
      }
    }

    // Reset to generation 0
    public void restart() {
      for (int i = 0; i < cols; i++) {
        for (int j = 0; j < rows; j++) {
          matrix[i][j] = 0;
        }
      }
      matrix[cols/2][0] = 1;    // We arbitrarily start with just the middle cell having a state of "1"
      generation = 0;
    }


    // The process of creating the new generation
    public void generate() {
      // For every spot, determine new state by examing current state, and neighbor states
      // Ignore edges that only have one neighor
      for (int i = 0; i < cols; i++) {
        int left  = matrix[(i+cols-1)%cols][generation%rows];   // Left neighbor state
        int me    = matrix[i][generation%rows];       // Current state
        int right = matrix[(i+1)%cols][generation%rows];  // Right neighbor state
        matrix[i][(generation+1)%rows] = rules(left,me,right); // Compute next generation state based on ruleset
      }
      generation++;
    }

    public void show(Costume costume, vec3 size, float area) {
      int offset = generation%rows;
      int displacement_x = (canvas.x-width)/2;
      int displacement_y = (canvas.y-height)/2;;
      for (int i = 0; i < cols; i++) {
        for (int j = 0; j < rows; j++) {
          int y = j - offset;
          if (y <= 0) y = rows + y;
          if (matrix[i][j] == 1) {
            vec3 temp_size = vec3(cell_size).mult(size);
            float temp_x = (i*cell_size) -displacement_x;
            float temp_y = ((y-1)*cell_size) -displacement_y;
            vec3 pos = vec3(temp_x,temp_y,0);
            set_ratio_costume_size(map(area,get_area_min(),get_area_max(),0,1));
            costume(pos,temp_size,costume);
          } 
        }
      }
    }

    // Implementing the Wolfram rules
    public int rules (int a, int b, int c) {
      if (a == 1 && b == 1 && c == 1) return ruleset[7];
      if (a == 1 && b == 1 && c == 0) return ruleset[6];
      if (a == 1 && b == 0 && c == 1) return ruleset[5];
      if (a == 1 && b == 0 && c == 0) return ruleset[4];
      if (a == 0 && b == 1 && c == 1) return ruleset[3];
      if (a == 0 && b == 1 && c == 0) return ruleset[2];
      if (a == 0 && b == 0 && c == 1) return ruleset[1];
      if (a == 0 && b == 0 && c == 0) return ruleset[0];
      return 0;
    }

    // The CA is done if it reaches the bottom of the screen
    public boolean finished() {
      if (generation > canvas.y/cell_size) {
        return true;
      } 
      else {
        return false;
      }
    }
  }
}



















/**
Ecosysteme 
2016-2019
v 0.1.11
*/
class Ecosystem_agent extends Romanesco {
	public Ecosystem_agent() {
		item_name = "Eco Agents";
		item_author  = "Stan le Punk";
		item_version = "Version 0.1.11";
		item_pack = "Ecosystem 2016-2019";
    item_costume = "";
		item_mode = "Virus/Human/Alien/Other"; // separate the differentes mode by "/"

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    diameter_is = false;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = true;
    variety_is = false;
    life_is = true;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = true;
  }

  int type_agents = 6 ;
  int colour_groups = type_agents ;
  float range_colour = 0 ;
  int mode_ref = 0 ;
  //boolean host_mode = false ;
  float [] hue_fill = new float[type_agents] ;
  float [] hue_stroke = new float[type_agents] ;
  float hue_fill_ref, hue_stroke_ref ;

  // boolean info_agent = false ;
  // boolean agent_display = true ;
  //boolean bg_refresh = true ;
  float speed_agent = .01f ;
  boolean host_mode_ref ;
  float ratio_canvas = 2 ;


  public void setup() {
    // here we cannot use the setting pos, because it's too much ling with the item 27 !!!
    setting_start_position(ID_item, 0, 0, 0) ;

    load_nucleotide_table(items_path+"ecosystem/code.csv");
    vec3 pos = vec3(width/2, height/2, 0) ;
    vec3 canvas = vec3(get_canvas_x(),get_canvas_y(),get_canvas_z());
    canvas.mult(ratio_canvas) ;


    host_mode_ref = follow_is() ;
    init_environment(pos, canvas) ;
    use_horizon(true) ;
    use_rebound(false) ;
    // init_ecosystem(get_size_x(), get_life()) ;
    init(true) ;
    if(init_ecosystem) {
      vec3 ratio_size = vec3(get_size_x(),get_size_y(),get_size_z()) ;
      ecosystem_setting(biomass,follower[ID_item],ratio_size,get_life(),get_speed_x(),this);
      init_ecosystem = false ;
      first_save = true ;
    }
  }



  
	public void draw() {
    // Master and Follower item 
    if(follow_is()) {
      follower[ID_item] = true ;
    } else {
      follower[ID_item] = false ;
    }
    



    if(host_mode_ref != follower[ID_item]) {
      init_ecosystem() ;
      host_mode_ref = follower[ID_item] ;
    }

    if(follower[ID_item]) {
      master_ID[ID_item] = 27 ;
      sync_symbiosis(master_ID[ID_item]) ;
      update_symbiosis() ;
    } else {
       master_ID[ID_item] = 0 ;
    }



    // SETTING
    speed_agent = get_speed_x() *get_speed_x();

    float thickness_common = get_thickness() ;
    
    if(action_is()) {
      if(key_1) {
        colour_groups = 1 ;
      }
      if(key_2) {
        colour_groups = 2 ;
      }
      if(key_3) {
        colour_groups = 3 ;
      }
      if(key_4) {
        colour_groups = 4 ;
      }
      if(key_5) {
        colour_groups = 5 ;
      }
      if(key_6) {
        colour_groups = 6 ;
      }
    } 

    float max = 360 / colour_groups ;
    range_colour = map(get_spectrum(),0,360,0,max) ;

    
    if(hue_fill_ref != hue(get_fill())) {
      vec4 [] pool_fill = color_pool_HSB(type_agents, colour_groups, hue(get_fill()), range_colour) ;
      for(int i = 0 ; i < hue_fill.length ; i++) {
        hue_fill[i] = pool_fill[i].x ;
      }
      hue_fill_ref = hue_fill[0] = hue(get_fill()) ;
    }
    if(hue_stroke_ref != hue(get_stroke())) {
      vec4 [] pool_stroke = color_pool_HSB(type_agents, colour_groups, hue(get_stroke()), range_colour) ;
      for(int i = 0 ; i < hue_stroke.length ; i++) {
        hue_stroke[i] = pool_stroke[i].x ;
      }
      hue_stroke_ref = hue_stroke[0] = hue(get_stroke()) ;
    }
    if(colour_is()) {
      vec4 [] pool_fill = color_pool_HSB(type_agents, colour_groups, random(g.colorModeX), range_colour) ;
      vec4 [] pool_stroke = color_pool_HSB(type_agents, colour_groups, random(g.colorModeX), range_colour) ;
      for(int i = 0 ; i < type_agents ; i++) {
        hue_fill[i] = pool_fill[i].x ;
        hue_stroke[i] = pool_stroke[i].x ;
      }
      colour_is(false);
    }

    if(horizon_is()) {
      use_horizon(true) ; 
    } else {
      use_horizon(false) ;
    }
    // 1 / FLORA VIRUS
    vec4 fill_flora = vec4(hue_fill[0], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_flora = vec4(hue_stroke[0], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
    // 2 / DEAD
    vec4 fill_dead = vec4(hue_fill[1], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_dead = vec4(hue_stroke[1], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
    // 3 / BACTERIUM
    vec4 fill_bacterium = vec4(hue_fill[2], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_bacterium = vec4(hue_stroke[2], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
    // 4 / HERBIVORE
    vec4 fill_herbivore = vec4(hue_fill[3], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_herbivore = vec4(hue_stroke[3], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
    // 5 / OMNIVORE
    vec4 fill_omnivore = vec4(hue_fill[4], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_omnivore = vec4(hue_stroke[4], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;
    // 6 / CARNIVORE
    vec4 fill_carnivore = vec4(hue_fill[5], saturation(get_fill()), brightness(get_fill()), alpha(get_fill())) ;
    vec4 stroke_carnivore = vec4(hue_stroke[5], saturation(get_stroke()), brightness(get_stroke()), alpha(get_stroke())) ;





    vec3 alpha_behavior_common = vec3(0, -1, 1) ;

    Costume costume_flora = new Costume(p5,VIRUS_ROPE);
    costume_flora.set_num(2);
    costume_flora.set_node(3);
    costume_flora.set_mutation(64);
    Costume costume_herbivore = new Costume(p5,TRIANGLE_ROPE);
    Costume costume_carnivore =new Costume(p5,STAR_ROPE);
    costume_carnivore.set_summit(9);
    Costume costume_omnivore =new Costume(p5,STAR_ROPE);
    costume_omnivore.set_summit(5);
    Costume costume_bacterium =new Costume(p5,SQUARE_ROPE);
    Costume costume_dead =new Costume(p5,CROSS_BOX_2_ROPE);
    if(dimension_is()) {
      costume_flora = new Costume(p5,VIRUS_ROPE);
      costume_flora.set_num(3);
      costume_flora.set_node(8);
      costume_flora.set_mutation(64);
      costume_herbivore =new Costume(p5,TETRAHEDRON_ROPE);
      costume_carnivore =new Costume(p5,STAR_3D_ROPE);
      costume_carnivore.set_summit(9);
      costume_omnivore =new Costume(p5,STAR_3D_ROPE);
      costume_omnivore.set_summit(5);
      costume_bacterium =new Costume(p5,RECT_ROPE);
      costume_dead =new Costume(p5,CROSS_BOX_3_ROPE);

    }

    style_flora = update_style(style_flora, "flora", costume_flora, fill_flora, stroke_flora, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;

    style_herbivore = update_style(style_herbivore, "herbivore", costume_herbivore, fill_herbivore, stroke_herbivore, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;

    style_carnivore = update_style(style_carnivore, "carnivore", costume_carnivore, fill_carnivore, stroke_carnivore, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;
    style_omnivore = update_style(style_omnivore, "omnivore", costume_omnivore, fill_omnivore, stroke_omnivore, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;

    style_dead = update_style(style_dead, "dead", costume_bacterium, fill_dead, stroke_dead, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;
    style_bacterium = update_style(style_bacterium, "bacterium", costume_dead, fill_bacterium, stroke_bacterium, thickness_common, alpha_behavior_common, fill_is(), stroke_is()) ;





    // INIT
    init(birth_is()) ;

		if(init_ecosystem) {
      vec3 ratio_size = vec3(get_size_x(),get_size_y(),get_size_z()) ;
			ecosystem_setting(biomass, follower[ID_item], ratio_size, get_life(), get_speed_x(),this);
			init_ecosystem = false ;
			first_save = true ;
		}
    

    // UPDATE
		update_list() ;
    if(FULL_RENDERING) {
      if(special_is()) {
        info_agent(true) ;
      } else {
        info_agent(false) ;
      } 
    }

    // CANVAS
    vec3 canvas = vec3(get_canvas_x(), get_canvas_y(), get_canvas_z()) ;
    canvas.mult(ratio_canvas) ;
    set_canvas_environment(canvas) ;

    // SHOW
		show_agent() ;

    // INFO
    if (item_info_display[ID_item]) {
      strokeWeight(1) ;
      stroke(blanc) ;
      noFill() ;
      costume(ECO_BOX_POS,ECO_BOX_SIZE,BOX_ROPE);
    }   	
	}
  /**
  METHOD
  */
  public void init(boolean new_birth) {
    if(get_mode_id() != mode_ref || new_birth) {
      mode_ref = get_mode_id();
      birth_is(false);
      if(get_mode_id() == 0) {
        set_pop(true, false, false, false, false) ;
      } else if(get_mode_id() == 1) {
        set_pop(true, true, false, false, true) ;
      } else if(get_mode_id() == 2) {
        set_pop(true, true, true, false, true) ;
      } else if(get_mode_id() == 3) {
        set_pop(true, true, true, true, true) ;
      } 
      init_ecosystem() ;
    }

  }

  public void set_pop(boolean use_flora, boolean use_herbivore, boolean use_carnivore, boolean use_omnivore, boolean use_bacterium) {
    int div_pop = 1 ;
    if(!FULL_RENDERING) div_pop= 20 ;
    if(use_flora) {
      set_pop_flora(10 +PApplet.parseInt(1500 *get_quantity())/div_pop) ;
    } else set_pop_flora(0) ;
    if(use_herbivore) {
      set_pop_herbivore(20 +PApplet.parseInt(300 *get_quantity())/div_pop) ;
    } else set_pop_herbivore(0) ;
    if(use_carnivore) {
      set_pop_carnivore(2 +PApplet.parseInt(20 *get_quantity())/div_pop) ;
    } else set_pop_carnivore(0) ;
    if(use_omnivore) {
      set_pop_omnivore(4 +PApplet.parseInt(40 *get_quantity())/div_pop) ;
    } else set_pop_omnivore(0) ;
    if(use_bacterium) {
      set_pop_bacterium(1 +PApplet.parseInt(10 *get_quantity())/div_pop) ;
    } else set_pop_bacterium(0) ;

    set_pop_dead(0/div_pop) ;
  }
}


































/**
MANAGE ECO-SYSTEM BUILT 0.2.1
*/

/**
ECOS_SYSTEM setting

*/

// LIST
ArrayList<Agent> FLORA_LIST = new ArrayList<Agent>() ;

ArrayList<Agent> BACTERIUM_LIST = new ArrayList<Agent>() ;

ArrayList<Agent> OMNIVORE_CHILD_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> OMNIVORE_FEMALE_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> OMNIVORE_MALE_LIST = new ArrayList<Agent>() ;

ArrayList<Agent> HERBIVORE_CHILD_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> HERBIVORE_FEMALE_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> HERBIVORE_MALE_LIST = new ArrayList<Agent>() ;

ArrayList<Agent> CARNIVORE_CHILD_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> CARNIVORE_FEMALE_LIST = new ArrayList<Agent>() ;
ArrayList<Agent> CARNIVORE_MALE_LIST = new ArrayList<Agent>() ;

ArrayList<Dead> DEAD_LIST = new ArrayList<Dead>() ;

// QUANTITY
int num_flora = 0 ;
int num_herbivore = 0 ; 
int num_omnivore = 0 ; 
int num_carnivore = 0 ; 
int num_bacterium = 0 ;
int num_dead = 0 ;

// Colour
Info_Object style_carnivore, style_herbivore, style_omnivore ;
Info_Object style_flora ;
Info_Object style_dead ;
Info_Object style_bacterium ;


Info_dict flora_carac = new Info_dict() ;
Info_dict herbivore_carac = new Info_dict() ;
Info_dict omnivore_carac = new Info_dict() ;
Info_dict carnivore_carac = new Info_dict() ;
Info_dict bacterium_carac = new Info_dict() ;
Info_dict dead_carac = new Info_dict() ;





// main method
public void ecosystem_setting(Biomass b, boolean host_mode, vec3 factor_size, float factor_life, float ratio_speed, Romanesco item) {
  factor_size.x = map(factor_size.x, item.get_size_x_min(), item.get_size_x_max(), width/2000, width/100) ;
  factor_size.y = map(factor_size.y, item.get_size_y_min(), item.get_size_y_max(), width/2000, width/100) ;
  factor_size.z = map(factor_size.z, item.get_size_z_min(), item.get_size_z_max(), width/2000, width/100) ;
  factor_life = map(factor_life, item.get_life_min(), item.get_life_max(), .5f, 3) ;
  ratio_speed = map(ratio_speed, 0,1, .5f, 8) ;
    // b.set_humus(ECO_BOX_SIZE.x *ECO_BOX_SIZE.y *.01) ;

  clear_agent() ;
  // order of quantity for set_num_agents(int... num)"  ;


  set_caracteristic_agent(factor_size, factor_life, ratio_speed) ;

  Costume costume = new Costume(this);
  float thickness = 1.f ;
  vec3 alpha_behavior_flora = vec3(0, -1, 1) ; // it's like 100% all the time
  boolean fill_is = true ;
  boolean stroke_is = true ;

  if(get_pos_host() != null) {

    alpha_behavior_flora = vec3(get_pos_host().z, -.4f, .8f) ;
  }
  
  if(style_flora == null ) {
    costume.set_type(VIRUS_ROPE);
    costume.set_node(3);
    costume.set_num(4);
    costume.set_mutation(64);
    thickness = 1.f ;
    vec4 fill_flora = vec4(color_flora) ;
    vec4 stroke_flora = vec4(color_flora) ;
    style_flora = new Info_Object("Flora Aspect", costume, fill_flora, stroke_flora, thickness, alpha_behavior_flora, fill_is, stroke_is) ;  
  }

  // HERBIVORE
  if(style_herbivore == null ) {
    costume.set_type(STAR_ROPE);
    costume.set_summit(4);
    vec4 fill_herbivore = vec4(color_herbivore) ;
    vec4 stroke_herbivore = vec4(color_herbivore) ;
    vec3 alpha_behavior_herbivore = vec3(0, -1, 1) ;
    style_herbivore = new Info_Object("Herbivore Aspect", costume, fill_herbivore, stroke_herbivore, thickness, alpha_behavior_herbivore, fill_is, stroke_is) ;
  }

  
  // OMNIVORE
  if(style_omnivore == null) {
    costume.set_type(STAR_ROPE);
    costume.set_summit(7);
    vec4 fill_omnivore = vec4(150, 100, 80, 100) ;
    vec4 stroke_omnivore = vec4(150, 100, 80, 100) ;
    vec3 alpha_behavior_omnivore = vec3(0, -1, 1) ;
    style_omnivore = new Info_Object("Omnivore Aspect", costume, fill_omnivore, stroke_omnivore, thickness, alpha_behavior_omnivore, fill_is, stroke_is) ;
  }


  // CARNIVORE
  if(style_carnivore == null) {
    costume.set_type(STAR_ROPE);
    costume.set_summit(12);
    vec4 fill_carnivore = vec4(0, 100, 100, 100) ;
    vec4 stroke_carnivore = vec4(0, 100, 100, 100) ;
    vec3 alpha_behavior_carnivore = vec3(0, -1, 1) ;
    style_carnivore = new Info_Object("Carnivore Aspect", costume, fill_carnivore, stroke_carnivore, thickness, alpha_behavior_carnivore, fill_is, stroke_is) ;
  }

  
  // BACTERIUM
  if(style_bacterium == null) {
    costume.set_type(TRIANGLE_ROPE);
    vec4 fill_bacterium = vec4(30, 0, 30, 100) ;
    vec4 stroke_bacterium = vec4(30, 0, 30, 100) ;
    vec3 alpha_behavior_bacterium = vec3(0, -1, 1) ;
    style_bacterium = new Info_Object("Bacterium Aspect", costume, fill_bacterium, stroke_bacterium, thickness, alpha_behavior_bacterium, fill_is, stroke_is) ;
  }  
  

  // DEAD
  if(style_dead == null) {
    costume.set_type(CROSS_BOX_2_ROPE);
    vec4 fill_dead = vec4(0, 0, 30, 100) ;
    vec4 stroke_dead = vec4(0, 0, 30, 100) ;
    vec3 alpha_behavior_dead = vec3(0, -1, 1) ;
    style_dead = new Info_Object("Dead Aspect", costume, fill_dead, stroke_dead, thickness, alpha_behavior_dead, fill_is, stroke_is) ;
  }



  if(!host_mode) {
    // classic radom drop zone
    build_flora(FLORA_LIST, flora_carac, style_flora, num_flora) ;
  } else {
    //drop zone from list of point
    build_flora(FLORA_LIST, flora_carac, style_flora, num_flora, get_symbiosis_area_pos()) ;
    symbiosis(FLORA_LIST, get_symbiosis_area_pos(), get_host_address()) ;
  }

  build_herbivore(HERBIVORE_CHILD_LIST, herbivore_carac, style_herbivore, num_herbivore) ;
  build_omnivore(OMNIVORE_CHILD_LIST, omnivore_carac, style_omnivore, num_omnivore) ;
  build_carnivore(CARNIVORE_CHILD_LIST, carnivore_carac, style_carnivore, num_carnivore) ;
  build_bacterium(BACTERIUM_LIST, bacterium_carac, style_bacterium, num_bacterium) ;
  build_dead(DEAD_LIST, dead_carac, style_dead, num_dead) ;
}


public Info_Object update_style(Info_Object style, String name, Costume costume, vec4 fill, vec4 stroke, float thickness, vec3 alpha_behavior, boolean fill_is, boolean stroke_is) {
  // style.clear() ;
 return new Info_Object(name, costume, fill, stroke, thickness, alpha_behavior, fill_is, stroke_is) ;
}


// set num
public void set_pop_flora(int num) {
  num_flora = num ;
}

public void set_pop_herbivore(int num) {
  num_herbivore = num ;
}

public void set_pop_carnivore(int num) {
  num_carnivore = num ;
}

public void set_pop_omnivore(int num) {
  num_omnivore = num ;
}

public void set_pop_bacterium(int num) {
  num_bacterium = num ;
}

public void set_pop_dead(int num) {
  num_dead= num ;
}










// control
public void control_population_via_frameRate(int level, int num) {
  if(frameRate < level) {
    spawn_carnivore(num) ;
    DEAD_LIST.clear() ;

  } else {
    if (HERBIVORE_CHILD_LIST.size() + HERBIVORE_FEMALE_LIST.size() +HERBIVORE_MALE_LIST.size() < num_herbivore ) {
      CARNIVORE_CHILD_LIST.clear() ;
      CARNIVORE_FEMALE_LIST.clear() ;
      CARNIVORE_MALE_LIST.clear() ;
    }
  }
}













// local
public void clear_agent() {
  flora_carac.clear() ;
  herbivore_carac.clear() ;
  carnivore_carac.clear() ;
  omnivore_carac.clear() ;
  bacterium_carac.clear() ;
  dead_carac.clear() ;

  FLORA_LIST.clear() ;

  BACTERIUM_LIST.clear() ;

  HERBIVORE_CHILD_LIST.clear() ;
  HERBIVORE_FEMALE_LIST.clear() ;
  HERBIVORE_MALE_LIST.clear() ;

  OMNIVORE_CHILD_LIST.clear() ;
  OMNIVORE_FEMALE_LIST.clear() ;
  OMNIVORE_MALE_LIST.clear() ;

  CARNIVORE_CHILD_LIST.clear() ;
  CARNIVORE_FEMALE_LIST.clear() ;
  CARNIVORE_MALE_LIST.clear() ;

  DEAD_LIST.clear() ;
}


public void set_caracteristic_agent(vec3 ratio_size, float ratio_life, float ratio_speed) {
  flora_carac.add("name", "Virus") ;
  flora_carac.add("size", vec3(30).mult(ratio_size)) ;
  flora_carac.add("life_expectancy", PApplet.parseInt(100000 *60 *ratio_life)) ;
  flora_carac.add("nutrient_quality", 15) ;
  flora_carac.add("speed_growth", 2) ; // size point per cycle
  flora_carac.add("need", .3f) ;
  flora_carac.add("first_colour", vec4(1)) ;

  herbivore_carac.add("name", "Hippie") ;
  herbivore_carac.add("size", vec3(40).mult(ratio_size)) ;
  herbivore_carac.add("stamina", 100) ;
  herbivore_carac.add("life_expectancy", PApplet.parseInt(1000 *60 *ratio_life)) ;
  herbivore_carac.add("velocity", PApplet.parseInt(6 *ratio_speed)) ;
  herbivore_carac.add("nutrient_quality", 40) ;
  herbivore_carac.add("sense_range", 4000) ;
  herbivore_carac.add("gourmet", 3.5f) ;
  herbivore_carac.add("starving", 4) ;
  herbivore_carac.add("digestion", 2.5f) ;
  herbivore_carac.add("sex_appeal", vec2(40, 5)) ;
  herbivore_carac.add("multiple_pregnancy", 50.f) ;
  herbivore_carac.add("first_colour", vec4(1)) ;

  omnivore_carac.add("name", "Punk") ;
  omnivore_carac.add("size", vec3(40).mult(ratio_size)) ; // in pixel
  omnivore_carac.add("stamina", 200) ; // point of life
  omnivore_carac.add("life_expectancy", PApplet.parseInt(800 *60 *ratio_life)) ; // frame of live before die
  omnivore_carac.add("velocity", PApplet.parseInt(8 *ratio_speed)) ; // in pixel
  omnivore_carac.add("nutrient_quality", 20) ; // multi the stamina point to give the calories
  omnivore_carac.add("sense_range", 1000) ; // range in pixel
  omnivore_carac.add("gourmet", 2.5f) ; 
  omnivore_carac.add("attack", 5) ; // attack point
  omnivore_carac.add("starving", 3) ; 
  omnivore_carac.add("digestion", 6.5f) ; // calorie multiplicator, hight is good.
  omnivore_carac.add("sex_appeal", vec2(45, 4)) ; // multe the size to give the range in pixel
  omnivore_carac.add("multiple_pregnancy", 10.5f) ; // chance to have twin or better in pourcent
  omnivore_carac.add("colour", 1) ;
  omnivore_carac.add("first_colour", vec4(1)) ;

  carnivore_carac.add("name", "Alien") ;
  carnivore_carac.add("size", vec3(50).mult(ratio_size)) ;
  carnivore_carac.add("stamina", 400) ;
  carnivore_carac.add("life_expectancy", PApplet.parseInt(1200 *60 *ratio_life)) ;
  carnivore_carac.add("velocity", PApplet.parseInt(10 *ratio_speed)) ;
  carnivore_carac.add("nutrient_quality", 20) ;
  carnivore_carac.add("sense_range", 1200) ;
  carnivore_carac.add("gourmet", 2.5f) ;
  carnivore_carac.add("attack", 10) ;
  carnivore_carac.add("starving", 4) ;
  carnivore_carac.add("digestion", 4.5f) ;
  carnivore_carac.add("sex_appeal", vec2(30, 10)) ;
  carnivore_carac.add("multiple_pregnancy", 5.5f) ;
  carnivore_carac.add("colour", 1) ;
  carnivore_carac.add("first_colour", vec4(1)) ;

  bacterium_carac.add("name", "Gnak Gnak") ;
  bacterium_carac.add("size", vec3(10).mult(ratio_size)) ;
  bacterium_carac.add("stamina", 200) ;
  bacterium_carac.add("life_expectancy", PApplet.parseInt(800 *60 *ratio_life)) ;
  bacterium_carac.add("velocity", PApplet.parseInt(5 *ratio_speed)) ;
  bacterium_carac.add("nutrient_quality", 1) ;
  bacterium_carac.add("sense_range", 500) ;
  bacterium_carac.add("starving", 2) ;
  bacterium_carac.add("digestion", 12.5f) ;
  bacterium_carac.add("colour", 1) ;
  bacterium_carac.add("first_colour", vec4(1)) ;

  dead_carac.add("name", "UNDEAD") ;
  dead_carac.add("size", vec3(25).mult(ratio_size)) ;
  dead_carac.add("nutrient_quality", 40) ;
  dead_carac.add("colour", 1) ;
  dead_carac.add("first_colour", vec4(1)) ;
}



/**
SPAWN carnivore
*/
// annecdotic method
public void spawn_carnivore(int num_carnivore) {
    if(CARNIVORE_CHILD_LIST.size() < num_carnivore) {
    int population_target = HERBIVORE_CHILD_LIST.size() + HERBIVORE_FEMALE_LIST.size() +  HERBIVORE_MALE_LIST.size() ;
    if(population_target > num_herbivore && frameCount%(5 *(int)frameRate) == 0 ) {
      int num = ceil(random(num_carnivore)) ;
      build_carnivore(CARNIVORE_CHILD_LIST, carnivore_carac, style_carnivore, num) ;
    }
  }
}










/**
ENVIRONMENT 0.0.4

*/

/**
* Create enviromnent where the ecosystem will be live
*/
public void build_environment(vec2 pos, vec2 size) {
  vec3 pos_3D = vec3(pos.x, pos.y,0) ;
  vec3 size_3D = vec3(size.x, size.y,0) ;
  build_environment(pos_3D, size_3D) ;
  // write here to be sure the Environment have a good info
}

public void build_environment(vec3 pos, vec3 size) {
  build_box(pos, size) ;

  float front = box_front() ;
  float back = box_back() ;

  set_limit_box(box_left() , box_right(), box_top(),  box_bottom(), front, back) ;
  int dist_to_horizon = PApplet.parseInt(abs(back) +abs(front)) ;
  set_horizon(dist_to_horizon) ;
  // use_rebound(true) ;
  set_textSize_info(18) ; 
  // b.set_humus(BOX.x *BOX.y *.01) ;
  // b.humus_max = b.humus = BOX.x *BOX.y *.01 ;
}

public float box_left() {
  return get_box_pos().x - (get_box_size().x *.5f) ;
}

public float box_right() {
  return get_box_pos().x + (get_box_size().x *.5f) ;
}

public float box_top() {
  return get_box_pos().y - (get_box_size().y *.5f) ;
}

public float box_bottom() {
  return get_box_pos().y + (get_box_size().y *.5f) ;
}

public float box_front() {
  return get_box_pos().z - (get_box_size().z *.5f) ;
}

public float box_back() {
  return get_box_pos().z + (get_box_size().z *.5f) ;
}




/**
SET ENVIRONMENT
*/
Biomass biomass ;
boolean init_ecosystem = true ;

public void init_ecosystem() {
  init_ecosystem = true ;
}



// set
public void set_environment(vec pos, vec canvas) {
  if(pos instanceof vec3 && canvas instanceof vec3 && renderer_P3D()) {
    vec3 p = (vec3) pos ;
    vec3 c = (vec3) canvas ;
    build_environment(p, c) ;
    set_renderer(P3D) ;
  } else if(pos instanceof vec2 && canvas instanceof vec2 && renderer_P3D()) {
    vec2 p = (vec2) pos ;
    vec2 c = (vec2) canvas ;
    build_environment(p, c) ;
  } else if(pos instanceof vec2 && canvas instanceof vec2 && !renderer_P3D()) {
    vec2 p = (vec2) pos ;
    vec2 c = (vec2) canvas ;
    build_environment(p, c) ;
  } else {
    System.err.println("Something wrong in your universe, the both Vec must be vec2 or vec3, plus the vec3 pos and canvas work only in P3D renderer") ;
  }
}


public void set_canvas_environment(vec size) {
  if(size instanceof vec3) {
    vec3 s = (vec3) size ;
    set_size_box(s) ;
    set_limit_box(box_left() , box_right(), box_top(),  box_bottom(), box_front(), box_back()) ;
  } else if (size instanceof vec2) {
    vec2 s = (vec2) size ;
    vec3 def_size = vec3(s.x,s.y,0) ;
    set_size_box(def_size) ;
    set_limit_box(box_left() , box_right(), box_top(),  box_bottom(), box_front(), box_back()) ;
  }  
}





// build
public void init_environment(vec pos, vec canvas) {
  biomass = new Biomass() ;
  set_environment(pos, canvas) ;  
}


/**
BIOTOPE 
*/
/*
vec4 biotope_colour(Biomass b) {
  float normal_humus_level = 1 - b.humus / b.humus_max ;
  float var_colour_ground = 90 *normal_humus_level ;
  return vec4(40,90, 5 +var_colour_ground,100) ;
}
*/






/**
UPDATE LIST
*/
public void update_list() {

  // flora update
  flora_update(FLORA_LIST, biomass) ;
  // bacterium update
  bacterium_update(DEAD_LIST, BACTERIUM_LIST, biomass, INFO_DISPLAY_AGENT) ;
  // dead corpse update
  
  dead_update(DEAD_LIST) ;
 
  // dynamic agent update
  herbivore_update(DEAD_LIST, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  omnivore_update(DEAD_LIST, OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
  carnivore_update(DEAD_LIST, CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;






  // Eating
  // carnivore eating
  eating_update(CARNIVORE_CHILD_LIST, DEAD_LIST) ;
  eating_update(CARNIVORE_FEMALE_LIST, DEAD_LIST) ;
  eating_update(CARNIVORE_MALE_LIST, DEAD_LIST) ;
  // omnivore eating
  eating_update(OMNIVORE_CHILD_LIST, DEAD_LIST) ;
  eating_update(OMNIVORE_FEMALE_LIST, DEAD_LIST) ;
  eating_update(OMNIVORE_MALE_LIST, DEAD_LIST) ;





  // hunting
  // carnivore hunt herbivorr and omnivore
  hunting_update(CARNIVORE_CHILD_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  hunting_update(CARNIVORE_FEMALE_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  hunting_update(CARNIVORE_MALE_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;

  hunting_update(CARNIVORE_CHILD_LIST, INFO_DISPLAY_AGENT, OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
  hunting_update(CARNIVORE_FEMALE_LIST, INFO_DISPLAY_AGENT, OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
  hunting_update(CARNIVORE_MALE_LIST, INFO_DISPLAY_AGENT, OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;

  // Omnivore hunt carnivore and herbivore
  hunting_update(OMNIVORE_CHILD_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  hunting_update(OMNIVORE_FEMALE_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  hunting_update(OMNIVORE_MALE_LIST, INFO_DISPLAY_AGENT, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;

  hunting_update(OMNIVORE_CHILD_LIST, INFO_DISPLAY_AGENT, CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
  hunting_update(OMNIVORE_FEMALE_LIST, INFO_DISPLAY_AGENT, CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
  hunting_update(OMNIVORE_MALE_LIST, INFO_DISPLAY_AGENT, CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;


  // picking
  picking_update(HERBIVORE_CHILD_LIST, FLORA_LIST) ;
  picking_update(HERBIVORE_FEMALE_LIST, FLORA_LIST) ;
  picking_update(HERBIVORE_MALE_LIST, FLORA_LIST) ;

  picking_update(OMNIVORE_CHILD_LIST, FLORA_LIST) ;
  picking_update(OMNIVORE_FEMALE_LIST, FLORA_LIST) ;
  picking_update(OMNIVORE_MALE_LIST, FLORA_LIST) ;


  // manage Child
  manage_child(HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST, HERBIVORE_CHILD_LIST) ;
  manage_child(OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST, OMNIVORE_CHILD_LIST) ;
  manage_child(CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST, CARNIVORE_CHILD_LIST) ;
  

  // reproduction
  reproduction_female_herbivore(HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST, HERBIVORE_CHILD_LIST, herbivore_carac, style_herbivore) ;
  reproduction_male(HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;

  reproduction_female_omnivore(OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST, OMNIVORE_CHILD_LIST, omnivore_carac, style_omnivore) ;
  reproduction_male(OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;

  reproduction_female_carnivore(CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST, CARNIVORE_CHILD_LIST, carnivore_carac, style_carnivore) ;
  reproduction_male(CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
}





/**
  SHOW
*/
public void show_agent() {
    // flora show
  flora_show(style_flora, FLORA_LIST) ;
  
  // dead / corpse show 
  show_dead(style_dead, DEAD_LIST) ;
  
  // dynamic agent show
  show_agent_dynamic(style_herbivore, HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  show_agent_dynamic(style_carnivore, CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
  show_agent_dynamic(style_omnivore, OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;

  show_bacterium(biomass, style_bacterium, BACTERIUM_LIST) ;

}















/**
VIRUS

*/
vec4 color_flora = vec4(0, 100, 80, 100) ;
vec4 color_herbivore = vec4(110, 100, 70, 100) ;


boolean new_costume_virus = false ;
public void set_virus_costume() {
  vec4 fill_flora = vec4(color_flora) ;
  vec4 stroke_flora = vec4(color_flora) ;
  float change_hue = random(50) ;
  float change_alpha = random(100) ;
  fill_flora.x += change_hue ;
  stroke_flora.x += change_hue ;
  fill_flora.w -= change_alpha ;
  stroke_flora.w -= change_alpha ;

  Costume costume = new Costume(this);
  costume.set_type(VIRUS_ROPE);
  costume.set_node(3);
  costume.set_num(4);
  costume.set_mutation(64);
  int new_costume = floor(random(8)) ;
  if(new_costume == 0 ) {
    costume.set_node(3);
    costume.set_num(4);
    costume.set_mutation(32);
  } else if(new_costume == 1 ) {
    costume.set_node(3);
    costume.set_num(4);
    costume.set_mutation(64);
  } else if(new_costume == 2 ) {
    costume.set_node(3);
    costume.set_num(4);
    costume.set_mutation(128);
  } else if(new_costume == 3 ) {
    costume.set_node(2);
    costume.set_num(2);
    costume.set_mutation(16);
  } else if(new_costume == 4 ) {
    costume.set_node(3);
    costume.set_num(8);
    costume.set_mutation(16);
  } else if(new_costume == 5 ) {
    costume.set_node(2);
    costume.set_num(2);
    costume.set_mutation(32);
  } else if(new_costume == 6 ) {
    costume.set_node(3);
    costume.set_num(8);
    costume.set_mutation(64);
  } else if(new_costume == 7 ) {
    costume.set_node(3);
    costume.set_num(8);
    costume.set_mutation(16);
  }




  float thickness = 1.f ;


  vec3 alpha_behavior_flora = vec3(get_pos_host().z, -.4f, .8f) ;
  style_flora = new Info_Object("Flora Aspect", costume, fill_flora, stroke_flora, thickness, alpha_behavior_flora) ;  
}














/**

INFO & LOG 0.1.0

*/

public void info_agent(boolean info) {
  INFO_DISPLAY_AGENT = info ;
}
/**
INFO
*/
public void info_ecosystem(int tempo) {
    if(frameCount%tempo == 0) {
    if (PRINT_POPULATION) {
      print_population() ;
    }
    // print_info_environment(biomass) ;
    //print_list() ;
    // print_info_carnivore(CARNIVORE_CHILD_LIST) ;
    print_info_herbivore("Child", HERBIVORE_CHILD_LIST) ;
    print_info_herbivore("Female", HERBIVORE_FEMALE_LIST) ;
    print_info_herbivore("Male", HERBIVORE_MALE_LIST) ;
    // print_info_bacterium(BACTERIUM_LIST) ;
  }
}

public void print_population() {
  println(frameCount) ;
  print_pop_agent_dynamic("Population Herbivore", HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
  print_pop_agent_dynamic("Population Carnivore", CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
  print_pop_agent_dynamic("Population Omnivore", OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
  print_pop_agent_dynamic("Population Bacterium", BACTERIUM_LIST) ;
  print_pop_agent_dynamic("Population Dead Bodies", DEAD_LIST) ;
}


public void print_list() {
  println("Flora", FLORA_LIST.size()) ;

  println("Bacterium",BACTERIUM_LIST.size()) ;

  println("Herbivore child",HERBIVORE_CHILD_LIST.size()) ;
  println("Herbivore female",HERBIVORE_FEMALE_LIST.size()) ;
  println("Herbivore male",HERBIVORE_MALE_LIST.size()) ;

  println("Carnivore",CARNIVORE_CHILD_LIST.size()) ;
  
  println("Corpse",DEAD_LIST.size()) ;
}
/**
LOG
*/




public void log_ecosystem(int tempo) {

  /**
  log population
  */
  if(frameCount%tempo == 0 && LOG_ECOSYSTEM) {
    // log eco agent
    int num_log_eco_agent = 6 ;
    if(!log_is()) {
      build_log(num_log_eco_agent) ;
    }

    log_eco_agent() ;
    log_eocsystem_resume() ;
    log_agent_global() ;

    log_save() ;
  }
}


// local log method
public void log_eocsystem_resume() {
      log_eco_resume(   biomass.humus, biomass.humus_max, 
                      HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST,
                      OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST,
                      CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST,
                      BACTERIUM_LIST,
                      FLORA_LIST,
                      DEAD_LIST) ;

}

public void log_eco_agent() {
  if(LOG_ALL_AGENTS) {
      log_eco_agent(0, "Herbivore", HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
      log_eco_agent(1, "Omnivore", OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
      log_eco_agent(2, "Carnivore", CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
      log_eco_agent(3, "Bacterium", BACTERIUM_LIST) ;
      log_eco_agent(4,  "Flora", FLORA_LIST) ;
      log_eco_agent(5,  "Dead", DEAD_LIST) ;
    } else {
      if(LOG_HERBIVORE) log_eco_agent(0, "Herbivore", HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
      if(LOG_OMNIVORE)  log_eco_agent(1, "Omnivore", OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
      if(LOG_CARNIVORE)  log_eco_agent(2, "Carnivore", CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
      if(LOG_BACTERIUM) log_eco_agent(3, "Bacterium", BACTERIUM_LIST) ;
      if(LOG_FLORA) log_eco_agent(4,  "Flora", FLORA_LIST) ;
      if(LOG_DEAD) log_eco_agent(5,  "Dead", DEAD_LIST) ;
    }

}

public void log_agent_global() {
  if(LOG_ALL_AGENTS) {
    log_agent_global("Herbivore", HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
    log_agent_global("Omnivore", OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
    log_agent_global("Carnivore", CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
    log_agent_global("Bacterium", BACTERIUM_LIST) ;
    log_agent_global("Flora", FLORA_LIST) ;
    log_agent_global("Dead", DEAD_LIST) ;
  } else {
    if(LOG_HERBIVORE) log_agent_global("Herbivore", HERBIVORE_CHILD_LIST, HERBIVORE_FEMALE_LIST, HERBIVORE_MALE_LIST) ;
    if(LOG_OMNIVORE) log_agent_global("Omnivore", OMNIVORE_CHILD_LIST, OMNIVORE_FEMALE_LIST, OMNIVORE_MALE_LIST) ;
    if(LOG_CARNIVORE) log_agent_global("Carnivore", CARNIVORE_CHILD_LIST, CARNIVORE_FEMALE_LIST, CARNIVORE_MALE_LIST) ;
    if(LOG_BACTERIUM) log_agent_global("Bacterium", BACTERIUM_LIST) ;
    if(LOG_BACTERIUM) log_agent_global("Flora", FLORA_LIST) ;
    if(LOG_DEAD) log_agent_global("Dead", DEAD_LIST) ;
  }
}
/**
END LOG & PRINT
*/
/**
Ecosysteme Host 
2016-2018
V 0.1.10
*/
class Ecosystem_DNA extends Romanesco {
	public Ecosystem_DNA() {
		item_name = "Eco DNA" ;
		item_author  = "Stan le Punk";
		item_version = "Version 0.1.9";
		item_pack = "Ecosystem 2016-2018";
    item_costume = "Point/Ellipse/Triangle/Rect/flower/Cross/ABC" ;
		item_mode = "" ; // separate the differentes mode by "/"

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    density_is = true;
    // influence_is = true;
    // calm_is = true;
    spectrum_is = true;
  }

  vec3 pos, canvas, radius, size ;
  int min_host = 5 ;
  int max_host = 1000 ;
  vec3 ratio_canvas = vec3(.5f, 1.5f, .5f) ;
  float ratio_size = .5f ;

  public void setup() {
    // here we cannot use the setting pos, because it's too much ling with the item 26 !!!
    setting_start_position(ID_item, 0,0,0) ;
    load_nucleotide_table(items_path+"ecosystem/code.csv");

    canvas = vec3(get_canvas_x(), get_canvas_y(), get_canvas_z()) ;
    canvas.mult(ratio_canvas) ;
    size = vec3(get_size_x(), get_size_y(), get_size_z()) ;
    size.mult(ratio_size) ;
    pos = vec3(width/2, height/2, 0) ;
    
    set_host(pos, size, canvas, get_quantity()) ;
    init_symbiosis() ;

  }


  boolean rebuilt_host = false ;
	public void draw() {
    float speed_rotation_host = get_speed_x() *get_speed_x();
    int direction_host = 1 ;
    boolean motion_bool_host = true ;
    
    /**
    change beat system for better reactivity
    
    */
    float radius_x = get_canvas_x() *all_transient(ID_item) ;
    canvas.set(radius_x, get_canvas_y(), get_canvas_z()) ;
    canvas.mult(ratio_canvas) ;
    radius.set(canvas) ;
    

    size.set(get_size_x(), get_size_y(), get_size_z()) ;
    size.mult(ratio_size) ;

    if(reverse_is()) {
      direction_host = 1; 
    } else { 
      direction_host = -1;
    }

    if(motion_is()) {
      motion_bool_host = true; 
    } else {
      motion_bool_host = false;
    }

    if(birth_is()) {
      set_host(pos, size, canvas, get_quantity()) ;
      init_symbiosis() ;
    	birth_is(false);
    }
    
    boolean_host(fill_is(), stroke_is(), wire_is()) ;

    if(get_costume().get_type() == TEXT_ROPE) {
      textFont(get_font());
    }

    float direction = get_dir_x();

    show_host(size, canvas, radius, direction, speed_rotation_host, direction_host, get_costume(), get_fill(), get_stroke(), get_thickness(), get_spectrum(), motion_bool_host, info_agent) ;
		
	}

	boolean info_agent = false ;
	boolean decorum_display = true ;
	boolean agent_display = true ;
	boolean bg_refresh = true ;
	int direction_dna = 1 ;
	float speed_rotation_dna = .01f ;




  public void set_host(vec3 pos, vec3 size, vec3 canvas, float ratio_quantity) {
    radius = vec3(canvas) ;
    int num = num_host(min_host, max_host, ratio_quantity) ;
    create_host(num, get_density(), pos, size, canvas, radius) ; 
  }

  public int num_host(int min, int max, float ratio) {
    int num = min ;
    num = PApplet.parseInt(max *ratio +min) ;
    if(!FULL_RENDERING) num = min ;
    return num ;
  }
}





/**
CREATE
*/
public void create_host(int num, float density, vec3 pos, vec3 size, vec3 canvas, vec3 radius) {
  // host
  pos_host(pos) ;
  size_host(size) ;
  canvas_host(canvas) ;
  radius_host(radius) ;

  int height_dna = (int)canvas.y ;
  int radius_dna = (int)radius.x ;
  int num_nucleotide = num ;
  int num_helix = 2 ; 

  init_host_target(num *num_helix) ;
  int by_revolution = 11 + PApplet.parseInt(density *74) ;

  create_dna(num_helix, num_nucleotide, by_revolution, pos, size, height_dna, radius_dna) ;
}


public void init_symbiosis() {
  init_symbiosis_area(strand_DNA.num()) ;
  set_symbiosis_area(strand_DNA.get_nuc_pos()) ;
}


/**
UPDATE SYMBIOSIS
*/
public void update_symbiosis() {
  update_symbiosis_area(strand_DNA.get_nuc_pos()) ;
}


public void sync_symbiosis(int id_item) {
  sync_symbiosis(FLORA_LIST) ;
}









/**
DNA
*/
Helix strand_DNA ;


public void create_dna(int num_helix, int num, int by_revolution, vec3 pos, vec3 size, int height_dna, int radius_dna) {
  int nucleotide = num ;

  int num_strand = num_helix ;

  strand_DNA = new Helix(num_strand, nucleotide, by_revolution) ;
  strand_DNA.set_radius(radius_dna) ;
  strand_DNA.set_height(height_dna) ;
  strand_DNA.set_final_pos(pos) ;
}




/**
SHOW
*/
public void show_host(vec3 size, vec3 canvas, vec3 radius, float direction, float speed_rotation_host, int direction_host, Costume costume, int fill, int stroke, float thickness, float spectrum, boolean rotation_bool_host, boolean info) {
	int height_dna = (int)canvas.y ;
	int radius_dna = (int)radius.x ;
  show_dna(size, height_dna, radius_dna, direction, speed_rotation_host, direction_host, costume, fill, stroke, thickness, spectrum, rotation_bool_host, info) ;
}



float rotation_dna = 0 ;
public void show_dna(vec3 size, int height_dna, int radius_dna, float direction, float speed_rotation_dna, int direction_dna, Costume costume, int fill, int stroke, float thickness, float spectrum, boolean rotation_bool_dna, boolean info) {
	// show DNA
  if(height_dna > 0 ) {
    if(rotation_bool_dna) {
      rotation_dna += abs(speed_rotation_dna) *direction_dna ;
      // rotation_dna = abs(rotation_dna) *direction_dna ;
      strand_DNA.rotation(rotation_dna) ;
      strand_DNA.set_radius(radius_dna) ;
      strand_DNA.set_height(height_dna) ;
    }  
    for(int i = 0 ; i < strand_DNA.length() ; i++) {
      costume_DNA(strand_DNA, i, size, direction, costume, fill, stroke, thickness, spectrum, info) ;
    }
  }
}


boolean display_fill_is, display_stroke_is ;
boolean link_is ;
public void boolean_host(boolean fill_is, boolean stroke_is, boolean link_is) {
  display_fill_is = fill_is ;
  display_stroke_is = stroke_is ;
  this.link_is = link_is ;
}

public void costume_DNA(Helix helix, int target, vec3 size, float direction, Costume costume, int fill_int, int stroke_int, float thickness, float spectrum, boolean info) {
  vec3 pos_a = helix.get_nuc_pos(0)[target] ;
  vec3 pos_b = helix.get_nuc_pos(1)[target] ;

  float angle_a = helix.get_nuc_angle(0)[target]  +direction ;
  float angle_b = helix.get_nuc_angle(1)[target]  +direction ;

  int size_link = 1 ;

  float radius = helix.get_radius().x ;
  float alpha_min = .01f ;
  float alpha_max = .8f ;
  
  aspect_is(display_fill_is, display_stroke_is) ;
  aspect(fill_int, stroke_int, thickness) ;
  if(link_is) line(pos_a, pos_b) ;
  

  vec4 fill = to_hsba(fill_int) ;
  vec4 stroke = to_hsba(stroke_int) ;

  // alpha
  float ratio_a = map(pos_a.z , -radius, radius, 0 +alpha_min, alpha_max) ;
  float alpha_a = g.colorModeA * ratio_a  ;
  float fill_alpha_a = alpha_a * map(fill.w, 0,100,0,1) ;
  float stroke_alpha_a = alpha_a * map(stroke.w, 0,100,0,1) ;


  vec4 fill_strand_a = vec4(fill.x, fill.y, fill.z, fill_alpha_a) ;
  vec4 stroke_strand_a = vec4(stroke.x, stroke.y, stroke.z, stroke_alpha_a) ;

  // change for the opposite color
  float hue_fill = fill.x +(spectrum *.5f)  ;
  float hue_stroke = stroke.x +(spectrum *.5f) ;
  if(hue_fill > g.colorModeX) hue_fill = hue_fill - g.colorModeX ;
  if(hue_stroke > g.colorModeX) hue_stroke = hue_stroke - g.colorModeX ;

  // alpha
  float ratio_b = map(pos_b.z, -radius, radius, 0 +alpha_min, alpha_max) ;
  float alpha_b = g.colorModeA *ratio_b ;
  float fill_alpha_b = alpha_b * map(fill.w, 0,100,0,1) ;
  float stroke_alpha_b = alpha_b * map(stroke.w, 0,100,0,1) ;
  


  vec4 fill_strand_b = vec4(hue_fill, fill.y, fill.z, fill_alpha_b) ;
  vec4 stroke_strand_b = vec4(hue_stroke, stroke.y, stroke.z, stroke_alpha_b) ;
  
  


  aspect_is(display_fill_is, display_stroke_is) ;
  aspect(fill_strand_a, stroke_strand_a, thickness,costume);

  if(costume.get_type() == TEXT_ROPE) {
    String nuc_a = "" +helix.get_DNA(0).sequence_a.get(target).nac ;
    costume_rotate_y() ;
    costume_text(nuc_a) ;
  }

  costume_rotate_y() ;
  costume(pos_a,size,angle_a,costume);

  

  aspect_is(display_fill_is, display_stroke_is) ;
  aspect(fill_strand_b, stroke_strand_b, thickness,costume) ;
  
  if(costume.get_type() == TEXT_ROPE) {
    String nuc_b = "" +helix.get_DNA(0).sequence_b.get(target).nac ;
    costume_rotate_y() ;
    costume_text(nuc_b) ;
  }

  costume_rotate_y() ;
  costume(pos_b, size, angle_b,costume) ;

}





























/**
ESCARGOT 
2011-2019
V 1.4.12
*/
//TOXIC








class Escargot extends Romanesco {
  public Escargot() {
    //from the index_objects.csv
    item_name = "Image" ;
    item_author  = "Stan le Punk";
    item_version = "version 1.4.12";
    item_pack = "Base 2012-2019" ;
    item_costume = "";
    item_mode = "Original/Raw/Point/Ellipse/Rectangle/Box/Cross/SVG/Vitraux" ;

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    spectrum_is = false;
  }
  //GLOBAL
  String pathSVG ;
    //VORONOI TOXIC
  // ranges for x/y positions of points
  FloatRange xpos, ypos;
  // helper class for rendering
  ToxiclibsSupport gfx;
  // empty voronoi mesh container
  Voronoi voronoi = new Voronoi();
  //VORONOI for void
  int thicknessVoronoi = 1 ;
  int colorStrokeVoronoi = color (0,0,0)  ;
  boolean whichColorVoronoi ;
  //ratio size image and window
  PVector ratioImgWindow = new PVector(1,1) ;
  //color strokeColor  ; // color for the stroke
  int thickness = 1 ; // if "zero" noStroke() is activate
  boolean useNewPalettePixColorToDisplay = true ; // if want use the original picture from the raw list to find color write "FALSE", but if you do that you can use the possibility to change the palette in Live, else use "TRUE"
  
  boolean colorPixDisplay = true ;
  boolean fillDisplay = true ;
  
  //ANALYZE PICTURE
  //size analyze pixel
  int pixelAnalyzeSize = 2; // pour la grille de mon cahier tester vec 40
  int pixelAnalyzeSizeRef = 2  ;
  //size display pixel
  int pixelDisplaySize = 1;
  int pixelStrokeWeight = 1;
  //escargot analyze
  int radiusAnalyze = 25 ; // radius analyze around the pixel
  int radiusAnalyzeRef = 25 ; // radius analyze around the pixel
  int speedAnalyze = 10 ; // quantity of point be analyzing in the image. It's random choice on the surface of the image.
  int maxEntryPoints = 500 ; // quantity of point be analyzing in the image. It's random choice on the surface of the image.
  int maxEntryPointsRef = 500 ; // quantity of point be analyzing in the image. It's random choice on the surface of the image.
  int maxVoronoiPoints = 125000 ; // max point for voronoi calcula bahond is very very slow
  
  String modeTri = ("b") ; // you can choice in few mode "hsb"(exact same hue, saturation and brithness the other mode is part of this three composantes, "b", "s", "hs", "hb", "sb"
  boolean useNewPalettePixColorToAnalyze = true ; // choice the color you analyze, the raw color you must write "FALSE" if you look in the "newColor" because you have change the color pixel for anything you must write "TRUE", best analyze with the new palette
  
  
  //PALETTE COLOR
  //random palette
  PVector HSBpalette = new PVector (6, 6, 12) ;  // quantity for each components of palette in HSB order // need "1" minimum in each componante
  //palette from you
  int hueColor[] =    new int [(int)HSBpalette.x] ;
  int satColor[] =    new int [(int)HSBpalette.y] ;
  int brightColor[] = new int [(int)HSBpalette.z] ;
  //spectrum for the color mode and more if you need
  vec4 HSBmode = new vec4 (360,100,100,100) ; // give the color mode in HSB
  
  //MOTION POSITION
  //Wind force, direction
  int windDirection = 25; //direction between 1 and 360
  int windForce = 3 ; //use the natural code of the wind 0 to 9 is good
  float internal_motion_pixel = 1 ; //motion of the pixel is under influence of the wind, if the wind is strong the pixel motion become low
  PVector motionInfo = new PVector(windDirection, windForce, internal_motion_pixel)  ;
  //ratio for the image, say if the picture must be adapted to the size window or not
  boolean ratioImg = true ;
  
  //COLOR MOTION
    /*
    each data (hueVariation, satVariation, brightVariation) is PVector with 3 values :
    value 1 : Pivot (laticce) between 0 to max, the max value is the componant of HSB for example 360 for the hue if it's a value choice is the colorMode
    value 2 : Speed evolution of this value : no max or min value but is better to use very small value like 0.1 or less
    value 3 : factor multiplication variation of the value 1 (pivot) must be include between "ZERO" and "ONE", if the value is "ZERO" it's the max of variation, if it's "ONE there's no variation 
    */
  //hue motion
  int huePivot = 180 ; // choice the color pivot on the wheel color, between "zero" and "HSBmode.x" ( HSBmode.x is the value of the hue wheel : generally 360 )
  float hueSpeed = 0.001f ; // Speed evolution of this value : no max or min value but is better to use very small value like 0.1 or less
  float hueRange = 0.0f ; // between "zero" and "one" : "zero" if the max amplitude between the pivot and the color start
  PVector hueVariation = new PVector (huePivot, hueSpeed, hueRange ) ;
  //saturation motion
  int satPivot = 10 ; // choice the color pivot on the wheel color, between "zero" and "HSBmode.y" ( HSBmode.y is the value of the saturation range : generally 100 )
  float satSpeed = 0.01f ; // no max or min value but is better to use very small value like 0.1 or less
  float satRange = 0.00f ; // between "zero" and "one" : "zero" if the max amplitude between the pivot and the color start
  PVector satVariation = new PVector (satPivot, satSpeed, satRange ) ;
  //saturation motion
  int brightPivot = 10 ; // choice the color pivot on the wheel color, between "zero" and "HSBmode.y" ( HSBmode.y is the value of the saturation range : generally 100 )
  float brightSpeed = 0.01f ; // no max or min value but is better to use very small value like 0.1 or less
  float brightRange = 0.00f ; // between "zero" and "one" : "zero" if the max amplitude between the pivot and the color start
  PVector brightVariation = new PVector (brightPivot, brightSpeed, brightRange ) ;
  
  //SOUND
  int forceBeat = 1 ;
  
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    load_bitmap(ID_item);
    if(!FULL_RENDERING) maxVoronoiPoints = 250 ;
    //load pattern SVG to display a Pixel pattern you create in Illustrator or other software
    pathSVG = preference_path +"pixel/model.svg" ;
    shapeSVGsetting(pathSVG) ;
    
    //random palette
    paletteRandom(HSBpalette, HSBmode ) ; // you must give the number of color and the size spectre color, here it's 360 for the hue and 100 for the rest
    
    //step 2 if you use Voronoi
    voronoiToxicSetup() ;

  }
  
  
  
  String imgPathRef = ("") ;
  boolean firstSettingPosition = true ;
  //DRAW
  public void draw() {
    /*
    if(firstSettingPosition && startingPos[ID_item].x == 0.0 && startingPos[ID_item].y == 0.0 ) {
      startingPos[ID_item].x = img[ID_item].width /4 ;
      startingPos[ID_item].y = img[ID_item].height /4 ;
      firstSettingPosition = false ;
    }
    */
    
    if(parameter_is()) {
      load_bitmap(ID_item);
    }

    if(bitmap[ID_item] != null) {  
      //MOTION
      windForce = (int)map(get_speed_x(),0,1,0,13) ;
      windDirection = (int)get_dir_x();
      if(reverse_is()) windDirection += PI;
      internal_motion_pixel = map(get_calm(),0,1, 0,20) *(1.0f + pen[ID_item].z) ;
      motionInfo.y = windForce ;
      motionInfo.z = internal_motion_pixel ;
      //PEN
       if (pen[ID_item].z == 1 ) pen[ID_item].z = 0 ; else pen[ID_item].z = pen[ID_item].z ;
       if( (pen[ID_item].x == 1.0f && pen[ID_item].y == 1.0f) || (pen[ID_item].x == 0.0f && pen[ID_item].y == 0.0f) ) {
         motionInfo.x = map(windDirection,0,TAU,0,360); 
       } else {
         PVector convertTilt = new PVector (-pen[ID_item].x, -pen[ID_item].y) ;
         motionInfo.x = deg360(convertTilt) ;
       }
       
       // if (!key_space_long) for( Old_Pixel p : listEscargot) {
       //alternat beween the pen and the controleur
       // if( pen[ID_item].x == 0 && pen[ID_item].y == 0 ) newDirection = normalDir(int(map(valueObj[ID_item][18],0,100,0,360))) ; else newDirection = new PVector (-pen[ID_item].x  , -pen[ID_item].y ) ;
       
       if (!motion_is()) for(Old_Pixel p : listEscargot) {
         p.updatePosPixel(motionInfo, bitmap[ID_item]) ;
       }
      ////////////////
      
      //ANALYZE
      //change the size of pixel ref for analyzing
      if (pixelAnalyzeSize != pixelAnalyzeSizeRef || radiusAnalyze != radiusAnalyzeRef || maxEntryPoints != maxEntryPointsRef) reInitilisationAnalyze() ;
  
      pixelAnalyzeSizeRef = pixelAnalyzeSize;
      radiusAnalyzeRef = radiusAnalyze ;
      maxEntryPointsRef = maxEntryPoints ;
      
      int n = PApplet.parseInt(map(get_quantity(),0,1,10,150)) ;
      maxEntryPoints = n *n ;
      
      // security for the voronoï displaying, because if you change the analyze in the voronoi process, Romanesco make the Arraylist error
      if(get_mode_id() != 8 || (maxEntryPoints != maxEntryPointsRef && scene) ) {
        //if (maxEntryPoints > listPixelRaw.size() / 4 ) maxEntryPoints = listPixelRaw.size() ;
        radiusAnalyze = PApplet.parseInt(map(get_swing_x(),0,1,2,100));
        pixelAnalyzeSize = PApplet.parseInt(map(get_quality(),0,1,100,2));
      } else {
        if(maxEntryPoints > maxVoronoiPoints) maxEntryPoints = maxVoronoiPoints  ;
      }
  
      
       //security for the droping img from external folder
       if(parameter_is() && key_a ) ratioImg = !ratioImg ;
       if(bitmap[ID_item] != null && bitmap[ID_item].width > 3 && ratioImg ) {
         analyzeImg(pixelAnalyzeSize) ;
         // ratioImgWindow = new PVector ((float)width / (float)img.width , (float)height / (float)img.height ) ;
         ratioImgWindow = new PVector ((float)width / (float)bitmap[ID_item].width , (float)width / (float)bitmap[ID_item].width ) ;
       } else if (bitmap[ID_item] != null && bitmap[ID_item].width > 3 && !ratioImg) {
         analyzeImg(pixelAnalyzeSize) ;
         ratioImgWindow.set(1,1) ;
       } else {
         ratioImgWindow.set(1,1) ;
       }
       
       //size and thickness
       PVector sizePix = new PVector (map(get_size_x(),.1f,width, 1, height/30 ), map(get_size_y(),.1f,width, 1, height/30 ), map(get_size_z(),.1f,width, 1, height/30 )) ;
       float sizePoint = map(get_size_x(),.1f,width, 1, height/6 ) ;
       float thickPix = map(get_thickness(),0.1f,height *.33f, 0.1f, height/10 ) ;
       
       // range 100
       float soundHundredMin = random(80) ;
       float soundHundredMax = random(soundHundredMin, soundHundredMin +20) ;
       PVector rangeReactivitySoundHundred = new PVector (soundHundredMin, soundHundredMax) ;
       //range 360
       float soundThreeHundredSixtyMin = random(330) ;
       float soundThreeHundredSixtyMax = random(soundThreeHundredSixtyMin, soundThreeHundredSixtyMin +30) ;
       PVector rangeReactivitySoundThreeHundredSixty = new PVector (soundThreeHundredSixtyMin, soundThreeHundredSixtyMax) ;
       //Music factor
       PVector musicFactor = new PVector ( all_transient(ID_item) *left[ID_item], all_transient(ID_item) *right[ID_item]) ;
       forceBeat = (int)map(get_repulsion(),0,1,1,40) ;

       
       // update image
       if(parameter_is() && imgPathRef != bitmap_path[which_bitmap[ID_item]] ) {
         analyzeDone = false ;
         escargotGOanalyze = false ;
         escargotClear() ;
         imgPathRef = bitmap_path[which_bitmap[ID_item]] ;
       }
      
      
      
      //choice new pattern SVG
      if ( action_is() && key_p ) {
        //step 1 clear the list for new analyze
        drawVertexSVG = false ;
        selectInput("select SVG pattern 50x50", "choiceSVG");
      }
      
      //change the color palette
      if (action_is() && key_x ) paletteRandom(HSBpalette, HSBmode ) ;
      
      //clear the pixels for the new analyze
      if (action_is() && ( key_delete || key_backspace)) {
        escargotClear() ;
        analyzeDone = false ;
        totalPixCheckedInTheEscargot = 0 ;
      }
  
  
  
      
  
       //CHANGE MODE DISPLAY
      /////////////////////
      
      // correction position to rotate the picture by the center
      pushMatrix() ;
      translate(-bitmap[ID_item].width /4, -bitmap[ID_item].height /4) ;
      
      if (get_mode_id() == 0 || get_mode_id() == 255 ) {
        displayRawPixel(sizePoint, get_fill(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 1 ) {
        escargotRaw(sizePoint, get_fill(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 2 ) {
        escargotPoint(sizePix, get_fill(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 3 ) {
        escargotEllipse(sizePix, thickPix, get_fill(), get_stroke(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 4 ) {
        escargotRect(sizePix, thickPix, get_fill(), get_stroke(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      }else if (get_mode_id() == 5 ) {
        escargotBox(sizePix, thickPix, get_fill(), get_stroke(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow, horizon_is()) ;
      } else if (get_mode_id() == 6 ) {
        escargotCross(sizePix, thickPix, get_fill(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 7 ) {
        escargotSVG(sizePix, thickPix, get_fill(), get_stroke(), rangeReactivitySoundHundred, rangeReactivitySoundThreeHundredSixty, musicFactor, ratioImgWindow) ;
      } else if (get_mode_id() == 8 ) {
        //if( listEscargot.size() < 600) {
        if( listEscargot.size() < maxVoronoiPoints + maxVoronoiPoints/10) {
          voronoiStatic(get_fill(), get_stroke(), thickPix, useNewPalettePixColorToDisplay, ratioImgWindow) ; 
        } else {
          text("Too much points to net voronoï connection", 20, height -20) ;
        }
      }
      
      // end of correction position
      popMatrix() ;
      
      // info display
      item_info[ID_item] = ("Image " +bitmap[ID_item].width + "x"+bitmap[ID_item].height + " Analyze "+listEscargot.size()+ " of " + maxEntryPoints+ " / Cell " + pixelAnalyzeSize+ "px / Radius analyze " + radiusAnalyze + " Scale " + ratioImgWindow.x + " / " +ratioImgWindow.y) ;
    } 
  }
  
  
  
  //ANNEXE VOID
  public void displayRawPixel(float sizeP, int cIn, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    // we must create a PVector because i'm lazy to create an other void beatReactivity for one float
    PVector sizePixCtrl = new PVector (0,0,sizeP) ;
    float factorSat = map(saturation(cIn),0,100,0,1) ;
    float factorBright = map(brightness(cIn),0,100,0,1) ;
    
    for (Old_Pixel p : listPixelRaw) {
      //display
      stroke(hue(p.colour),saturation(p.colour)*factorSat,brightness(p.colour)*factorBright, alpha(cIn)) ;
      float newSize = 0 ;
      if(sound_is())  newSize = beatReactivityHSB(sizePixCtrl, p.size, p.colour, rangeThreeHundredSixty, rangeHundred, musicFactor ).z ; else newSize = sizeP ;
      strokeWeight(newSize) ;
      point(p.pos.x *ratio.x, p.pos.y *ratio.y) ;
    }
  }
  
  
  
  //Display which point is use to caluculate the barycenter
  public void escargotRaw(float sizeP, int cIn, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ;
    float factorSat = map(saturation(cIn),0,100,0,1) ;
    float factorBright = map(brightness(cIn),0,100,0,1) ;
    // we must create a PVector because i'm lazy to creat an other void beatReactivity for one float
    PVector sizePixCtrl = new PVector (0,0,sizeP) ;
    
    for ( Old_Pixel p : listPixelRaw ) {
      if (p.ID == 1 ) {
        //color
        if ( colorPixDisplay ) c = p.newColour ; else c = p.colour ;
        
        //display
        stroke(hue(c),saturation(c)*factorSat,brightness(c)*factorBright, alpha(cIn)) ;
        float newSize = 0 ;
        if(sound_is())  newSize = beatReactivityHSB(sizePixCtrl, p.size, p.colour, rangeThreeHundredSixty, rangeHundred, musicFactor ).z ; else newSize = sizeP ;
        strokeWeight(newSize) ;
        point(p.pos.x *ratio.x, p.pos.y *ratio.y) ;
      }
    }
  }


  //Display Barycenter
  public void escargotPoint(PVector size, int cIn, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ;
    float factorSat = map(saturation(cIn),0,100,0,1) ;
    float factorBright = map(brightness(cIn),0,100,0,1) ;
    // we must create a PVector because i'm lazy to creat an other void beatReactivity for one float
    //PVector sizePixCtrl = new PVector (0,0,size.x) ;

    for (Old_Pixel p : listEscargot ) {
      //check if we must display original color or the new palette
      int x = (int)p.pos.x ; int y = (int)p.pos.y ;
      if ( colorPixDisplay ) c = p.newColour ; else c = get(x , y) ;
  
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode, brightPalette,  brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ;
      
      stroke(hue(c),saturation(c)*factorSat,brightness(c)*factorBright, alpha(cIn)) ;
      PVector newSize = new PVector() ;
      newSize = newSize2D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ; //<>// //<>//
      
      if (sound_is()) strokeWeight(newSize.x) ; else strokeWeight(p.size.x *size.x) ;
      
       point(p.pos.x *ratio.x, p.pos.y *ratio.y) ; 
    }
  }
  
  
  
  
  
  //ELLIPSE
  public void escargotEllipse(PVector size, float thickness, int cIn, int cOut, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ;
    float factorSatIn = map(saturation(cIn),0,100,0,1) ;
    float factorBrightIn = map(brightness(cIn),0,100,0,1) ;
    float factorSatOut = map(saturation(cIn),0,100,0,1) ;
    float factorBrightOut = map(brightness(cIn),0,100,0,1) ;
   
    for (Old_Pixel p : listEscargot) {
      
      if (colorPixDisplay) c = p.newColour ; else c = p.colour ;
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode, brightPalette, brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ; 

      //music influence on the opacity
      // A RETRAVAILLER
      
      //display
      if (alpha(cIn) != 0) fill(hue(c),saturation(c)*factorSatIn,brightness(c)*factorBrightIn, alpha(cIn)) ; else noFill() ;
      if (alpha(cOut) != 0) {
        stroke(hue(c),saturation(c)*factorSatOut,brightness(c)*factorBrightOut, alpha(cOut)) ; 
        strokeWeight(thickness ) ;
      } else { 
        noStroke() ;
      } 
      
      PVector newSize = new PVector() ;
      newSize = newSize2D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ;
      // display
      ellipse(p.pos.x *ratio.x,  p.pos.y *ratio.y, newSize.x, newSize.y) ; 
    }
  }
  
  //RECT
  public void escargotRect(PVector size, float thickness, int cIn, int cOut, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ;
    float factorSatIn = map(saturation(cIn),0,100,0,1) ;
    float factorBrightIn = map(brightness(cIn),0,100,0,1) ;
    float factorSatOut = map(saturation(cIn),0,100,0,1) ;
    float factorBrightOut = map(brightness(cIn),0,100,0,1) ;
    
    for (Old_Pixel p : listEscargot) {
      if ( colorPixDisplay ) c = p.newColour ; else c = p.colour ;
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode, brightPalette, brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ; 
      
      //display
      if (alpha(cIn) != 0) fill(hue(c),saturation(c)*factorSatIn,brightness(c)*factorBrightIn, alpha(cIn)) ; else noFill() ;
      if (alpha(cOut) != 0) {
        stroke(hue(c),saturation(c)*factorSatOut,brightness(c)*factorBrightOut, alpha(cOut)) ; 
        strokeWeight(thickness ) ;
      } else { 
        noStroke() ;
      } 

      PVector newSize = new PVector() ;
      newSize = newSize2D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ;
      // display
      rect((p.pos.x - (newSize.x *.5f)) *ratio.x, (p.pos.y - (newSize.y *.5f)) *ratio.y, newSize.x , newSize.y) ; 
    }
  }
  
  
  //RECT
  public void escargotBox(PVector size, float thickness, int cIn, int cOut, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio, boolean alignement) {
    int c ;
    float factorSatIn = map(saturation(cIn),0,100,0,1) ;
    float factorBrightIn = map(brightness(cIn),0,100,0,1) ;
    float factorSatOut = map(saturation(cIn),0,100,0,1) ;
    float factorBrightOut = map(brightness(cIn),0,100,0,1) ;
    
    for (Old_Pixel p : listEscargot) {
      if ( colorPixDisplay ) c = p.newColour ; else c = p.colour ;
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode,brightPalette, brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ; 
      
      //display
      if (alpha(cIn) != 0) fill(hue(c),saturation(c)*factorSatIn,brightness(c)*factorBrightIn, alpha(cIn)) ; else noFill() ;
      if (alpha(cOut) != 0) {
        stroke(hue(c),saturation(c)*factorSatOut,brightness(c)*factorBrightOut, alpha(cOut)) ; 
        strokeWeight(thickness ) ;
      } else { 
        noStroke() ;
      } 
      //recalculate the pose  to scale with coordonate in the middle of the shape ( like(RectMode(CENTER) )

      // float witness = beatReactivityHSB(size, p.size, c, rangeThreeHundredSixty, rangeHundred, musicFactor ).z  ;
      PVector newSize = new PVector() ;
      newSize = newSize3D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ;
      // display
      pushMatrix() ;
      if (!alignement) {
        translate(p.pos.x *ratio.x, p.pos.y *ratio.y, 0) ;
      } else {
        float horizon = newSize.z *.5f ;
        translate(p.pos.x *ratio.x, p.pos.y *ratio.y, horizon) ;
      }
      //show
      box(newSize.x, newSize.y, newSize.z) ;
      /*
      if (sound_is()) { 
        if( witness > size.z) box(newSize.x, newSize.y, newSize.z) ; 
      } else if (!sound_is()){ 
        box(newSize.x, newSize.y, newSize.z) ; 
      }
      */
      popMatrix() ;
    }
  }
  
  
  //CROSS
  public void escargotCross(PVector size, float thickness, int cIn, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ; 
    float factorSat = map(saturation(cIn),0,100,0,1) ;
    float factorBright = map(brightness(cIn),0,100,0,1) ;
    
    for (Old_Pixel p : listEscargot) {
      
      if ( colorPixDisplay ) c = p.newColour ; else c = p.colour ;
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode, brightPalette, brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ;
      

      int newC = color(hue(c),saturation(c)*factorSat,brightness(c)*factorBright, alpha(cIn)) ;

      PVector pos = new PVector(p.pos.x *ratio.x, p.pos.y *ratio.y) ;
      PVector newSize = new PVector() ;
      newSize = newSize3D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ;
      // display
      if (alpha(cIn) > 0 ) crossPoint3D(pos, newSize, newC, thickness) ;
    }
  }
  
  
  
  /////////////
  //display SVG shave like pixel
  public void escargotSVG(PVector size, float thickness, int cIn, int cOut, PVector rangeHundred, PVector rangeThreeHundredSixty, PVector musicFactor, PVector ratio) {
    int c ;
    float factorSatIn = map(saturation(cIn),0,100,0,1) ;
    float factorBrightIn = map(brightness(cIn),0,100,0,1) ;
    float factorSatOut = map(saturation(cIn),0,100,0,1) ;
    float factorBrightOut = map(brightness(cIn),0,100,0,1) ;
    
    for (Old_Pixel p : listEscargot) { 
      //check if we must display original color or the new palette
      int x = (int)p.pos.x ; int y = (int)p.pos.y ;
      if (colorPixDisplay) c = p.newColour ; else c = get(x , y) ;
      
      p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
      p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
      p.changeBright(HSBmode,brightPalette, brightStart, brightEnd) ;
      // update the color after change each componante
      p.updatePalette() ; 
      
      //display
      if (alpha(cIn) != 0) fill(hue(c),saturation(c)*factorSatIn,brightness(c)*factorBrightIn, alpha(cIn)) ; else noFill() ;
      if (alpha(cOut) != 0) {
        stroke(hue(c),saturation(c)*factorSatOut,brightness(c)*factorBrightOut, alpha(cOut)) ; 
        strokeWeight(thickness ) ;
      } else { 
        noStroke() ;
      } 
      //recalculate the pose  to scale with coordonate in the middle of the shape ( like(RectMode(CENTER) ) 
      
      PVector newSize = new PVector() ;
      newSize = newSize2D(size, p.size, rangeThreeHundredSixty, rangeHundred, musicFactor, c, forceBeat) ;
      // display
      float sizeSVG = newSize.x *.1f ;
      PVector newPos = new PVector ( p.pos.x - (50 *sizeSVG *.5f) *ratio.x ,p.pos.y - (50 *sizeSVG *.5f) *ratio.y) ;
  
      if (drawVertexSVG) drawBezierVertex(newPos, sizeSVG , listPointsFromSVG, shapeInfo ) ;
    }
  }
  
  
  
  
  
  /////////
  //VORONOI
  public void voronoiToxicSetup(){
    // focus x positions around horizontal center (w/ 33% standard deviation)
    xpos=new BiasedFloatRange(0, width, width/2, 0.333f);
    // focus y positions around bottom (w/ 50% standard deviation)
    ypos=new BiasedFloatRange(0, height, height, 0.5f);
    
    gfx = new ToxiclibsSupport(papplet);
  }
  
  // DRAW
  public void voronoiStatic(int fill, int stroke, float thickness, boolean whichColor, PVector ratio) {
    whichColorVoronoi = whichColor ;
    // thicknessVoronoi = e ;
    //colorStrokeVoronoi = stroke ;
  
  
    for (Old_Pixel b : listEscargot) {
      //security against the NaN result
      if (Float.isNaN(b.pos.x)) ; else voronoi.addPoint(new Vec2D(b.pos.x *ratio.x, b.pos.y *ratio.y));
    }
  
    for (Polygon2D poly : voronoi.getRegions() ) {
      //to recalculate the position in the arraylist
      PVector findPosFromVoronoi = new PVector (0,0) ;
      for (Vec2D v : voronoi.getSites() ) {
        if (poly.containsPoint(v) ) {
          //position in grid
          findPosFromVoronoi.x = PApplet.parseInt(v.x/pixelAnalyzeSize) ;
          findPosFromVoronoi.y = PApplet.parseInt(v.y/pixelAnalyzeSize) ;
          if(findPosFromVoronoi.x > cols -1 ) findPosFromVoronoi.x = cols -1 ;
          if(findPosFromVoronoi.y > rows -1 ) findPosFromVoronoi.y = rows -1 ;
          int posInList = (PApplet.parseInt(findPosFromVoronoi.x / ratio.x )  * rows ) + PApplet.parseInt(findPosFromVoronoi.y /ratio.y) ; 
          
          //look the color in the list
          if(posInList < listPixelRaw.size() ) {
            Old_Pixel p = (Old_Pixel) listPixelRaw.get(posInList) ;
            
            if (whichColorVoronoi) {
              //change the color with the new palette
              p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
              p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
              p.changeBright(HSBmode,brightPalette, brightStart, brightEnd) ;
              // update the color after change each componante
              p.updatePalette() ; 
              float newSat = map(saturation(p.newColour),0,100, 0,saturation(fill)) ;
              float newBright = map(brightness(p.newColour),0,100, 0,brightness(fill)) ;
              fill(hue(p.newColour), newSat, newBright, alpha(fill)) ;
            } else {
              //original color of the pix
              fill(hue(p.colour), saturation(p.colour), brightness(p.colour), alpha(fill)) ;
            }
            if(thicknessVoronoi == 0 ) { 
              noStroke() ; 
            } else { 
              stroke(stroke) ;
              strokeWeight(thickness) ;
            }
          }
          gfx.polygon2D(poly);
        }
      }
    }
    //clear voronoi list
    voronoi = new Voronoi();
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  //COLOR
  //beat rectivity
  public PVector beatReactivityHSB(PVector sizeFromControleur, PVector sizeFromList, int beatColor, PVector range360, PVector range100, PVector beatFactor) {
    PVector newSize = sizeFromControleur.copy() ;
    //HUE
    if ( hue(beatColor) > range360.x && hue(beatColor) < range360.y ) {
      newSize.x = newSize.x             *beatFactor.x ; 
      newSize.y = newSize.y             *beatFactor.x ;
      newSize.z = newSize.z *beatFactor.x ;
    } else {
      newSize.x = newSize.x ;
      newSize.y = newSize.y ;
      newSize.z = newSize.z ;
    }
    
    //BRIGHTNESS
    if ( brightness(beatColor) > range100.x && brightness(beatColor) < range100.y ) { 
      newSize.x = sizeFromList.x        *sizeFromControleur.x *beatFactor.y ;  
      newSize.y = sizeFromList.y        *sizeFromControleur.y *beatFactor.y ;
      newSize.z = sizeFromList.z                  *beatFactor.y  ; 
    } else {
      newSize.x = sizeFromList.x *sizeFromControleur.x ;
      newSize.y = sizeFromList.y *sizeFromControleur.y ;
      newSize.z = newSize.z ;
    }
    
    //SATURATION
    if ( saturation(beatColor) > range100.x && saturation(beatColor) < range100.y ) { 
      newSize.x = sizeFromList.x *sizeFromControleur.x *beatFactor.z ; 
      newSize.y = sizeFromList.y *sizeFromControleur.y *beatFactor.z ;
      newSize.z =                 sizeFromControleur.z *beatFactor.z  ; 
    } else {
      newSize.x = sizeFromList.x *sizeFromControleur.x ;
      newSize.y = sizeFromList.y *sizeFromControleur.y ;
      newSize.z = newSize.z ;
      
    }
    return newSize ;
  }
  
  // SIZE PIXEL CALCUL
  // 2D PIXEL
  public PVector newSize2D(PVector size, PVector classSize, PVector range360, PVector range100, PVector factor, int c, int beatAmplitude) {
    PVector result = new PVector() ;
    if (result.z > size.z || sound_is()) {
    result.x = beatReactivityHSB(size, classSize, c, range360, range100, factor).x *map(all_transient(ID_item),1,40,1,beatAmplitude);
    result.y = beatReactivityHSB(size, classSize, c, range360, range100, factor).y *map(all_transient(ID_item),1,40,1,beatAmplitude) ;
    result.z = beatReactivityHSB(size, classSize, c, range360, range100, factor).z ;
      
    } else {
      result.x = classSize.x *size.x ;
      result.y = classSize.y *size.y ;
    }
    return result ;
  }
  // 3D PIXEL
  public PVector newSize3D(PVector size, PVector classSize, PVector range360, PVector range100, PVector factor, int c, int beatAmplitude) {
    PVector result = new PVector() ;
    float ratioDepth = map(brightness(c),0,100,0,1) ;
    result.x = beatReactivityHSB(size, classSize, c, range360, range100, factor).x *map(all_transient(ID_item),1,40,1,beatAmplitude) ;
    result.y = beatReactivityHSB(size, classSize, c, range360, range100, factor).y *map(all_transient(ID_item),1,40,1,beatAmplitude) ;
    result.z = beatReactivityHSB(size, classSize, c, range360, range100, factor).z ;
      
    if (sound_is()) {
      result.x = result.x *size.x ;
      result.y = result.y *size.y ;
      result.z = result.z *size.z *ratioDepth ;
    } else {
      result.x = classSize.x *size.x ;
      result.y = classSize.y *size.y ;
      result.z = (result.x + result.y)*.25f *size.z *ratioDepth ;
    }
    return result ;
  }
  
  
  
  
  
  
  
  
  
  //////////////////////////////
  //VOID ANALYZE
  //ReInit the Analyze image
  public void reInitilisationAnalyze() { 
      escargotGOanalyze = false ;
      escargotClear() ;
      analyzeDone = false ;
      totalPixCheckedInTheEscargot = 0 ;
  }
    
  //main analyze void    
  public void analyzeImg(int sizePixForAnalyze) {
    //Analyze image
    // put in this void the size of pixel you want, to create grid analyzing and image than you want analyze
    colorAnalyzeSetting(sizePixForAnalyze, bitmap[ID_item]) ;
    
    //step 2
    //three componants : FIRST : size of the pixel grid // SECOND which PImage // THIRD mirror "FALSE" or "TRUE"
    recordPixelRaw(sizePixForAnalyze, bitmap[ID_item], false) ; 
    
    //step 3
    // give the list point of Pixel must be change with the new palette
    changeColorOfPixel(listPixelRaw) ; 
    
    //step 4
    //escargot analyze of the arraylist create by the void recordPixelRaw
    
   if (escargotGOanalyze && listEscargot.size() < maxEntryPoints) {
      //security to make sure the speed is not higher to the max entry points
      if (speedAnalyze > maxEntryPoints / 10 ) speedAnalyze = maxEntryPoints / 10 ;
      for (int i = 0 ; i < speedAnalyze ; i++ ) {
        int whichPointInTheList  = (int)random(listPixelRaw.size()) ;
        //void without control for escargot analyze
        //escargotAnalyze(whichPointInTheList, radiusAnalyze, modeTri, useNewPalettePixColorToAnalyze ) ;
        
        //void with control for escargot analyze, the last component is a boolean control
        escargotAnalyze(whichPointInTheList, radiusAnalyze, modeTri, useNewPalettePixColorToAnalyze, escargotGOanalyze, sizePixForAnalyze ) ; // escargotStopAnalyze
      }
    }
  }
}





//////////////////
//ESCARGOT ANALYZE
/////////////////
//GLOBAL
boolean escargotGOanalyze = false ; // to stop the escargot analyze
// analyse en escargot étoilé / analyze staring snail
int [] matricePosPixel = new int [10] ;

int getPixelEscargotAnalyze ;
//Barycentre
PVector barycenterEscargot = new PVector(0,0 ) ;
ArrayList<Old_Pixel> listEscargot =  new ArrayList<Old_Pixel>()   ;
//Temp Array List
ArrayList<Old_Pixel> listPixelTemp =  new ArrayList<Old_Pixel>()   ;
ArrayList<Old_Pixel> listPixelByCol =  new ArrayList<Old_Pixel>()  ;
ArrayList<Old_Pixel> listPixelByRow =  new ArrayList<Old_Pixel>() ;

//lattice pixel
int startingPixelToAnalyze ;
//level ananlyze around the pixel lattice
int  maxSnailLevel ; // degre of perimeter of analyze around the main pixel, and max perimeter
int  [] lockEscargot = new int[9] ; // for the 8 direction around the lattice, pivot, main pixel plus 1 for the origin
//info
int  numberPixelAnalyze ;
int  totalPixCheckedInTheEscargot ;


//main void analyze
//SETUP
public void escargotClear() {
  if(listEscargot.size() > 0 ) { 
    listEscargot.clear() ;
    listPixelRaw.clear() ;
  }
}

//DRAW

//CLASSIC ANALYZE
//analyze a specific point
public void escargotAnalyze(int pivot, int max, String mode, boolean whichColor, int sizePix ) {
  maxSnailLevel = max ;
  //setting the lockEscargot
  for (int i = 0 ; i< lockEscargot.length ; i++) lockEscargot[i] = 0 ;
  
  if(listPixelRaw.size() > 0 && pivot < listPixelRaw.size() ) {
    Old_Pixel pixelRef = (Old_Pixel) listPixelRaw.get(pivot) ;


    if (pixelRef.ID == 0 ) {
      startingPixelToAnalyze += 1 ; // information of how many pixel is starting point analyzing
      //choice wich color of pixel must be use for the analyzis, the original one or the new one
      int colorRef ;
      if ( !whichColor ) colorRef = pixelRef.colour ; else colorRef = pixelRef.newColour ;
      
      for (int snailLevel = 1 ; snailLevel <= maxSnailLevel ; snailLevel++) {
        for (int escargotPos = 1 ; escargotPos < 10 ; escargotPos++) { // "posPixelAroundTheMainPixel" give the direction around the pixel pivot
          if (lockEscargot[escargotPos -1] == 0 ) {
            //cols and rows is var from TAB "B_Pixel_Analyze_raw_Record"
            //strange the way is vetical and we must use the rows, not a same way than pixel who use the cols
                                    //escargot analyze algorythme return the position of pixel neightbor in the ordre of ArrayList
            getPixelEscargotAnalyze = escargot(escargotPos, pivot, snailLevel, rows, listPixelRaw.size() ) ; // find the position of the pixel target in the list
            
            if (getPixelEscargotAnalyze > 0 && getPixelEscargotAnalyze < listPixelRaw.size()  ) {  // check if the pixel is valid for the list
              Old_Pixel pixelEscargotAnalyze = (Old_Pixel) listPixelRaw.get(getPixelEscargotAnalyze) ; //look the pixel in the list
              
              //check the color by field hue, saturation, brightness
              if (mode.equals("hsb"))    hueSaturationBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field hue
              else if (mode.equals("h"))  hueCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field saturation
              else if (mode.equals("s"))  saturationCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field brightness
              else if (mode.equals("b"))  brightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field hue and saturation
              else if (mode.equals("hs"))  hueSaturationCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field hue and brigthness
              else if (mode.equals("hb"))  hueBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field saturation and brigthness
              else if (mode.equals("sb"))  saturationBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;   
              else hueCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
            }
          }
        }
      }
      //COMPLETE THE LIST of pixel escargot in the area around the barrycenter, to change the ID "zero" to "one"
      //check in cols to complete the pixel area after Escargot Analyze
      checkPixelInCol() ;
      //check in row to complete the pixel area after Escargot Analyze
      checkPixelInRow() ;
      
      //calculate the barycenter of the family point, this void must be in the main lood for include the good color
      findEscargot(colorRef, sizePix) ;
      //clear the temp for the next round analyzis
      for (int i = 0 ; i< lockEscargot.length ; i++) lockEscargot[i] = 0 ;
      listPixelTemp.clear() ;
      barycenterEscargot = new PVector(0,0) ;
      numberPixelAnalyze = 0 ;
      
    }
  }
}




//CLASSIC ANALYZE
//analyze a specific point, with possibility to stop the analyzis
public void escargotAnalyze(int pivot, int max, String mode, boolean whichColor, boolean analyzeGO, int sizePix ) {
  maxSnailLevel = max ;
  //setting the lockEscargot
  for (int i = 0 ; i< lockEscargot.length ; i++) lockEscargot[i] = 0 ;
  
  if(listPixelRaw.size() > 0 && pivot < listPixelRaw.size() ) {
    Old_Pixel pixelRef = (Old_Pixel) listPixelRaw.get(pivot) ;


    if (pixelRef.ID == 0 && analyzeGO ) {
      pixelRef.changeID(1) ;
      startingPixelToAnalyze += 1 ; // information of how many pixel is starting point analyzing
      //choice wich color of pixel must be use for the analyzis, the original one or the new one
      int colorRef ;
      if ( !whichColor ) colorRef = pixelRef.colour ; else colorRef = pixelRef.newColour ;
      
      for ( int snailLevel = 1 ; snailLevel <= maxSnailLevel ; snailLevel++) {
        for ( int escargotPos = 1 ; escargotPos < 10 ; escargotPos++) { // "posPixelAroundTheMainPixel" give the direction around the pixel pivot
          if (lockEscargot[escargotPos -1] == 0 ) {
            //cols and rows is var from TAB "B_Pixel_Analyze_raw_Record"
            //strange the way is vetical and we must use the rows, not a same way than pixel who use the cols
                                    //escargot analyze algorythme return the position of pixel neightbor in the ordre of ArrayList
            getPixelEscargotAnalyze = escargot(escargotPos, pivot, snailLevel, rows, listPixelRaw.size() ) ; // find the position of the pixel target in the list
            
            if (getPixelEscargotAnalyze > 0 && getPixelEscargotAnalyze < listPixelRaw.size()  ) {  // check if the pixel is valid for the list
              Old_Pixel pixelEscargotAnalyze = (Old_Pixel) listPixelRaw.get(getPixelEscargotAnalyze) ; //look the pixel in the list
              
              //check the color by field hue, saturation, brightness
              if (mode.equals("hsb"))    hueSaturationBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field hue
              else if (mode.equals("h"))  hueCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field saturation
              else if (mode.equals("s"))  saturationCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
              //check the color by field brightness
              else if (mode.equals("b"))  brightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field hue and saturation
              else if (mode.equals("hs"))  hueSaturationCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field hue and brigthness
              else if (mode.equals("hb"))  hueBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;
              //check the color by field saturation and brigthness
              else if (mode.equals("sb"))  saturationBrightnessCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ;   
              else hueCheck(escargotPos, colorRef, pixelEscargotAnalyze, whichColor) ; 
            }
          }
        }
      } 
        
      //COMPLETE THE LIST of pixel escargot in the area around the barrycenter, to change the ID "zero" to "one"
      //check in cols to complete the pixel area after Escargot Analyze
      checkPixelInCol() ;
      //check in row to complete the pixel area after Escargot Analyze
      checkPixelInRow() ;
      
      
      //calculate the barycenter of the family point, this void must be in the main lood for include the good color
      findEscargot(colorRef, sizePix) ;
      

      
      
      //clear the temp for the next round analyzis
      for (int i = 0 ; i< lockEscargot.length ; i++) lockEscargot[i] = 0 ;
      listPixelTemp.clear() ;
      barycenterEscargot = new PVector(0,0) ;
      totalPixCheckedInTheEscargot += numberPixelAnalyze ;
      
      numberPixelAnalyze = 0 ;
      
    }
  }
}





//ANNEXE PRIVATE VOID


///////////////////////
//COMPLETE THE ESCARGOT
//COL
private void checkPixelInCol() {
  int numPixInCol = 0 ;
  
  for ( int whichCol = 1 ; whichCol <= cols ; whichCol++) {
    for ( int j = 0 ; j< listPixelTemp.size() ; j++) {
      Old_Pixel pixTemp = (Old_Pixel) listPixelTemp.get(j) ;
      if( pixTemp.gridPos.x == whichCol ) {
        numPixInCol += 1 ;
        listPixelByCol.add(new Old_Pixel(pixTemp.rank)) ;
      }
    }
    //Changez the ID "ZERO" to "ONE" of pixel if there is more of one point in col
    if(numPixInCol > 1  ) {
      int [] pixPosInCol = new int [numPixInCol] ;
      for ( int k = 0 ; k < listPixelByCol.size() ; k++) {
        Old_Pixel pixByCol = (Old_Pixel) listPixelByCol.get(k) ;
        pixPosInCol[k] = pixByCol.rank ;
      }
      pixPosInCol = sort(pixPosInCol) ;
      for(int l = pixPosInCol[0] ; l < pixPosInCol[pixPosInCol.length -1] ; l++) {
        Old_Pixel pix = (Old_Pixel) listPixelRaw.get(l) ;
        if(pix.ID == 0) {
          // git a new ID "ONE" to say this Pixel has been checked, and now don'k try to make something with her
          pix.changeID(1) ;
          //complet the temp list completed
          PVector posInTheGrid = gridPosition(l) ;
      //    listPixelTempCompleted.add(new Pixel(l, posInTheGrid)) ;
          listPixelTemp.add(new Old_Pixel(l, posInTheGrid)) ;
        }
      }
    }
    //clear the  list for the next col
    numPixInCol = 0 ; 
    listPixelByCol.clear() ;
  }
}


//ROW
private void checkPixelInRow() {
  int numPixInRow = 0 ;
  for ( int whichRow = 1 ; whichRow <= rows ; whichRow++) {
    for ( int j = 0 ; j< listPixelTemp.size() ; j++) {
      Old_Pixel pixTemp = (Old_Pixel) listPixelTemp.get(j) ;
      if( pixTemp.gridPos.y == whichRow ) { 
        numPixInRow += 1 ;
        listPixelByRow.add(new Old_Pixel(pixTemp.rank, pixTemp.gridPos)) ;
      }
    }
    //Changez the ID "ZERO" to "ONE" of pixel if there is more of one point in col
    if(numPixInRow > 1  ) {
      int [] pixPosInRow = new int [numPixInRow] ;
      int [] whichColForPix = new int [numPixInRow] ;
      for ( int k = 0 ; k < listPixelByRow.size() ; k++) {
        Old_Pixel pixByRow = (Old_Pixel) listPixelByRow.get(k) ;
        pixPosInRow[k] = pixByRow.rank ;
        whichColForPix[k] = (int)pixByRow.gridPos.x ;
      }
      //pixPosInRow = sort(pixPosInRow) ;
      whichColForPix = sort(whichColForPix) ;
      int startPoint = whichColForPix[0] ;
      int lastPoint = whichColForPix[pixPosInRow.length -1] ;

      for(int l = startPoint ; l < lastPoint  ; l++) {
        int whichPixel = (l-1) * rows + pixPosInRow[0] %rows ;
        Old_Pixel pix = (Old_Pixel) listPixelRaw.get(whichPixel) ;
        if(pix.ID == 0) {
          // git a new ID "ONE" to say this Pixel has been checked, and now don'k try to make something with her
          pix.changeID(1) ;
          //complet the temp list completed
          PVector posInTheGrid = gridPosition(whichPixel) ;
          //listPixelTempCompleted.add(new Pixel(whichPixel, posInTheGrid)) ;
          listPixelTemp.add(new Old_Pixel(whichPixel, posInTheGrid)) ;
        } 
      }
    }
    //clear the  list for the next row
    numPixInRow = 0 ;
    listPixelByRow.clear() ; 
  }
}

////////////
//BARYCENTER
public void findEscargot(int cRef, int pixSize) {
  for ( Old_Pixel p :  listPixelTemp ) {
    PVector posInTheGrid = p.gridPos ;
    barycenterEscargot.x += posInDisplay(posInTheGrid.x, pixSize) ;
    barycenterEscargot.y += posInDisplay(posInTheGrid.y, pixSize) ;
  }
  //divid the some of the point to find the position of the barycenter
  barycenterEscargot.x /= listPixelTemp.size() ; 
  barycenterEscargot.y /= listPixelTemp.size() ;

  PVector sizeBarycenter = new PVector(numberPixelAnalyze, numberPixelAnalyze) ;
  //add barycenter in the list
  listEscargot.add(new Old_Pixel(barycenterEscargot, sizeBarycenter, cRef)); 
}


//SCALE THE POSITION FROM THE GRID TO DISPLAY
public float posInDisplay(float posInGrid, int sizeCell) {
  float p = 0 ;
  p = posInGrid * sizeCell - (sizeCell * .5f ) ;
  return p ;
}
  

/////////////////////////////////////////////////
//POSITION in the grid systeme with cols and rows
public PVector gridPosition(int posPixel) {
  PVector gridPos = new PVector (0,0) ;
  for ( int j = 0 ; j < cols ; j++) {

    // return the collums where leave the pixel
    if (posPixel >= rows * j && posPixel < (rows * j) + rows) {
        gridPos.x = j +1 ;
    }
    // return the line(row) where leave the pixel
    for ( int k = 0 ; k < rows ; k++) {
      if (posPixel == (rows * (j)) + k) {
        gridPos.y = k +1 ;
      }
    }
  }
  return gridPos ;
}

///////////////////
int wichColorCheck ;
//HSB CHECK
//by hsb
public void hueSaturationBrightnessCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 // check if the pixel is never analyze before
      && hue(wichColorCheck) == hue(cRef) // and if the hue is good
      && saturation(wichColorCheck) == saturation(cRef) // and if the saturation is good
      && brightness(wichColorCheck) == brightness(cRef) ) { // and if the brightness is good too 
    // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

//by hue
public void hueCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 && hue(wichColorCheck) == hue(cRef) ) { // check if the pixel is never analyze before and if the hue is good
  // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

//by saturation
public void saturationCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 && saturation(wichColorCheck) == saturation(cRef) ) // check if the pixel is never analyze before and if the hue is good
    {

    // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

//by brightness
public void brightnessCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 && brightness(wichColorCheck) == brightness(cRef) ) // check if the pixel is never analyze before and if the hue is good
    {
      // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}
//by hue and saturation
public void hueSaturationCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 // check if the pixel is never analyze before
      && hue(wichColorCheck) == hue(cRef) // and if the hue is good
      && saturation(wichColorCheck) == saturation(cRef) ) // and if the saturation is good
      { 
    // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

// by hue and brigthness
public void hueBrightnessCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 // check if the pixel is never analyze before
      && hue(wichColorCheck) == hue(cRef) // and if the hue is good
      && brightness(wichColorCheck) == brightness(cRef) ) { // and if the brightness is good too 
    // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

//by saturation and brightness
public void saturationBrightnessCheck(int escargotPos_n, int cRef, Old_Pixel pixelEscargotAnalyze, boolean whichPix) {
  //choice the ref color in pix Class a original color or the new one
  if( !whichPix ) wichColorCheck = pixelEscargotAnalyze.colour ; else wichColorCheck = pixelEscargotAnalyze.newColour ;
  if( pixelEscargotAnalyze.ID == 0 // check if the pixel is never analyze before
      && saturation(wichColorCheck) == saturation(cRef) // and if the saturation is good
      && brightness(wichColorCheck) == brightness(cRef) ) { // and if the brightness is good too 
    // change the ID "ZERO" to "ONE" to indicate this that pixel has to be checked and have a good color.
    pixelEscargotAnalyze.changeID(1) ;
    //return the coordinate in the grid system rows and cols
    PVector posInTheGrid = gridPosition(getPixelEscargotAnalyze) ;
    
    listPixelTemp.add( new Old_Pixel(getPixelEscargotAnalyze, posInTheGrid)) ;
    
    numberPixelAnalyze += 1 ; // count of pixel has be analyzing
  } else {
    //close this direction for the next round
    lockEscargot[escargotPos_n -1] = 1 ;
  }
}

///////////////////


//////////////////
//MATRICE ESCARGOT
//escargot analyze algorythme return the position of pixel neightbor in the ordre of ArrayList
//strange the order int the arraylist is vertical, not like a pixel order who is horizontale, So we must use the rows, not cols to find a good neightbor pixel.
public int escargot(int escargotPos_n, int start, int level, int numRows, int sizeList ) {
  //pivot
  matricePosPixel[1] = start + (0*level *numRows) + (0*level)  ; // neutre
  //autour du pivot
  ////////////////
  matricePosPixel[2] = start + (1*level *numRows) + (0*level)  ; // Est
  //special condition for the bottom boarder
  if (start%numRows + level >= numRows ) matricePosPixel[3] = -1 ; else matricePosPixel[3] = start + (1*level *numRows) + (1*level)  ; // Sud-Est
  if (start%numRows + level >= numRows ) matricePosPixel[4] = -1 ; else matricePosPixel[4] = start + (0*level *numRows) + (1*level)  ; // Sud
  if (start%numRows + level >= numRows ) matricePosPixel[5] = -1 ; else matricePosPixel[5] = start - (1*level *numRows) + (1*level)  ; // Sud-Ouest
  matricePosPixel[6] = start - (1*level *numRows) + (0*level)  ; // Ouest
  //special condition for the top boarder
  if (start%numRows < level ) matricePosPixel[7] = -1 ; else matricePosPixel[7] = start - (1*level *numRows) - (1*level)  ; // Nord-Ouest
  if (start%numRows < level ) matricePosPixel[8] = -1 ; else matricePosPixel[8] = start + (0*level *numRows) - (1*level)  ; // Nord
  if( start%numRows < level ) matricePosPixel[9] = -1 ; else matricePosPixel[9] = start + (1*level *numRows) - (1*level)  ; // Nord-Est
  
  if      ( escargotPos_n == 1 ) return matricePosPixel [1] ;
  else if ( escargotPos_n == 2 ) return matricePosPixel [2] ;
  else if ( escargotPos_n == 3 ) return matricePosPixel [3] ;
  else if ( escargotPos_n == 4 ) return matricePosPixel [4] ;
  else if ( escargotPos_n == 5 ) return matricePosPixel [5] ;
  else if ( escargotPos_n == 6 ) return matricePosPixel [6] ;
  else if ( escargotPos_n == 7 ) return matricePosPixel [7] ;
  else if ( escargotPos_n == 8 ) return matricePosPixel [8] ;
  else if ( escargotPos_n == 9 ) return matricePosPixel [9] ;
  else return matricePosPixel[0] ;
}














////////////////
//PIXEL ANALYZE
///////////////
ArrayList<Old_Pixel> listPixelRaw = new ArrayList<Old_Pixel>() ;
// Number of columns and rows in our system
int cols, rows ; 
float ratioCols, ratioRows;
//give the position in the order of displaying
int whereIsPixel ;
//security when you load an image, to start the displaying only if you've finish to analyze this one
boolean analyzeDone ;

//SETUP
//SETTING
public void colorAnalyzeSetting(int pixSize, PImage imgAnalyze) {
  if (imgAnalyze != null ) {
    
    cols = imgAnalyze.width / pixSize;
    rows = imgAnalyze.height / pixSize;
    
    ratioCols = width / imgAnalyze.width ;
    ratioRows = height / imgAnalyze.height ;
  } 
}




//RECORD
//RAW RECORD without timer
public void recordPixelRaw(int cellSize, PImage imgRecord, boolean mirror) {
  if (imgRecord != null && !analyzeDone  ) {
    imgRecord.loadPixels() ;
    //start analyze
    for (int i = 0; i < cols; i++) {
      for (int j = 0; j < rows; j++) {
        
        int x = i*cellSize;
        int y = j*cellSize;
        //check if there is mirror effect or not
        if(!mirror) whereIsPixel =  y*imgRecord.width +x; else whereIsPixel = (imgRecord.width -x -1) + y*imgRecord.width; // Reversing x to mirror the image
        //analyze the color of the pixel in the HSB mode
        float h = hue       (imgRecord.pixels[whereIsPixel]);
        float s = saturation(imgRecord.pixels[whereIsPixel]);
        float b = brightness(imgRecord.pixels[whereIsPixel]);
        // Make a new color and position
        int c = color(h, s, b);
        PVector pos = new PVector(x+cellSize/2, y+cellSize/2 ) ;
        //add position and color of the pixel in the list
        listPixelRaw.add(new Old_Pixel(pos, c)) ;
      }
    }
    analyzeDone = true ;
    escargotGOanalyze = true ;
  } 
}

//RAW RECORD with timer
int stepAnalyzeImg ;
//from image
public void recordPixelRaw(int cellSize, PImage imgRecord, float time, boolean mirror) {
  int newStep = timer(time) ;
  //analyze each new step
  if (stepAnalyzeImg != newStep ) {
    //clear the list for new analyze
    listPixelRaw.clear() ;
    
    imgRecord.loadPixels() ;
    //start analyze
    for (int i = 0; i < cols; i++) {
      for (int j = 0; j < rows; j++) {
        int x = i*cellSize;
        int y = j*cellSize;
        //check if there is mirror effect or not
        if(!mirror) whereIsPixel =  y*imgRecord.width +x; else whereIsPixel = (imgRecord.width - x - 1) + y*imgRecord.width; // Reversing x to mirror the image
        //analyze the color of the pixel in the HSB mode
        float h = hue       (imgRecord.pixels[whereIsPixel]);
        float s = saturation(imgRecord.pixels[whereIsPixel]);
        float b = brightness(imgRecord.pixels[whereIsPixel]);
        // Make a new color and position
        int c = color(h, s, b);
        PVector pos = new PVector(x+cellSize/2, y+cellSize/2 ) ;
        //add position and color of the pixel in the list
        listPixelRaw.add(new Old_Pixel(pos, c)) ;
      }
    }
  }
  stepAnalyzeImg = newStep ;
}








////////////
//DRAW SVG
PShape shapeSVG ;
boolean drawVertexSVG ;
ArrayList<PVector> listPointsFromSVG = new ArrayList<PVector>();;
ArrayList <PVector> shapeInfo = new ArrayList<PVector>(); ;

//SETUP
public void shapeSVGsetting(String p) {
  drawVertexSVG = false ;
  listPointsFromSVG.clear();
  shapeInfo.clear();
  shapeSVG = loadShape(p) ;
  startPoint = endPoint = 0 ;
  createListOfPoint(shapeSVG) ;
}


//Information about the shape
PShape[] childrenShape ; // to create a shape children from SVG
int IDshapeChildren ;
int startPoint, endPoint ;

public void createListOfPoint (PShape s ) {
  
  int  numChildren, numPoint;
  PVector pos  ;
  //find the quantity object from SVG
  numChildren = s.getChildCount(); 
  
  //if there is children, separate the shape
  if ( numChildren > 0 ) {
    for ( int i = 0 ; i  < numChildren ; i++) {
      childrenShape = s.getChildren() ;
      createListOfPoint (childrenShape[i]) ;
    }
  //if there no children we can write the shape in the list
  } else {
    numPoint = s.getVertexCount() ;
    //to find the exit point in the list
    endPoint = startPoint + numPoint ;
    
    
    //add information ID, entry and exit point of each children shape for the future !
    shapeInfo.add(new PVector(IDshapeChildren, startPoint, endPoint )) ;
    //display information
    //to find the ID shape
    IDshapeChildren += 1 ;
    //to find the next entry point in the list
    
    //startPoint = endPoint +1 ;
    startPoint = endPoint  ;
    
    //startPoint = endPoint  ;
    //loop to put the point from SVG in the list
    for ( int j = 0 ; j < numPoint ; j++) {
      pos = new PVector (s.getVertexX(j), s.getVertexY(j), 0.0f ) ;
      listPointsFromSVG.add(new PVector(pos.x, pos.y, pos.z)) ;
    }
    drawVertexSVG = true ;
  }
}




//Draw shape bezier Vertex
public void drawBezierVertex(ArrayList<PVector> list, ArrayList<PVector> shapes) {
    if (drawVertexSVG) {
      for ( int i = 0 ; i < shapes.size() ; i++) {
      int start = PApplet.parseInt(shapes.get(i).y) ;
      int end   = PApplet.parseInt(shapes.get(i).z) ;
      beginShape() ;
      for ( int j = start ; j < end ; j++) {
        if (j == start ) { 
          
          vertex(list.get(j).x, list.get(j).y) ;
        } else if (j > start && j < end -2 ) { 
          bezierVertex( list.get(j).x, list.get(j).y, list.get(j+1).x, list.get(j+1).y, list.get(j+2).x, list.get(j+2).y ) ;
        }
        //must be different of "0" for the starting point
        if( j != start ) j += 2 ; // +=2 for the switch to next point because the BezierVertex need the coordinate
      }
      endShape() ;
    }
  }
}
//Draw with scale
public void drawBezierVertex(PVector pos, float scale, ArrayList<PVector> list, ArrayList<PVector> shapes) {
  if (drawVertexSVG) {
      for ( int i = 0 ; i < shapes.size() ; i++) {
      int start = PApplet.parseInt(shapes.get(i).y) ;
      int end   = PApplet.parseInt(shapes.get(i).z) ;
      beginShape() ;
      for ( int j = start ; j < end ; j++) {
        if (j == start ) { 
          
          vertex(list.get(j).x *scale +pos.x, list.get(j).y *scale +pos.y) ;
        } else if (j > start && j < end -2 ) { 
          bezierVertex( list.get(j).x   *scale +pos.x, list.get(j).y   *scale +pos.y, 
                        list.get(j+1).x *scale +pos.x, list.get(j+1).y *scale +pos.y, 
                        list.get(j+2).x *scale +pos.x, list.get(j+2).y *scale +pos.y ) ;
        }
        //must be different of "0" for the starting point
        if( j != start ) j += 2 ; // +=2 for the switch to next point because the BezierVertex need the coordinate
      }
      endShape() ;
    }
  }
}









/**
//LOAD PATTERN
//SVG PATTERN
*/
String pathSVGescargot ;

//load SVG
public void choiceSVG(File selection) {
  if (selection == null) {
    println("no pattern selected");
  } else {
    pathSVGescargot  = selection.getAbsolutePath() ;
    shapeSVGsetting(pathSVGescargot) ;

  }
}













/**
COLOR MANAGEMENT
*/
int [] hueStart  ;
int [] hueEnd  ;
int [] huePalette, huePaletteRef ;

//SATURATION
int [] satStart  ;
int [] satEnd  ;
int [] satPalette, satPaletteRef ;
//BRIGHTNESS
int [] brightStart  ;
int [] brightEnd  ;
int [] brightPalette, brightPaletteRef ;


//DRAW OR SETUP
//MAKE PALETTE
// random hue Palette
public void paletteRandom(PVector n, vec4 spectrum) {
  huePalette = new int [(int)n.x] ;
  huePaletteRef = new int [(int)n.x] ;
  for (int i = 0 ; i < (int)n.x ; i++) huePalette [i] = huePaletteRef [i] = (int)random(spectrum.x) ;
  huePalette = sort(huePalette) ;
  huePaletteRef = sort(huePaletteRef) ;
  //calcul of the value range of each color on color wheel
  hueSpectrumPalette(huePalette, (int)spectrum.x) ;
  
  //saturation
  satPalette = new int [(int)n.y] ;
  satPaletteRef = new int [(int)n.y] ;
  for (int i = 0 ; i < (int)n.y ; i++) satPalette [i] = satPaletteRef [i] = (int)random(spectrum.y) ;
  satPalette = sort(satPalette) ;
  satPaletteRef = sort(satPaletteRef) ;
  //calcul of the value range of each color on color wheel
  satSpectrumPalette(satPalette, (int)spectrum.y) ;
  
  //brightness
  brightPalette = new int [(int)n.z] ;
  brightPaletteRef = new int [(int)n.z] ;
  for (int i = 0 ; i < (int)n.z ; i++) brightPalette [i] = brightPaletteRef [i] = (int)random(spectrum.z) ;
  brightPalette = sort(brightPalette) ;
  brightPaletteRef = sort(brightPaletteRef) ;
  //calcul of the value range of each color on color wheel
  brightSpectrumPalette(brightPalette, (int)spectrum.z) ; 
}

//hue Spectrum
public void hueSpectrumPalette(int [] hueP, int sizeSpectrum) {  
  if( hueP.length > 0 ) {
    int max = hueP.length  ;
    hueStart = new int [max] ;
    hueEnd = new int [max] ;
    int [] zoneLeftHue = new int [max] ;
    int [] zoneRightHue = new int [max] ;
    int [] zoneHue = new int [max] ;
  
    
    // int total = 0 ;
    if(max >1 ) {
      for ( int i = 0 ; i < max ; i++ ) {
        if ( i == 0 ) {
          zoneLeftHue[i] = (hueP[i] + sizeSpectrum - hueP[max -1 ]  ) /2  ;
          zoneRightHue[i] = (hueP[i+1] - hueP[i] ) / 2 ;
          
          if (hueP[i] < zoneLeftHue[i] ) hueStart[i] = sizeSpectrum - ( zoneLeftHue[i] - hueP[i]) ; else hueStart[i] = hueP[i] - zoneLeftHue[i] ;
          hueEnd[i] = hueP[i] + zoneRightHue[i] ;
          
          zoneHue[i] = zoneLeftHue[i] + zoneRightHue[i] ;
          
        } else if ( i > 0 && i < max-1 ) {
          zoneLeftHue[i] = (hueP[i] - hueP[i-1]  ) / 2  ;
          zoneRightHue[i] = (hueP[i+1] - hueP[i] ) / 2 ;
          
          hueStart[i] = hueP[i] - zoneLeftHue[i] ;
          hueEnd[i] = hueP[i] + zoneRightHue[i] ;
          
          zoneHue[i] = zoneLeftHue[i] + zoneRightHue[i] ;
          
        } else if ( i == max -1 ) { 
          zoneLeftHue[i] = (hueP[i] - hueP[i-1]  ) / 2  ;
          zoneRightHue[i] = (sizeSpectrum - hueP[max -1] + hueP[0] ) / 2 ;
          
          hueStart[i] = hueP[i] - zoneLeftHue[i] ;
          if( hueP[i] + zoneRightHue[i] > sizeSpectrum ) hueEnd[i] = (hueP[i] + zoneRightHue[i]) -sizeSpectrum ; else hueEnd[i] = hueP[i] + zoneRightHue[i] ;
          
          zoneHue[i] = zoneLeftHue[i] + zoneRightHue[i] ;
        }
      }
    } else {
      zoneLeftHue[0] = hueP[0]  ;
      zoneRightHue[0] = sizeSpectrum - hueP[0]  ;
      hueStart[0] = 0 ;
      hueEnd[0] = sizeSpectrum ;
    }
  }
}

//saturation Spectrum
public void satSpectrumPalette(int [] satP, int sizeSpectrum) {  
  if(satP.length > 0 ) {
    int max = satP.length  ;
    satStart = new int [max] ;
    satEnd = new int [max] ;
    int [] zoneLeftSat = new int [max] ;
    int [] zoneRightSat = new int [max] ;
    int [] zoneSat = new int [max] ;
  
    
    //int total = 0 ;
    if (max > 1 ) {
      for ( int i = 0 ; i < max ; i++ ) {
        if ( i == 0 ) {
          zoneLeftSat[i] = (satP[i] + sizeSpectrum - satP[max -1 ]  ) /2  ;
          zoneRightSat[i] = (satP[i+1] - satP[i] ) / 2 ;
          
          if (satP[i] < zoneLeftSat[i] ) satStart[i] = sizeSpectrum - ( zoneLeftSat[i] - satP[i]) ; else satStart[i] = satP[i] - zoneLeftSat[i] ;
          satEnd[i] = satP[i] + zoneRightSat[i] ;
          
          zoneSat[i] = zoneLeftSat[i] + zoneRightSat[i] ;
          
        } else if ( i > 0 && i < max-1 ) {
          zoneLeftSat[i] = (satP[i] - satP[i-1]  ) / 2  ;
          zoneRightSat[i] = (satP[i+1] - satP[i] ) / 2 ;
          
          satStart[i] = satP[i] - zoneLeftSat[i] ;
          satEnd[i] = satP[i] + zoneRightSat[i] ;
          
          zoneSat[i] = zoneLeftSat[i] + zoneRightSat[i] ;
          
        } else if ( i == max -1 ) { 
          zoneLeftSat[i] = (satP[i] - satP[i-1]  ) / 2  ;
          zoneRightSat[i] = (sizeSpectrum - satP[max -1] + satP[0] ) / 2 ;
          
          satStart[i] = satP[i] - zoneLeftSat[i] ;
          if( satP[i] + zoneRightSat[i] > sizeSpectrum ) satEnd[i] = (satP[i] + zoneRightSat[i]) -sizeSpectrum ; else satEnd[i] = satP[i] + zoneRightSat[i] ;
          
          zoneSat[i] = zoneLeftSat[i] + zoneRightSat[i] ;
        }
      }
    } else {
      zoneLeftSat[0] = satP[0]  ;
      zoneRightSat[0] = sizeSpectrum - satP[0]  ;
      satStart[0] = 0 ;
      satEnd[0] = sizeSpectrum ;
    }
  }
}




//brightness Spectrum
public void brightSpectrumPalette(int [] brightP, int sizeSpectrum) {  
  if(brightP.length > 0 ) {
    int max = brightP.length  ;
    brightStart = new int [max] ;
    brightEnd = new int [max] ;
    int [] zoneLeftBright = new int [max] ;
    int [] zoneRightBright = new int [max] ;
    int [] zoneBright = new int [max] ;
  
    
    //int total = 0 ;
    if ( max > 1 ) {
      for ( int i = 0 ; i < max ; i++ ) {
        if ( i == 0 ) {
          zoneLeftBright[i] = (brightP[i] + sizeSpectrum - brightP[max -1 ]  ) /2  ;
          zoneRightBright[i] = (brightP[i+1] - brightP[i] ) / 2 ;
          
          if (brightP[i] < zoneLeftBright[i] ) brightStart[i] = sizeSpectrum - ( zoneLeftBright[i] - brightP[i]) ; else brightStart[i] = brightP[i] - zoneLeftBright[i] ;
          brightEnd[i] = brightP[i] + zoneRightBright[i] ;
          
          zoneBright[i] = zoneLeftBright[i] + zoneRightBright[i] ;
          
        } else if ( i > 0 && i < max-1 ) {
          zoneLeftBright[i] = (brightP[i] - brightP[i-1]  ) / 2  ;
          zoneRightBright[i] = (brightP[i+1] - brightP[i] ) / 2 ;
          
          brightStart[i] = brightP[i] - zoneLeftBright[i] ;
          brightEnd[i] = brightP[i] + zoneRightBright[i] ;
          
          zoneBright[i] = zoneLeftBright[i] + zoneRightBright[i] ;
          
        } else if ( i == max -1 ) { 
          zoneLeftBright[i] = (brightP[i] - brightP[i-1]  ) / 2  ;
          zoneRightBright[i] = (sizeSpectrum - brightP[max -1] + brightP[0] ) / 2 ;
          
          brightStart[i] = brightP[i] - zoneLeftBright[i] ;
          if( brightP[i] + zoneRightBright[i] > sizeSpectrum ) brightEnd[i] = (brightP[i] + zoneRightBright[i]) -sizeSpectrum ; else brightEnd[i] = brightP[i] + zoneRightBright[i] ;
          
          zoneBright[i] = zoneLeftBright[i] + zoneRightBright[i] ;
        }
      } 
    } else {
      zoneLeftBright[0] = brightP[0]  ;
      zoneRightBright[0] = sizeSpectrum - brightP[0]  ;
      brightStart[0] = 0 ;
      brightEnd[0] = sizeSpectrum ;
    }
  }
}

//CHANGE COLOR pixel in the list of Pixel
public void changeColorOfPixel(ArrayList listMustBeChange ) {
  for( int i = 0 ; i<listMustBeChange.size() ; i++) {
    Old_Pixel p = (Old_Pixel) listMustBeChange.get(i) ;
    p.changeHue   (HSBmode, huePalette, hueStart, hueEnd) ;
    p.changeSat   (HSBmode, satPalette, satStart, satEnd) ; 
    p.changeBright(HSBmode, brightPalette, brightStart, brightEnd) ;
    
    p.updatePalette() ; 
  }
}











//timer
int chrnmtr, chronometer, newChronometer ;
public int timer(float tempo) {
  int translateTempo = PApplet.parseInt(1000 *tempo) ;
  newChronometer = millis()%translateTempo ;
  if (chronometer > newChronometer ) {
    chrnmtr += 1;
  }
  chronometer = newChronometer ;
  return chrnmtr ;
}






/**
* Flux Force Field
* 2018-2019
* v 0.0.11
*/
class Flux extends Romanesco {

  ArrayList<Vehicle> vehicles;

	public Flux() {
		item_name = "FF Flux";
		item_author  = "Stan le Punk";
		item_version = "Version 0.0.11";
		item_pack = "Force 2018-2019";
    item_costume = "pixel/point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;

    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    //frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;

    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
  }





  public void setup() {
    setting_start_position(ID_item,0,0,height/2);
    set_vehicle(100);

  }
  


  public void draw() {
    if(get_costume().get_type() != PIXEL_ROPE) {
      int mult_particle = 1;
      draw_flux(mult_particle);
    }
  }

  public void draw_2D() {
    if(get_costume().get_type() == PIXEL_ROPE) {
      int mult_particle = 10 ;
      draw_flux(mult_particle);
    }
  }




  public void draw_flux(int mult_particle) {
    float ratio_num = get_quantity() *get_quantity() *get_quantity();
    int num = (int)map(ratio_num,0,1,10,3000); // > 100_000;
    num *= mult_particle;
    
    set_vehicle(num);
    init_vehicle(num,get_force_field()); 
    
    float speed = .1f + (get_speed_x()*2.f);
    update_vehicle(get_force_field(),speed);
    aspect(get_fill(), get_stroke(),get_thickness());
    vec3 size = vec3(get_size_x(),get_size_y(),get_size_z());
    // size.map(get_size_x_min(),get_size_x_max(),1,get_size_x_max());
    show_vehicle(size,get_area(),get_costume());

    //
    item_info[ID_item] = ("vehicles: " +vehicles.size());
  }




  private int get_num() {
    return vehicles.size();
  }

  private boolean vehicle_is = false;
  private void init_vehicle(int num, Force_field ff) {
    if(ff != null && !vehicle_is) {
      build_vehicle(num,ff);
      vehicle_is = true;
    } 
  }
  

  // private int num_ref;
  private void set_vehicle(int num) {
    if(vehicles != null && num != vehicles.size()) {
      vehicles.clear();
      vehicle_is = false;
    } else if(vehicles == null || num != vehicles.size()) {
      vehicle_is = false;
    }
  }


  private void build_vehicle(int num, Force_field ff) {
    if(vehicles == null) vehicles = new ArrayList<Vehicle>();
    int w = ff.get_canvas().x;
    int h = ff.get_canvas().y;
    vec2 range_speed = vec2(1.f,2.f);
    vec2 range_force = vec2(.2f,1.f);

    for (int i = 0; i < num; i++) {
      float max_speed = +range_speed.x + random_next_gaussian(range_speed.y,3);
      float max_force = +range_force.x + random_next_gaussian(range_force.y,3);
      vec2 pos = vec2().rand(vec2(0,w),vec2(0,h));
      vehicles.add(new Vehicle(pos,max_speed,max_force));
    }
  }




  private void update_vehicle(Force_field ff, float speed) {
    if(ff != null) {
      for (Vehicle v : vehicles) {
        v.mult_speed(speed);
        v.update(ff);
        v.follow();   
        v.swap();
        v.manage_border(manage_border_is);
      }
    }
  }

  private boolean manage_border_is;
  private void manage_border() {
    manage_border_is = (manage_border_is == true) ? false:true;
  }

  private void show_vehicle(vec size, float ratio, Costume costume) {
    for (Vehicle v : vehicles) {
      float theta = v.get_direction() + radians(90);
      set_ratio_costume_size(map(ratio,width*.1f, width*TAU,0,1));
      if(get_costume().get_type() == PIXEL_ROPE) {
        costume(v.get_position().mult(displayDensity()),size,theta,costume);
      } else {
        costume(v.get_position(),size,theta,costume);
      }
      
    }
  }
}



















/**
* Force Field
* 2018-2019
* v 0.0.11
*/
class FF extends Romanesco {
	public FF() {
		item_name = "FF Force Field";
		item_author  = "Stan le Punk";
		item_version = "Version 0.0.11";
		item_pack = "Force 2018-2019";
    item_costume = "line/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12/none";
    item_mode = "fluid/magnetic/gravity/perlin/equation/chaos/image";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    spectrum_is = true;

    grid_is = true;
    viscosity_is = true;
    diffusion_is = true;
    power_is = true;
    mass_is = true;
  }





  public void setup() {
    setting_start_position(ID_item,0,0,0);
  }
  

  int ref_mode = 0 ;
  float ref_cell = 0;
  float ref_detection = 0;
  public void draw() { 
    minimum_spot();
    set_ff();
    if(ref_cell != get_grid() || ref_mode != get_mode_id() || ref_detection != get_area() || birth_is()) {
      ref_mode = get_mode_id();
      ref_cell = get_grid();
      ref_detection = get_area();
      birth_is(false);
      init_force_field(get_spot_num());
      // EQUATION
      if(get_pattern_force_field() == EQUATION) {
        generate_ff_equation();
      }
      
    }

    update_force_field_is(true);
    ivec2 aspect_colour = ivec2(get_fill(),get_stroke());
    aspect_is(fill_is(),stroke_is());

    float thickness = get_thickness();
    float scale = get_size_x() *.1f;
    float range = 0 ;
    if(reverse_is()) {
      range = map(get_spectrum(),0,360,0,-1);
    } else {
      range = map(get_spectrum(),0,360,0,1);
    }
    
    Force_field ff = get_force_field();
    
    if(get_costume().get_type() == NULL) {
      // nothing
    } else {
      show_field(ff,scale,range,aspect_colour,thickness,get_area(),get_costume());
    }
    
    info();
  }



  private void generate_ff_equation() {
    init_eq();
    float x = random(-1,1);
    float y = random(-1,1);

    eq_center_dir(x,y);
    x = random(-1,1);
    y = random(-1,1);
    eq_center_len(x,y);

    eq_reverse_len(false);
    int swap_rand = floor(random(4));
    if(swap_rand == 0) eq_swap_xy("x","y");
    else if(swap_rand == 1) eq_swap_xy("y","x");
    else if(swap_rand == 2) eq_swap_xy("y","y");
    else if(swap_rand == 3) eq_swap_xy("x","x");
    else eq_swap_xy("x","y");
    // eq_swap_xy("x","y");
    // eq_swap_xy("y","y");
    int pow_x_rand = floor(random(-5,5));
    int pow_y_rand = floor(random(-5,5));
    if(pow_x_rand == 0) pow_x_rand = 1 ;
    if(pow_y_rand == 0) pow_y_rand = 1 ;
    eq_pow(pow_x_rand,pow_y_rand);
    float mult_x_rand = random(-5,5);
    float mult_y_rand = random(-5,5);
    if(mult_x_rand == 0) mult_x_rand = 1 ;
    if(mult_y_rand == 0) mult_y_rand = 1 ;
    eq_mult(mult_x_rand,mult_x_rand);
  }


  private void info() {
    if(get_force_field().get_type() == FLUID) info("Cell: "+get_grid(),"Force field: FLUID frequence: "+ get_force_field().get_frequence(),"viscosity: "+ get_force_field().get_viscosity(),"diffusion: "+ get_force_field().get_diffusion());
    else if(get_force_field().get_type() == MAGNETIC) info("Cell: "+get_grid(),"Force field: MAGNETIC");
    else if(get_force_field().get_type() == GRAVITY) info("Cell: "+get_grid(),"Force field: GRAVITY");
    else if(get_force_field().get_pattern() == PERLIN) info("Cell: "+get_grid(),"Force field: PERLIN");
    else if(get_force_field().get_pattern() == EQUATION) info("Cell: "+get_grid(),"Force field: EQUATION");
    else if(get_force_field().get_pattern() == CHAOS) info("Cell: "+get_grid(),"Force field: CHAOS");
    else if(get_force_field().get_pattern() == IMAGE) info("Cell: "+get_grid(),"Force field: IMAGE");
  }

  /**
  MINIMUM SPOT
  Use this method when there is no puppet master for the dynamic force field
  */
  boolean puppet_master_is = false ;
  private void minimum_spot() {
    if(!puppet_master_is() ) {

      if(get_spot_num() != 2) {
        clear_spot();
        add_spot(2);
        
      }
      // to re-init the value of specific spot in case there is not puppet master
      if(puppet_master_is) {
        // MAGNETIC CASE
        set_force_magnetic_tesla(50,-50);
        set_force_magnetic_diam(50);
        // GRAVITY CASE
        set_force_gravity_mass(50);
        puppet_master_is = false;
      }

      // update spot position
      if(motion_is()) {
        force_field_romanesco.set_spot_pos(mouse[0].x,mouse[0].y,0);
        force_field_romanesco.set_spot_pos(width -mouse[0].x,height -mouse[0].y,1);
      }
    } else {
      puppet_master_is = true;
    }
  }







  /**
  SET FORCE
  */
  private void set_ff() {
    // set detection
    int level_detection = (int)map(get_scope(),width *.1f,width*TAU,10,1);
    // println("level",level_detection);
    set_spot_detection_force_field(level_detection);

    // set cell
    int cell_size = (int)map(get_grid(),width *.1f,width*TAU,height/10,2);
    set_cell_force_field(cell_size);
    // set type
    if(get_mode_id() == 0) {
      set_type_force_field(FLUID);
    } else if(get_mode_id() == 1) {
      set_type_force_field(MAGNETIC);
    } else if(get_mode_id() == 2) {
      set_type_force_field(GRAVITY);
    } else {
      set_type_force_field(STATIC);
    }
    // set pattern
    if(get_mode_id() == 3) {
      set_pattern_force_field(PERLIN);
    } else if(get_mode_id() == 4) {
      set_pattern_force_field(EQUATION);
    } else if(get_mode_id() == 5) {
      set_pattern_force_field(CHAOS);
    } else if(get_mode_id() == 6) {
      set_pattern_force_field(IMAGE);
    } else {
      set_pattern_force_field(BLANK);
    }

    // set different force field FLUID
    if(get_type_force_field() == FLUID) {
      set_fluid_field();  
    } else if(get_type_force_field() == MAGNETIC) {
      set_magnetic_field();

    } else if(get_type_force_field() == GRAVITY) {
      set_gravity_field();
    }
  }

  private void set_magnetic_field() {
    int tesla = ceil(map(get_power(),0,1,1,height/3));
    set_force_magnetic_tesla(tesla,-tesla);

    int diam = ceil(get_diameter());
    set_force_magnetic_diam(diam);
  }

  private void set_gravity_field() {
    int mass = ceil(map(get_mass(),0,1,1,height/3));
    set_force_gravity_mass(mass);
  }

  private void set_fluid_field() {
    /*
      set_force_fluid_frequence(2/frameRate);
      set_force_fluid_viscosity(.001);
      set_force_fluid_diffusion(1.);
      */
      float frequence = map(get_frequence(),0,1,.01f,.1f);
      // set_force_fluid_frequence(frequence/frameRate);
      set_force_fluid_frequence(frequence);
      float viscosity = (get_viscosity()*get_viscosity()*get_viscosity())*.25f;
      set_force_fluid_viscosity(viscosity);
      float diffusion = get_diffusion();
      set_force_fluid_diffusion(diffusion);

  }



  /**
  SHOW FIELD
  */
  private void show_field(Force_field ff, float scale, float range_colour, ivec2 aspect, float thickness, float ratio, Costume costume) {
    if(ff != null) {
      vec2 offset = vec2(ff.get_resolution());
      offset.sub(ff.get_resolution()/2);
      //
      for (int x = 0; x < ff.cols; x++) {
        for (int y = 0; y < ff.rows; y++) {
          vec2 pos = vec2(x *ff.get_resolution(), y *ff.get_resolution());
          vec2 dir = vec2(ff.field[x][y].x,ff.field[x][y].y);
          if(ff.get_super_type() == r.STATIC) {
            float mag = ff.field[x][y].w;
            pattern_field(dir, mag, pos, ff.resolution *scale,range_colour,aspect,thickness,ratio,costume);
          } else {
            pos.add(offset);
            float mag = (float)Math.sqrt(dir.x*dir.x + dir.y*dir.y + dir.z*dir.z); ;
            pattern_field(dir, mag, pos, ff.resolution *scale,range_colour,aspect,thickness,ratio,costume);
          }
        }
      }
    }  
  }

  // Renders a vector object 'v' as an arrow and a position 'x,y'
  private void pattern_field(vec2 dir, float mag, vec2 pos, float scale, float range_colour, ivec2 aspect,float thickness, float ratio, Costume costume) {
    vec5 colorMode = vec5(getColorMode());
    colorMode(HSB,1);

    pushMatrix();
    // Translate to position to render vector
    translate(pos);
    // Call vector heading function to get direction (note that pointing to the right is a heading of 0) and rotate
    rotate(dir.angle());
    // Calculate length of vector & scale it to be dir_vector or smaller if dir_vector
    if(mag > 1) mag = 1; // limit for the huge mag of gravity and magnetic field
    float size = mag *scale;

    float max = range_colour *mag;

    // float value = map(abs(len), 0, scale,max,min);
    int colour_fill = aspect.x;
    float hue_fill = hue(colour_fill)+max;
    if(hue_fill >= g.colorModeX) hue_fill -= g.colorModeX;
    if(hue_fill < 0) hue_fill = (g.colorModeX +hue_fill);
    vec4 c_fill = vec4(hue_fill,saturation(colour_fill),brightness(colour_fill),alpha(colour_fill));

    int colour_stroke = aspect.y;
    float hue_stroke = hue(colour_stroke)+max;
    if(hue_stroke >= g.colorModeX) hue_stroke -= g.colorModeX;
    if(hue_stroke < 0) hue_stroke = (g.colorModeX +hue_stroke);
    vec4 c_stroke = vec4(hue_stroke,saturation(colour_stroke),brightness(colour_stroke),alpha(colour_stroke));

    
    aspect(c_fill,c_stroke,thickness);
    set_ratio_costume_size(map(ratio,width*.1f, width*TAU,0,1));
    
    // costume_rope(vec2(),vec3(size),costume);
    // pass by costume for the line is very slow
    if(costume.get_type() != LINE_ROPE) {
      set_ratio_costume_size(map(ratio,width*.1f, width*TAU,0,1));
      costume(vec2(),vec3(size),costume);
    } else {
      if(size > scale) size = scale;
      line(-size,0,size,0);
    }
    popMatrix();

    colorMode(colorMode);
  }
}



















/**
Puppet Master
2018-2019
v 0.0.12
*/
class Puppet_master extends Romanesco {
	public Puppet_master() {
		item_name = "FF Puppet Master";
		item_author  = "Stan le Punk";
		item_version = "Version 0.0.12";
		item_pack = "Force 2018-2019";
    item_costume = "none/pixel/point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "solo/duo/valse 2D/<valse 3D>/whisky walk/random";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = true;
    speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    repulsion_is = true;
    attraction_is = true;
    density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;

    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
  }





  public void setup() {
    setting_start_position(ID_item,0,0,(height/2)+1);
  }
  

  vec3 speed = vec3();
  public void draw() {
    puppet_master(true);
    // int num, float quantity_slider, boolean use_slider_quantity
    // num_spot_management(300, get_quantity(),true);

    ivec2 canvas_ff = get_force_field().get_canvas();
    float max_w = map(get_canvas_x(),width *.1f,(float)width *TAU,canvas_ff.x,5*canvas_ff.x);
    vec2 limit_w = vec2(-(max_w-canvas_ff.x),max_w);

    float max_h = map(get_canvas_y(),width *.1f,(float)width *TAU,canvas_ff.y,5*canvas_ff.y);
    vec2 limit_h = vec2(-(max_h-canvas_ff.y),max_h);
    
    // here we use the y component of canvas because the `z`don't exist.
    float max_d = map(get_canvas_z(),width *.1f,(float)width *TAU,canvas_ff.y*.1f,5*canvas_ff.y);
    vec2 limit_d = vec2(-(max_d-canvas_ff.y),max_d);



    
    // motion
    if(motion_is()) {
      // speed rotation
      speed.x = (get_speed_x()*get_speed_x()*get_speed_x());
      speed.x *= .1f;
      //angle growth
      speed.y = get_speed_y()*get_speed_y()*get_speed_y();
      speed.y *= .1f;
      //angle growth
      speed.z = get_speed_z()*get_speed_z()*get_speed_z();
      speed.z *= .1f;
      if(reverse_is()) {
        speed.mult(-1);
      }
    } 

    // num spiral
    int num_spiral = (int)map(get_angle(),0,TAU,1,13);

    // range min_max for the radius
    vec2 range = vec2(get_swing_x(),get_swing_x()*5);

    int which_behavior = floor(map(get_variety(),0,1,0,6));
    if(which_behavior == 6) which_behavior = 5;

    // attractivity / repulsion
    int diameter = (int)map(get_diameter(),width *.1f,(float)width *TAU,2,height/3);
    int attraction = (int)map(get_attraction(),0,1,0,100);
    int repulsion = (int)map(get_repulsion(),0,1,0,-100);
    int mass =(int)map(get_density(),0,1,0,100);

    if(get_type_force_field() == MAGNETIC) {
      set_force_magnetic_tesla(attraction,repulsion);
      set_force_magnetic_diam(50);
    } else if(get_type_force_field() == GRAVITY) {
      set_force_gravity_mass(mass);
    }


    

    // SPOT POSITION
    if(get_mode_id() == 0) {
      solo_spot();
    } else if(get_mode_id() == 1) {
      duo_spot();
    } else if(get_mode_id() == 2) {
      num_spot_management(300, get_quantity(),true);
      valse_2D_spot(get_canvas_x(),speed,num_spiral,range,which_behavior);
    } else if(get_mode_id() == 3) {
      num_spot_management(300, get_quantity(),true);
      valse_3D_spot();
    } else if(get_mode_id() == 4) {
      num_spot_management(300, get_quantity(),true);
      whisky_spot(canvas_ff,speed,limit_w,limit_h,limit_d);
    } else if(get_mode_id() == 5) {
      num_spot_management(300, get_quantity(),true);
      random_spot(frameCount%60 == 0);
    }



    // SHOW SPOT
    float ratio_size_costume = map(get_area(),width*.1f, width*TAU,0,width*.001f);
    vec3 size = vec3(get_size_x(),get_size_y(),get_size_z());
    aspect_is(fill_is(),stroke_is());
    aspect(get_fill(), get_stroke(),get_thickness());
    
    for(int i =  0 ; i < get_spot_num() ; i++) {
      vec3 pos = vec3(get_spot_pos(i));
      set_ratio_costume_size(ratio_size_costume);
      costume(pos,size,get_costume());
    }
  }




  private void solo_spot() {
    num_spot_management(1, get_quantity(),false);
    set_spot_pos(mouse[ID_item],0);
  }

  private void duo_spot() {
    num_spot_management(2, get_quantity(),false);
    set_spot_pos(mouse[ID_item],0);
    set_spot_pos(width -mouse[ID_item].x,height -mouse[ID_item].y,1);
  }



  Cloud_2D valse_2D;
  int ref_num;
  private void valse_2D_spot(float radius, vec3 speed, int num_spiral, vec2 range, int which_behavior) {
    if(valse_2D == null || ref_num != get_spot_num()) {
      valse_2D = new Cloud_2D(p5,get_spot_num(),r.ORDER);
      ref_num = get_spot_num();
    }
    // cloud_2D.pos(ref_pos);
    valse_2D.set_radius(radius);
    valse_2D.spiral(num_spiral);
    valse_2D.rotation(speed.x,false);
    valse_2D.set_growth(speed.y);
    valse_2D.range(range);
    if(which_behavior == 0) {
      valse_2D.set_behavior("SIN");
    } else if(which_behavior == 1) {
      valse_2D.set_behavior("SIN_TAN");
    } else if(which_behavior == 2) {
      valse_2D.set_behavior("SIN_TAN_COS");
    } else if(which_behavior == 3) {
      valse_2D.set_behavior("SIN_POW_SIN");
    } else if(which_behavior == 4) {
      valse_2D.set_behavior("POW_SIN_PI");
    } else if(which_behavior == 5) {
      valse_2D.set_behavior("SIN_TAN_POW_SIN");
    }
    valse_2D.update();
    // update spot position from cloud
    //vec3 [] temp = cloud_2D.list();
    for(int i = 0 ; i < get_spot_num() &&  i < valse_2D.length(); i++) {
      set_spot_pos(valse_2D.list()[i],i);
      //pos[i] = vec2(temp[i].x,temp[i].y);
    }


  }



  Cloud_3D cloud_3D;
  private void valse_3D_spot() {

  }






  // END CLASS
  private void random_spot(boolean condition) {
    boolean random_draw = false;
    if(sound_is() && transient_is(0)) {
    	random_draw = true;
    } else if(!sound_is() && condition) {
    	random_draw = true;
    }

    if(random_draw) {
      random_distribution_2D(width,height);
    }
  }


  private void whisky_spot(ivec2 canvas, vec3 speed, vec2 limit_w, vec2 limit_h, vec2 limit_d) {
  	float sx = speed.x;
  	float sy = speed.y;
  	float sz = speed.z;
  	sx *= sx;
  	sx *= (width/50);
  	sy *= sy;
  	sy *= (width/50);	
  	sz *= sz;
  	sz *= (width/50);	
  	for(int i = 0 ; i < get_spot_num() ; i++) {
  		vec3 vel = vec3().rand(vec2(-sx,sx),vec2(-sy,sy),vec2(-sz,sz));
  		vec3 tempo_pos = get_spot_pos(i);
  		tempo_pos.add(vel);
  		set_spot_pos(tempo_pos,i);
  	}
  	random_spot(false);
    // manage spot when those too drunk and go beyond the galaxy
    for(int i =  0 ; i < get_spot_num() ; i++) {
      vec3 pos = vec3(get_spot_pos(i));
      if(in_vec(limit_w,pos.x) && in_vec(limit_h,pos.y) && in_vec(limit_d,pos.z)) {
        // nothing happen
      } else {
        vec2 new_pos = vec2().rand(vec2(-canvas.x,canvas.x),vec2(-canvas.y,canvas.y));
        set_spot_pos(vec3(new_pos),i);
      }
    }
  }










  // global method
  int ref_spot_quantity ;
  private void num_spot_management(int num, float quantity_slider, boolean use_slider_quantity) {
    int spot_quantity = num;
    if(!FULL_RENDERING) num /= 10;
    
    if(use_slider_quantity) {
      float ratio_quantity = quantity_slider;
      ratio_quantity = (ratio_quantity*ratio_quantity*ratio_quantity);
      spot_quantity = ceil(map(ratio_quantity,0,1,1,num));
    }
    
    if(ref_spot_quantity != spot_quantity || ref_spot_quantity != get_spot_num()) {
      ref_spot_quantity = spot_quantity;
      clear_spot();
      add_spot(spot_quantity);
    }
  }


  private void random_distribution_2D(int w, int h) {
  	random_distribution_2D(vec2(0,w), vec2(0,h));
  }

  private void random_distribution_2D(vec2 range_w, vec2 range_h) {
  	for(int i = 0 ; i < get_spot_num() ; i++) {
  		set_spot_pos(random(range_w.x,range_w.y),random(range_h.x,range_h.y),i);
  	}
  }


  private boolean in_vec(vec2 ref, float value) {
    if(value < ref.x && value < ref.y) {
      return false;
    } else if(value > ref.x && value > ref.y) {
      return false;
    } else return true;
  }
}












/**
GALAXIE
2012-2019
V 1.5.4
*/

class Galaxie extends Romanesco {
  int POINT_M, ELLIPSE_M, TRIANGLE_M, SQUARE_M, RECT_M = MAX_INT ;
  int STAR_4_M, STAR_5_M, STAR_7_M, STAR_9_M = MAX_INT ;
  int SUPER_STAR_8_M, SUPER_STAR_12_M = MAX_INT ;
  int TETRAHEDRON_M, BOX_M = MAX_INT ;
  int CROSS_2_M, CROSS_3_M = MAX_INT ; 
  int SPHERE_LOW_M, SPHERE_MEDIUM_M, SPHERE_HIGH_M = MAX_INT ;

  public Galaxie() {
    //from the index_objects.csv
    item_name = "Galaxie" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.5.4";
    item_pack = "Base 2012-2019";
    // item_mode ="Point/Ellipse/Rectangle/Box" ;
    item_costume = "Point/Ellipse/Triangle/Rectangle/pentagon/flower/Cross/Star 5/Star 7/Super Star 8/Super Star 12" ;
    item_mode = "" ;
    ELLIPSE_M = 0 ;
    TRIANGLE_M = 1 ;
    RECT_M = 2 ;
    STAR_5_M = 3 ;
    SUPER_STAR_12_M = 4 ;
    TETRAHEDRON_M = 5 ;
    BOX_M = 6 ;
    CROSS_3_M = 7 ;
    SPHERE_LOW_M = 8 ;
    SPHERE_MEDIUM_M = 9 ;

    //item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Stroke hue,Stroke sat,Stroke bright,Stroke alpha,Thickness,Size X,Size Y,Size Z,Canvas X,Canvas Y,Quantity,Speed X,Influence" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is  = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    //diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    //canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  boolean makeSand = true ;
  boolean shiftGrain = false ;
  boolean gravityGrain = true ;
  vec3 posCenterGrain = vec3();

  PVector orientationStyletGrain ;

  int numGrains ;
  int numFromController ;
  PVector [] grain ;
  float vitesseGrainA = 0.0f;
  float vitesseGrainB = 0.0f ;
  PVector vitesseGrain = new PVector (0,0) ;
  float speedDust ;
  //vibration
  float vibrationGrain = 0.1f ;
  //the stream of sand
  PVector deformationGrain = new PVector () ;

  PVector motionGrain = new PVector () ;
  //float newRayonGrain = 1 ;
  float variableRayonGrain = -0.001f ;
  //float variableRayonGrain = -0.1 ;
  
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, 0, 0, 0) ;
  }
  //DRAW
  public void draw() {
    
    //surface
    PVector marge = new PVector(map(get_canvas_x(),width/10, width, width/20, width*10), map(get_canvas_y(),width/10, width, height/20, height*10), map(get_canvas_z(), width/10, width, width/10, width *10))  ;
    PVector surface = new PVector(marge.x *2 +width, marge.y *2 +height) ;
    
    //quantity of star
    float max = 1500 ;
    float min = 300 ;
    if(!FULL_RENDERING ) {
      min = 30 ;
      max = 150 ;
    }
    float quantity = map(get_quantity(),0,1,min,max) ;
    if (get_costume().get_type() == POINT_ROPE) {
      numFromController = PApplet.parseInt(quantity *10); 
    } else {
      numFromController = PApplet.parseInt(quantity);
    }
    

    if ((numGrains != numFromController && parameter_is()) || reset(this) ) {
      makeSand = true;
    }
    
    if (makeSand) {
      numGrains = numFromController ;
      grainSetup(numGrains, marge) ;
      makeSand = false ;
    }
 
    //give back the pen info
    float pressionGrain = sq(1 + pen[ID_item].z) ;
    orientationStyletGrain = new PVector ( pen[ID_item].x *10.0f , pen[ID_item].y *10.0f ) ;
    deformationGrain = orientationStyletGrain.copy() ; ;
    
    // speed / vitesse
     speedDust = map(get_speed_x(),0,1, 0.00005f ,.5f) ; 
     if(sound_is()) speedDust *= 3 ;
        
    vitesseGrainA = map(left[ID_item],0,1, 1, 17) ;
    vitesseGrainB = map(right[ID_item],0,1, 1, 17) ;
    

    
    vitesseGrain.x = vitesseGrainA *speedDust *tempo[ID_item] *pressionGrain  ;
    vitesseGrain.y = vitesseGrainB *speedDust *tempo[ID_item] *pressionGrain  ;
    if(reverse_is()) {
      vitesseGrain.x = vitesseGrain.x *1 ; 
      vitesseGrain.y = vitesseGrain.y *1 ; 
    } else {
      vitesseGrain.x = vitesseGrain.x *-1 ;
      vitesseGrain.y = vitesseGrain.y *-1 ;
    }
    
    // force
    int maxInfluence = 11 ;
    variableRayonGrain = map(get_influence(), 0,1, 0, maxInfluence ) ;
    
    //size
    float objWidth =  .1f +get_size_x() *mix[ID_item] ;
    float objHeight = .1f +get_size_y() *mix[ID_item] ;
    float objDepth = .1f +get_size_z() *mix[ID_item] ;
    vec3 size = vec3(objWidth, objHeight,objDepth) ;
    
    //thickness / épaisseur
    float thickness = get_thickness() ;

    int colorIn = get_fill() ;
    int colorOut = get_stroke() ;
    

    
    // Axe rotation
    posCenterGrain.set(mouse[ID_item]) ;
    //ratio transformation du canvas
    float ratioX = surface.x / PApplet.parseFloat(width) ;
    float ratioY = surface.y / PApplet.parseFloat(height) ;
    
    vec3 newPosCenterGrain = vec3() ;
    newPosCenterGrain.x = posCenterGrain.x *ratioX -marge.x ;
    newPosCenterGrain.y = posCenterGrain.y *ratioY -marge.y ;
    // copy the final result
    posCenterGrain.set(newPosCenterGrain) ;
    
    /////////
    //UPDATE
    if(motion_is()) if (get_speed_x() >= 0.01f) updateGrain(key_up, key_down, key_left, key_right, clickLongLeft[ID_item], marge);
    
    //////////////
    //DISPLAY MODE
    // select_costume();

    
    // aspect(get_fill(), get_stroke(), get_thickness(), get_costume()) ;
    show(size, thickness,ID_item);
    
   
    
    
    // INFO DISPLAY
    item_info[ID_item] =("Quantity " +numGrains + " - Canvas " + (int)surface.x + "x" + (int)surface.y + " - Center Galaxy " + PApplet.parseInt(posCenterGrain.x +marge.x) + "x" + PApplet.parseInt(posCenterGrain.y +marge.y) + " - speed" +PApplet.parseInt(speedDust *200.f)) ;
    if (item_info_display[ID_item]) {
      strokeWeight(1) ;
      stroke(blanc) ;
      noFill() ;
      text("Galaxy center", posCenterGrain.x +5, posCenterGrain.y -5) ; 
      line(-marge.x,       posCenterGrain.y, width +marge.x, posCenterGrain.y ) ;
      line(posCenterGrain.x, -marge.y,       posCenterGrain.x, marge.y +height ) ;
      
      rect(-marge.x, -marge.y, marge.x *2 + width, marge.y *2 + height) ;
    }   

  }
  // END DISPLAY


  
  
  
    
    
  
  
  
  
  
  
  //ANNEXE VOID
  //DISPLAY MODE

  public void show(vec3 size, float thickness, int ID) {
    float z_pos = 0 ;
    float ratio = .001f ;
    
    for(int i = 0; i < grain.length; i++) {
      // ratio is used to don't have "moirage" problem
      z_pos += ratio ;
      vec3 pos = vec3(grain[i].x, grain[i].y, z_pos) ;
      aspect(get_fill(),get_stroke(), get_thickness());
      set_ratio_costume_size(map(get_area(),width*.1f, width*TAU*4,0,1));
      costume(pos,size,get_costume()) ;

    }
  }

  //SETUP
  public void grainSetup(int num, PVector marge) {
    grain = new PVector [num] ;
    for(int i = 0; i < num ; i++) {
      grain[i] = new PVector (random(-marge.x, width +marge.x), random(-marge.y, height +marge.y)) ;
    }
    makeSand = true ;
  }
    
    
  //void update  
  public void updateGrain(boolean up, boolean down, boolean leftSide, boolean rightSide, boolean mouseClic, PVector area) {
    
    for(int i = 0; i < grain.length; i++) {
      // newRayonGrain = newRayonGrain -variableRayonGrain ;
      
      motionGrain.x = grain[i].x -posCenterGrain.x -(deformationGrain.x +right[ID_item]) +variableRayonGrain ;
      motionGrain.y = grain[i].y -posCenterGrain.y -(deformationGrain.y +left[ID_item] ) +variableRayonGrain ;
  
      PVector posGrain = new PVector () ;
      float r = dist(grain[i].x/vitesseGrain.x, grain[i].y /vitesseGrain.x, PApplet.parseInt(posCenterGrain.x) /vitesseGrain.x, PApplet.parseInt(posCenterGrain.y) /vitesseGrain.x);
      
      //spiral rotation
      if (mouseClic) {
        posGrain.x = cos(-1/r*vitesseGrain.y)*motionGrain.x - ( sin(-1/r*vitesseGrain.y)*motionGrain.y );
        posGrain.y = sin(-1/r*vitesseGrain.y)*motionGrain.x + ( cos(-1/r*vitesseGrain.y)*motionGrain.y );
      } else {
        posGrain.x = cos(1/r*vitesseGrain.y)*motionGrain.x - ( sin(1/r*vitesseGrain.y)*motionGrain.y );
        posGrain.y = sin(1/r*vitesseGrain.y)*motionGrain.x + ( cos(1/r*vitesseGrain.y)*motionGrain.y );
      }
      
      // to make line veticale or horizontal
      if (rightSide || leftSide  ) {
        posGrain.x = cos(1/r*vitesseGrain.y)*motionGrain.x ;
        posGrain.y = sin(1/r*vitesseGrain.y)*motionGrain.x ;
      } else if (down || up) {
        posGrain.x = sin(-1/r*vitesseGrain.y)*motionGrain.y ;
        posGrain.y = cos(-1/r*vitesseGrain.y)*motionGrain.y ;
      }

      
      //the dot follow the mouse  
      posGrain.x += posCenterGrain.x;
      posGrain.y += posCenterGrain.y;
      
      PVector vibGrain = new PVector(random(-vibrationGrain,vibrationGrain), random(-vibrationGrain,vibrationGrain), random(-vibrationGrain,vibrationGrain) ) ; 
      //return pos of the pixel
      grain[i].x = posGrain.x + vibGrain.x;
      grain[i].y = posGrain.y + vibGrain.y;
      
      // wall to move the pos to one border to other
      //marge around the scene
      float margeWidth = area.x ;
      float margeHeight = area.y ;
      if(grain[i].x > width +margeWidth) grain[i].x = -margeWidth;
      if(grain[i].x < -margeWidth)     grain[i].x = width +margeWidth;
      if(grain[i].y > height + margeHeight) grain[i].y = -margeHeight;
      if(grain[i].y < -margeHeight)     grain[i].y = height +margeHeight;
    }
  }
}
/**
* Grillo
* the tab is the template that you can duplicate to add the item you want in your Romanesco.
* You must change the class name and this one must be unique.
v 0.0.6
*/
class Grillo extends Romanesco {
  public Grillo() {
    //from the index_objects.csv
    item_name = "Grillo" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 0.0.6";
    item_pack = "Base 2018-2019";
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12"; // costume available from get_costume();
    item_mode = "Random/Automata/Full";
    // define slider
    // COL 1
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;
    // COL 2
    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = true;
    speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    jit_x_is = true;
    jit_y_is = true;
    jit_z_is  = true;
    swing_x_is = true;
    swing_y_is = true;
    swing_z_is = true;
    // COL 3
    // quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
    grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;

  }

  public void setup() {
    // give the starting position of your item on the 3D grid
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  //DRAW
  vec3 offset [][][];
  vec3 dir [][][];
  boolean grillo_is[][][];
  int ref_num;
  String ref_mode;
  public void draw() {
    ivec3 canvas = ivec3(round(map(get_canvas(),get_canvas_x_min(),get_canvas_x_max(),1,19)));
    if(ref_num != canvas.x*canvas.y*canvas.z || !get_mode_name().equals(ref_mode)) {
      reset(canvas);
      if(get_mode_name().equals("Random")) {
        pile_ou_face(canvas,true);
      } else if(get_mode_name().equals("Full")) {
        pile_ou_face(canvas,false);
      }
      ref_mode = get_mode_name();
    }

    direction(canvas);
    offset(canvas);

    if(birth_is()) {
      if(get_mode_name().equals("Random")) {
        pile_ou_face(canvas,true);
      } else {
        pile_ou_face(canvas,false);
      }
      birth_is(false);
    }


    aspect(get_fill(),get_stroke(),get_thickness());
    int cell = (int)map(get_grid(),get_grid_min(),get_grid_max(),5,height);
    for(int x = 0 ; x < canvas.x ; x++) {
      for(int y = 0 ; y < canvas.y ; y++) {
        for(int z = 0 ; z < canvas.z ; z++) {

          if(grillo_is[x][y][z]) {
            float pos_x = -((canvas.x*cell)/2)+(cell/2)+(cell*x);
            float pos_y = -((canvas.y*cell)/2)+(cell/2)+(cell*y);
            float pos_z = -((canvas.z*cell)/2)+(cell/2)+(cell*z);
            vec3 pos = (vec3(pos_x,pos_y,pos_z)).add(offset[x][y][z]);
            manage_costume(pos,dir[x][y][z]);
          }
        }
      }
    }

    // here if you want code in 3D mode
    info("items: "+(canvas.x*canvas.y*canvas.z),"Mode: "+get_mode_name());
  }

  public void manage_costume(vec3 pos, vec3 dir) {
    vec3 size = get_size().copy();
    if(get_costume().get_type() == STAR_3D_ROPE) {
      size.div(1,1,10);
    } else if(get_costume().get_type() == CROSS_BOX_3_ROPE || get_costume().get_type() == CROSS_BOX_2_ROPE) {
      set_ratio_costume_size(map(get_area(),get_area_min(),get_area_max(),0,1));
    }
    costume(pos,size,dir,get_costume());
  }

  public void direction(ivec3 canvas) {
    if(!get_dir().equals(0) || motion_is()) {
      for(int x = 0 ; x < canvas.x ; x++) {
        for(int y = 0 ; y < canvas.y ; y++) {
          for(int z = 0 ; z < canvas.z ; z++) {
            dir[x][y][z].set(get_dir());
          }
        }
      }
    }
  }


  public void offset(ivec3 canvas) {
    if(!get_speed().equals(0) || !get_jitter().equals(0) || motion_is()) {
      vec3 swing = map(get_swing().mult(get_swing()),0,1,0,width/2);
      vec3 s = map(get_speed(),get_speed_x_min(),get_speed_x_max(),0,.01f);
      s.x = cos(s.x *frameCount);
      s.y = cos(s.y *frameCount);
      s.z = cos(s.z *frameCount);

      vec3 range = map(get_jitter().mult(get_jitter()),0,1,0,height/2);

      for(int x = 0 ; x < canvas.x ; x++) {
        for(int y = 0 ; y < canvas.y ; y++) {
          for(int z = 0 ; z < canvas.z ; z++) {
            vec3 temp = mult(swing,s);
            // offset[x][y][z].set(temp);
            vec3 jit = vec3().jitter(range);
            offset[x][y][z].set(temp.add(jit));
          }
        }
      }
    }
  }

  public void pile_ou_face(ivec3 canvas, boolean coin_toss) {
    for(int x = 0 ; x < canvas.x ; x++) {
      for(int y = 0 ; y < canvas.y ; y++) {
        for(int z = 0 ; z < canvas.z ; z++) {
          if(coin_toss) {
            float pile_ou_face = random(1);
             if(pile_ou_face < .5f) {
              grillo_is[x][y][z] = true;
            } else {
              grillo_is[x][y][z] = false;
            }
          } else {
            grillo_is[x][y][z] = true;
          }
        }
      }
    }
  }


  public void reset(ivec3 canvas) {
    offset = new vec3[canvas.x][canvas.y][canvas.z];
    dir = new vec3[canvas.x][canvas.y][canvas.z];
    grillo_is = new boolean[canvas.x][canvas.y][canvas.z];
    ref_num = canvas.x*canvas.y*canvas.z;
    for(int x = 0 ; x < canvas.x ; x++) {
      for(int y = 0 ; y < canvas.y ; y++) {
        for(int z = 0 ; z < canvas.z ; z++) {
          offset[x][y][z] = vec3();
          dir[x][y][z] = vec3();
        }
      }
    }
  }
}















/**
HONEYCOMB
2011-2019
v 0.1.5
*/


class Honeycomb extends Romanesco {
  ArrayList <Hexagon> grid; // the arrayList to store the whole grid of cells
  public Honeycomb() {
    //from the index_objects.csv
    item_name = "Nid d'abeille" ;
    item_author  = "Amnon Owed";
    item_version = "Version 0.1.5";
    item_pack = "Base 2012-2019" ;
    item_costume = "" ;
    item_mode = "" ;

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = false;
    sat_stroke_is = false;
    bright_stroke_is = false;
    alpha_stroke_is = false;
    thickness_is = true;
    size_x_is = true;
    size_y_is = false;
    size_z_is = false;
    diameter_is = false;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = false;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = false;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
  //GLOBAL
  boolean newHoneycomb  ;
  float hexagonRadius = 8.8f; // the radius of the individual hexagon cell
  float radiusRef = hexagonRadius ;
  float hexagonStroke = 3.0f; // stroke weight around hexagons (simulated! much faster than using the stroke() method)
  float strokeRef = hexagonStroke ;
  float neighbourDistance = hexagonRadius*2 ; // the default distance to include up to 6 neighbours
  PVector canvas, canvasRef ;
  
  float sliderCanvasX, sliderCanvasY, sliderCanvasXref, sliderCanvasYref ;
  boolean initRef = true ;

  
  PVector[] v = new PVector[6]; // an array to store the 6 pre-calculated vertex positions of a hexagon

  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    canvas = new PVector(width, height) ;
    canvasRef = canvas.copy();
    if(grid == null) grid = new ArrayList<Hexagon>();
    initGrid(canvas); // initialize the CA grid of hexagons (including neighbour search and creation of hexagon vertex positions)
  }
  //DRAW
  public void draw() {
    neighbourDistance = hexagonRadius *2;
    hexagonStroke = get_thickness() ;
    hexagonRadius = map(get_size_x(),.1f,width, width /40, width/15)  ;

    
    // limitation for the preview
    int minSize = width/80 ;
    if(FULL_RENDERING) {
      sliderCanvasX = map(get_canvas_x(), width/10, width, minSize, width *4) ;
      sliderCanvasY = map(get_canvas_y(), width/10, width, minSize, width *4) ;      
    } else {
      sliderCanvasX = map(get_canvas_x(), width/10, width, minSize, width) ;
      sliderCanvasY = map(get_canvas_y(), width/10, width, minSize, width) ;
    }
    
    
    canvas = new PVector(sliderCanvasX,sliderCanvasY) ;
      
    // Good idea to lock the value when you come back for a new slider setting, must work around this concept
    if(initRef) {
      sliderCanvasXref = sliderCanvasX ;
      sliderCanvasYref = sliderCanvasY ;
      initRef = false ;
    }

    sliderCanvasXref = sliderCanvasX ;
    sliderCanvasYref = sliderCanvasY ;
    
    // music factor
    float soundSizeFactor ;
    if(get_time_track() > 0.2f) soundSizeFactor = all_transient(ID_item) ; else soundSizeFactor = 1.0f ;
    

    if(hexagonRadius != radiusRef || hexagonStroke != strokeRef || (canvas.x != canvasRef.x || canvas.y != canvasRef.y) ) {
      initGrid(canvas);
    }
    //update the reference
    canvasRef = canvas.copy() ;
    strokeRef = hexagonStroke ;
    radiusRef = hexagonRadius ;
    
    // DISPLAY
    noStroke() ;
    pushMatrix() ;
    translate(-width/2, -height/2) ;
    for (Hexagon h : grid) { h.calculateNewColor(); }
  
    // change the color of each hexagon cell to the new color and display it
    // this can be done in one loop because all calculations are already finished
    
    for (Hexagon h : grid) {
      h.changeColor();
      h.display(v, get_fill(),soundSizeFactor);
    }
    popMatrix() ;
    
    // new honeycomb
    if((birth_is())) {
      newHoneycomb = true ;
      birth_is(false);
    }
    
    if(newHoneycomb) {
      float r = random(1000000); // random number that is used by all the hexagon cells...
      for (Hexagon h : grid) { h.resetColor(r); } // ... to generate a new color
      newHoneycomb = false ;
    }
    
    
    // INFO
    item_info[ID_item] = (grid.size() + " hexagons") ;
  }
  
  
  
  // ANNEXE VOID
  // do everything needed to start up the grid ONCE
  public void initGrid(PVector canvas) {
  grid.clear(); // clear the grid
    
    // calculate horizontal grid size based on sketch width, hexagonRadius and a 'safety margin'
    int hX = PApplet.parseInt(canvas.x/hexagonRadius/3)+2;
    // calculate vertical grid size based on sketch height, hexagonRadius and a 'safety margin'
    int hY = PApplet.parseInt(canvas.y/hexagonRadius/0.866f)+3;
    
    // create the grid of hexagons
    for (int i=0; i<hX; i++) {
      for (int j=0; j<hY; j++) {
        // each hexagon contains it's xy position within the grid (also see the Hexagon class)
        grid.add(new Hexagon(i, j,hexagonRadius) );
      }
    }
    
    // let each hexagon in the grid find it's neighbours
    for (Hexagon h : grid) {
      h.getNeighbours(neighbourDistance);
    }
    
    // create the vertex positions for the hexagon
    for (int i=0; i<6; i++) {
      float r = hexagonRadius - hexagonStroke * 0.5f; // adapt radius to facilitate the 'simulated stroke'
      float theta = i*PI/3;
      v[i] = new PVector(r*cos(theta), r*sin(theta));
    }
  }

  /*

 Hexagon class to store a single cell inside a grid that can do the following things:
 - calculate it's own actual xy position based on it's ij coordinates within the grid
 - find it's neighbours within the grid based on a distance function
 - set it's color based on my own experimental color formula ;-)
 - calculate the average color of it's neighbours
 - calculate it's new color based on a set of rules
 - change it's current color by it's new color
 - display itself as a colored hexagon
 
*/

  private class Hexagon {
    float x, y; // actual xy position
    ArrayList <Hexagon> neighbours = new ArrayList <Hexagon> (); // arrayList to store the neighbours
    float currentColor, newColor; // store the current and new colors (actually just the hue)

    Hexagon(int i, int j, float radius) {
      x = 3*radius*(i+((j%2==0)?0:0.5f)); // calculate the actual x position within the sketch window
      y = 0.866f*radius*j; // calculate the actual y position within the sketch window
      resetColor(0); // set the initial color
    }

    public void resetColor(float r) {
      currentColor = (r+sin(x+r*0.01f)*30+y/6)%360; // could be anything, but this makes the grid look good! :D
    }

    // given a distance parameter, this will add all the neighbours within range to the list
    public void getNeighbours(float distance) {
      // neighbours.clear(); // in this sketch not required because neighbours are only searched once
      for (Hexagon h : grid) { // for all the cells in the grid
        if (h!=this) { // if it's not the cell itself
          if (dist(x,y, h.x,h.y) < distance) { // if it's within distance
            neighbours.add( h ); // then add it to the list: "Welcome neighbour!"
          }
        }
      }
    }
    
    // calculate the new color based on a completely arbitrary set of 'rules'
    // this could be anything, right now it's this, which makes the CA pretty dynamic
    // if you tweak this in the wrong way you quickly end up with boring static states
    public void calculateNewColor() {
      float avgColor = averageColor(); // get the average of the neighbours (see other method)
      float tmpColor = currentColor;
      if (avgColor < 0) {
        tmpColor = 50; // if the average color is below 0, set the color to 50
      } else if (avgColor < 150) {
        tmpColor += 5; // if the average color is between 0 and 150, add 5 to the color
      } else if (avgColor > 210) {
        tmpColor -= 5; // if the average color is above 210, subtract 5 from the color
      }
      // in all other cases (aka the average color is between 150 and 210) the color remains unchanged
      newColor = tmpColor;
    }
    
    // returns the average color (aka hue) of the neighbours
    public float averageColor() {
      float avgColor = 0; // start with 0
      for (Hexagon h : neighbours) {
        avgColor += h.currentColor; // add the color from each neighbour
      }
      avgColor /= neighbours.size(); // divide by the number of neighbours
      return avgColor; // done!
    }
    
    public void changeColor() {
      currentColor = newColor; // set the current color to the new(ly calculated) color
    }

    // display the hexagon at position xy with the current color
    // use the vertex positions that have been pre-calculated ONCE (instead of re-calculating these for each cell on each draw)
    public void display(PVector[] v, int in, float factor) {
      pushMatrix();
      translate(x, y);
      fill(currentColor, saturation(in), brightness(in), alpha(in));
      beginShape();
      for (int i=0; i<6; i++) { vertex(v[i].x *factor, v[i].y *factor); }
      endShape();
      popMatrix();
    }
  }
}
//end object two









/**
HORLOGE
2012-2018
v 1.0.12
*/

class Horloge extends Romanesco {
  public Horloge() {
    //from the index_objects.csv
    item_name = "Horloge" ;
    item_author  = "Stan Le Punk";
    item_version = "Version 1.0.12";
    item_pack = "Base 2012-2018" ;
    item_mode = "Ellipse Clock 12/Ellipse Clock 24/Line Clock 12/Line Clock 24/minutes/secondes";// separate the name by a slash and write the next mode immadialtly after this one.
    item_costume = "";

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    // hue_stroke_is = true;
    // sat_stroke_is = true;
    // bright_stroke_is = true;
    // alpha_stroke_is = true;
    // thickness_is = true;
    size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = true;
    speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is= true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  vec3 pos_clock = vec3() ; 
  int local_frameCount ;
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, -width) ;
    pos_clock = vec3(width/2,height/2,0) ;
  }
  
  
  
  
  //DRAW
  public void draw() {
    textAlign(CENTER);
    // typo
    float size_font = (get_size_x() *2) +12;
    if(sound_is()) size_font *= all_transient(ID_item);
    if(size_font < 1) size_font = 1;
    textFont(get_font(),size_font);
    
    // couleur du texte
    float t = alpha(get_fill()) * abs(mix[ID_item]) ;
    if (sound_is()) t = alpha(get_fill()) ;
    int c = color(hue(get_fill()), saturation(get_fill()), brightness(get_fill()), t ) ;
    // security against the blavk bug opacity
    if (alpha(c) == 0 ) {
      noFill() ; 
      noStroke() ; 
    } else {     
      fill (c) ; 
    }
    
    //rotation / deg
    float angle = get_angle();
    //amplitude
    float amp = map(get_area(), get_area_min(),get_area_max(), get_area_min() *.4f, get_area_max() *.2f) ;

    // pos clock
    if(motion_is()) {
      local_frameCount += 1 ;
      int direction = 1 ;
      if(reverse_is()) direction = -1 ;
      float speed_x = get_speed_x() *.1f ;
      float speed_y = get_speed_y() *.1f ;
      float speed_z = get_speed_z() *.1f ;
      float pos_x = sin(local_frameCount *speed_x *direction) *map(get_canvas_x(),width/10,width *r.PHI,0,width *r.PHI) ;
      float pos_y = cos(local_frameCount *speed_y *direction) *map(get_canvas_y(),width/10,width *r.PHI,0,width *r.PHI) ;
      float pos_z = sin(local_frameCount *speed_z *direction) *map(get_canvas_z(),width/10,width *r.PHI,0,width *r.PHI) ;
      pos_clock = vec3(pos_x,pos_y,pos_z) ;
    }

    
    //CHANGE MODE DISPLAY
    if (get_mode_id() == 0 ) {
      horlogeCercle (pos_clock, angle, amp, 12 ) ; // on 12 hours model english clock
    } else if (get_mode_id() == 1 ) {
      horlogeCercle (pos_clock, angle,  amp, 24 ) ; // on 24 hours model international clock
    } else if (get_mode_id() == 2 ) {
      horlogeLigne  (pos_clock, angle, amp, 12 ) ; // on 12 hours model english clock
    } else if (get_mode_id() == 3 ) {
      horlogeLigne  (pos_clock, angle, amp, 24 ) ; // on 24 hours model international clock
    } else if (get_mode_id() == 4 ) {
      horlogeMinute(pos_clock, angle) ;
    } else if (get_mode_id() == 5 ) {
      horlogeSeconde(pos_clock, angle) ;
    }

  }
  
  
  //ANNEXE
  public void horlogeCercle(vec3 posHorloge, float angle, float  amp, int timeMode) {
    //Angles pour sin() et cos() départ à 3h, enlever PI/2 pour un départ à midi
    float s = map (second(), 0, 60, 0,    TWO_PI ) - HALF_PI ;
    float m = map (minute(), 0, 60, 0,    TWO_PI ) - HALF_PI ;
    float h = map (hour() % 12, 0, 12, 0, TWO_PI ) - HALF_PI ;
    
    
    //seconde
    textAlign(CENTER, CENTER) ;
    translate(posHorloge.x, posHorloge.y, posHorloge.z) ;
    rotate(angle) ;
    text (nf(second(),2), cos(s)*amp*8 , sin(s)*amp*8 ) ;
    //minute
    text (nf(minute(),2), cos(m)*amp*6 , sin(m)*amp*6  ) ;
    //heure
    text(nf(hour()%timeMode ,2), cos(h)*amp*4 , sin(h)*amp*4  ) ;
    // text
    if ( timeMode == 12 ) if (hour() < 12 ) text("AM", 0, 0) ; else  text("PM", 0, 0 ) ; else text("TIME", 0, 0) ;
    
    textAlign(LEFT, TOP) ;
  }
  
  
  ////
  public void horlogeLigne(vec3 posHorloge, float angle, float amp, int timeMode) {
    //seconde
    textAlign(CENTER, CENTER) ;
    translate(posHorloge.x, posHorloge.y, posHorloge.z) ;
    rotate(angle) ;
    text( nf(hour()%timeMode,2)   + "." + 
          nf(minute(),2)   + "." + 
          nf(second(),2), 
          0, 0);
    textAlign(LEFT, TOP) ;
  }
  
  ////
  public void horlogeMinute(vec3 posHorloge, float angle) {
    textAlign(CENTER, CENTER) ;
    translate(posHorloge.x, posHorloge.y, posHorloge.z) ;
    rotate(angle) ;
    text(hour() *60 + minute() + " MINUTES", 0,0) ;
    textAlign(LEFT, TOP) ;
  }
  
  ////
  public void horlogeSeconde(vec3 posHorloge, float angle) {
    textAlign(CENTER, CENTER) ;
    translate(posHorloge.x, posHorloge.y, posHorloge.z) ;
    rotate(angle) ;
    text((hour() *3600) + (minute() *60) + second() + " SECONDES", 0,0) ;
    textAlign(LEFT, TOP) ;
  }
}
//end object one
/**
Kino
2018-2019
v 0.2.2
*/
class Kino extends Romanesco {
	public Kino() {
		item_name = "Kino";
		item_author  = "Stan le Punk";
		item_version = "Version 0.2.1";
		item_pack = "Base 2018-2019";
		item_costume = ""; // separate the differentes mode by "/"
		item_mode = "Movie/Diaporama/Movie 3D/Diaporama 3D"; // separate the differentes mode by "/"

		hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    // hue_stroke_is = true;
    // sat_stroke_is = true;
    // bright_stroke_is = true;
    // alpha_stroke_is = true;
    // thickness_is = true;
    // size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    // diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    spectrum_is = true;

    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    coord_x_is = true;
    // coord_y_is = true;
    // coord_z_is = true;
	}

	public void setup() {
		setting_start_position(ID_item,0,0,0);
		load_movie(true,ID_item);
	}

  float coord_ref;
	public void draw() {
    param();
    

    
    if(get_movie() != null && get_mode_id() != 0 && get_mode_id() != 2) {
      get_movie().pause();
    }

    boolean background_is = false;
		if(get_movie() != null && get_mode_id() == 2) {
			kino_movie(colour,FIT,background_is,to_white);
		} else if(get_mode_id() == 3) {
			kino_bitmap(colour,FIT,background_is,to_white);
		}

    if(parameter_is() && get_movie() != null) {
      if(coord_ref != get_coord_x()) {
        coord_ref = get_coord_x();
        float pos = get_coord_x() *get_movie().duration();
        get_movie().jump(pos);
      }     
    }
	}

  public void draw_2D() {
    param();
    boolean background_is = true;
    if(get_mode_id() == 0) {
      kino_movie(colour,CENTER,background_is,to_white);
    } else if(get_mode_id() == 1) {
      kino_bitmap(colour,CENTER,background_is,to_white);
    }
  }

  vec4 colour;
  int to_white = 0;
  // float speed_movie = 1;
  // float ref_speed_slider;
  public void param() {
    float h = get_fill_hue();
    float s = get_fill_sat();
    float b = get_fill_bright();
    float a = get_fill_alpha();
    if(colour == null) {
      colour = vec4(h,s,b,a);
    } else {
      colour.set(h,s,b,a);
    }
    // normalize colour
    colour.div(vec4(g.colorModeX,g.colorModeY,g.colorModeZ,g.colorModeA));
    colour.w(colour.x *colour.w *colour.w);

    // to make the colour to white or black
    if(reverse_is()) {
      to_white = 1;
    }

    // change the video speed 
    // if(ref_speed_x() != ref_speed_x) {
    // ref_speed_slider = get_speed_x();
    // float temp_speed = map(get_speed_x(),0,1,-1,1);
    // }

    // float temp_speed = get_speed_x() *get_speed_x() *get_speed_x();
    // temp_speed = map(temp_speed,0,1,0,30);
    // float range = .3;
    // if(temp_speed < 1. + range && temp_speed > 1. -range) temp_speed = 1.;
    // speed_movie = temp_speed;

  }
  
  // kino movie
  int ref_which_movie;
	private void kino_movie(vec4 c, int what, boolean background_is, int mode_to_black_or_white) {
		if(ref_which_movie != which_movie() && ref_which_movie < movie_time.length) {
      movie_time[ref_which_movie] = get_movie().time();
			load_movie(true,ID_item);
      if(movie_time[which_movie()] < get_movie().duration()) {
        get_movie().jump(movie_time[which_movie()]);
      }
			ref_which_movie = which_movie();
		} else {
			// need to write in case the movie path file change or new movie is imported
			load_movie(false,ID_item);
		}
    if(get_movie() != null) {
      // get_movie().speed(speed_movie);
  		if(motion_is()) {
        if(sound_is()) {
          get_movie().volume(1); 
        } else {
          get_movie().volume(0);
        }
  			get_movie().loop();
  		} else {
  			get_movie().pause();
  		}

      if(background_is) {
        // set_background(get_movie(),what);
        set_background(fx_level(get_movie(),false,mode_to_black_or_white,c.array()),what);
      } else {
        image(fx_level(get_movie(),false,mode_to_black_or_white,c.array()),what);
      }
    }
	}


	// kino movie
	private void kino_bitmap(vec4 c, int what, boolean background_is, int mode_to_black_or_white) {
		load_bitmap(ID_item);
    if(get_bitmap() != null) {
      if(background_is) {
        set_background(fx_level(get_bitmap(),false,mode_to_black_or_white,c.array()),what);
      } else {
        image(fx_level(get_bitmap(),false,mode_to_black_or_white,c.array()),what);
      }
    }
	}
}








/**
KOFOSPHERE 
2013-2019
v 1.2.2
*/
class Kofosphere extends Romanesco {
  public Kofosphere() {
    item_name = "Kofosphere" ;
    item_author  = "Kof";
    item_version = "Version 1.2.2";
    item_pack = "Base 2013-2019" ;
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12";
    item_mode = "monochrome/polychrome" ;
    /*
    item_costume = "";
    item_mode = "Point color/Point mono/Box color/Box mono" ;
    */
    // item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Stroke hue,Stroke sat,Stroke bright,Stroke alpha,Thickness,Size X,Size Y,Size Z,Canvas X,Quantity,Speed X" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is  = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL

  Sphere sphere;
  
  //SETUP
  public void setup() {
   setting_start_position(ID_item, width/2, height/2, 0) ;
   float startingRadius = width ;
   sphere = new Sphere(vec2(item_setting_position[0][ID_item].x,item_setting_position[0][ID_item].y),startingRadius);
 }
  
  
  
  
  //DRAW
  public void draw() {
    float beatFactor = map(all_transient(ID_item), 1,12, 1.f, 3.5f);
    float radius = map(get_canvas_x(), width/10, width, .01f, 1.1f);
    if(sound_is()) radius = sq(radius) *beatFactor ; 
    
    // quantity of particules
    float ratio_num = get_quantity() *get_quantity();
    int max = 300;
    int quantity = (int)map(ratio_num,0,1,10,max); 
    if(get_costume().get_type() == POINT_ROPE && FULL_RENDERING) {
      quantity *= 10;
    }
    
    // speed
    float ratio_speed = .1f ;
    float norm_speed = map(get_speed_x(),0,1,0,1.5f) ;
    norm_speed *= norm_speed ;
    if(reverse_is()) norm_speed *= ratio_speed ; else norm_speed *= -ratio_speed;
    vec2 speed = vec2(norm_speed) ;
    speed.mult(.5f +left[ID_item], .5f +right[ID_item]) ;

    // size for the box
    vec3 size = vec3(get_size_x(),get_size_y(),get_size_z()); 
    size.mult(2);
    sphere.drawSpheres(size,speed,radius,quantity,get_costume(),ID_item);

    
    // INFO
    item_info[ID_item] = ("Quantity " + quantity +  " - Speed ") ;

  }
  //
  private class Sphere{
    
    vec2 pos;
    float radius;
    float density = 6.f;
    float speedRotateX  ;
    float speedRotateY ;

    // CONSTRUCTOR
    private Sphere(vec2 pos, float radius){
      this.pos = pos.copy();
      this.radius = radius;
      // as always
      noiseSeed(19);
    }

    
    float newRadius ;
    public void drawSpheres(vec3 size, vec2 speed, float radiusFactor, float quantity, Costume costume, int ID) {
      boolean kofosphereInColor ;
      //color mode
      if(get_mode_id()==0) {
        kofosphereInColor = false; 
      } else {
        kofosphereInColor = true;
      }
      
      float number_quantity = 1500.f;
      quantity = (float)quantity *(1/number_quantity) ;
      // param
      speedRotateX += speed.x ;
      speedRotateY += speed.y ;
      //
      newRadius = radius *radiusFactor ;
      /// color
      float hueIn = hue(get_fill()) ;
      float saturationIn = saturation(get_fill()) ;
      float brightnessIn = brightness(get_fill()) ;
      float opacityIn = alpha(get_fill()) ;
      
      float hueOut = hue(get_stroke()) ;
      float saturationOut = saturation(get_stroke()) ;
      float brightnessOut = brightness(get_stroke()) ;
      float opacityOut = alpha(get_stroke()) ;

      
      pushMatrix();
      translate(pos);
      //speed rotation
      rotateX(speedRotateX);
      rotateY(speedRotateY);
      

      // int frequence = 100 ; KOF value
      float frequence = map(get_frequence(),1,0,1,200);
      if(frequence < 1) frequence = 1;
      float d = noise(frameCount/frequence)*(number_quantity +(number_quantity *quantity));
      density = 2.9f +(20*(1 -quantity));
      

      
      for(float f = -180 ; f < d; f += density){
        // we put this calcul here, because we don't need this calcul in the next loop.
        // it's more lighty for the computation
        if(kofosphereInColor) {
          hueIn = map(f,0,d,0,360) ;
          hueOut = map(f,0,d,0,360) ;
        }
        int c_fill = color(hueIn,saturationIn,brightnessIn,opacityIn);
        int c_stroke = color(hueOut,saturationOut,brightnessOut,opacityOut);
          
        for(float ff = -90 ; ff < 90; ff += density){
          
          // apparence
          // float max_factor = 250.; // KOF value
          float max_factor = width;
          float x = cos(radians(f)) *max_factor *cos(radians(ff));
          float y = sin(radians(f)) *max_factor *cos(radians(ff));
          float z = sin(radians(ff)) *max_factor;
          float ratio_size = modelZ(x,y,z);
          float factor_size = map(abs(ratio_size),0,max_factor,.005f,1);

          float thickness = get_thickness();
          vec3 def_size = size.copy();
          boolean use_factor_is = true;
          if(use_factor_is) {
            thickness *= factor_size;
            def_size.mult(factor_size);
          }
          
          // position
          float pos_x = cos(radians(f)) *newRadius *cos(radians(ff));
          float pos_y = sin(radians(f)) *newRadius *cos(radians(ff));
          float pos_z = sin(radians(ff)) *newRadius;
          float deform = noise((frameCount +lerp(f,ff,noise((frameCount+ff)/222.0f))) *.003f) *1.33f;
          
          // display
          aspect(c_fill,c_stroke,thickness);
          aspect_is(fill_is(),stroke_is());
          set_ratio_costume_size(map(get_area(),width*.1f, width*TAU,0,1));
          vec3 pos = vec3(pos_x *deform, pos_y *deform, pos_z *deform);
          costume(pos,def_size,costume);
          
        }
      }

      // axis();
      popMatrix();

    }

    public void axis(){
      stroke(255,20);
      strokeWeight(3);
      line(-200,0,0,200,0,0);
      line(0,-200,0,0,200,0);
      line(0,0,-200,0,0,200);
    }
  }
}




/**
LETTER
2012-2019
v 1.4.4
*/
//GEOMERATIVE


class Letter extends Romanesco {
  public Letter() {
    item_name = "Letter" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.4.4";
    item_pack = "Base 2012-2019" ;

    item_costume = "Point/Line/Triangle";
    item_mode = "";
    // define slider
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    // diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    jit_x_is = true;
    jit_y_is = true;
    jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  RFont f;
  RShape grp;
  
  int sizeRef, sizeFont ;
  String sentenceRef = ("") ; 
  String pathRef = ("") ;
 
  int whichLetter ;
  int axeLetter ;
  int startDirection = -1 ;
  int numLetter ;

  
  //SETUP
  public void setup() {
    setting_start_position(ID_item,width/2,height/2,0);
    geomerative.RG.init(papplet); // Geomerative
  }
  
  
  
  
  //DRAW
  float speed = 0 ;
  String sentence;
  public void draw() {
    load_txt(ID_item) ;
    // test the font is a ttf or not
    boolean warning_font = false;
    if(!get_font_type().equals("ttf") && !get_font_type().equals("TTF")) {
      select_font_type("ttf");
      warning_font = true;
    }

    sizeFont = PApplet.parseInt(map(get_size_x(),get_size_x_min(), get_size_x_max(), (float)height *.01f, (float)height *.7f));
    int max_string = 49;
    if(get_text().length() < max_string) max_string = get_text().length();
    sentence = get_text().substring(0,max_string);
    

    //check if something change to update the RG.getText
    boolean reset = false;
    boolean reset_font = false;

    if (sizeRef != sizeFont || !sentenceRef.equals(sentence) || !pathRef.equals(get_font_path())) {
      sizeRef = sizeFont;
      sentenceRef = (sentence);
      pathRef = get_font_path();
      reset = true;
      reset_font = true;
    } else if(birth_is()) {
      reset = true; 
      birth_is(false);
    } 

    update(reset,reset_font);

    // INFO
    String warning_font_type = "font type accepted is TTF";
    if(warning_font) warning_font_type = "font type is not TTF, instead class Letter use a first TTF from library";
    info("Quantity of letter display:",numLetter," - Speed:",PApplet.parseInt(speed*100),"font",get_font_name(),warning_font_type);

  }


  public void update(boolean reset,boolean reset_font) {
    if(grp == null) {
      grp = geomerative.RG.getText(sentence,get_font_path(),(int)sizeFont,CENTER);
    }
    if(reset || reset_font) {
      grp = geomerative.RG.getText(sentence,get_font_path(),(int)sizeFont,CENTER);
      axeLetter = PApplet.parseInt(random (grp.countChildren()));
    }

    if(reverse_is()) {
      int choiceDir = floor(random(2));
      if(choiceDir == 0 ) {
        startDirection = -1; 
      } else {
        startDirection = 1;
      }
    }
    
    if(all_transient(ID_item) > 10 || key_n ) {
      axeLetter = PApplet.parseInt(random (grp.countChildren())) ;
    }

    /////////
    //ENGINE
    if(motion_is()) {
      if(sound_is()) {
        speed = map(get_speed_x()*get_speed_x(),0,1,0.f,.3f) *tempo[ID_item];
      } else {
        speed = map(get_speed_x()*get_speed_x(),0,1,0.f,.1f);
      } 
    } else {
      speed = 0;
    }
    //to stop the move
    //if (!action_is()) speed = 0.0 ; 
    if(reverse_is()) speed = -speed ;
    
    //num letter to display
    numLetter = (int)map(get_quantity(),0,1, 0,grp.countChildren() +1) ;
    
    //DISPLAY
    // thickness
    float thicknessLetter = map(get_thickness(), .1f, height/3, 0.1f, height /10) ; ;

    // color
    if(get_costume().get_type() != TRIANGLE_ROPE) {
      noFill() ; 
      stroke(get_fill()) ; 
      strokeWeight(thicknessLetter) ;
    } else {
      fill(get_fill()) ; 
      stroke(get_stroke()) ; 
      strokeWeight(thicknessLetter) ;
    }
    //jitter
    float jitterX = map(get_jitter_x(),0,1, 0, (float)width *.1f) ;
    float jitterY = map(get_jitter_y(),0,1, 0, (float)width *.1f) ;
    float jitterZ = map(get_jitter_z(),0,1, 0, (float)width *.1f) ;
    vec3 jitter = vec3(jitterX *jitterX, jitterY *jitterY, jitterZ *jitterZ) ;

    letters(speed, axeLetter, jitter) ;
    //END YOUR WORK

  }
  
  
  // ANNEXE
  float rotation ;
  
  public void letters(float speed, int axeLetter, vec3 jttr) {
    if (sound_is()) {
      whichLetter = (int)all_transient(ID_item) ; 
    } else {
      whichLetter = 0 ;
    }
    
    //security against the array out bounds
    if(whichLetter < 0 ) {
      whichLetter = 0 ; 
    } else if (whichLetter >= grp.countChildren()) {
      whichLetter = grp.countChildren() -1  ;
    }

    wheelLetter(numLetter, speed, jttr) ;

    
    if(axeLetter < 0 ) {
      axeLetter = 0 ; 
    } else if (axeLetter >= grp.countChildren()) {
      axeLetter = grp.countChildren() - 1 ;
    }
    displayLetter(axeLetter,jttr);
  }





  
  int whichOneChangeDirection = 1 ;
  
  public void wheelLetter(int num, float speed, vec3 jttr) {
    // direction rotation for each one
    if(frameCount%160 == 0 || key_n) whichOneChangeDirection = round(random(1,num)) ;
    //position
    for (int i = 0 ; i < num ; i++) {
      int targetLetter ;
      targetLetter = whichLetter +i ;
      if (targetLetter < grp.countChildren() ) {
        if(i%whichOneChangeDirection == 0 ) {
          speed  = speed *-1  ;
        }
        speed = speed *startDirection ;
        if(speed != 0) {
          grp.children[targetLetter].rotate(speed, grp.children[axeLetter].getCenter());
        }
        displayLetter(targetLetter,jttr);
      }
    }
  }
  
  public void displayLetter(int which, vec3 ampJttr) {
    RPoint[] pnts = grp.children[which].getPoints(); 
    vec3 [] points = geomerativeFontPoints(pnts);

    for (int i = 0; i < points.length; i++) {
      points[i].add(jitterPVector(ampJttr));
      float factor = 40.f;
      points[i].z = points[i].z +(all_transient(ID_item) *factor); 
      if(get_costume().get_type() == POINT_ROPE ) point(points[i]);
      if(get_costume().get_type() == LINE_ROPE ) if(i > 0 ) line( points[i-1],points[i]);
      if(get_costume().get_type() == TRIANGLE_ROPE ) if(i > 1 ) {
        beginShape();
        vertex(points[i-2]);
        vertex(points[i-1]);
        vertex(points[i]);
        endShape(CLOSE);
        // triangle(points[i-2].x, points[i-2].y, points[i-2].z,   points[i-1].x, points[i-1].y, points[i-1].z, points[i].x, points[i].y, points[i].z );
      }
      
    }
  }
  
  //ANNEXE VOID
  //jitter for PVector points
  public vec3 jitterPVector(vec3 range) {
    float factor = 0.0f ;
    if(sound_is()) factor = 2.0f ; else factor = .1f;
    int rangeX = PApplet.parseInt(range.x *left[ID_item] *factor);
    int rangeY = PApplet.parseInt(range.y *right[ID_item] *factor);
    int rangeZ = PApplet.parseInt(range.z *mix[ID_item] *factor);
    vec3 jitting = vec3();
    jitting.x = random(-rangeX, rangeX);
    jitting.y = random(-rangeY, rangeY);
    jitting.z = random(-rangeZ, rangeZ);
    return jitting;
  }
  
  //void work with geomerative
  public vec3 [] geomerativeFontPoints(RPoint[] p) {
    vec3 [] pts = new vec3[p.length] ;
    for(int i = 0 ; i < pts.length ; i++) {
      pts[i] = vec3();
      pts[i].x = p[i].x ; 
      pts[i].y = p[i].y ;  
    }
    return pts ;
  }
}






/**
LIGNES
2011-2019
v 1.2.5
*/
Line line ;
//object three
class Lignes extends Romanesco {
  public Lignes() {
    item_name = "Lignes" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.2.5";
    item_pack = "Base 2011-2019" ;
    item_costume = "" ;
    item_mode = "Lines 1/Lines 2/Lines 3/Lines 4/Lines 5/Lines 6" ;

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    // hue_stroke_is = true;
    // sat_stroke_is = true;
    // bright_stroke_is = true;
    // alpha_stroke_is = true;
    thickness_is = true;
    // size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    angle_is = true;
    // scope_is = true;
    // scan_is = true;
    align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
  float ampLine  =1.0f ;
  float speed ;
  float thicknessLine ;
  //SETUP
  public void setup() {
    setting_start_position(ID_item, 0, 0, -width) ;
    line = new Line() ;
  }
  
  //DRAW
  public void draw() {
    if(transient_value[0][ID_item] > 1 ) {
      ampLine = transient_value[0][ID_item] *(map(get_swing_x(), 0,1, 0, 3)) ;
      thicknessLine = (get_thickness() *ampLine ) ;
    } else {
      thicknessLine = get_thickness() ;
    }

    //speed
    if(motion_is()) {
      speed = map(get_speed_x()*get_speed_x(),0,1,0,height/20) * tempo[ID_item]; 
    } else {
      speed = 0;
    }
    
    if(reverse_is()) speed = speed *1 ; else speed = speed * -1 ;

    // size canvas
    float canvas_x = map(get_canvas_x(),get_canvas_x_min(),get_canvas_x_max(), width/2, width *4);
    float canvas_y = map(get_canvas_y(),get_canvas_y_min(),get_canvas_y_max(), height/2, height *4);
    vec2 canvas = vec2(canvas_x,canvas_y);

    //quantity
    float ratio_num = map(get_quantity()*get_quantity(),0,1,1,100);

    int step_angle = (int)map(get_angle(),0,TAU,0,360);
    float step_rotate = map(get_alignment(),0,1,0,TAU);
    

    // this loop is a bullshit must be refactor, 
    // because mode[ID_item] have allways a same value after the mode is selected from controller
    for(int i = 0 ; i < 6 ; i++) {
      int num_grid = i +1 ;
      if(get_mode_id() == i) {
        loop_display_line(num_grid, step_angle, step_rotate /num_grid, canvas, ratio_num, speed, thicknessLine);
      }
    }
  }

  public void loop_display_line(int num_grid, int step, float step_rotate, vec2 canvas, float ratio_num, float speed, float thickness) {
    for(int i = 0 ; i < num_grid ; i++) {
      int angle = step *i ;
      float rotation_grid = step_rotate *i ;
      pushMatrix() ;
      rotateX(rotation_grid) ;
      display_line(canvas, ratio_num, speed / (i +1), thicknessLine,angle) ;
      popMatrix() ;
    }
  }

  

  public void display_line(vec2 canvas, float ratio_num, float speed, float thickness, int start_angle_deg) {
    float direction = get_dir_x() +start_angle_deg ;
    rotation(direction, 0, 0) ;
    //display
    line.drawLine (speed,ratio_num,get_fill(),thickness, canvas) ;

  }
}
//end 





//CLASS TRAME
class Line {
  Line()  { }
  
  // float nbrlgn ; 
  float speed;
  float vd, vg ;
  
  public void drawLine (float v, float ratio_num, int c, float e, vec2 canvas) {
    if( e < 0.1f ) e = .1f; //security for the negative value
     strokeWeight(e);
    // security against the black brightness bug opacity
    if (alpha(c) == 0) {
      noStroke(); 
    } else {
      stroke(c);
    }

    float num = ratio_num;
    float reset_speed = (canvas.x + canvas.y) /num;
    speed += (v);
    
    if ( abs(speed) > reset_speed) {
      speed = 0 ; 
    }
    
    for (int i=0 ; i < num +1 ; i++) {
      float x1 = ( -(canvas.y) +i*((canvas.x+ canvas.y) /num)) +speed -e;
      float y1 = -e ;
      float x2 =  (0 +i*((canvas.x +canvas.y) /num)) +speed +e;
      float y2 = canvas.x+canvas.y +e;
      line (x1,y1,x2,y2);
    }
  }
}
/**
Lorenz attractor
2016-2019
v 0.1.4
Inspirated by Nature of Code of Daniel Shiffman
*/
/*
* @see https://www.youtube.com/watch?v=f0lkz2gSsIk&list=PLRqwX-V7Uu6ZiZxtDDRCi6uhfTH4FilpH&index=15
* @see https://en.wikipedia.org/wiki/Lorenz_system
*/
class Lorenz extends Romanesco {
	public Lorenz() {
		item_name = "Lorenz attractor";
		item_author  = "Stan le Punk";
		item_version = "Version 0.1.4";
		item_pack = "Nature of Code 2016-2019";
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5";
    item_mode = "Costume/Surface";

	  hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    jit_x_is = true;
    jit_y_is = true;
    jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }

  float a = 10;
  float b = 28;
  float c = 8.f / 3.f;
  vec3 pos;
  ArrayList<vec3> list_points;



  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0);
  }



	public void draw() {
    if(list_points == null) {
      pos = vec3(.01f, 0, 0) ;
      list_points = new ArrayList<vec3>() ;
    } else {
      build_lorenz_attractor(list_points) ;
      if(alpha(get_fill()) > 0 || get_thickness() > 0) {
        float canvas = get_canvas_x() *.01f ;
        vec3 jitter = get_jitter().copy();
        jitter.mult(height/10) ;
        vec3 size = get_size().copy();
        vec3 dir = get_dir().copy();
        fill(get_fill());
        stroke(get_stroke());
        strokeWeight(get_thickness());
        set_ratio_costume_size(map(get_area(),width*.1f, width*TAU,0,1));
        show_lorenz_attractor(size,dir,canvas,jitter,list_points,get_mode_id(),get_costume());
      }


      // keep the size of list reasonable :)
      int max = 5000 ;
      if(!FULL_RENDERING) max /= 50 ;
      int threshold = 2 + PApplet.parseInt(get_life() *max);
      if(list_points.size() > threshold) {
        int remove_size = list_points.size() - threshold;
        for(int i = 0 ; i < remove_size ; i++) {
          if(i < list_points.size()) list_points.remove(i);
        }  
      }
    }    
  }



  private void build_lorenz_attractor(ArrayList<vec3> list) {
    float dt = .01f ;
    vec3 d = vec3() ;
    d.x = (a * (pos.y -pos.x)) *dt ;
    d.y = (pos.x * (b -pos.z) - pos.y) *dt ;
    d.z = (pos.x * pos.y -c *pos.z) *dt ;
    
    pos.add(d) ;
    vec3 final_pos = pos.copy() ;
    list.add(final_pos) ;
  }


  private void show_lorenz_attractor(vec3 size, vec3 dir, float canvas, vec3 jitter, ArrayList<vec3> list, int mode, Costume costume) {

    if(mode == 1 ) beginShape() ;
    for(vec3 p : list) {
      vec3 pos = p.copy() ;
      pos.mult(canvas,canvas,1);
      vec3 offset = pos.copy().div(2);
      pos.sub(offset.x,offset.y,0);
      pos.jitter(jitter);
      if(mode == 1) {
        vertex(pos) ;
      } else {
        costume(pos,size,dir,costume);
      }
    }
    if(mode == 1) endShape() ;
  }
}












/**
* Wave
* 2019-2019
* v 0.0.4
*/
class Mer extends Romanesco {
  public Mer() {
    //from the index_objects.csv
    item_name = "Mer" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 0.0.4";
    item_pack = "Base 2019-2019" ;
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12"; // costume available from get_costume();
    item_mode = "";
    // define slider
    // COL 1
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    //size_z_is = true;
    diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;
    // COL 2
    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    //dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;
    // COL 3
    quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;  
  }

  int cols = 2;
  int rows = 2;
  int cell_x = 2;
  int cell_y = 2;
  int offset_x = cell_x/2;
  int offset_y = cell_y/2;
  Wave [] ani ;
  boolean build_sea_is;

  public void setup() {
    // give the starting position of your item on the 3D grid
    ani = new Wave[cols*rows];
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  //DRAW
  
  public void draw() {
    info("info about the item","more","more");
  }
  
  
  public void draw_2D() {
    // here if you want code in 2D mode
    if(birth_is()) {
      build_sea_is = false;
      birth_is(false);
    }
    if(!build_sea_is) {
      cols = (int)map(get_canvas_x(),0,get_canvas_x_max(),2,width/10);
      rows = (int)map(get_canvas_y(),0,get_canvas_y_max(),2,height/10);
      ani = new Wave[cols*rows];
      cell_x = width/cols;
      cell_y = height/rows;
      offset_x = cell_x/2;
      offset_y = cell_y/2;
      float min_size_wave = 5;
      vec2 size_max_wave = vec2(get_size_x(),get_size_y());
      float start_hue_fill = get_fill_hue();
      build_sea_grid(min_size_wave,size_max_wave,get_speed_x(),start_hue_fill);
      build_sea_is = true;
    }

    // show
    // float max_speed = get_speed_x();
    int count = 0;
    for(int j = 0; j < rows ; j++) {
      for(int i = 0 ; i < cols ; i++) {  
        int x = i * cell_x +offset_x;
        int y = j * cell_y +offset_y;
        if(count < ani.length) {
          ani[count].update();
          // ani[count].set_speed(get_speed_x());
          // ani[count].set_radius(get_size_x(),get_size_y());
          ani[count].apparence(get_fill_alpha(),get_stroke_alpha(),get_thickness());
          ani[count].render_shape(x,y,get_diameter(),get_costume());
          count++; 
        }
      }
    }
    // int count = 0;
    // for(int i = 0; i < cols ; i++) {
    //   for(int j = 0 ; j < rows ; j++) {  
    //     int x = i * cell_x +offset_x;
    //     int y = j * cell_y +offset_y;
    //     if(count < ani.length) {
    //       ani[count].update();
    //       // ani[count].set_speed(get_speed_x());
    //       // ani[count].set_radius(get_size_x(),get_size_y());
    //       ani[count].apparence(get_fill_alpha(),get_stroke_alpha(),get_thickness());
    //       ani[count].render_shape(x,y,get_diameter(),get_costume());
    //       count++; 
    //     }
    //   }
    // }
    // info("info about the item","more","more");
  }


  public void build_sea_grid(float min, vec2 range, float max_speed, float start_hue) {
    for(int i = 0 ; i < ani.length ; i++) {
      ani[i] = new Wave();
      ani[i].set_start_hue(start_hue);
      ani[i].set_speed(random(-max_speed,max_speed)*.1f);
      ani[i].set_radius(random(min,range.x),random(min,range.y));
    }
  }


  private class Wave {
    float dir;
    float speed;
    float rx;
    float ry;
    int cycle = 0;
    float start_hue =0;

    Wave() {}

    public void reset_cycle() {
      cycle = 0;
    }

    public void set_speed(float speed) {
      this.speed = speed;
    }

    public void set_start_hue(float start_hue) {
      this.start_hue = start_hue;
    }


    public void set_radius(float rx, float ry) {
      this.rx = rx;
      this.ry = ry;
    }

    public void update() {
      dir += speed;
      cycle++;
    }

    public void apparence(float fill_alpha, float stroke_alpha, float thickness) {
      float hue = (cycle*speed+start_hue)%g.colorModeX; // ici c'est égale à 360, définit avec colorMode dans le setup;
      float saturation = g.colorModeY;
      float brightness = g.colorModeZ;
      int colour_fill = color(hue,saturation,brightness,fill_alpha);
      int colour_stroke = color(hue,saturation,brightness,stroke_alpha);
      // println(hue,saturation,brightness,fill_alpha);
      // println(colour_fill,colour_stroke,thickness);
      aspect(colour_fill,colour_stroke,thickness);
      // fill(r.WHITE);
    }

    public void render_shape(int x, int y, float max_size, Costume costume) {
      vec2 pos = to_cartesian_2D(dir);
      pos.mult(rx,ry);
      float size = abs(sin(frameCount *speed) *max_size);
      push();
      translate(x,y);
      costume(vec3(pos),vec3(size),costume);
      pop();
    }
  }
  //
}
















/**
ORBITAL
2015-2019
v 0.0.5
*/
class Orbital extends Romanesco {
  float r_min;
  float r_max;
 
  // Shape spreaded dimensions
  float spreadL;
  float spreadW;
 
  // Process
  PVector rfactors = new PVector();
  PVector rotation = new PVector();
  PVector rotationToReach = new PVector();
 
  // attributes
  int iterations;
  float offset;
  float rad;
  float vel;
  int dir;
  float smoothf;
  float initialForce;
 
  Flock_Orbital flock;
 
  public Orbital() {
    item_name = "Orbital" ;
    item_author  = "Alexandre Petit";
    item_version = "Version 0.0.5";
    item_pack = "Workshop 2015-2019" ;
    item_costume = "" ; // separate the differentes mode by "/"
    item_mode = "" ; // separate the differentes mode by "/"
    /** 
    List of the available sliders
    "Hue fill,Saturation fill,Brightness fill,Alpha fill,Hue stroke,Saturation stroke,Brightness stroke,Alpha stroke,Thickness,
    Size X,Size Y,Size Z,Canvas X,Canvas Y,Canvas Z,Quantity,
    Speed,Direction,Angle,Amplitude,Analyze,Family,Life,Force" ; 
    */
    // item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Stroke hue,Stroke sat,Stroke bright,Stroke alpha,Quantity,Speed X" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = false;
    size_x_is = false;
    size_y_is = false;
    size_z_is = false;
    diameter_is = false;
    canvas_x_is = false;
    canvas_y_is = false;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = true;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
 
  // Main method
  // setup
  public void setup() {

    setting_start_position(ID_item, width/2, height/2, 0);
    setting_start_direction(ID_item, 45, 45);

    flock = new Flock_Orbital();
  
    dir = 0;
    vel = radians(2);//radians(8);
    rad = 100;
    offset = 20;
    iterations = 16; // [!] iterations is binded to band. Do not go over 16 (band count) !!
    smoothf = .05f;
    initialForce = 10;
  
    r_max = max(width, height) * .8f;
    r_min = max(width, height) * .2f;
    resetOrbit();
  }
 
  // draw
  public void draw() {
    // it's nice to code the variable from the sliders or from sound... here to see easily what's happen in your object.
    float quantity = map(get_quantity(), 0, 1, .001f, 1) ;

    // display
    orbital_1(quantity) ;

    item_info[ID_item] = ("There is " + flock.size() + " orbital shape") ;
    

  }
 
  public void orbital_1(float quantity) {
    update(quantity);
    render();
  }
 
 
  public void update(float quantity) {
  
    checkControls();
  
    rotationToReach.x += rfactors.x * vel * get_speed_x();
    rotationToReach.y += rfactors.y * vel * get_speed_x();
    rotationToReach.z += rfactors.z * vel * get_speed_x();
    rotation.x += (rotationToReach.x - rotation.x) * smoothf;
    rotation.y += (rotationToReach.y - rotation.y) * smoothf;
    rotation.z += (rotationToReach.z - rotation.z) * smoothf;
    normaliseRotation(); // keep values between 0 and 2PI // FIXME
  
  
    Boid_Orbital b;
    PVector force = new PVector(initialForce *transient_value[2][ID_item], 0, 0);
    int it = ceil(iterations *quantity);
    if(!FULL_RENDERING) it /= 10 ;
    float lSpreadL = 1 ;
    float lSpreadW = 1 ;
    for(int i = 0; i < it; i++) {
        if (sound_is() && i < NUM_BANDS) {
            lSpreadL = spreadL * band[ID_item][i];
            lSpreadW = spreadW * band[ID_item][i];
        }
        b = new Boid_Orbital(offset + (float)i/iterations * (rad * mix[ID_item]), 0, 0, rotation, spreadW, lSpreadL);
        b.applyForce(force);
        flock.addBoid(b);
      
       
        rotation.mult(-1);
        b = new Boid_Orbital(offset + (float)i/iterations * (rad * mix[ID_item]), 0, 0, rotation, spreadW, lSpreadW);
        b.applyForce(force);
        flock.addBoid(b);
        rotation.mult(-1);
    }
  
    flock.update();
  }
 
  public void checkControls() {
     if (key_n && action_is()) randomPos();
     // else if (key_j) ;//randomiserad = D_MIN + random(D_MAX - D_MIN);
     else if (key_o && action_is()) resetOrbit();
     else if (reverse_is()) jump();
  }
 
  public void render() {
      //flock.render();
      flock.render(hue(get_fill()),
                   saturation(get_fill()),
                   brightness(get_fill()),
                   alpha(get_fill()),
                  
                   hue(get_stroke()),
                   saturation(get_stroke()),
                   brightness(get_stroke()),
                   alpha(get_stroke())
               );
                 
  }
 
  public void changeDir() {
    int aux;
    do aux = (int)random(3);
    while(aux == dir);
    dir = aux;
  
    rfactors.set(0,0,0);
  
    switch(dir) {
      case 0 : rfactors.x = 1; break;
      case 1 : rfactors.y = 1; break;
      case 2 : rfactors.z = 1; break;
    }
  }
 
  public void randomDir() {
    rfactors.x = random(1);
    rfactors.y = random(1);
    rfactors.z = random(1);
  }
 
  public void randomPos() {
    rotationToReach.x = random(TWO_PI);
    rotationToReach.y = random(TWO_PI);
    rotationToReach.z = random(TWO_PI);
  }
 
  public void resetOrbit() {
     rotationToReach.set(0,0,0);
     rfactors.set(0,radians(90),0);
  }
 
  public void jump() {
    int amp = 30 ;
    rotationToReach.x = rotation.x;
    rotationToReach.y = rotation.y;
    rotationToReach.z = radians(random(-amp,amp));
  }
 
  // Normalise interpolation before value interpolation
  public void normaliseRotation() {
     rotation.x = radians(degrees(rotation.x));
     rotation.y = radians(degrees(rotation.y));
     rotation.z = radians(degrees(rotation.z));
  }
 
 
}


// ----------------------------------------------------------------------------------------------------------------------------------------
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

// Flock class
// Does very little, simply manages the ArrayList of all the boids

class Flock_Orbital {
  ArrayList<Boid_Orbital> list_boids_orbital; // An ArrayList for all the boids

  Flock_Orbital() {
      list_boids_orbital = new ArrayList<Boid_Orbital>(); // Initialize the ArrayList
  }

  public void update() {
  
      Boid_Orbital b;
      int size = list_boids_orbital.size();
      for(int i = size-1; i>=0; i--) {
          b = list_boids_orbital.get(i);
          if (b.isDead()) {
              list_boids_orbital.remove(i);
          } else {
              b.update();
          }
      }
  }
 
  public void render() {
     render(360,0,100,100, 360,0,100,100);
  }
 
  public void render(float fillH, float fillS, float fillB, float fillA, float strokeH, float strokeS, float strokeB, float strokeA) {
     for(Boid_Orbital b : list_boids_orbital) {
         pushMatrix();
         rotate(b.rotation.x, 1, 0, 0);
         rotate(b.rotation.y, 0, 1, 0);
         rotate(b.rotation.z, 0, 0, 1);
  
         b.render(fillH, fillS, fillB, fillA, strokeH, strokeS, strokeB, strokeA);  // Passing the entire list of boids to each boid individually
         popMatrix();
      }
  }

  public void addBoid(Boid_Orbital b) {
      list_boids_orbital.add(b);
  }


  public int size() {
    return list_boids_orbital.size();
  }
 
  public void clear() {
      list_boids_orbital.clear();
  }
}


// ---------------------------------------------------------------------------------------------------------------------------
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

// Boid class
// Methods for Separation, Cohesion, Alignment added

class Boid_Orbital {

  PVector location;
  PVector velocity;
  PVector acceleration;
 
  float maxforce;    // Maximum steering force
  float maxspeed;    // Maximum speed
  float friction;    // Friction
 
  PVector rotation;
  PVector source;
 
  int lifetime;
  int life;
 
  
  float L = 20;
  float W = 1;
 
  Boid_Orbital(float x, float y, float z, PVector _rotation, float _w, float _l) {
    acceleration = new PVector(0,0,0);
    velocity = new PVector(0,0,0);
    location = new PVector(x,y,z);
    lifetime = 300;
    life = lifetime;
    rotation = _rotation.get();
    source = location.get();
    maxspeed = 30;
    maxforce = 4;
    friction = .97f;
  }

  // Method to update location
  public void update() {
  // Update velocity
    velocity.mult(friction);
    velocity.add(acceleration);
    // Limit speed
    velocity.limit(maxspeed);
    location.add(velocity);
    // Reset accelertion to 0 each cycle
    acceleration.mult(0);
  
    --life;
  }
 
  public void render(float fillH, float fillS, float fillB, float fillA, float strokeH, float strokeS, float strokeB, float strokeA) {
  
    float theta = velocity.heading2D() + radians(90);
    float alphaAmt = processAlpha();
  
    if (fillA > 0) {
        fill(fillH, fillS, fillB, fillA * alphaAmt);
    } else {
        noFill();
    }
  
    if (strokeA > 0) {
        stroke(strokeH, strokeS, strokeB, strokeA * alphaAmt);
    } else {
        noStroke();
    }
  
    pushMatrix();
    translate(location.x,location.y, location.z);
    rotate(theta);
  
    //box(r);
    //sphere(r);
    if (W == L) {
        box(W);
    } else {
        beginShape(TRIANGLE_STRIP);
        vertex(-W, -L);
        vertex(-W,  L);
        vertex( W,  L);
        vertex( W, -L);
        endShape();
    }
  
    popMatrix();
  }

  public void applyForce(PVector force) {
    // We could add mass here if we want A = F / M
    acceleration.add(force);
  }
 
  public boolean isDead() {
     return life <= 0 || (acceleration.mag() + velocity.mag()) < 1;
  }
 
  public float processAlpha() {
     return (float)life/lifetime;
  }
}
/**
* Pulsar
* 2018-2019
* v 0.0.8
*/

//object one
class Pulsar extends Romanesco {
  Cloud_3D pulsar;

  public Pulsar() {
    item_name = "Pulsar" ;
    item_author  = "Stan le Punk";
    item_version = "version 0.0.8";
    item_pack = "Base 2018-2019";
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/star";
    item_mode = "nothing/cyclus/heart/ring cyclus/ring heart/helmet cyclus/helmet heart" ;
    // item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Thickness,Size X,Size Y,Canvas X,Canvas Y,Quantity,Reactivity,Angle,Life,Spurt X,Flow,Direction X,Direction Y" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = true;
    speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    // jit_x_is = true;
    //jit_y_is = true;
    // jit_z_is = true;
    swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }

  
  //SETUP
  public void setup() {
    setting_start_position(ID_item,width/2, height/2,0);
  }
  //DRAW
  int num_ref ;
  public void draw() {
    float num_temp = get_quantity();
    num_temp = num_temp *num_temp *num_temp;
    int num = PApplet.parseInt(5 + (5000 *num_temp));
    if(pulsar == null || num_ref != num) {
      pulsar = new Cloud_3D(p5, num,P3D,r.ORDER,r.POLAR);
      num_ref = num;
    } else {
      pulsar();
    }
  }


  public void pulsar() {
    int radius = (int)get_canvas_x();

    vec3 speed = vec3(get_speed_x(),get_speed_y(),get_speed_z());
    speed.pow(3).div(2);

    // cloud_3D.ring(.01, false);
    // cloud_3D.helmet(.005, false);
    float ratio_size = map(get_area(),width*.1f, width*TAU,0,1);
    pulsar.size(get_size_x(),get_size_y(),get_size_z());
    // cloud_3D.size((height/4) *abs(sin(frameCount *.01)));
    // cloud_3D.orientation_y(map(mouseY,0,height,-PI,PI));
    // cloud_3D.angle(frameCount *.01);
    aspect(get_fill(), get_stroke(), get_thickness());
    



    // rendering


    if(motion_is()) {
      pulsar.rotation_x(speed.x,false);
      pulsar.rotation_y(speed.y,false);
      pulsar.rotation_z(speed.z,false);
      pulsar.orientation(get_dir());

      mode();
      float swing = get_swing_x() *get_swing_x();
      swing = map(swing,0,1,0,80);

      pulsar.set_tempo((int)swing);
      if(!sound_is()) {

        // pulsar.set_tempo(80);   
      } else {
        // pulsar.set_tempo((int)tempo[ID_item]); 
        float ratio_transient = all_transient(ID_item);
        radius *= (ratio_transient *.2f);
      }

    } else {
      pulsar.set_behavior("RADIUS"); // nothing
    }
    pulsar.set_radius(radius);

    vec3 pos = vec3();
    
    pulsar.pos(pos);
    pulsar.update();

    pulsar.costume_ratio_size(ratio_size);
    pulsar.costume(get_costume());
    pulsar.show();
  }



  public void mode() {
    if(get_mode_id() == 0) {
      pulsar.set_behavior("RADIUS"); // nothing
    } else if(get_mode_id() == 1) {
      pulsar.set_behavior("SIN"); // cyclus

    } else if(get_mode_id() == 2) {
      pulsar.set_behavior("SIN_POW_SIN"); // heart

    } else if(get_mode_id() == 3) {
      pulsar.set_behavior("SIN"); // cyclus ring
      pulsar.ring(.01f, false);
    } else if(get_mode_id() == 4) {
      pulsar.set_behavior("SIN_POW_SIN"); // heart ring
      pulsar.ring(.01f, false);
    } else if(get_mode_id() == 5) {
      pulsar.set_behavior("SIN"); // cyclus helmet
      pulsar.helmet(.01f, false);
    } else if(get_mode_id() == 6) {
      pulsar.set_behavior("SIN_POW_SIN"); // hear helmet
      pulsar.helmet(.01f, false);
    }
  }
}





  
/**
RUBIS
2013-2019
v 1.0.8
*/

class Rubis extends Romanesco {
  public Rubis() {
    //from the index_objects.csv
    item_name = "Rubis" ;
    item_author  = "Stan le Punk";
    item_version = "version 1.0.9";
    item_pack = "Base 2013-2019";
    item_costume = "";
    item_mode = "Vertex/Point";

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = false;
    size_y_is = false;
    size_z_is = false;
    diameter_is = false;
    canvas_x_is = true;
    canvas_y_is = false;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = true;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = true;
    jit_y_is = true;
    jit_z_is = true;
    swing_x_is = true;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = true;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
  //GLOBAL
  IntList IDpeople = new IntList() ;
  ArrayList<Ami> listPeople = new ArrayList<Ami>() ;
  int numPeople, rangePeople, refNumPeople ;
  PVector target ;
  boolean goBack  ;
  boolean newPeoplePosition, newPopulation ;
  
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    int num = (int)random(15,25)  ;
    rangePeople = width/2 ;
    amiSetting(num, rangePeople) ;
  }
  
  
  

  //DRAW
  public void draw() {
    vec3 center = vec3() ;

    // speed
    float speed = map(get_speed_x(),0,1,.0001f,.2f);
    speed = speed*speed ;
    if(sound_is() && sound_is()) {
      speed *= all_transient(ID_item);
    }



    vec3 jitter = vec3() ;
    if(sound_is() && sound_is()) {
      float valueX = left[ID_item] *get_jitter_x() *width ;
      float valueY = right[ID_item] *get_jitter_y() *width ;
      float valueZ = mix[ID_item] *get_jitter_z() *width ;
      jitter.set(valueX,valueY,valueZ) ;
    }

    // size of the rubis
    float radiusMax = get_canvas_x() *.7f ;
    float radiusMin = map(get_swing_x(), 0, 1, radiusMax, radiusMax /10) ;


     // stop motion
    if(!motion_is()) { 
      speed = 0 ; 
      jitter.set(0) ;
    }

 


    
    // new population
    int max_people = 150 ;
    float quantity = get_quantity();
    if(!FULL_RENDERING)  quantity *= .1f ;
    numPeople = (int)map(quantity,0, 1, 10, max_people) ; 
    if ( numPeople != refNumPeople ) newPopulation = true ;
    refNumPeople = (int)map(quantity,0, 1, 10, max_people) ;
    if(newPopulation) {
      listPeople.clear() ;
      amiSetting(numPeople, rangePeople) ;
      newPopulation = false ;
    }
    
    
    if(get_mode_id() == 1) {
      aspect(get_fill(), get_stroke(), get_thickness(), POINT_ROPE) ;
    } else {
      aspect(get_fill(), get_stroke(), get_thickness()) ;
    }

    ami_heart_move(center, speed, radiusMin, radiusMax, jitter,get_mode_id()) ;


  }
  
  ////////////////
  // VOID
  //setting
  public void amiSetting(int num, int size) {
    for ( int i = 0 ; i < num ; i++ ) {
      int ID = i ;
      //position of people
      PVector p  = new PVector (random(-size, size), random(-size, size), random(-size, size)) ;
      //friend of this people
      for ( int f = 0 ; f < num ; f++) IDpeople.append(f) ;
      int numFriend = (int)random(num / 2 ) ;
      int [] IDfriend = new int [numFriend] ;
      for ( int j = 0 ; j < numFriend ; j++) {
        int whichPeople = (int)random(IDpeople.size() ) ;
        int IDofFriend = IDpeople.get(whichPeople) ;
        IDfriend[j] = IDofFriend ;
        if(IDpeople.size() > 0 ) IDpeople.remove(whichPeople) ; 
      }
      //add information to the arraylist
      Ami people = new Ami(p, ID, IDfriend ) ;
      listPeople.add(people) ;
      //clear the list for a new start friend round
      IDpeople.clear() ;
    }
  }
  //draw
  //different points
  public void ami_heart_move(vec3 posCenter, float speed, float distMin, float distMax, vec3 jitter, int mode) {
    // new distribution
    if(newPeoplePosition) {
      for(int i = 0 ; i < listPeople.size() ; i++) {
        int r = (int)distMax ;
        Ami peopleOrigin = listPeople.get(i) ;
        peopleOrigin.originalPos = new PVector(random(-r,r),random(-r,r),random(-r,r)) ; 
      }
      newPeoplePosition = false ;
    }
    
    // ACTION
    countAmiArrivedToTarget = 0 ;
    for(int i = 0 ; i < listPeople.size() ; i++) {
      Ami peopleOrigin = listPeople.get(i) ;
      //update
      if (!goBack) target = new PVector(posCenter.x, posCenter.y, posCenter.z) ; else  target = new PVector(peopleOrigin.originalPos.x, peopleOrigin.originalPos.y, peopleOrigin.originalPos.z) ;
      PVector jitting = new PVector(random(-jitter.x, jitter.x), random(-jitter.y, jitter.y), random(-jitter.y, jitter.y)) ;
      target.add(jitting) ;
      peopleOrigin.pos = heartMove(peopleOrigin.pos, target, distMin, speed) ;
      //draw
      if(mode == 0 ) triangleFriends(peopleOrigin) ;
      if(mode == 1 ) pointFriends() ;

    }
    
    // info
    item_info[ID_item] =(numPeople + " summits") ;
  }
  
  
  
  /////////
  // ANNEXE
  
  // HEART MOVE
  int countAmiArrivedToTarget ;
  
  public PVector heartMove(PVector pos, PVector target, float distMin, float speed) {
    pos = gotoTarget(pos, target, speed) ; 
    float distance = 0 ;
    distance = PVector.dist(pos, target) ;
    if( distance < distMin  ) countAmiArrivedToTarget += 1 ;
    if(countAmiArrivedToTarget == listPeople.size() ) {
      goBack = !goBack ;
      newPeoplePosition = true ;
    }
    return pos ;
  }
  // END ANNEXE HEART MOVE
  
  
  
  // CONNECT YOUR FRIEND with line
  public void pointFriends() {
    if (listPeople.size() > 1 ) {
      //PVector me = ami.pos ;
      // f += 2
     for (Ami ami : listPeople) {
        //Ami amiOne = listPeople.get(ami.friendList[f]) ;
        // Ami amiTwo ;
        //if (ami.friendList[f] +1 >= listPeople.size() )  amiTwo = listPeople.get(ami.friendList[0]) ; else amiTwo = listPeople.get(ami.friendList[f] +1) ; 
        //PVector posAmiOne = amiOne.pos.copy() ;
        //PVector posAmiTwo = amiTwo.pos.copy() ;
        //display
        point(ami.pos.x, ami.pos.y, ami.pos.z) ;
        //point(posAmiOne.x, posAmiOne.y, posAmiOne.z) ;
        // point(posAmiTwo.x, posAmiTwo.y, posAmiTwo.z) ;
      }
    }
  }
  // END CONNECT YOUR FRIEND with line
  
  // CONNECT YOUR FRIEND with triangle
  public void triangleFriends(Ami ami) {
    if (ami.friendList.length > 1 ) {
      PVector me = ami.pos ;
      // f += 2
      for ( int f = 0 ; f < ami.friendList.length -1 ; f++) {
        Ami amiOne = listPeople.get(ami.friendList[f]) ;
        Ami amiTwo ;
        if (ami.friendList[f] +1 >= listPeople.size() )  amiTwo = listPeople.get(ami.friendList[0]) ; else amiTwo = listPeople.get(ami.friendList[f] +1) ; 
        PVector posAmiOne = amiOne.pos.copy() ;
        PVector posAmiTwo = amiTwo.pos.copy() ;
        //display
        beginShape() ;
        vertex(me.x, me.y, me.z) ;
        vertex(posAmiOne.x, posAmiOne.y, posAmiOne.z) ;
        vertex(posAmiTwo.x, posAmiTwo.y, posAmiTwo.z) ;
        endShape(CLOSE) ;
      }
    }
  }
  // END CONNECT YOUR FRIEND with triangle
  
  // END ANNEXE
  /////////////
}









////////////
// CLASS
class Ami {
  PVector pos = new PVector() ;
  PVector originalPos = new PVector() ;
  PVector size ;
  int ID ;
  int [] friendList ;
  
  Ami (PVector pos, int ID, int [] IDfriend ) {
    this.originalPos = pos ;
    this.pos = pos ;
    this.ID = ID ;
    friendList = new int [IDfriend.length] ;
    for ( int i = 0 ; i < IDfriend.length ; i ++ ) {
      friendList[i] = IDfriend[i] ;
    }
  }
  
  
  Ami ( PVector pos) {
    this.pos = pos ;
  }
}
/**
* Simple
* v 0.0.4
* 2018-2019
*/
class Simple extends Romanesco {
  public Simple() {
    //from the index_objects.csv
    item_name = "Simple" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 0.0.3";
    item_pack = "Simple 2018-2019" ;
    item_costume = "ellipse/triangle/rect/cross/pentagon/flower 5/flower 7/flower 12/flower 24/Star 5/Star 7/Super Star 8/Super Star 12"; // costume available from get_costume();
    item_mode = "";
    // define slider
    // COL 1
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;
    // COL 2
    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    dir_x_is = true;
    dir_y_is = true;
    dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;
    // COL 3
    // quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;
  }

  public void setup() {
    // give the starting position of your item on the 3D grid
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  //DRAW
  public void draw() {
    // here if you want code in 3D mode
    info("info about the item","more","more");
    aspect(get_fill(),get_stroke(),get_thickness());
    set_ratio_costume_size(map(get_area(),get_area_min(),get_area_max(),0,1));
    costume(vec3(),get_size().mult(3),get_costume());
  }
/*
  void draw_2D() {
    // here if you want code in 2D mode
  } 
  */  
}















/**
SOLEIL
2012-2019
1.2.1
*/
class Soleil extends Romanesco {
  public Soleil() {
    item_name = "Soleil" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.2.1";
    item_pack = "Base 2013-2019";
    item_costume = "" ;
    item_mode = "Beam/Lie'Bro'One/Lie'Bro'Two/Lie'Bro Noisy";
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    // size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    diameter_is = false;
    canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    spurt_x_is = true;
    // spurt_y_is = true;
    //spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    jit_z_is = true;
    // swing_x_is = true;
    // swing_y_is = true;
    //swing_z_is = true;

    quantity_is = true;
    //variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
        // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;
    coord_x_is = true;
    coord_y_is = true;
    // coord_z_is = true;
  }
  //GLOBAL
  float jitter, spurt;
  float angleRotation;
  //SETUP
  public void setup() {
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  vec3 pos;
  //DRAW
  public void draw() {
    aspect(get_fill(),get_stroke(),get_thickness());
    // orbital revolution
    boolean revolution = false;
    if(action_is() && special_is()) {
      revolution = true;
    }
    
    if(pos == null) pos = vec3(0);
    if(revolution) {
      pos.set(get_coord_x()*width,get_coord_y()*height,0); 
    } else {
      pos.set(0);
    }
    // diam
    float diam = get_canvas_x();
    if(sound_is()) diam *= all_transient(ID_item);
    // num beam
    float num_temp = get_quantity() *get_quantity();
    int numBeam = (int)(num_temp *87 +1);
    if(!FULL_RENDERING) numBeam /= 20;
    if(numBeam < 2 ) numBeam = 2;
    
    // spurt
    float ratio_spurt = (get_spurt_x() *get_spurt_x()) +.005f;
    spurt += (ratio_spurt *.33f)  ;
    float spurting = cos(spurt) *tempo[ID_item] ;

    // jitter
    PVector jitter = new PVector() ;
    float ratio_jitter = get_jitter_z() *get_jitter_z() ;
    float amp = sq(ratio_jitter *(height /10)) ;
    float right_jit =  ((right[ID_item] *right[ID_item] *5) *amp) ;
    float left_jit = ((left[ID_item] *left[ID_item] *5) *amp) ;
    if(sound_is()) jitter = new PVector(right_jit, left_jit) ; else jitter = new PVector(amp,amp);

    // rotation direction
    int direction = 1 ;
    if(reverse_is()) direction = 1 ; else direction = -1 ;
    if(!motion_is()) direction = 0 ;
    
    // rotation speed
    float speedRotation = 0 ;
    float ratio_speed = (get_speed_x() *get_speed_x()) +.05f ;
    if(get_speed_x() <= 0) ratio_speed = 0 ;
    speedRotation = sq(ratio_speed *8.0f *tempo[ID_item]) *direction ;
    angleRotation += speedRotation ;
    rotate (radians(angleRotation)) ;

    // mode
    if(get_mode_id() == 0) soleil(pos,diam,numBeam);
    if(get_mode_id() == 1) soleil(pos,diam,numBeam,spurting);
    if(get_mode_id() == 2) soleil(pos,diam,numBeam,spurt);
    if(get_mode_id() == 3) soleil(pos,diam,numBeam,spurt,jitter);
    
    // info display
    info("The sun have "+numBeam + " beams"," Special motion revolution is "+revolution);
    
    
  }
  
  // ANNEXE
  // soleil with jitter
  public void soleil(vec3 pos, float diam, int numBeam, float spurt, PVector jitter) {
    int numPoints = numBeam *2 ;
    for (int i = 0 ; i < numPoints -1 ; i = i +2) {
      float vibration = random(-jitter.x, jitter.y) ;
      PVector p1 = new PVector() ;
      PVector p2 = new PVector() ;
      p1 = circle(to_PVector(pos), (int)diam, numPoints, spurt)[i].copy() ;
      p2 = circle(to_PVector(pos), (int)diam, numPoints, spurt)[i +1].copy() ;
  
      beginShape();
      vertex(pos);
      vertex(p1.x +vibration, p1.y +vibration, p1.z +vibration);
      vertex(p2.x +vibration, p2.y +vibration, p2.z +vibration);
      endShape(CLOSE);
    }
  }
  
  
  // soleil with jitter
  public void soleil(vec3 pos, float diam, int numBeam, float jitter) {
    int numPoints = numBeam *2 ;
    for (int i = 0 ; i < numPoints -1 ; i = i +2) {
      PVector p1 = new PVector();
      PVector p2 = new PVector();
      p1 = circle(to_PVector(pos), (int)diam, numPoints, jitter)[i].copy();
      p2 = circle(to_PVector(pos), (int)diam, numPoints, jitter)[i +1].copy();
  
      beginShape() ;
      vertex(pos) ;
      vertex(p1.x, p1.y, p1.z) ;
      vertex(p2.x, p2.y, p2.z) ;
      endShape(CLOSE) ;
    }
  }
  
  // classic soleil
  public void soleil(vec3 pos, float diam, int numBeam) {
    int numPoints = numBeam *2 ;
    for (int i = 0 ; i < numPoints -1 ; i = i +2) {
      PVector p1 = new PVector() ;
      PVector p2 = new PVector() ;
      p1 = circle(to_PVector(pos), (int)diam, numPoints)[i].copy() ;
      p2 = circle(to_PVector(pos), (int)diam, numPoints)[i +1].copy() ;
      beginShape() ;
      vertex(pos) ;
      vertex(p1.x, p1.y, p1.z) ;
      vertex(p2.x, p2.y, p2.z) ;
      endShape(CLOSE) ;
    }
  }

  public PVector to_PVector(vec v) {
    return new PVector(v.x,v.y,v.z);
  }
}
/**
SPIRALE
2011-2019
v 1.3.12
*/

Spirale spirale ; 

class Spirale_romanesco extends Romanesco {
  public Spirale_romanesco() {
    //from the index_objects.csv
    item_name = "Spirale" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.3.12";
    item_pack = "Base 2011-2019" ;
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/flower/Star 5/Star 7/Super Star 8/Super Star 12" ;
    item_mode = "" ;

    // item_slider = "Fill hue,Fill sat,Fill bright,Fill alpha,Stroke hue,Stroke sat,Stroke bright,Stroke alpha,Thickness,Size X,Size Y,Size Z,Quantity,Speed X,Canvas X,Canvas Y,Swing X,Alignment" ;
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  //GLOBAL
     
    float speed ; 
    boolean reverseSpeed;
    float pos_swing ;
    int dir_swing = 1 ;
  //SETUP
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, 0) ;
    setting_start_direction(ID_item, 135,45) ;
    spirale = new Spirale() ;
  }
  
  //DRAW
  public void draw() {

    //quantity
    int n ;
    int nMax = 1 ;
     nMax = 1 + PApplet.parseInt(get_quantity() *300) ; 
    if(!FULL_RENDERING) nMax *= .1f ;
    n = nMax ;

    float max = map(width,100,3000,1.0f,1.1f)  ;
    float z = max ;
    //speed
    
    // if(reverse_is()) reverseSpeed = !reverseSpeed ;
    
    if(motion_is()) {
      float s = map(get_speed_x(),0,1,0,8) ;
      s *= s ;
      if(reverse_is()) speed = s *tempo[ID_item] ; else speed = s *tempo[ID_item] *-1.f ;
    } else { 
      speed = 0.0f ;
    }
    //sound volume
    float minValueVol = .8f ;
    float maxValueVol = 5.5f ;
    if(!sound_is()) maxValueVol = 1 ;
    float volumeLeft = map (left[ID_item], 0,1, minValueVol, maxValueVol ) ;
    float volumeRight = map (right[ID_item], 0,1, minValueVol, maxValueVol ) ;
    float volumeMix = map (mix[ID_item], 0,1, minValueVol, maxValueVol ) ;
    
    
    //SIZE
    float transient_map = map(transient_value[1][ID_item] +transient_value[3][ID_item] +transient_value[4][ID_item],1,9,1,50) ;
    float minValueSize = .5f ;
    float maxValueSize = width *.003f ;
    
    float sx = map(get_size_x(), .1f, width, minValueSize, maxValueSize) ;
    float sy = map(get_size_y(), .1f, width, minValueSize, maxValueSize) ;
    float sz  = map(get_size_z(), .1f, width, minValueSize, maxValueSize) ; 
    sx *= sx ;
    sy *= sy ;
    sz *= sz ;

    
    float temp_size_x = pow(sx, 3) *volumeLeft *transient_map;
    float temp_size_y = pow(sy, 3) *volumeRight *transient_map;
    float temp_size_z = pow(sz, 3) *volumeMix *transient_map;  
    vec3 size = vec3(temp_size_x,temp_size_y,temp_size_z);
    
    //amplitude of the translate
    float minValueCanvas = .01f ;
    float maxValueCanvas = 3 *(transient_value[2][ID_item] *.7f);
    float canvasXtemp = map(get_canvas_x(), width *.1f, width,minValueCanvas,maxValueCanvas);
    float canvasYtemp = map(get_canvas_y(), width *.1f, width,minValueCanvas,maxValueCanvas);
    float canvasZtemp = map(get_canvas_z(), width *.1f, width,minValueCanvas,maxValueCanvas);
    vec3 canvas = vec3(canvasXtemp,canvasYtemp,canvasZtemp);

    // alignement
    float max_align = get_alignment() *(height/10) ;
    if(get_swing_x() > 0 && motion_is() && horizon_is()) {
      float align ;
      float speed_swing = get_swing_x() *get_swing_x() ;
      if(pos_swing > max_align || pos_swing < -max_align || all_transient(ID_item) > 8) {
        dir_swing *= -1 ;
      }
      if(pos_swing > max_align +1) pos_swing = max_align ;
      if(pos_swing < -max_align -1) pos_swing = -max_align ;
      speed_swing *= dir_swing ;
      pos_swing += speed_swing ;


    } else {
      pos_swing = max_align ;
    }

    // aspect
    aspect(get_fill(), get_stroke(), get_thickness(), get_costume()) ;

    // mode    
    vec3 pos = vec3() ; // we write that because the first part of the void is not available any more.
    spirale.update(pos, speed);
    float ratio_size = map(get_area(),width*.1f, width*TAU,0,1);
    spirale.show(n, nMax, size, z, canvas, get_costume(), horizon_is(), pos_swing,ratio_size) ;
    
    // info display
    item_info[ID_item] = ("Speed "+speed+ " - Amplitude " + map(z, 1.01f, 1.27f, 1,100) + " - Quantity " + nMax) ;
  }

}










//CLASS
class Spirale {  
  float rotation ;
  float angle  ;

  Spirale () { }






  public void update(vec pos_temp, float speed) {
    vec3 pos = vec3() ;
    if(pos_temp instanceof vec2) {
      vec2 p = (vec2) pos_temp ;
      pos.set(p.x, p.y, 0) ;
    } else if(pos_temp instanceof vec3) {
      vec3 p = (vec3) pos_temp ;
      pos.set(p) ;
    }
    Float s = speed ;
    if(!s.isNaN()) rotation += speed;
    
    if (rotation > 360) {
      rotation = 0 ; 
    } else if (rotation < 0 ) {
      rotation = 360 ;
    }
    float angle = rotation ;
    //translate (pos) ;
    rotate(radians(angle) ) ;
  }


  float translate = 1.f ;
  float ratioSize = 1.f ;

  public void show (int n, int nMax, vec3 size, float z, vec3 canvas, Costume costume, boolean horizon, float alignment, float ratio_size) {
    n = n-1 ;
    
    translate += z ;
    ratioSize += .1f ;
    
    float ratioRendering = 1.f ;
    if(FULL_RENDERING) {
      ratioRendering = 1.f ; 
    } else {
      ratioRendering = 6.f ;
    }
    
    
    vec3 size_final = vec3(size.x *ratioSize *ratioRendering, size.y *ratioSize *ratioRendering, size.z *ratioSize *ratioRendering) ;



    //display Mode
    vec3 pos = vec3();
    set_ratio_costume_size(ratio_size);
    costume(pos, size_final,costume);
    //
    vec3 canvas_temp = canvas.copy();
    canvas_temp = mult(canvas,translate);
    canvas_temp.mult(ratioRendering);
    if(horizon) canvas_temp.z = canvas.z *.5f *alignment;
    translate(canvas_temp);
    /*
    float new_pos_x = translate *canvas.x *ratioRendering ;
    float new_pos_y = translate *canvas.y *ratioRendering ;
    float new_pos_z = 0 ;
    if(horizon) new_pos_z = size.z *.5 *alignment ;
    translate (new_pos_x,new_pos_y,new_pos_z) ;
    */

    
    rotate ( PI/6 ) ;

    if ( n > 0) { 
      show(n,nMax,size,z,canvas,costume,horizon,alignment,ratio_size); 
    } else{
      translate = 1.f;
      ratioSize = 1.f;
    }
  }
}
/**
SURFACE
2014-2019
v 1.1.2
*/

class Surface extends Romanesco {
  public Surface() {
    item_name = "Surface" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.1.2";
    item_pack = "Base 2014-2019";
    item_costume = "" ;
    item_mode = "Surfimage/Vague/Vague++" ; // separate the differentes mode by "/"

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is = true;
    swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }
  
  // Main method image 
  boolean newPicture ;
  boolean choicePicture = false ;
  PImage image  ;
  ArrayList<Polygon> grid_surface_image;
  // Main method surface simple
  ArrayList<Polygon> grid_surface_simple;
  
  // setup
  public void setup() {
    setting_start_position(ID_item, width/2, height/2, -height/2) ;
    setting_start_direction(ID_item,45,-10) ;
    load_bitmap(ID_item);
  }
  
  // declare VAR
  //////////////
  float speed = .3f ;
  // GRID IMAGE
  int sizePixel_image ;
  int altitude_image ;
  // GRID SIMPLE
  float amplitude_simple_grid = 30 ;
  float ratio_swing = 4 ;
  float step  = .01f ;  
  float refSizeTriangle ;
  vec2 canvasRef ;
  vec4 fill_color, stroke_color ;
  
  
  // draw
  public void draw() {
    if(grid_surface_image == null) grid_surface_image = new ArrayList<Polygon>();
    if(grid_surface_simple == null) grid_surface_simple = new ArrayList<Polygon>();
    // color to vec4 composant
    fill_color = vec4(hue(get_fill()),saturation(get_fill()),brightness(get_fill()),alpha(get_fill())) ;
    stroke_color = vec4(hue(get_stroke()),saturation(get_stroke()),brightness(get_stroke()),alpha(get_stroke())) ;
    // load image
    if(parameter_is()) {
      load_bitmap(ID_item);
    }

    //ratio speed
    float ratio_speed = get_speed_x() *get_speed_x() *get_speed_x() ;

    //speed
    if(motion_is() ) {
      speed = ratio_speed ; 
    } else { 
      speed = 0 ;
    }
    // swing
    if(sound_is() && sound_is()) { 
      ratio_swing = all_transient(ID_item) ; 
    } else {
      ratio_swing = 2 ;
    }
    // update motion
    if(motion_is()) {
      float speed_image = ratio_speed ;
      float amplitude_image = get_swing_x() *width *ratio_swing ;
      altitude_image = PApplet.parseInt(sin(frameCount *speed_image) *amplitude_image) ;
    }
    
    
    
    // IMAGE GRID
    sizePixel_image = floor(map(get_quality(), 0,1,width/20,2)) ;
    if(!FULL_RENDERING) sizePixel_image *= 3 ;
    // update data of the image
    if(key_n) {
      newPicture = false ; 
      choicePicture = false ;
    }
    
    
    
    
    // simple grid param
    ////////////////////
    if(get_mode_id() != 0 ) {
      //size pixel triangle
      int sizePixMin = 7 ;
      int sizePix_grid_simple = PApplet.parseInt(sizePixMin +get_size_x() /11) ;
      if(!FULL_RENDERING) sizePix_grid_simple *= 3 ;
      //size canvas grid
      vec2 newCanvas = vec2(get_canvas_x(),get_canvas_y()) ;
      newCanvas.mult(4.5f) ;
      // create grid if there is no grid
      if(grid_surface_simple.size() < 1) create_surface_simple(sizePix_grid_simple,newCanvas) ;
      
      // from of the wave
      int maxStep = (int)map(get_influence(),0,1,2,50) ;
      step = map(noise(5),0,1,0,maxStep) ; // break the linear mode of the wave
      // amplitude
      amplitude_simple_grid = get_swing_x() *height *.07f *ratio_swing  ;
      amplitude_simple_grid *= amplitude_simple_grid  ;
      
      // clear the list
      if(refSizeTriangle != get_size_x() || !canvasRef.equals(newCanvas)) {
        grid_surface_simple.clear() ;
      }
      
      // Vague + clear
      if(get_mode_id() == 1 ) {
        if(refSizeTriangle != get_size_x() || !canvasRef.equals(newCanvas)) {
          if(get_mode_id() == 1 ) grid_surface_simple.clear() ;
          create_surface_simple(sizePix_grid_simple,newCanvas) ;
        }
      }
      // vague ++
      if(get_mode_id() == 2) {
        if(refSizeTriangle != get_size_x() || !canvasRef.equals(newCanvas)) {
          create_surface_simple(sizePix_grid_simple,newCanvas) ;
        }
      }
      // make the reference
      refSizeTriangle = get_size_x() ;
      canvasRef = newCanvas ;
    }
    // END simple grid param
    ////////////////////////
    

    
    
    // update all mode
    /////////////////////////////
    update_and_clean(get_mode_id()) ;
    
    // info
    if(get_mode_id() == 0 ) {
      String about_img = ("no image available");
      if(image != null) {
        about_img = ("size: "+image.width+"x"+image.height);
      }
      item_info[ID_item] =("Mode: " + get_mode_name() +" | Triangles:"+grid_surface_image.size() + " | " + about_img); 
    } else item_info[ID_item] =("Mode: " + get_mode_name() +" | Triangles:"+grid_surface_simple.size()) ;
    
    
  }
  // End Display method
  ////////////////////
  
  
  
  
  // Annexe method
 
  // method display mode
  public void update_and_clean(int whichMode) {
    if(whichMode == 0 ) {
      if( grid_surface_simple.size() > 0 )grid_surface_simple.clear() ;
      update_surface_image(sizePixel_image, fill_color, stroke_color,get_thickness(), altitude_image) ;
    } else if (whichMode == 1 || whichMode == 2 ) {
      if( grid_surface_image.size() > 0 )grid_surface_image.clear() ;
      update_surface_simple(get_fill(), get_stroke(), get_thickness(), speed, amplitude_simple_grid, step) ;
    }
  }
  
  
  // SURFACE SIMPLE
  public void create_surface_simple(int sizePix, vec2 canvas) {
    /*
    PVector setting_position give the starting position for the drawing grid, the value is -1 to 1
    if you start with (0,0) the canvas start from the center, if you use the extreme value, the draw start from corner.
    this value can be interesting for the rotation axes.
    */
    PVector pos = new PVector(0, 0) ; 
    surfaceGrid(sizePix, canvas, pos, grid_surface_simple) ;
  }
  
  
  public void update_surface_simple(int c_fill, int c_stroke, float thickness, float speed, float amplitude, float step) {
    moveAllTriangle(speed, amplitude, step) ;
    for (Polygon t : grid_surface_simple) {
      t.color_fill = c_fill ;
      t.color_stroke = c_stroke ;
      t.strokeWeight = thickness ;
      t.draw_polygon() ;
    }
  }
  
  
  
  // WAVE MOVE
  int whichTriangleMove ;
  //wave
  float theta = 0 ;
  float wavePosition ;
  
  public void moveAllTriangle(float speed, float amplitude, float step) {
     // wave move for triangle
    theta += speed ;
    wavePosition = theta ;
    whichTriangleMove++ ;
    if( whichTriangleMove > grid_surface_simple.size() ) whichTriangleMove = 0 ;
    //update pattern
    for ( Polygon t : grid_surface_simple) {
      t.update_AllPoints_Zpos_Polygon(sin(wavePosition)*amplitude) ;
      wavePosition += step ;
    }
  }
  // END SURFACE SIMPLE
  
  
  
  
  
  
  
  
  
  
  
  
  // BUILD SURFACE IMAGE
  vec4 stroke_ref = vec4()  ;
  vec4 fill_ref = vec4()  ;
  // float alpha_fill_ref  ;
  float thickness_ref  ;
  int altitude_ref ;
  boolean refresh_surface ;
    // advice method
  public void update_surface_image(int sizePix, vec4 color_fill, vec4 color_stroke, float thickness, int altitude) {
    if( !stroke_ref.equals(color_stroke) || !fill_ref.equals(color_fill) || thickness_ref != thickness || altitude_ref != altitude) refresh_surface = true ;
    stroke_ref = color_stroke.copy() ;
    fill_ref = color_fill.copy() ;
    altitude_ref = altitude ;
    thickness_ref = thickness ;
    // if(choicePicture) loadImageFromFolder() ;
    if(!choicePicture) {
      image = bitmap[ID_item] ;
      newPicture = true ;
      choicePicture = true ;
    }
    if((newPicture && choicePicture) || refresh_surface) {
      surface_build_image_grid(0,0,altitude, sizePix, grid_surface_image, color_fill, color_stroke, thickness) ;
      refresh_surface = false ;
    }
    if(image != null) surfaceShapeDraw() ;
  }
  
  
  
  // SURFACE METHODE
  // annexe method
  public void surface_build_image_grid(float x, float y, int altitude, int sizeTriangle, ArrayList<Polygon> gridTriangle, vec4 color_fill, vec4 color_stroke, float thickness) {
      //setting grid
    PVector pos = new PVector(x, y) ; 
    /*
    PVector setting_position give the starting position for the drawing grid, the value is -1 to 1
     if you start with (0,0) the canvas start from the center, if you use the extreme value, the draw start from corner.
     this value can be interesting for the rotation axes.
     */
    surfaceGridImg(sizeTriangle, pos, image, gridTriangle) ;
    if(gridTriangle.size() > 0 ) {
      println("compute Surface grid");
      surfaceImgColor(gridTriangle, color_fill, color_stroke, thickness) ;
      
      surfaceImgSummit(altitude, gridTriangle) ;
      createSurfaceShape(gridTriangle) ;
      newPicture = false ;
    }
  }
  
  // CHANGE PATTERN from IMAGE
  PImage imgSurface ;
  
  
  public void surfaceGridImg(int sizePix, PVector pos, PImage imgSurface, ArrayList<Polygon> gridTriangle) {
    if(imgSurface != null) {
      // find info from image
      this.imgSurface = imgSurface ;
      // clear the list if you load an other picture.
      gridTriangle.clear(); 
      listTrianglePoint.clear() ;
      
      //classic grid method
      vec2 canvas = vec2(imgSurface.width, imgSurface.height);
      surfaceGrid(sizePix, canvas, pos, gridTriangle) ;
    }
  }
  
  // color surface
  public void surfaceImgColor(ArrayList<Polygon> gridTriangle, vec4 color_fill, vec4 color_stroke, float thickness) {
    /* We calculated the value of first pixel in the pixel arraylist to remove or add this "firstValue" to the other the pixel, 
     because we need have count from zero to find give the good color to the good polygon. */
    Polygon ref = (Polygon) grid_surface_image.get(0) ;
    int firstValue = PApplet.parseInt((ref.pos.y -1) *imgSurface.width +ref.pos.x) ;

    for (Polygon t : gridTriangle) {
      // find the pixel in the picture import with the triangle grid to return the color to polygon.
      int  rankPixel = PApplet.parseInt((t.pos.y) *imgSurface.width +t.pos.x) -firstValue ;
  
      
      if (rankPixel < imgSurface.pixels.length) { //security for the array crash
        int colorTriangle = imgSurface.pixels[rankPixel] ;
        float newSat = saturation(colorTriangle) ;
        float newBright = brightness(colorTriangle) ;
        if (color_fill.gre() <= newSat ) newSat = color_fill.gre();
        if (color_fill.bri() <= newBright ) newBright = color_fill.bri();
        t.color_fill = color(hue(colorTriangle),newSat, newBright, color_fill.w) ;
        t.color_stroke = color(stroke_color.x,stroke_color.y,stroke_color.z,stroke_color.w)  ;
        t.strokeWeight = thickness ;
      }
    }
  }
  
  public void surfaceImgSummit(int altitude, ArrayList<Polygon> gridTriangle) {
    /* We calculated the value of first pixel in the pixel arraylist to remove or add this "firstValue" to the other the pixel, 
     because we need have count from zero to find give the good color to the good polygon. */
    PVector posFirstValue = (PVector) listTrianglePoint.get(0) ;
    int firstValue = PApplet.parseInt((posFirstValue.y -1) *imgSurface.width +posFirstValue.x) ;
  
    for (PVector pos : listTrianglePoint) {
      int  rankPixel = PApplet.parseInt((pos.y) *imgSurface.width +pos.x) -firstValue ;
      //security for the array crash
      if (rankPixel < imgSurface.pixels.length) {
        float brightness = brightness(imgSurface.pixels[rankPixel]) ;
        // this value can change with you colorMode environement
        float maxValueBrightness = 255 ;
        pos.z = map(brightness, 0, maxValueBrightness, 0, 1) ;
  
        // update position
        for (Polygon t : gridTriangle) {
          t.update_SpecificPoints_Zpos_Polygon(pos, pos.z *altitude) ;
        }
      }
    }
  }
}










// SHAPE METHOD
  PShape patternShape;
  // local void
  public void createSurfaceShape(ArrayList<Polygon> gridTriangle) {
    println("Create high Surface mesh");
    patternShape = createShape();
    patternShape.beginShape(TRIANGLES);
    for (Polygon t : gridTriangle) {
      t.draw_polygon_in_PShape(patternShape) ;
    }
    patternShape.endShape(CLOSE);
    println("High Surface mesh has been created with "+patternShape.getVertexCount()+" vertex");
  }
  //
  public void surfaceShapeDraw() {
    shape(patternShape);
  }
  // END SHAPE METHOD
  ///////////////////




















// BUILD
/////////

// GRID TRIANGLE
ArrayList<PVector> listTrianglePoint = new ArrayList<PVector>() ;

// Main void
public void surfaceGrid(int triangleSize, vec2 canvas, PVector pos, ArrayList<Polygon> gridTriangle) {
  buildTriangleGrid(triangleSize, canvas, pos, gridTriangle) ;
  selectCommonSummit(gridTriangle) ;
}


// Annexe void
// build the grid
public void buildTriangleGrid(int triangleSize, vec2 canvas, PVector startingPositionToDraw, ArrayList<Polygon> gridTriangle) {
  triangleSize *=2 ;
  // setting var
  PVector pos =new PVector() ;
  int countTriangle = 0 ;
  // security
  if(triangleSize > canvas.x ) canvas.x = triangleSize ;
  if(triangleSize > canvas.y ) canvas.y = triangleSize ;
  
  //starting position
  startingPositionToDraw.x = map(startingPositionToDraw.x,-1,1,0,1) ;
  startingPositionToDraw.y = map(startingPositionToDraw.y,-1,1,0,1) ;
  PVector startingPos = new PVector(-canvas.x *startingPositionToDraw.x, -canvas.y *startingPositionToDraw.y) ;
  // define geometric data
  int radiusCircumCircle = triangleSize ;
  float sideLengthOfEquilateralTriangle = radiusCircumCircle *sqrt(3) ; // find the length of triangle side
  float medianLineLength = sideLengthOfEquilateralTriangle *(sqrt(3) *.5f) ; // find the length of the mediane equilateral triangle
  
  // angle correction
  float correction = .5235f ;
  float correctionAngle  ;
  
  // Build the grid
  for(int i = 0 ; i < canvas.y/medianLineLength ; i++) {
    float verticalCorrection = medianLineLength *i ;
    // we change the starting line to make a good pattern.
    float horizontalCorrection ;
    if(i%2 == 0 ) horizontalCorrection = 0 ; else horizontalCorrection = sideLengthOfEquilateralTriangle *.5f ;
    
    for(int j = 0 ; j < canvas.x/sideLengthOfEquilateralTriangle*2 ; j++) {
      if(j%2 == 0 ) {
        correctionAngle = correction +PI ;
        // correction of the triangle position to have a good line
        float correctionPosY = (radiusCircumCircle*2) -medianLineLength ; 
        pos.y = radiusCircumCircle -correctionPosY + verticalCorrection;
        
      } else {
        pos.y = radiusCircumCircle +verticalCorrection ;
        correctionAngle = correction +TAU ;
      }
      pos.x = j *(sideLengthOfEquilateralTriangle *.5f) +horizontalCorrection ; 
      pos.add(startingPos) ;
      
      //create triangle and add in the list of triangle
      Polygon triangle = new Polygon(pos, radiusCircumCircle, correctionAngle, 3, countTriangle++);
      gridTriangle.add(triangle) ;
      
    }
  }
}


// build the list of the common summit
public void selectCommonSummit(ArrayList<Polygon> gridTriangle) {
  // loop to check the triangle list and add summit point to list
  boolean addSum = true ;
  for(Polygon p : gridTriangle) {
    int num = p.points.length ;
    for (int i = 0 ; i < num ; i++) {
      // find the position of the summit
      PVector posSum = new PVector(p.points[i].x, p.points[i].y) ;
      
      // check if the summits points are in the list
      for(PVector sumPoint : listTrianglePoint) {
        // we use a range around the point, because the calcul of the summit is not exact.
        float range = .1f ;
        if((posSum.x <= sumPoint.x +range && posSum.x >= sumPoint.x -range)  && (posSum.y <= sumPoint.y +range && posSum.y >= sumPoint.y -range) ) addSum = false ;
      }
      if(addSum)listTrianglePoint.add(posSum) ;
      addSum = true ;
    }
  }
}

// END BUILD
///////////











/**
MUST BE REMPLACED BY PRIMITIVE
*/
// CLASS POLYGONE june 2015 / 1.1.2
///////////////////////////////////

class Polygon {
  vec4 [] points ;
  PVector pos ;
  float radius ;
  // put the alpha to zero by default in case there is polygon outside the array when you want change the color of polygone
  int color_fill = color(255) ;
  int color_stroke = color(0) ;
  float strokeWeight = 1 ;
  int ID ;



  Polygon(PVector pos, float radius, float rotation, int num_of_summit, int ID) {
    this.pos = pos.copy() ;
    this.radius = radius ;
    this.ID = ID ;
    points = new vec4 [num_of_summit] ;
    float angle = TAU / num_of_summit ;

    for (int i = 0; i < num_of_summit; i++) {
      float newAngle = angle*i;
      float x = pos.x + cos(newAngle +rotation) *radius;
      float y = pos.y + sin(newAngle +rotation) *radius;
      float z = pos.z ;
      points[i] = new vec4(x, y, z, ID) ;
    }
  }

  // DRAW
  public void draw_polygon() {
    fill(color_fill) ;
    stroke(color_stroke) ;
    strokeWeight(strokeWeight) ;
    // check for transparency
    if(strokeWeight == 0 || alpha(color_stroke) == 0) noStroke() ;
    if(alpha(color_fill) == 0) noFill() ;
    // draw
    beginShape();
    for (int i = 0; i < points.length; i++) {
      vertex(points[i].x, points[i].y, points[i].z);
    }
    endShape(CLOSE) ;
  }
  
  public void draw_polygon(PVector motion) {
    fill(color_fill) ;
    stroke(color_stroke) ;
    strokeWeight(strokeWeight) ;
    // check for transparency
    if(strokeWeight == 0 || alpha(color_stroke) == 0) noStroke() ;
    if(alpha(color_fill) == 0) noFill() ;
    // draw
    pushMatrix() ;
    translate(motion.x,motion.y,motion.z) ;
    beginShape();
    for (int i = 0; i < points.length; i++) {
      vertex(points[i].x, points[i].y, points[i].z);
    }
    endShape(CLOSE) ;
    popMatrix() ;
  }
  
  public void draw_polygon(PVector motion, PVector rotation) {
    fill(color_fill) ;
    stroke(color_stroke) ;
    strokeWeight(strokeWeight) ;
    // check for transparency
    if(strokeWeight == 0 || alpha(color_stroke) == 0) noStroke() ;
    if(alpha(color_fill) == 0) noFill() ;
    // draw
    pushMatrix() ;
    translate(motion.x,motion.y,motion.z) ;
    rotateX(radians(rotation.x)) ;
    rotateZ(radians(rotation.y)) ;
    rotateY(radians(rotation.z)) ;
    beginShape();
    for (int i = 0; i < points.length; i++) {
      vertex(points[i].x, points[i].y, points[i].z);
    }
    endShape(CLOSE) ;
    popMatrix() ;
  }
  
  
  // SHAPE METHOD
  public void draw_polygon_in_PShape(PShape in) {
    in.fill(color_fill) ;
    in.stroke(color_stroke) ;
    in.strokeWeight(strokeWeight) ;
    // check for trnsparency
    if(strokeWeight == 0 || alpha(color_stroke) == 0) in.noStroke() ;
    if(alpha(color_fill) == 0) in.noFill() ;
    // draw
    for (int i = 0; i < points.length; i++) {
      in.vertex(points[i].x, points[i].y, points[i].z);
    }
  }
  
  public void draw_polygon_in_PShape(PShape in, PVector motion) {
    in.fill(color_fill) ;
    in.stroke(color_stroke) ;
    in.strokeWeight(strokeWeight) ;
    // check for trnsparency
    if(strokeWeight == 0 || alpha(color_stroke) == 0) in.noStroke() ;
    if(alpha(color_fill) == 0) in.noFill() ;
    // draw
    pushMatrix() ;
    translate(motion.x,motion.y,motion.z) ;
    for (int i = 0; i < points.length; i++) {
      in.vertex(points[i].x, points[i].y, points[i].z);
    }
    popMatrix() ;
  }


  //UPDATE ALL THE POINT
  public void update_AllPoints_Zpos_Polygon(float newPosZ) {
    for (int i = 0; i < points.length; i++) {
      points[i].z = newPosZ ;
    }
  }


  //UPDATE SPECIFIC POINT
  public void update_SpecificPoints_Zpos_Polygon(PVector ref, float newPosZ) {
    for (int i = 0; i < points.length; i++) {
      float range = .1f ; // we use a range around the point to be sure to catch it.
      if ((ref.x <= points[i].x +range && ref.x >= points[i].x -range)  && (ref.y <= points[i].y +range && ref.y >= points[i].y -range) ) points[i].z = newPosZ ;
    }
  }
}





















/**
* Tartan
* v 0.0.3
* 2018-2019
*/
class Tartan extends Romanesco {
  public Tartan() {
    //from the index_objects.csv
    item_name = "Tartan" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 0.0.3";
    item_pack = "Tartan 2018-2019" ;
    item_costume = ""; // costume available from get_costume();
    item_mode = "Tartan/Strip";
    // define slider
    // COL 1
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    //size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;
    // COL 2
    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    //dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;
    // COL 3
    quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;
  }

  public void setup() {
    // give the starting position of your item on the 3D grid
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  //DRAW
  public void draw() {
    // here if you want code in 3D mode
    if(get_mode_name().equals("Tartan")) {
      tartan();
    } else if(get_mode_name().equals("Strip")) {
      strip();

    }
    info("info about the item","more","more");
  }
   /*
  void draw_2D() {
    // here if you want code in 2D mode
  }   
  */

  public void tartan() {
    strip();

  }
  

  // int ref_num_strip;
  public void strip() {
    int num_strip = (int)map(get_quantity()*get_quantity(),get_quantity_min(),get_quantity_max(),1,111);
    int w_strip = (int)get_size_x()*5;
    int h_strip = (int)get_size_y()*2;

    int space = (int)map(get_canvas_y(),get_canvas_y_min(),get_canvas_y_max(),h_strip,h_strip*(height*.1f));
    int total_height = num_strip *(h_strip+space);
    float start_y = -(total_height*.5f);
    // float start_x = -(w_strip*.5);
    float start_x = 0;
    rectMode(CENTER);
    aspect(get_fill(),get_stroke(),get_thickness());
    for(int i = 0 ; i < num_strip ; i++) {
      float x = start_x ;
      float y = start_y +(i*(h_strip+space));
      rect(x,y,w_strip,h_strip);
    }


  }
}















/**
VECTORIAL
2015-2019
v 0.0.10
*/
class Vectorial extends Romanesco {
 
  public Vectorial() {
    item_name = "Vectorial" ;
    item_author  = "Stan le Punk";
    item_version = "Version 0.0.10";
    item_pack = "Base 2015-2019" ;
    item_costume = "" ;
    item_mode = "Classic original/Classic custom/Walker original/Walker custom" ; // separate the differentes mode by "/"

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is  = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    // size_x_is = true;
    // size_y_is = true;
    // size_z_is = true;
    // diameter_is = true;
    canvas_x_is = true;
    canvas_y_is = true;
    // canvas_z_is = true;

    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    // dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    jit_x_is = true;
    jit_y_is = true;
    jit_z_is = true;
    swing_x_is = true;
    swing_y_is = true;
    swing_z_is = true;

    // quantity_is = true;
    // variety_is = true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
  }

  String ref_name = "" ;
  boolean walker  ;
  float beat_factor = 1 ;
  String svg_bricks_saved = "RPE_SVG/bricks/"  ;

  vec3 jitting = vec3(0) ;
  vec4 normalize_fill = vec4(1) ;
  vec4 normalize_stroke = vec4(1) ;
 
  // setup
  public void setup() {
    setting_start_position(ID_item, width/2, height/2 +height/4, -height);
    setting_start_direction(ID_item, 30,-20);

    load_svg(ID_item);
    println("svg_current_path",svg_current_path);
    if(svg_current_path != null) {
      svg_import[ID_item].build(svg_current_path, svg_bricks_saved);
      svg_import[ID_item].mode(CENTER);
      ref_name = svg_import[ID_item].name;
    }
  }


  public void draw() {
    if(svg_import[ID_item] != null) {
      if(parameter_is()) {
        load_svg(ID_item);
        println("svg_current_path",svg_current_path);
        ref_name = svg_import[ID_item].name ;  
        if(!svg_import[ID_item].name.equals(ref_name)) {
          ref_name = svg_import[ID_item].name ;
          svg_import[ID_item].build(svg_current_path,svg_bricks_saved) ;
          svg_import[ID_item].mode(CENTER);
        }
      }
      if(svg_current_path != null) {
        rendering();
      }
    } 
  }

  public void draw_2D() {
    if(svg_import[ID_item] == null) {
      fill(0,0,100);
      textAlign(CENTER);
      textSize(18);
      text("No vectorial media available\nCheck if there is one in your medias library",width/2,height/2);
    }
  }



  public void rendering() {
    // color
    float normalize_hue_fill = map(hue(get_fill()),0,360,0,1) ;
    float normalize_sat_fill = map(saturation(get_fill()),0,100,0,1) ;
    float normalize_bright_fill = map(brightness(get_fill()),0,100,0,1) ;
    float normalize_alpha_fill = map(alpha(get_fill()),0,100,0,1) ;

    float normalize_hue_stroke = map(hue(get_stroke()),0,360,0,1) ;
    float normalize_sat_stroke = map(saturation(get_stroke()),0,100,0,1) ;
    float normalize_bright_stroke = map(brightness(get_stroke()),0,100,0,1) ;
    float normalize_alpha_stroke = map(alpha(get_stroke()),0,100,0,1) ;


    // scale
    float scale_x = map(get_canvas_x(), get_canvas_x_min(), get_canvas_x_max(), .1f, 8);
    float scale_y = map(get_canvas_y(), get_canvas_y_min(), get_canvas_y_max(), .1f, 8);
    vec3 scale_3D = vec3(scale_x, scale_y,1) ;

    // beat factor
    if(sound_is()) beat_factor = all_transient(ID_item) ; else beat_factor = 1.f ;


    
    // jitter
    

    if(FULL_RENDERING) {
      jitting.set(get_jitter_x(),get_jitter_y(),get_jitter_z());
      jitting.mult((int)height/2 *beat_factor) ;
    } else {
      jitting.set(0) ;
    }

    // pos
    vec3 pos_3D = vec3 (mouse[ID_item].x,mouse[ID_item].y, mouse[ID_item].z); 

    if(get_mode_id() == 0 ) {
      if(walker) {
        svg_import[ID_item].build() ;
        walker = false ;
      }
      normalize_fill.set(1, normalize_sat_fill,normalize_bright_fill, normalize_alpha_fill) ;
      normalize_stroke.set(1,normalize_sat_stroke,normalize_bright_stroke, normalize_alpha_stroke) ;
      full_svg_3D(pos_3D, scale_3D, jitting, svg_import[ID_item], normalize_fill, normalize_stroke, true) ;
    // classic colour  
    } else if(get_mode_id() == 1 ) {
      if(walker) {
        svg_import[ID_item].build() ;
        walker = false ;
      }
      normalize_fill.set(normalize_hue_fill, normalize_sat_fill,normalize_bright_fill, normalize_alpha_fill) ;
      normalize_stroke.set(normalize_hue_stroke,normalize_sat_stroke,normalize_bright_stroke, normalize_alpha_stroke) ;
      full_svg_3D(pos_3D, scale_3D, jitting, svg_import[ID_item], normalize_fill, normalize_stroke, get_thickness(), false) ;
    // walker  
    } else if(get_mode_id() == 2 && FULL_RENDERING) {
      walker = true ;
      normalize_fill.set(1, normalize_sat_fill,normalize_bright_fill, normalize_alpha_fill) ;
      normalize_stroke.set(1,normalize_sat_stroke,normalize_bright_stroke, normalize_alpha_stroke) ;
      walker_svg_3D(pos_3D, scale_3D, svg_import[ID_item], normalize_fill, normalize_stroke, true) ;
      if(key_n ) svg_import[ID_item].build() ;
      if(beat_factor > 5 && FULL_RENDERING) svg_import[ID_item].build() ;
    // walker colour
    } else if(get_mode_id() == 3 && FULL_RENDERING) {
      walker = true ;
      normalize_fill.set(normalize_hue_fill, normalize_sat_fill,normalize_bright_fill, normalize_alpha_fill) ;
      normalize_stroke.set(normalize_hue_stroke,normalize_sat_stroke,normalize_bright_stroke, normalize_alpha_stroke) ;
      walker_svg_3D(pos_3D, scale_3D, svg_import[ID_item], normalize_fill, normalize_stroke, get_thickness(), false) ;
      if(key_n ) svg_import[ID_item].build() ;
      if(beat_factor > 5 && FULL_RENDERING) svg_import[ID_item].build() ;
    } else {
      if(walker) {
        svg_import[ID_item].build() ;
        walker = false ;
      }
      normalize_fill.set(1, normalize_sat_fill,normalize_bright_fill, normalize_alpha_fill) ;
      normalize_stroke.set(1,normalize_sat_stroke,normalize_bright_stroke, normalize_alpha_stroke) ;
      full_svg_3D(pos_3D, scale_3D, jitting, svg_import[ID_item], normalize_fill, normalize_stroke, true) ;
    }

  }



  // annexe
  public void walker_svg_3D(vec3 pos_3D, vec3 scale_3D, ROPE_svg svg, vec4 factor_fill, vec4 factor_stroke, boolean original_colour) {
    float thickness = 1 ;
    walker_svg_3D(pos_3D, scale_3D, svg, factor_fill, factor_stroke, thickness, original_colour) ;

  }
  public void walker_svg_3D(vec3 pos_3D, vec3 scale_3D, ROPE_svg svg, vec4 factor_fill, vec4 factor_stroke, float thickness, boolean original_colour) {
    vec3 swing = vec3(get_swing_x(),get_swing_y(),get_swing_z()) ;
    swing.mult(height /5 *beat_factor) ;
    for(int ID = 0 ; ID < svg.num_brick() ; ID++ ) {
      int length = svg.list_svg_vec(ID).length ;
      vec3 [] value = new vec3[length] ;
      for(int i = 0 ; i < value.length ; i++) {
        value[i] = vec3().rand(vec2(-swing.x,swing.x),vec2(-swing.y,swing.y),vec2(-swing.z,swing.z));
        value[i].mult(.1f) ;
      }
      svg.add_def(ID, value) ;
      svg.pos(pos_3D) ;
      svg.scaling(scale_3D) ;
      if(original_colour) {
        svg.original_style(true, true) ;
        svg.fill_factor(factor_fill) ; 
        svg.stroke_factor(factor_stroke) ; 
      } else {
        svg.original_style(false, false) ;
        svg.fill(factor_fill) ; 
        svg.stroke(factor_stroke) ; 
        svg.strokeWeight(thickness) ; 
      }
      svg.draw(ID) ;
    }
  }

  // 
  public void full_svg_3D(vec3 pos_3D, vec3 scale_3D, vec3 jitter_3D, ROPE_svg svg, vec4 factor_fill, vec4 factor_stroke, boolean original_colour) {
    float thickness = 1 ;
    full_svg_3D(pos_3D, scale_3D, jitter_3D, svg, factor_fill, factor_stroke, thickness, original_colour) ;
  }
  public void full_svg_3D(vec3 pos_3D, vec3 scale_3D, vec3 jitter_3D, ROPE_svg svg, vec4 factor_fill, vec4 factor_stroke, float thickness, boolean original_colour) {
    svg.pos(pos_3D) ;
    svg.scaling(scale_3D) ;
    svg.jitter(jitter_3D) ;
    if(original_colour) {
      svg.original_style(true, true) ;
      svg.fill_factor(factor_fill) ; 
      svg.stroke_factor(factor_stroke) ; 
    } else {
      svg.original_style(false, false) ;
      svg.fill(factor_fill) ; 
      svg.stroke(factor_stroke) ; 
      svg.strokeWeight(thickness) ; 
    }
    svg.draw() ;
  }
}
/**
WEBCAM 
2011-2019
v 1.2.10
*/
class Webcam extends Romanesco {
  public Webcam() {
    //from the index_objects.csv
    item_name = "Webcam" ;
    item_author  = "Stan le Punk";
    item_version = "Version 1.2.10";
    item_pack = "Base 2012-2019" ;
    item_costume = "" ;
    item_mode = "Rectangle color/Rectangle mono/Point color/Point mono/Box color/Box mono" ;

    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = false;
    sat_stroke_is = false;
    bright_stroke_is = false;
    alpha_stroke_is = false;
    thickness_is = false;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    diameter_is = false;
    canvas_x_is = true;
    canvas_y_is = true;
    canvas_z_is = false;

    // frequence_is = true;
    speed_x_is = false;
    speed_y_is = false;
    speed_z_is = false;
    spurt_x_is = false;
    spurt_y_is = false;
    spurt_z_is = false;
    dir_x_is = false;
    dir_y_is = false;
    dir_z_is = false;
    jit_x_is = false;
    jit_y_is = false;
    jit_z_is  = false;
    swing_x_is = false;
    swing_y_is = false;
    swing_z_is = false;

    quantity_is = false;
    variety_is = false;
    life_is = false;
    flow_is = false;
    quality_is = false;
    area_is = false;
    angle_is = false;
    scope_is = false;
    scan_is = false;
    align_is = false;
    repulsion_is = false;
    attraction_is = false;
    density_is = false;
    influence_is = false;
    calm_is = false;
    spectrum_is = false;
  }
  //GLOBAL
  int cameraStatut = 0 ;

  vec2 factorDisplayCam ;
  vec3 factorDisplayPixel ;
  
  int colorPixelCam ;
  
  int cellSizeX, cellSizeY, posPixelX, posPixelY   ;
  int cols ;
  int rows ; 
  
  
  //SETUP
  public void setup() {
    setting_start_position(ID_item, 0, 0, 0) ;
    factorDisplayCam = vec2();
    factorDisplayPixel = vec3();
  }
  //DRAW
  public void draw() {
    select_camera(3);
    video_camera_manager();
    //PART ONE
    //calcul the ration between the size of camera and the size of the scene
    factorDisplayCam.set(width / CAM_SIZE.x,height / CAM_SIZE.y);
    
    // size
    float minVal = 0.1f ;
    float maxVal = height / 50 ;
    float size_x = map(get_size_x(),0.1f,width, minVal, maxVal) *transient_value[3][ID_item] ;
    float size_y = map(get_size_y(),0.1f,width, minVal, maxVal) *transient_value[2][ID_item] ;
    float size_z = map(get_size_z(),0.1f,width, minVal, maxVal) *transient_value[4][ID_item] ;
    vec3 factorSizePix = vec3(size_x, size_y, size_z) ; 
    factorDisplayPixel.set(factorDisplayCam.x *factorSizePix.x,factorDisplayCam.y *factorSizePix.y, factorSizePix.z) ;//PARAMETER THAT YOU CAN USE
    
    //PART TWO

    if(FULL_RENDERING) {
      cellSizeX = PApplet.parseInt(map(get_canvas_y(),width/10, width, 50, 1))  ; 
      cellSizeY = PApplet.parseInt(map(get_canvas_x(),width/10, width, 50, 1))  ;
    } else {
      cellSizeX = PApplet.parseInt(map(get_canvas_y(),width/10, width, 50, 20))  ; 
      cellSizeY = PApplet.parseInt(map(get_canvas_x(),width/10, width, 50, 20))  ;
    }
    if(cellSizeX < 1 ) cellSizeX = 1 ;
    if(cellSizeY < 1 ) cellSizeY = 1 ;
    
    cols = (int)CAM_SIZE.x / cellSizeX; // before the resizing
    rows = (int)CAM_SIZE.y / cellSizeY;
    if (BROADCAST) {
      get_cam().loadPixels();
      for (int i = 0; i < cols ; i++) {
        for (int j = 0; j < rows ; j++) {
          // Where are we, pixel-wise?
          posPixelX = i *cellSizeX  ;
          posPixelY = j *cellSizeY  ;
          //// display pixel 
          int  loc = posPixelX +posPixelY *get_cam().width; // classic
          //  int loc = (cam.width - x - 1) + y*cam.width; // mirror
          //make pixel
          if(get_cam().pixels.length > 0) {

            PVector hsb = new PVector (hue(get_cam().pixels[loc]), saturation(get_cam().pixels[loc]), brightness(get_cam().pixels[loc]) ) ;
            // Make a new color with an alpha component
            displayPix(get_mode_id(),hsb) ; 
          }
        }
      } 
    } else {
      fill(get_fill()) ;
      textSize(get_size_x()/10) ;
      text("Big Brother stops watching you, you're so boring !",0,0) ;
    } 
    rectMode (CORNER) ;
  }
  
  
  
  
  
  
  //annexe

  
  
  public void displayPix(int mode, PVector hsb) {
    //DISPLAY
    pushMatrix() ;
    //P3D Give the position and the orientation of your object in the 3 dimensionals space
    PVector newDisplay = new PVector  (cellSizeX *factorDisplayCam.x,   cellSizeY *factorDisplayCam.y) ;
    
    float newCellSizeX = cellSizeX *factorDisplayPixel.x *left[ID_item] ;
    float newCellSizeY = cellSizeY *factorDisplayPixel.y *right[ID_item] ;
    float factorSizeZ = map(get_size_z(), .1f, width, .01f, height/100) ;
    PVector newCellSize = new PVector (newCellSizeX, newCellSizeY, factorSizeZ ) ;
    //init the position of image on the middle of the screen
    vec3 posMouseCam = vec3( width / 2, height /2, 0) ;
    if (mouse[ID_item].x >= -item_setting_position[0][ID_item].x && mouse[ID_item].y >= -item_setting_position[0][ID_item].y) posMouseCam.set(mouse[ID_item]) ;
    //create the ratio for the translate position in functiun of the size of the Scene, not really good algorythm
    float ratioDisplay = (float)width / (float)height ;
    float factorDisplacementRatioSizeOfTheDisplay = map(width, 0, 2000, .6f, .2f ) ;
    float factorTranslateX = factorDisplacementRatioSizeOfTheDisplay / ratioDisplay ;
    float factorTranslateY = factorDisplacementRatioSizeOfTheDisplay ;

    //finalization of the position
    float finalPosPixelX = ( (posPixelX +newDisplay.x *factorTranslateX) *factorDisplayCam.x) + posMouseCam.x - width *0.5f ;
    float finalPosPixelY = ( (posPixelY +newDisplay.y *factorTranslateY) *factorDisplayCam.y) + posMouseCam.y - height*0.5f ;
    PVector pos = new PVector (finalPosPixelX, finalPosPixelY, 0);
    //translate(finalPosPixelX, finalPosPixelY, finalPosPixelZ);
               
    rectMode(CENTER) ;
    
    if(mode == 0 ) rectangleColour(pos, newCellSize, hsb) ;
    if(mode == 1 ) rectangleMonochrome(pos, newCellSize, hsb) ;
    if(mode == 2 ) pointColour(pos, newCellSize, hsb) ;
    if(mode == 3 ) pointMonochrome(pos, newCellSize, hsb) ;
    if(mode == 4 ) boxColour(pos, newCellSize, hsb) ;
    if(mode == 5 ) boxMonochrome(pos, newCellSize, hsb) ;
    //
    popMatrix() ;
  }
  
  
  
  
  
  
  // different mode
  public void rectangleMonochrome(PVector pos, PVector size, PVector hsb) {
    size = checkSize(size).copy() ;
    translate(pos.x, pos.y, pos.z);
    monochrome(hsb) ;
    fill(colorPixelCam) ;
    noStroke() ;
    antiBugFillBlack(colorPixelCam) ;
    rect (0,0, size.x, size.y) ;
  }
  //
  public void rectangleColour(PVector pos, PVector size, PVector hsb) {
    size = checkSize(size).copy() ;
    translate(pos.x, pos.y, pos.z);
    colour(hsb) ;
    fill(colorPixelCam) ;
    noStroke() ;
    antiBugFillBlack(colorPixelCam) ;
    rect (0,0, size.x, size.y) ;
  }
  //
  public void pointMonochrome(PVector pos, PVector size, PVector hsb) {
    size = checkSize(size).copy() ;
    translate(pos.x, pos.y, pos.z);
    monochrome(hsb) ;
    stroke(colorPixelCam) ;
    strokeWeight(size.x) ;
    antiBugFillBlack(colorPixelCam) ;
    point(0,0,0) ;
  }
  //
  public void pointColour(PVector pos, PVector size, PVector hsb) {
    size = checkSize(size).copy() ;
    translate(pos.x, pos.y, pos.z);
    colour(hsb) ;
    stroke(colorPixelCam) ;
    strokeWeight(size.x) ;
    antiBugFillBlack(colorPixelCam) ;
    point(0,0,0)  ;
  }
  //
  public void boxMonochrome(PVector pos, PVector size, PVector hsb) {
    float depth = (hsb.z +.05f) *size.z ;
    if(horizon_is()) translate(pos.x, pos.y, depth *.5f); else translate(pos.x, pos.y, pos.z);
    monochrome(hsb) ;
    fill(colorPixelCam) ;
    antiBugFillBlack(colorPixelCam) ;
    noStroke() ;
    box(size.x, size.y, depth) ;
  }
  //
  public void boxColour(PVector pos, PVector size, PVector hsb) {
    float depth = (hsb.z +.05f) *size.z ;
    if(horizon_is()) translate(pos.x, pos.y, depth *.5f); else translate(pos.x, pos.y, pos.z);
    colour(hsb) ;
    fill(colorPixelCam) ;
    antiBugFillBlack(colorPixelCam) ;
    noStroke() ;
    box(size.x, size.y, depth) ;
  }

  public void antiBugFillBlack(int c) {
    if (alpha(c) == 0 ) {
      noFill() ; 
      noStroke() ; 
    } else {     
      fill (c) ; 
    }
  }
    
    
  //Annexe
  
  // security size 
  public PVector checkSize(PVector size) {
    float minSize = .5f ;
    if (size.x < minSize ) size.x = minSize ;
    if (size.y < minSize ) size.y = minSize ;
    if (size.z < minSize ) size.z = minSize ;
    return size ;
  }
  
  public void colour(PVector hsb) {
    float newSat = hsb.y *map(saturation(get_fill()),0,100,0,1) ;
    float newBrigth = hsb.z *map(brightness(get_fill()),0,100,0,1) ;
    colorPixelCam = color(hsb.x, newSat, newBrigth, alpha(get_fill()));
  }
  
  public void monochrome(PVector hsb) {
    float newHue = hue(get_fill()) ;
    float newSat = hsb.y *map(saturation(get_fill()),0,100,0,1) ;
    float newBrigth = hsb.z *map(brightness(get_fill()),0,100,0,1) ;
    //display the result
    colorPixelCam = color(newHue, newSat, newBrigth, alpha(get_fill()));
  }
}
/**
* Template
* the tab is the template that you can duplicate to add the item you want in your Romanesco.
* You must change the class name and this one must be unique.
* v 0.0.4
* 2012-2019
*/
class Template extends Romanesco {
  public Template() {
    //from the index_objects.csv
    item_name = "Template" ;
    item_author  = "Stan le Punk";
    item_references = "";
    item_version = "Version 0.0.4";
    item_pack = "Template 2012-2019" ;
    item_costume = "point/ellipse/triangle/rect/cross/pentagon/Star 5/Star 7/Super Star 8/Super Star 12"; // costume available from get_costume();
    item_mode = "";
    // define slider
    // COL 1
    hue_fill_is = true;
    sat_fill_is = true;
    bright_fill_is = true;
    alpha_fill_is = true;
    hue_stroke_is = true;
    sat_stroke_is = true;
    bright_stroke_is = true;
    alpha_stroke_is = true;
    thickness_is = true;
    size_x_is = true;
    size_y_is = true;
    size_z_is = true;
    // diameter_is = true;
    // canvas_x_is = true;
    // canvas_y_is = true;
    // canvas_z_is = true;
    // COL 2
    // frequence_is = true;
    // speed_x_is = true;
    // speed_y_is = true;
    // speed_z_is = true;
    // spurt_x_is = true;
    // spurt_y_is = true;
    // spurt_z_is = true;
    //dir_x_is = true;
    // dir_y_is = true;
    // dir_z_is = true;
    // jit_x_is = true;
    // jit_y_is = true;
    // jit_z_is  = true;
    // swing_x_is = true;
    // swing_y_is = true;
    // swing_z_is = true;
    // COL 3
    // quantity_is = true;
    // variety_is =true;
    // life_is = true;
    // flow_is = true;
    // quality_is = true;
    // area_is = true;
    // angle_is = true;
    // scope_is = true;
    // scan_is = true;
    // align_is = true;
    // repulsion_is = true;
    // attraction_is = true;
    // density_is = true;
    // influence_is = true;
    // calm_is = true;
    // spectrum_is = true;
    // COL 4
    // grid_is = true;
    // viscosity_is = true;
    // diffusion_is = true;
    // power_is = true;
    // mass_is = true;
    // coord_x_is = true;
    // coord_y_is = true;
    // coord_z_is = true;
  }

  public void setup() {
    // give the starting position of your item on the 3D grid
    setting_start_position(ID_item,width/2,height/2,0);
  }
  
  //DRAW
  public void draw() {
    // here if you want code in 3D mode
    info("info about the item","more","more");
    aspect(get_fill(),get_stroke(),get_thickness());
    set_ratio_costume_size(map(get_area(),get_area_min(),get_area_max(),0,1));
    costume(vec3(),get_size(),get_costume());
  }

  public void draw_2D() {
    // here if you want code in 2D mode
  }   
}















/**
Abstract CLASS ROMANESCO
v 1.4.1
2013-2019
*/
public abstract class Romanesco implements rope.core.R_Constants {
  protected String item_name;
  protected String item_author;
  protected String item_references;
  protected String item_version;
  protected String item_pack;
  protected String romanesco_renderer;
  protected String item_costume;
  protected String item_mode;
  protected String item_slider;

  protected int ID_item;
  protected int ID_group;

  // value slider
  int fill,stroke;

  Varom fill_hue,fill_sat,fill_bright,fill_alpha;
  Varom stroke_hue,stroke_sat,stroke_bright,stroke_alpha;
  Varom thickness; 
  Varom size_x,size_y,size_z;
  Varom diameter;
  Varom canvas_x,canvas_y,canvas_z;

  Varom frequence;
  Varom speed_x,speed_y,speed_z;
  Varom spurt_x,spurt_y,spurt_z;
  Varom dir_x,dir_y,dir_z;
  Varom jitter_x,jitter_y,jitter_z;
  Varom swing_x,swing_y,swing_z;

  Varom quantity,variety;
  Varom life,flow,quality;

  Varom area,angle,scope,scan;
  Varom alignment,repulsion,attraction,density;
  Varom influence,calm,spectrum;

  Varom grid;
  Varom viscosity,diffusion;

  Varom power;
  Varom mass;
  Varom coord_x,coord_y,coord_z;


  // parameter
  boolean show,sound,action,parameter;

  Mode mode;
  Costume costume;
  int costume_id;

  boolean birth, colour, dimension, horizon, motion, follow, reverse, special, wire;
  boolean fill_is, stroke_is;
  boolean setting, clearList;

  ROFont font_item;


  // state slider is
  // col 1
  protected boolean hue_fill_is;
  protected boolean sat_fill_is;
  protected boolean bright_fill_is;
  protected boolean alpha_fill_is;
  protected boolean hue_stroke_is;
  protected boolean sat_stroke_is;
  protected boolean bright_stroke_is;
  protected boolean alpha_stroke_is;
  protected boolean thickness_is;
  protected boolean size_x_is;
  protected boolean size_y_is;
  protected boolean size_z_is;
  protected boolean diameter_is;
  protected boolean canvas_x_is;
  protected boolean canvas_y_is;
  protected boolean canvas_z_is;
  // col 2
  protected boolean frequence_is;
  protected boolean speed_x_is;
  protected boolean speed_y_is;
  protected boolean speed_z_is;
  protected boolean spurt_x_is;
  protected boolean spurt_y_is;
  protected boolean spurt_z_is;
  protected boolean dir_x_is;
  protected boolean dir_y_is;
  protected boolean dir_z_is;
  protected boolean jit_x_is;
  protected boolean jit_y_is;
  protected boolean jit_z_is;
  protected boolean swing_x_is;
  protected boolean swing_y_is;
  protected boolean swing_z_is;
  // col 3
  protected boolean quantity_is;
  protected boolean variety_is;
  protected boolean life_is;
  protected boolean flow_is;
  protected boolean quality_is;
  protected boolean area_is;
  protected boolean angle_is;
  protected boolean scope_is;
  protected boolean scan_is;
  protected boolean align_is;
  protected boolean repulsion_is;
  protected boolean attraction_is;
  protected boolean density_is;
  protected boolean influence_is;
  protected boolean calm_is;
  protected boolean spectrum_is;
  // col 4
  protected boolean grid_is;
  protected boolean viscosity_is;
  protected boolean diffusion_is;
  protected boolean power_is;
  protected boolean mass_is;
  protected boolean coord_x_is;
  protected boolean coord_y_is;
  protected boolean coord_z_is;  
  
  public Romanesco() {
    item_name = "Unknown";
    item_author = "Anonymous";
    item_references = "none";
    item_version = "Alpha";
    item_pack = "Base 2012-2018";
    item_costume = ""; // separate the name by a slash and write the next mode immadialtly after this one.
    item_mode = ""; // separate the name by a slash and write the next mode immadialtly after this one.
    item_slider = "";
    ID_group = 0;
    ID_item = 0;

    hue_fill_is = false;
    sat_fill_is = false;
  }

  //manager return
  public void set_slider(String [][] slider) {
    if(!hue_fill_is) item_slider +="," ; else item_slider += (slider[0][0] +",");
    if(!sat_fill_is) item_slider +="," ; else item_slider += (slider[0][1]+",");
    if(!bright_fill_is) item_slider +="," ; else item_slider += (slider[0][2]+",");
    if(!alpha_fill_is) item_slider +="," ; else item_slider += (slider[0][3]+",");
    if(!hue_stroke_is) item_slider +="," ; else item_slider += (slider[0][4] +",");
    if(!sat_stroke_is) item_slider +="," ; else item_slider += (slider[0][5]+",");
    if(!bright_stroke_is) item_slider +="," ; else item_slider += (slider[0][6]+",");
    if(!alpha_stroke_is) item_slider +="," ; else item_slider += (slider[0][7]+",");
    if(!thickness_is) item_slider +="," ; else item_slider += (slider[0][8]+",");
    if(!size_x_is) item_slider +="," ; else item_slider += (slider[0][9]+",");
    if(!size_y_is) item_slider +="," ; else item_slider += (slider[0][10]+",");
    if(!size_z_is) item_slider +="," ; else item_slider += (slider[0][11]+",");
    if(!diameter_is) item_slider +="," ; else item_slider += (slider[0][12]+",");
    if(!canvas_x_is) item_slider +="," ; else item_slider += (slider[0][13]+",");
    if(!canvas_y_is) item_slider +="," ; else item_slider += (slider[0][14]+",");
    if(!canvas_z_is) item_slider +="," ; else item_slider += (slider[0][15]+",");

    if(!frequence_is) item_slider +="," ; else item_slider += (slider[1][0]+",");
    if(!speed_x_is) item_slider +="," ; else item_slider += (slider[1][1]+",");
    if(!speed_y_is) item_slider +="," ; else item_slider += (slider[1][2]+",");
    if(!speed_z_is) item_slider +="," ; else item_slider += (slider[1][3]+",");
    if(!spurt_x_is) item_slider +="," ; else item_slider += (slider[1][4]+",");
    if(!spurt_y_is) item_slider +="," ; else item_slider += (slider[1][5]+",");
    if(!spurt_z_is) item_slider +="," ; else item_slider += (slider[1][6]+",");
    if(!dir_x_is) item_slider +="," ; else item_slider += (slider[1][7]+",");
    if(!dir_y_is) item_slider +="," ; else item_slider += (slider[1][8]+",");
    if(!dir_z_is) item_slider +="," ; else item_slider += (slider[1][9]+",");
    if(!jit_x_is) item_slider +="," ; else item_slider += (slider[1][10]+",");
    if(!jit_y_is) item_slider +="," ; else item_slider += (slider[1][11]+",");
    if(!jit_z_is) item_slider +="," ; else item_slider += (slider[1][12]+",");
    if(!swing_x_is) item_slider +="," ; else item_slider += (slider[1][13]+",");
    if(!swing_y_is) item_slider +="," ; else item_slider += (slider[1][14]+",");
    if(!swing_z_is) item_slider +="," ; else item_slider += (slider[1][15]+",");

    if(!quantity_is) item_slider +="," ; else item_slider += (slider[2][0]+",");
    if(!variety_is) item_slider +="," ; else item_slider += (slider[2][1]+",");
    if(!life_is) item_slider +="," ; else item_slider += (slider[2][2]+",");
    if(!flow_is) item_slider +="," ; else item_slider += (slider[2][3]+",");
    if(!quality_is) item_slider +="," ; else item_slider += (slider[2][4]+",");
    if(!area_is) item_slider +="," ; else item_slider += (slider[2][5]+",");
    if(!angle_is) item_slider +="," ; else item_slider += (slider[2][6]+",");
    if(!scope_is) item_slider +="," ; else item_slider += (slider[2][7]+",");
    if(!scan_is) item_slider +="," ; else item_slider += (slider[2][8]+",");
    if(!align_is) item_slider +="," ; else item_slider += (slider[2][9]+",");
    if(!repulsion_is) item_slider +="," ; else item_slider += (slider[2][10]+",");
    if(!attraction_is) item_slider +="," ; else item_slider += (slider[2][11]+",");
    if(!density_is) item_slider +="," ; else item_slider += (slider[2][12]+",");
    if(!influence_is) item_slider +="," ; else item_slider += (slider[2][13]+",");
    if(!calm_is) item_slider +="," ; else item_slider += (slider[2][14]+",");
    if(!spectrum_is) item_slider +="," ; else item_slider += (slider[2][15]+",");

    if(!grid_is) item_slider +="," ; else item_slider += (slider[3][0]+",");
    if(!viscosity_is) item_slider +="," ; else item_slider += (slider[3][1]+",");
    if(!diffusion_is) item_slider +="," ; else item_slider += (slider[3][2]+",");
    if(!power_is) item_slider +="," ; else item_slider += (slider[3][3]+",");
    if(!mass_is) item_slider +="," ; else item_slider += (slider[3][4]+",");
    if(!coord_x_is) item_slider +="," ; else item_slider += (slider[3][5]+",");
    if(!coord_y_is) item_slider +="," ; else item_slider += (slider[3][6]+",");
    if(!coord_z_is) item_slider +="," ; else item_slider += (slider[3][7]+",");
  }

  

  // Must be declared in the sub-classes
  public abstract void setup();

  public abstract void draw();


  protected void draw_2D() {}


  protected void init() {
    costume = new Costume(p5,ELLIPSE_ROPE);
    mode = new Mode();
    fill_is(true);
    stroke_is(true);
    set_thickness_raw(1,0,0);
    wire_is(true);
  }


  protected void info(Object... obj) {
    String mark = " | ";
    item_info[ID_item] = write_message_sep(mark,obj);
  }

  /**
  * set method
  */
  protected void set_id(int id) {
    ID_item = id;
  }

  protected void set_group(int group) {
    ID_group = group;
  }

  protected void set_mode(Mode mode) {
    this.mode = mode;
  }
  
  /**
  * set costume from here is tricky, because there is dependancy from the String item_custume
  */
  protected void set_costume_id(int costume_id) {
    if(costume_id >= 0 && costume_id < split(item_costume,"/").length) {
      this.costume_id = costume_id;
    }
  }


  protected void set_costume(Costume costume, int id) {
    this.costume = costume;
    this.costume_id = costume_id;
  }
  
  // set boolean button controller
  protected void show_is(boolean show) {
    this.show = show;
  }

  protected void sound_is(boolean sound) {
    this.sound = sound;
  }

  protected void action_is(boolean action) {
    this.action = action; 
  } 

  protected void parameter_is(boolean parameter) {
    this.parameter = parameter;
  }






  /**
  * SET CONTROL SLIDER
  * v 0.1.0
  */
  // FILL
  protected void set_fill(float... arg) {
    if(arg.length == 1) {
      set_fill(arg[0],arg[0],arg[0],g.colorModeA);
    } else if(arg.length == 2) {
      set_fill(arg[0],arg[0],arg[0],arg[1]);
    } else if(arg.length == 3) {
      set_fill(arg[0],arg[1],arg[2],g.colorModeA);
    } else if(arg.length == 4) {
      set_fill(arg[0],arg[1],arg[2],arg[3]);
    } else {
      printErrTempo(60,"method set_fill(float... arg) wait for an array length from 1 to 4");
    }
  }

  protected void set_fill(float x, float y, float z, float a) {
    this.fill = color(x,y,z,a);
    set_fill_hue(x);
    set_fill_sat(y);
    set_fill_bright(z);
    set_fill_alpha(a);
  }

  
  // hue
  protected void set_fill_hue(float fill_hue) {
    this.fill_hue.set(fill_hue);
  }

  protected void set_fill_hue_raw(float fill_hue) {
    set_fill_hue_raw(fill_hue,0,0);
  }

  protected void set_fill_hue_raw(float fill_hue, int begin, int end) {
    if(this.fill_hue == null) this.fill_hue = new Varom();
    this.fill_hue.set_raw(fill_hue,begin,end);
  }

  protected void set_fill_hue_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.fill_hue == null) this.fill_hue = new Varom();
    this.fill_hue.set_min_raw(min_raw);
    this.fill_hue.set_max_raw(max_raw);
    this.fill_hue.set_min(min);
    this.fill_hue.set_max(max);
  }
  
  // sat
  protected void set_fill_sat(float fill_sat) {
     this.fill_sat.set(fill_sat);
  }

  protected void set_fill_sat_raw(float fill_sat) {
     set_fill_sat_raw(fill_sat,0,0);
  }

  protected void set_fill_sat_raw(float fill_sat, int begin, int end) {
    if(this.fill_sat == null) this.fill_sat = new Varom();
    this.fill_sat.set_raw(fill_sat,begin,end);
  }

  protected void set_fill_sat_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.fill_sat == null) this.fill_sat = new Varom();
    this.fill_sat.set_min_raw(min_raw);
    this.fill_sat.set_max_raw(max_raw);
    this.fill_sat.set_min(min);
    this.fill_sat.set_max(max);
  }
  
  // bright
  protected void set_fill_bright(float fill_bright) {
     this.fill_bright.set(fill_bright);
  }

  protected void set_fill_bright_raw(float fill_bright) {
     set_fill_bright_raw(fill_bright,0,0);
  }

  protected void set_fill_bright_raw(float fill_bright, int begin, int end) {
    if(this.fill_bright == null) this.fill_bright = new Varom();
    this.fill_bright.set_raw(fill_bright,begin,end);
  }

  protected void set_fill_bright_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.fill_bright == null) this.fill_bright = new Varom();
    this.fill_bright.set_min_raw(min_raw);
    this.fill_bright.set_max_raw(max_raw);
    this.fill_bright.set_min(min);
    this.fill_bright.set_max(max);
  }
  
  // alpha
  protected void set_fill_alpha(float fill_alpha) {
     this.fill_alpha.set(fill_alpha);
  }

  protected void set_fill_alpha_raw(float fill_alpha) {
     set_fill_alpha_raw(fill_alpha,0,0);
  }

  protected void set_fill_alpha_raw(float fill_alpha, int begin, int end) {
    if(this.fill_alpha == null) this.fill_alpha = new Varom();
    this.fill_alpha.set_raw(fill_alpha,begin,end);
  }

  protected void set_fill_alpha_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.fill_alpha == null) this.fill_alpha = new Varom();
    this.fill_alpha.set_min_raw(min_raw);
    this.fill_alpha.set_max_raw(max_raw);
    this.fill_alpha.set_min(min);
    this.fill_alpha.set_max(max);
  }


  // STROKE
  protected void set_stroke(float... arg) {
    if(arg.length == 1) {
      set_stroke(arg[0],arg[0],arg[0],g.colorModeA);
    } else if(arg.length == 2) {
      set_stroke(arg[0],arg[0],arg[0],arg[1]);
    } else if(arg.length == 3) {
      set_stroke(arg[0],arg[1],arg[2],g.colorModeA);
    } else if(arg.length == 4) {
      set_stroke(arg[0],arg[1],arg[2],arg[3]);
    } else {
      printErrTempo(60,"method set_stroke(float... arg) wait for an array length from 1 to 4");
    }
  }

  protected void set_stroke(float x, float y, float z, float a) {
    this.stroke = color(x,y,z,a);
    set_stroke_hue(x);
    set_stroke_sat(y);
    set_stroke_bright(z);
    set_stroke_alpha(a);
  }

  
  // stroke hue
  protected void set_stroke_hue(float stroke_hue) {
     this.stroke_hue.set(stroke_hue);
  }

  protected void set_stroke_hue_raw(float stroke_hue) {
     set_stroke_hue_raw(stroke_hue,0,0);
  }

  protected void set_stroke_hue_raw(float stroke_hue, int begin, int end) {
    if(this.stroke_hue == null) this.stroke_hue = new Varom();
    this.stroke_hue.set_raw(stroke_hue,begin,end);
  }

  protected void set_stroke_hue_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.stroke_hue == null) this.stroke_hue = new Varom();
    this.stroke_hue.set_min_raw(min_raw);
    this.stroke_hue.set_max_raw(max_raw);
    this.stroke_hue.set_min(min);
    this.stroke_hue.set_max(max);
  }
  
  // stroke sat
  protected void set_stroke_sat(float stroke_sat) {
     this.stroke_sat.set(stroke_sat);
  }

  protected void set_stroke_sat_raw(float stroke_sat) {
     set_stroke_sat_raw(stroke_sat,0,0);
  }

  protected void set_stroke_sat_raw(float stroke_sat, int begin, int end) {
    if(this.stroke_sat == null) this.stroke_sat = new Varom();
    this.stroke_sat.set_raw(stroke_sat,begin,end);
  }

  protected void set_stroke_sat_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.stroke_sat == null) this.stroke_sat = new Varom();
    this.stroke_sat.set_min_raw(min_raw);
    this.stroke_sat.set_max_raw(max_raw);
    this.stroke_sat.set_min(min);
    this.stroke_sat.set_max(max);
  }
  
  // stroke bright
  protected void set_stroke_bright(float stroke_bright) {
     this.stroke_bright.set(stroke_bright);
  }

  protected void set_stroke_bright_raw(float stroke_bright) {
     set_stroke_bright_raw(stroke_bright,0,0);
  }

  protected void set_stroke_bright_raw(float stroke_bright, int begin, int end) {
    if(this.stroke_bright == null) this.stroke_bright = new Varom();
    this.stroke_bright.set_raw(stroke_bright,begin,end);
  }

  protected void set_stroke_bright_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.stroke_bright == null) this.stroke_bright = new Varom();
    this.stroke_bright.set_min_raw(min_raw);
    this.stroke_bright.set_max_raw(max_raw);
    this.stroke_bright.set_min(min);
    this.stroke_bright.set_max(max);
  }

  // stroke alpha
  protected void set_stroke_alpha(float stroke_alpha) {
     this.stroke_alpha.set(stroke_alpha);
  }

  protected void set_stroke_alpha_raw(float stroke_alpha) {
     set_stroke_alpha_raw(stroke_alpha,0,0);
  }

  protected void set_stroke_alpha_raw(float stroke_alpha, int begin, int end) {
    if(this.stroke_alpha == null) this.stroke_alpha = new Varom();
    this.stroke_alpha.set_raw(stroke_alpha,begin,end);
  }

  protected void set_stroke_alpha_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.stroke_alpha == null) this.stroke_alpha = new Varom();
    this.stroke_alpha.set_min_raw(min_raw);
    this.stroke_alpha.set_max_raw(max_raw);
    this.stroke_alpha.set_min(min);
    this.stroke_alpha.set_max(max);
  }
  

  // thickness
  protected void set_thickness_raw(float thickness) {
    set_thickness_raw(thickness,0,0);
  }

  protected void set_thickness_raw(float thickness, int begin, int end) {
    if(this.thickness == null) this.thickness = new Varom();
    this.thickness.set_raw(thickness,begin,end);
  }

  protected void set_thickness_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.thickness == null) this.thickness = new Varom();
    this.thickness.set_min_raw(min_raw);
    this.thickness.set_max_raw(max_raw);
    this.thickness.set_min(min);
    this.thickness.set_max(max);
  }

  // SIZE
  protected void set_size_raw(float size) {
    set_size_raw(size,0,0);
  }

  protected void set_size_raw(float size, int begin, int end) {
    set_size_x_raw(size,begin,end);
    set_size_y_raw(size,begin,end);
    set_size_z_raw(size,begin,end);
  }
  
  // size x
  protected void set_size_x_raw(float size_x) {
    set_size_x_raw(size_x,0,0);
  }

  protected void set_size_x_raw(float size_x, int begin, int end) {
    if(this.size_x == null) this.size_x = new Varom();
    this.size_x.set_raw(size_x,begin,end);
  }

  protected void set_size_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.size_x == null) this.size_x = new Varom();
    this.size_x.set_min_raw(min_raw);
    this.size_x.set_max_raw(max_raw);
    this.size_x.set_min(min);
    this.size_x.set_max(max);
  }
  
  // size y
  protected void set_size_y_raw(float size_y) {
    set_size_y_raw(size_y,0,0);
  }

  protected void set_size_y_raw(float size_y, int begin, int end) {
    if(this.size_y == null) this.size_y = new Varom();
    this.size_y.set_raw(size_y,begin,end);
  }

  protected void set_size_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.size_y == null) this.size_y = new Varom();
    this.size_y.set_min_raw(min_raw);
    this.size_y.set_max_raw(max_raw);
    this.size_y.set_min(min);
    this.size_y.set_max(max);
  }

  // size z
  protected void set_size_z_raw(float size_z) {
    set_size_z_raw(size_z,0,0);
  }

  protected void set_size_z_raw(float size_z, int begin, int end) {
    if(this.size_z == null) this.size_z = new Varom();
    this.size_z.set_raw(size_z,begin,end);
  }

  protected void set_size_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.size_z == null) this.size_z = new Varom();
    this.size_z.set_min_raw(min_raw);
    this.size_z.set_max_raw(max_raw);
    this.size_z.set_min(min);
    this.size_z.set_max(max);
  }
  
  // diameter
  protected void set_diameter_raw(float diameter) {
     set_diameter_raw(diameter,0,0);
  }

  protected void set_diameter_raw(float diameter, int begin, int end) {
    if(this.diameter == null) this.diameter = new Varom();
    this.diameter.set_raw(diameter,begin,end);
  }

  protected void set_diameter_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.diameter == null) this.diameter = new Varom();
    this.diameter.set_min_raw(min_raw);
    this.diameter.set_max_raw(max_raw);
    this.diameter.set_min(min);
    this.diameter.set_max(max);
  }
  
  // CANVAS
  protected void set_canvas_raw(float canvas) {
     set_canvas_raw(canvas,0,0);
  }

  protected void set_canvas_raw(float canvas, int begin, int end) {
    set_canvas_x_raw(canvas,begin,end);
    set_canvas_y_raw(canvas,begin,end);
    set_canvas_z_raw(canvas,begin,end);
  }

  // canvas x
  protected void set_canvas_x_raw(float canvas_x) {
     set_canvas_x_raw(canvas_x,0,0);
  }

  protected void set_canvas_x_raw(float canvas_x, int begin, int end) {
    if(this.canvas_x == null) this.canvas_x = new Varom();
    this.canvas_x.set_raw(canvas_x,begin,end);
  }

  protected void set_canvas_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.canvas_x == null) this.canvas_x = new Varom();
    this.canvas_x.set_min_raw(min_raw);
    this.canvas_x.set_max_raw(max_raw);
    this.canvas_x.set_min(min);
    this.canvas_x.set_max(max);
  }

  // canvas y
  protected void set_canvas_y_raw(float canvas_y) {
     set_canvas_y_raw(canvas_y,0,0);
  }

  protected void set_canvas_y_raw(float canvas_y, int begin, int end) {
    if(this.canvas_y == null) this.canvas_y = new Varom();
    this.canvas_y.set_raw(canvas_y,begin,end);
  }

  protected void set_canvas_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.canvas_y == null) this.canvas_y = new Varom();
    this.canvas_y.set_min_raw(min_raw);
    this.canvas_y.set_max_raw(max_raw);
    this.canvas_y.set_min(min);
    this.canvas_y.set_max(max);
  }

  // canvas z
  protected void set_canvas_z_raw(float canvas_z) {
     set_canvas_z_raw(canvas_z,0,0);
  }

  protected void set_canvas_z_raw(float canvas_z, int begin, int end) {
    if(this.canvas_z == null) this.canvas_z = new Varom();
    this.canvas_z.set_raw(canvas_z,begin,end);
  }

  protected void set_canvas_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.canvas_z == null) this.canvas_z = new Varom();
    this.canvas_z.set_min_raw(min_raw);
    this.canvas_z.set_max_raw(max_raw);
    this.canvas_z.set_min(min);
    this.canvas_z.set_max(max);
  }
  
  // COL 2
  // frequence
  protected void set_frequence_raw(float frequence) {
    set_frequence_raw(frequence,0,0);
  }

  protected void set_frequence_raw(float frequence, int begin, int end) {
    if(this.frequence == null) this.frequence = new Varom();
    this.frequence.set_raw(frequence,begin,end);
  }

  protected void set_frequence_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.frequence == null) this.frequence = new Varom();
    this.frequence.set_min_raw(min_raw);
    this.frequence.set_max_raw(max_raw);
    this.frequence.set_min(min);
    this.frequence.set_max(max);
  }
  
  // SPEED
  protected void set_speed_raw(float speed) {
     set_speed_raw(speed,0,0);
  }

  protected void set_speed_raw(float speed, int begin, int end) {
    set_speed_x_raw(speed,begin,end);
    set_speed_y_raw(speed,begin,end);
    set_speed_z_raw(speed,begin,end);
  }
  
  // speed x
  protected void set_speed_x_raw(float speed_x) {
     set_speed_x_raw(speed_x,0,0);
  }

  protected void set_speed_x_raw(float speed_x, int begin, int end) {
    if(this.speed_x == null) this.speed_x = new Varom();
    this.speed_x.set_raw(speed_x,begin,end);
  }

  protected void set_speed_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.speed_x == null) this.speed_x = new Varom();
    this.speed_x.set_min_raw(min_raw);
    this.speed_x.set_max_raw(max_raw);
    this.speed_x.set_min(min);
    this.speed_x.set_max(max);
  }
  
  // speed y
  protected void set_speed_y_raw(float speed_y) {
     set_speed_y_raw(speed_y,0,0);
  }

  protected void set_speed_y_raw(float speed_y, int begin, int end) {
    if(this.speed_y == null) this.speed_y = new Varom();
    this.speed_y.set_raw(speed_y,begin,end);
  }

  protected void set_speed_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.speed_y == null) this.speed_y = new Varom();
    this.speed_y.set_min_raw(min_raw);
    this.speed_y.set_max_raw(max_raw);
    this.speed_y.set_min(min);
    this.speed_y.set_max(max);
  }
  
  // speed z
  protected void set_speed_z_raw(float speed_z) {
    set_speed_z_raw(speed_z,0,0);
  }

  protected void set_speed_z_raw(float speed_z, int begin, int end) {
    if(this.speed_z == null) this.speed_z = new Varom();
    this.speed_z.set_raw(speed_z,begin,end);
  }

  protected void set_speed_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.speed_z == null) this.speed_z = new Varom();
    this.speed_z.set_min_raw(min_raw);
    this.speed_z.set_max_raw(max_raw);
    this.speed_z.set_min(min);
    this.speed_z.set_max(max);
  }
  
  // SPURT
  protected void set_spurt_raw(float spurt) {
    set_spurt_raw(spurt,0,0);
  }

  protected void set_spurt_raw(float spurt, int begin, int end) {
    set_spurt_x_raw(spurt,begin,end);
    set_spurt_y_raw(spurt,begin,end);
    set_spurt_z_raw(spurt,begin,end);
  }
  
  // spurt x
  protected void set_spurt_x_raw(float spurt_x) {
     set_spurt_x_raw(spurt_x,0,0);
  }

  protected void set_spurt_x_raw(float spurt_x, int begin, int end) {
    if(this.spurt_x == null) this.spurt_x = new Varom();
    this.spurt_x.set_raw(spurt_x,begin,end);
  }

  protected void set_spurt_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.spurt_x == null) this.spurt_x = new Varom();
    this.spurt_x.set_min_raw(min_raw);
    this.spurt_x.set_max_raw(max_raw);
    this.spurt_x.set_min(min);
    this.spurt_x.set_max(max);
  }

  // spurt y
  protected void set_spurt_y_raw(float spurt_y) {
     set_spurt_y_raw(spurt_y,0,0);
  }

  protected void set_spurt_y_raw(float spurt_y, int begin, int end) {
    if(this.spurt_y == null) this.spurt_y = new Varom();
    this.spurt_y.set_raw(spurt_y,begin,end);
  }

  protected void set_spurt_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.spurt_y == null) this.spurt_y = new Varom();
    this.spurt_y.set_min_raw(min_raw);
    this.spurt_y.set_max_raw(max_raw);
    this.spurt_y.set_min(min);
    this.spurt_y.set_max(max);
  }

  // spurt z
  protected void set_spurt_z_raw(float spurt_z) {
     set_spurt_z_raw(spurt_z,0,0);
  }

  protected void set_spurt_z_raw(float spurt_z, int begin, int end) {
    if(this.spurt_z == null) this.spurt_z = new Varom();
    this.spurt_z.set_raw(spurt_z,begin,end);
  }

  protected void set_spurt_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.spurt_z == null) this.spurt_z = new Varom();
    this.spurt_z.set_min_raw(min_raw);
    this.spurt_z.set_max_raw(max_raw);
    this.spurt_z.set_min(min);
    this.spurt_z.set_max(max);
  }
  
  // DIR
  protected void set_dir_raw(float dir) {
     set_dir_raw(dir,0,0);
  }

  protected void set_dir_raw(float dir, int begin, int end) {
    set_dir_x_raw(dir,begin,end);
    set_dir_y_raw(dir,begin,end);
    set_dir_z_raw(dir,begin,end);
  }
  
  // dir x
  protected void set_dir_x_raw(float dir_x) {
     set_dir_x_raw(dir_x,0,0);
  }

  protected void set_dir_x_raw(float dir_x, int begin, int end) {
    if(this.dir_x == null) this.dir_x = new Varom();
    this.dir_x.set_raw(dir_x,begin,end);
  }

  protected void set_dir_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.dir_x == null) this.dir_x = new Varom();
    this.dir_x.set_min_raw(min_raw);
    this.dir_x.set_max_raw(max_raw);
    this.dir_x.set_min(min);
    this.dir_x.set_max(max);
  }

  // dir y
  protected void set_dir_y_raw(float dir_y) {
     set_dir_y_raw(dir_y,0,0);
  }

  protected void set_dir_y_raw(float dir_y, int begin, int end) {
    if(this.dir_y == null) this.dir_y = new Varom();
    this.dir_y.set_raw(dir_y,begin,end);
  }

  protected void set_dir_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.dir_y == null) this.dir_y = new Varom();
    this.dir_y.set_min_raw(min_raw);
    this.dir_y.set_max_raw(max_raw);
    this.dir_y.set_min(min);
    this.dir_y.set_max(max);
  }

  // dir z
  protected void set_dir_z_raw(float dir_z) {
     set_dir_z_raw(dir_z,0,0);
  }

  protected void set_dir_z_raw(float dir_z, int begin, int end) {
    if(this.dir_z == null) this.dir_z = new Varom();
    this.dir_z.set_raw(dir_z,begin,end);
  }

  protected void set_dir_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.dir_z == null) this.dir_z = new Varom();
    this.dir_z.set_min_raw(min_raw);
    this.dir_z.set_max_raw(max_raw);
    this.dir_z.set_min(min);
    this.dir_z.set_max(max);
  }
  
  // JITTER
  protected void set_jitter_raw(float jitter) {
     set_jitter_raw(jitter,0,0);
  }

  protected void set_jitter_raw(float jitter, int begin, int end) {
    set_jitter_x_raw(jitter,begin,end);
    set_jitter_y_raw(jitter,begin,end);
    set_jitter_z_raw(jitter,begin,end);
  }

  // jitter x
  protected void set_jitter_x_raw(float jitter_x) {
     set_jitter_x_raw(jitter_x,0,0);
  }

  protected void set_jitter_x_raw(float jitter_x, int begin, int end) {
    if(this.jitter_x == null) this.jitter_x = new Varom();
    this.jitter_x.set_raw(jitter_x,begin,end);
  }

  protected void set_jitter_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.jitter_x == null) this.jitter_x = new Varom();
    this.jitter_x.set_min_raw(min_raw);
    this.jitter_x.set_max_raw(max_raw);
    this.jitter_x.set_min(min);
    this.jitter_x.set_max(max);
  }

  // jitter y
  protected void set_jitter_y_raw(float jitter_y) {
     set_jitter_y_raw(jitter_y,0,0);
  }

  protected void set_jitter_y_raw(float jitter_y, int begin, int end) {
    if(this.jitter_y == null) this.jitter_y = new Varom();
    this.jitter_y.set_raw(jitter_y,begin,end);
  }

  protected void set_jitter_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.jitter_y == null) this.jitter_y = new Varom();
    this.jitter_y.set_min_raw(min_raw);
    this.jitter_y.set_max_raw(max_raw);
    this.jitter_y.set_min(min);
    this.jitter_y.set_max(max);
  }

  // jitter z
  protected void set_jitter_z_raw(float jitter_z) {
     set_jitter_z_raw(jitter_z,0,0);
  }

  protected void set_jitter_z_raw(float jitter_z, int begin, int end) {
    if(this.jitter_z == null) this.jitter_z = new Varom();
    this.jitter_z.set_raw(jitter_z,begin,end);
  }

  protected void set_jitter_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.jitter_z == null) this.jitter_z = new Varom();
    this.jitter_z.set_min_raw(min_raw);
    this.jitter_z.set_max_raw(max_raw);
    this.jitter_z.set_min(min);
    this.jitter_z.set_max(max);
  }
  
  // SWING
  protected void set_swing_raw(float swing) {
     set_swing_raw(swing,0,0);
  }

  protected void set_swing_raw(float swing, int begin, int end) {
    set_swing_x_raw(swing,begin,end);
    set_swing_y_raw(swing,begin,end);
    set_swing_z_raw(swing,begin,end);
  }
  
  // swing x
  protected void set_swing_x_raw(float swing_x) {
     set_swing_x_raw(swing_x,0,0);
  }

  protected void set_swing_x_raw(float swing_x, int begin, int end) {
    if(this.swing_x == null) this.swing_x = new Varom();
    this.swing_x.set_raw(swing_x,begin,end);
  }

  protected void set_swing_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.swing_x == null) this.swing_x = new Varom();
    this.swing_x.set_min_raw(min_raw);
    this.swing_x.set_max_raw(max_raw);
    this.swing_x.set_min(min);
    this.swing_x.set_max(max);
  }
  
  // swing y
  protected void set_swing_y_raw(float swing_y) {
     set_swing_y_raw(swing_y,0,0);
  }

  protected void set_swing_y_raw(float swing_y, int begin, int end) {
    if(this.swing_y == null) this.swing_y = new Varom();
    this.swing_y.set_raw(swing_y,begin,end);
  }

  protected void set_swing_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.swing_y == null) this.swing_y = new Varom();
    this.swing_y.set_min_raw(min_raw);
    this.swing_y.set_max_raw(max_raw);
    this.swing_y.set_min(min);
    this.swing_y.set_max(max);
  }
  
  // swing z
  protected void set_swing_z_raw(float swing_z) {
     set_swing_z_raw(swing_z,0,0);
  }

  protected void set_swing_z_raw(float swing_z, int begin, int end) {
    if(this.swing_z == null) this.swing_z = new Varom();
    this.swing_z.set_raw(swing_z,begin,end);
  }

  protected void set_swing_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.swing_z == null) this.swing_z = new Varom();
    this.swing_z.set_min_raw(min_raw);
    this.swing_z.set_max_raw(max_raw);
    this.swing_z.set_min(min);
    this.swing_z.set_max(max);
  }


  // COL 3
  //quantity
  protected void set_quantity_raw(float quantity) {
     set_quantity_raw(quantity,0,0);
  }

  protected void set_quantity_raw(float quantity, int begin, int end) {
    if(this.quantity == null) this.quantity = new Varom();
    this.quantity.set_raw(quantity,begin,end);
  }

  protected void set_quantity_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.quantity == null) this.quantity = new Varom();
    this.quantity.set_min_raw(min_raw);
    this.quantity.set_max_raw(max_raw);
    this.quantity.set_min(min);
    this.quantity.set_max(max);
  }
  
  // variety
  protected void set_variety_raw(float variety) {
     set_variety_raw(variety,0,0);
  }

  protected void set_variety_raw(float variety, int begin, int end) {
    if(this.variety == null) this.variety = new Varom();
    this.variety.set_raw(variety,begin,end);
  }

  protected void set_variety_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.variety == null) this.variety = new Varom();
    this.variety.set_min_raw(min_raw);
    this.variety.set_max_raw(max_raw);
    this.variety.set_min(min);
    this.variety.set_max(max);
  }

  // life
  protected void set_life_raw(float life) {
     set_life_raw(life,0,0);
  }

  protected void set_life_raw(float life, int begin, int end) {
    if(this.life == null) this.life = new Varom();
    this.life.set_raw(life,begin,end);
  }

  protected void set_life_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.life == null) this.life = new Varom();
    this.life.set_min_raw(min_raw);
    this.life.set_max_raw(max_raw);
    this.life.set_min(min);
    this.life.set_max(max);
  }

  // flow
  protected void set_flow_raw(float flow) {
     set_flow_raw(flow,0,0);
  }

  protected void set_flow_raw(float flow, int begin, int end) {
    if(this.flow == null) this.flow = new Varom();
    this.flow.set_raw(flow,begin,end);
  }

  protected void set_flow_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.flow == null) this.flow = new Varom();
    this.flow.set_min_raw(min_raw);
    this.flow.set_max_raw(max_raw);
    this.flow.set_min(min);
    this.flow.set_max(max);
  }

  // quality
  protected void set_quality_raw(float quality) {
     set_quality_raw(quality,0,0);
  }

  protected void set_quality_raw(float quality, int begin, int end) {
    if(this.quality == null) this.quality = new Varom();
    this.quality.set_raw(quality,begin,end);
  }

  protected void set_quality_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.quality == null) this.quality = new Varom();
    this.quality.set_min_raw(min_raw);
    this.quality.set_max_raw(max_raw);
    this.quality.set_min(min);
    this.quality.set_max(max);
  }

  // area
  protected void set_area_raw(float area) {
    set_area_raw(area,0,0);
  }

  protected void set_area_raw(float area, int begin, int end) {
    if(this.area == null) this.area = new Varom();
    this.area.set_raw(area,begin,end);
  }

  protected void set_area_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.area == null) this.area = new Varom();
    this.area.set_min_raw(min_raw);
    this.area.set_max_raw(max_raw);
    this.area.set_min(min);
    this.area.set_max(max);
  }

  // angle
  protected void set_angle_raw(float angle) {
    set_angle_raw(angle,0,0);
  }

  protected void set_angle_raw(float angle, int begin, int end) {
    if(this.angle == null) this.angle = new Varom();
    this.angle.set_raw(angle,begin,end);
  }

  protected void set_angle_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.angle == null) this.angle = new Varom();
    this.angle.set_min_raw(min_raw);
    this.angle.set_max_raw(max_raw);
    this.angle.set_min(min);
    this.angle.set_max(max);
  }

  // scope
  protected void set_scope_raw(float scope) {
    set_scope_raw(scope,0,0);
  }

  protected void set_scope_raw(float scope, int begin, int end) {
    if(this.scope == null) this.scope = new Varom();
    this.scope.set_raw(scope,begin,end);
  }

  protected void set_scope_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.scope == null) this.scope = new Varom();
    this.scope.set_min_raw(min_raw);
    this.scope.set_max_raw(max_raw);
    this.scope.set_min(min);
    this.scope.set_max(max);
  }

  // scan
  protected void set_scan_raw(float scan) {
    set_scan_raw(scan,0,0);
  }

  protected void set_scan_raw(float scan, int begin, int end) {
    if(this.scan == null) this.scan = new Varom();
    this.scan.set_raw(scan,begin,end);
  }

  protected void set_scan_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.scan == null) this.scan = new Varom();
    this.scan.set_min_raw(min_raw);
    this.scan.set_max_raw(max_raw);
    this.scan.set_min(min);
    this.scan.set_max(max);
  }

  // alignment
  protected void set_alignment_raw(float alignment) {
    set_alignment_raw(alignment,0,0);
  }

  protected void set_alignment_raw(float alignment, int begin, int end) {
    if(this.alignment == null) this.alignment = new Varom();
    this.alignment.set_raw(alignment,begin,end);
  }

  protected void set_alignment_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.alignment == null) this.alignment = new Varom();
    this.alignment.set_min_raw(min_raw);
    this.alignment.set_max_raw(max_raw);
    this.alignment.set_min(min);
    this.alignment.set_max(max);
  }
  
  // repulsion
  protected void set_repulsion_raw(float repulsion) {
    set_repulsion_raw(repulsion,0,0);
  }

  protected void set_repulsion_raw(float repulsion, int begin, int end) {
    if(this.repulsion == null) this.repulsion = new Varom();
    this.repulsion.set_raw(repulsion,begin,end);
  }

  protected void set_repulsion_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.repulsion == null) this.repulsion = new Varom();
    this.repulsion.set_min_raw(min_raw);
    this.repulsion.set_max_raw(max_raw);
    this.repulsion.set_min(min);
    this.repulsion.set_max(max);
  }
  
  // attraction
  protected void set_attraction_raw(float attraction) {
    set_attraction_raw(attraction,0,0);
  }

  protected void set_attraction_raw(float attraction, int begin, int end) {
    if(this.attraction == null) this.attraction = new Varom();
    this.attraction.set_raw(attraction,begin,end);
  }

  protected void set_attraction_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.attraction == null) this.attraction = new Varom();
    this.attraction.set_min_raw(min_raw);
    this.attraction.set_max_raw(max_raw);
    this.attraction.set_min(min);
    this.attraction.set_max(max);
  }
  
  // density
  protected void set_density_raw(float density) {
    set_density_raw(density,0,0);
  }

  protected void set_density_raw(float density, int begin, int end) {
    if(this.density == null) this.density = new Varom();
    this.density.set_raw(density,begin,end);
  }

  protected void set_density_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.density == null) this.density = new Varom();
    this.density.set_min_raw(min_raw);
    this.density.set_max_raw(max_raw);
    this.density.set_min(min);
    this.density.set_max(max);
  }
  
  // influence
  protected void set_influence_raw(float influence) {
    set_influence_raw(influence,0,0);
  }

  protected void set_influence_raw(float influence, int begin, int end) {
    if(this.influence == null) this.influence = new Varom();
    this.influence.set_raw(influence,begin,end);
  }

  protected void set_influence_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.influence == null) this.influence = new Varom();
    this.influence.set_min_raw(min_raw);
    this.influence.set_max_raw(max_raw);
    this.influence.set_min(min);
    this.influence.set_max(max);
  }
  
  // calm
  protected void set_calm_raw(float calm) {
    set_calm_raw(calm,0,0);
  }

  protected void set_calm_raw(float calm, int begin, int end) {
    if(this.calm == null) this.calm = new Varom();
    this.calm.set_raw(calm,begin,end);
  }

  protected void set_calm_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.calm == null) this.calm = new Varom();
    this.calm.set_min_raw(min_raw);
    this.calm.set_max_raw(max_raw);
    this.calm.set_min(min);
    this.calm.set_max(max);
  }

  // spectrum
  protected void set_spectrum_raw(float spectrum) {
    set_spectrum_raw(spectrum,0,0);
  }

  protected void set_spectrum_raw(float spectrum, int begin, int end) {
    if(this.spectrum == null) this.spectrum = new Varom();
    this.spectrum.set_raw(spectrum,begin,end);
  }

  protected void set_spectrum_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.spectrum == null) this.spectrum = new Varom();
    this.spectrum.set_min_raw(min_raw);
    this.spectrum.set_max_raw(max_raw);
    this.spectrum.set_min(min);
    this.spectrum.set_max(max);
  }
  
  // COL 4
  // grid
  protected void set_grid_raw(float grid) {
    set_grid_raw(grid,0,0);
  }

  protected void set_grid_raw(float grid, int begin, int end) {
    if(this.grid == null) this.grid = new Varom();
    this.grid.set_raw(grid,begin,end);
  }

  protected void set_grid_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.grid == null) this.grid = new Varom();
    this.grid.set_min_raw(min_raw);
    this.grid.set_max_raw(max_raw);
    this.grid.set_min(min);
    this.grid.set_max(max);
  }
  
  // viscosity
  protected void set_viscosity_raw(float viscosity) {
    set_viscosity_raw(viscosity,0,0);
  }

  protected void set_viscosity_raw(float viscosity, int begin, int end) {
    if(this.viscosity == null) this.viscosity = new Varom();
    this.viscosity.set_raw(viscosity,begin,end);
  }

  protected void set_viscosity_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.viscosity == null) this.viscosity = new Varom();
    this.viscosity.set_min_raw(min_raw);
    this.viscosity.set_max_raw(max_raw);
    this.viscosity.set_min(min);
    this.viscosity.set_max(max);
  }
  
  // diffusion
  protected void set_diffusion_raw(float diffusion) {
    set_diffusion_raw(diffusion,0,0);
  }

  protected void set_diffusion_raw(float diffusion, int begin, int end) {
    if(this.diffusion == null) this.diffusion = new Varom();
    this.diffusion.set_raw(diffusion,begin,end);
  }

  protected void set_diffusion_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.diffusion == null) this.diffusion = new Varom();
    this.diffusion.set_min_raw(min_raw);
    this.diffusion.set_max_raw(max_raw);
    this.diffusion.set_min(min);
    this.diffusion.set_max(max);
  }
  
  // power
  protected void set_power_raw(float power) {
    set_power_raw(power,0,0);
  }

  protected void set_power_raw(float power, int begin, int end) {
    if(this.power == null) this.power = new Varom();
    this.power.set_raw(power,begin,end);
  }

  protected void set_power_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.power == null) this.power = new Varom();
    this.power.set_min_raw(min_raw);
    this.power.set_max_raw(max_raw);
    this.power.set_min(min);
    this.power.set_max(max);
  }
  
  // mass
  protected void set_mass_raw(float mass) {
    set_mass_raw(mass,0,0);
  }

  protected void set_mass_raw(float mass, int begin, int end) {
    if(this.mass == null) this.mass = new Varom();
    this.mass.set_raw(mass,begin,end);
  }

  protected void set_mass_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.mass == null) this.mass = new Varom();
    this.mass.set_min_raw(min_raw);
    this.mass.set_max_raw(max_raw);
    this.mass.set_min(min);
    this.mass.set_max(max);
  }
  
  // COORD
  protected void set_coord_raw(float coord) {
    set_coord_raw(coord,0,0);
  }

  protected void set_coord_raw(float coord, int begin, int end) {
    set_coord_x_raw(coord,begin,end);
    set_coord_y_raw(coord,begin,end);
    set_coord_z_raw(coord,begin,end);
  }

  // coord x
  protected void set_coord_x_raw(float coord_x) {
    set_coord_x_raw(coord_x,0,0);
  }

  protected void set_coord_x_raw(float coord_x, int begin, int end) {
    if(this.coord_x == null) this.coord_x = new Varom();
    this.coord_x.set_raw(coord_x,begin,end);
  }

  protected void set_coord_x_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.coord_x == null) this.coord_x = new Varom();
    this.coord_x.set_min_raw(min_raw);
    this.coord_x.set_max_raw(max_raw);
    this.coord_x.set_min(min);
    this.coord_x.set_max(max);
  }

  // coord y
  protected void set_coord_y_raw(float coord_y) {
    set_coord_y_raw(coord_y,0,0);
  }

  protected void set_coord_y_raw(float coord_y, int begin, int end) {
    if(this.coord_y == null) this.coord_y = new Varom();
    this.coord_y.set_raw(coord_y,begin,end);
  }

  protected void set_coord_y_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.coord_y == null) this.coord_y = new Varom();
    this.coord_y.set_min_raw(min_raw);
    this.coord_y.set_max_raw(max_raw);
    this.coord_y.set_min(min);
    this.coord_y.set_max(max);
  }

  // coord z
  protected void set_coord_z_raw(float coord_z) {
    set_coord_z_raw(coord_z,0,0);
  }

  protected void set_coord_z_raw(float coord_z, int begin, int end) {
    if(this.coord_z == null) this.coord_z = new Varom();
    this.coord_z.set_raw(coord_z,begin,end);
  }

  protected void set_coord_z_min_max(float min_raw, float max_raw, float min, float max) {
    if(this.coord_z == null) this.coord_z = new Varom();
    this.coord_z.set_min_raw(min_raw);
    this.coord_z.set_max_raw(max_raw);
    this.coord_z.set_min(min);
    this.coord_z.set_max(max);
  }










  // set boolean
  protected void set_show(boolean show) {
    this.show = show;
  }

  protected void set_sound(boolean sound) {
    this.sound = sound;
  }

  protected void set_action(boolean action) {
    this.action = action;
  }

  protected void set_parameter(boolean parameter) {
    this.parameter = parameter;
  }

  protected void birth_is(boolean birth) {
    this.birth = birth;
  }

  protected void colour_is(boolean colour) {
    this.colour = colour;
  }

  protected void dimension_is(boolean dimension) {
    this.dimension = dimension;
  }

  protected void horizon_is(boolean horizon) {
    this.horizon = horizon;
  }

  protected void motion_is(boolean motion) {
    this.motion = motion;
  }

  protected void follow_is(boolean follow) {
    this.follow = follow;
  }

  protected void reverse_is(boolean reverse) {
    this.reverse = reverse;
  }

  protected void special_is(boolean special) {
    this.special = special;
  }

  protected void wire_is(boolean wire) {
    this.wire = wire;
  }

  protected void fill_is(boolean fill_is) {
    this.fill_is = fill_is;
  }

  protected void stroke_is(boolean stroke_is) {
    this.stroke_is = stroke_is;
  }

  protected void switch_birth() {
    this.birth = !this.birth;
  }

  protected void switch_colour() {
    this.colour = !this.colour;
  }

  protected void switch_dimension() {
    this.dimension = !this.dimension;
  }

  protected void switch_horizon() {
    this.horizon = !this.horizon;
  }

  protected void switch_motion() {
    this.motion = !this.motion;
  }

  protected void switch_follow() {
    this.follow = !this.follow;
  }

  protected void switch_reverse() {
    this.reverse = !this.reverse;
  }

  protected void switch_special() {
    this.special = !this.special;
  }

  protected void switch_wire() {
    this.wire = !this.wire;
  }

  protected void switch_fill() {
    this.fill_is = !this.fill_is;
  }

  protected void switch_stroke() {
    this.stroke_is = !this.stroke_is;
  }

  protected void switch_setting() {
    this.setting = !this.setting;
  }

  protected void clearList_is(boolean clearList) {
    this.clearList = clearList;
  }

  protected void set_font(ROFont font) {
    this.font_item = font;
  }

  protected void select_font_type(String type) {
    for(int i = 0 ; i < font.length ;i++) {
      if(font[i].get_type().equals(type)) {
        font_item = font[i];
        break;
      }
    }
  }














  
  /**
  ALL GET METHOD
  */
  protected int get_id() {
    return ID_item;
  }

  protected int get_group() {
    return ID_group;
  }

  protected String get_name() {
    return item_name;
  }

  protected boolean show_is() {
    return show;
  }

  protected boolean sound_is() {
    return sound;
  }

  protected boolean action_is() {
    return action; 
  } 

  protected boolean parameter_is() {
    return parameter;
  }

  protected Mode get_mode() {
    return mode;
  }

  protected int get_mode_id() {
    return mode.get_id();
  }

  protected String [] get_mode_all_names() {
    return mode.get_name();
  }

  protected String get_mode_name() {
    return mode.get_name(mode.get_id());
  }

  protected Costume get_costume() {
    return get_costume_private();
  }

  protected int get_costume_id() {
    return costume_id;
  }




  /**
  state method use in Prescene generally
  */
  protected boolean fill_is() {
    return fill_is;
  }

  protected boolean stroke_is() {
    return stroke_is;
  }

  protected boolean birth_is() {
    return birth;
  }
  
  protected boolean colour_is() {
    return colour;

  }
  protected boolean dimension_is() {
    return dimension;
  }
  
  protected boolean horizon_is() {
    return horizon;
  }

  protected boolean motion_is() {
    return motion;
  }

  protected boolean follow_is() {
    return follow;
  }

  protected boolean reverse_is() {
    return reverse;
  }

  protected boolean wire_is() {
    return wire;
  }

  protected boolean special_is() {
    return special;
  }


  protected boolean clear_list_is() {
    return clearList;
  }
  


  /**
  * get slider method 
  */
  // FILL
  protected int get_fill() {
    return fill;
  }
  
  // fill_hue
  protected float get_fill_hue() {
    return fill_hue.get();
  }

  protected float get_fill_hue_raw() {
    return fill_hue.raw();
  }

  protected float get_fill_hue_max() {
    return fill_hue.max();
  }

  protected float get_fill_hue_min() {
    return fill_hue.min();
  }
  
  // fill_sat
  protected float get_fill_sat() {
    return fill_sat.get();
  }

  protected float get_fill_sat_raw() {
    return fill_sat.raw();
  }

  protected float get_fill_sat_max() {
    return fill_sat.max();
  }

  protected float get_fill_sat_min() {
    return fill_sat.min();
  }
  
  // fill_bright
  protected float get_fill_bright() {
    return fill_bright.get();
  }

  protected float get_fill_bright_raw() {
    return fill_bright.raw();
  }

  protected float get_fill_bright_max() {
    return fill_bright.max();
  }

  protected float get_fill_bright_min() {
    return fill_bright.min();
  }
  
  // fill_alpha
  protected float get_fill_alpha() {
    return fill_alpha.get();
  }

  protected float get_fill_alpha_raw() {
    return fill_alpha.raw();
  }

  protected float get_fill_alpha_max() {
    return fill_alpha.max();
  }

  protected float get_fill_alpha_min() {
    return fill_alpha.min();
  }
  
  // STROKE
  protected int get_stroke() {
    return stroke;
  }
  // stroke_hue
  protected float get_stroke_hue() {
    return stroke_hue.get();
  }

  protected float get_stroke_hue_raw() {
    return stroke_hue.raw();
  }

  protected float get_stroke_hue_max() {
    return stroke_hue.max();
  }

  protected float get_stroke_hue_min() {
    return stroke_hue.min();
  }
  
  // stroke_sat
  protected float get_stroke_sat() {
    return stroke_sat.get();
  }

  protected float get_stroke_sat_raw() {
    return stroke_sat.raw();
  }

  protected float get_stroke_sat_max() {
    return stroke_sat.max();
  }

  protected float get_stroke_sat_min() {
    return stroke_sat.min();
  }
  
  // stroke_bright
  protected float get_stroke_bright() {
    return stroke_bright.get();
  }

  protected float get_stroke_bright_raw() {
    return stroke_bright.raw();
  }

  protected float get_stroke_bright_max() {
    return stroke_bright.max();
  }

  protected float get_stroke_bright_min() {
    return stroke_bright.min();
  }
  
  // stroke_alpha
  protected float get_stroke_alpha() {
    return stroke_alpha.get();
  }

  protected float get_stroke_alpha_raw() {
    return stroke_alpha.raw();
  }

  protected float get_stroke_alpha_max() {
    return stroke_alpha.max();
  }

  protected float get_stroke_alpha_min() {
    return stroke_alpha.min();
  }

  // thickness
  protected float get_thickness() {
    return thickness.get();
  }

  protected float get_thickness_raw() {
    return thickness.raw();
  }

  protected float get_thickness_max() {
    return thickness.max();
  }

  protected float get_thickness_min() {
    return thickness.min();
  }
  

  // size
  protected vec3 get_size() {
    return vec3(get_size_x(),get_size_y(),get_size_z());
  }
  
  // size x
  protected float get_size_x() {
    return size_x.get();
  }

  protected float get_size_x_raw() {
    return size_x.raw();
  }

  protected float get_size_x_max() {
    return size_x.max();
  }

  protected float get_size_x_min() {
    return size_x.min();
  }

  // size y
  protected float get_size_y() {
    return size_y.get();
  }

  protected float get_size_y_raw() {
    return size_y.raw();
  }

  protected float get_size_y_max() {
    return size_y.max();
  }

  protected float get_size_y_min() {
    return size_y.min();
  }

  // size z
  protected float get_size_z() {
    return size_z.get();
  }

  protected float get_size_z_raw() {
    return size_z.raw();
  }

  protected float get_size_z_max() {
    return size_z.max();
  }

  protected float get_size_z_min() {
    return size_z.min();
  }
  
  // diameter
  protected float get_diameter() {
    return diameter.get();
  }

  protected float get_diameter_raw() {
    return diameter.raw();
  }

  protected float get_diameter_max() {
    return diameter.max();
  }

  protected float get_diameter_min() {
    return diameter.min();
  }

  // canvas
  protected vec3 get_canvas() {
    return vec3(get_canvas_x(),get_canvas_y(),get_canvas_z());
  }

  // canvas x
  protected float get_canvas_x() {
    return canvas_x.get();
  }

  protected float get_canvas_x_raw() {
    return canvas_x.raw();
  }

  protected float get_canvas_x_max() {
    return canvas_x.max();
  }

  protected float get_canvas_x_min() {
    return canvas_x.min();
  }

  // size y
  protected float get_canvas_y() {
    return canvas_y.get();
  }

  protected float get_canvas_y_raw() {
    return canvas_y.raw();
  }

  protected float get_canvas_y_max() {
    return canvas_y.max();
  }

  protected float get_canvas_y_min() {
    return canvas_y.min();
  }

  // size z
  protected float get_canvas_z() {
    return canvas_z.get();
  }

  protected float get_canvas_z_raw() {
    return canvas_z.raw();
  }

  protected float get_canvas_z_max() {
    return canvas_z.max();
  }

  protected float get_canvas_z_min() {
    return canvas_z.min();
  }


  // COL 2
  // frequence
  protected float get_frequence() {
    return frequence.get();
  }

  protected float get_frequence_raw() {
    return frequence.raw();
  }

  protected float get_frequence_max() {
    return frequence.max();
  }

  protected float get_frequence_min() {
    return frequence.min();
  }


  // speed
  protected vec3 get_speed() {
    return vec3(get_speed_x(),get_speed_y(),get_speed_z());
  }

  // speed x
  protected float get_speed_x() {
    return speed_x.get();
  }

  protected float get_speed_x_raw() {
    return speed_x.raw();
  }

  protected float get_speed_x_max() {
    return speed_x.max();
  }

  protected float get_speed_x_min() {
    return speed_x.min();
  }

  // speed y
  protected float get_speed_y() {
    return speed_y.get();
  }

  protected float get_speed_y_raw() {
    return speed_y.raw();
  }

  protected float get_speed_y_max() {
    return speed_y.max();
  }

  protected float get_speed_y_min() {
    return speed_y.min();
  }

  // speed z
  protected float get_speed_z() {
    return speed_z.get();
  }

  protected float get_speed_z_raw() {
    return speed_z.raw();
  }

  protected float get_speed_z_max() {
    return speed_z.max();
  }

  protected float get_speed_z_min() {
    return speed_z.min();
  }

  // spurt
  protected vec3 get_spurt() {
    return vec3(get_spurt_x(),get_spurt_y(),get_spurt_z());
  }

  // spurt x
  protected float get_spurt_x() {
    return spurt_x.get();
  }

  protected float get_spurt_x_raw() {
    return spurt_x.raw();
  }

  protected float get_spurt_x_max() {
    return spurt_x.max();
  }

  protected float get_spurt_x_min() {
    return spurt_x.min();
  }

  // spurt y
  protected float get_spurt_y() {
    return spurt_y.get();
  }

  protected float get_spurt_y_raw() {
    return spurt_y.raw();
  }

  protected float get_spurt_y_max() {
    return spurt_y.max();
  }

  protected float get_spurt_y_min() {
    return spurt_y.min();
  }

  // spurt z
  protected float get_spurt_z() {
    return spurt_z.get();
  }

  protected float get_spurt_z_raw() {
    return spurt_z.raw();
  }

  protected float get_spurt_z_max() {
    return spurt_z.max();
  }

  protected float get_spurt_z_min() {
    return spurt_z.min();
  }

  // DIR
  protected vec3 get_dir() {
    return vec3(get_dir_x(),get_dir_y(),get_dir_z());
  }

  // dir x
  protected float get_dir_x() {
    return dir_x.get();
  }

  protected float get_dir_x_raw() {
    return dir_x.raw();
  }

  protected float get_dir_x_max() {
    return dir_x.max();
  }

  protected float get_dir_x_min() {
    return dir_x.min();
  }

  // dir y
  protected float get_dir_y() {
    return dir_y.get();
  }

  protected float get_dir_y_raw() {
    return dir_y.raw();
  }

  protected float get_dir_y_max() {
    return dir_y.max();
  }

  protected float get_dir_y_min() {
    return dir_y.min();
  }

  // dir z
  protected float get_dir_z() {
    return dir_z.get();
  }

  protected float get_dir_z_raw() {
    return dir_z.raw();
  }

  protected float get_dir_z_max() {
    return dir_z.max();
  }

  protected float get_dir_z_min() {
    return dir_z.min();
  }

  // JITTER
  protected vec3 get_jitter() {
    return vec3(get_jitter_x(),get_jitter_y(),get_jitter_z());
  }

  // jitter x
  protected float get_jitter_x() {
    return jitter_x.get();
  }

  protected float get_jitter_x_raw() {
    return jitter_x.raw();
  }

  protected float get_jitter_x_max() {
    return jitter_x.max();
  }

  protected float get_jitter_x_min() {
    return jitter_x.min();
  }

  // jitter y
  protected float get_jitter_y() {
    return jitter_y.get();
  }

  protected float get_jitter_y_raw() {
    return jitter_y.raw();
  }

  protected float get_jitter_y_max() {
    return jitter_y.max();
  }

  protected float get_jitter_y_min() {
    return jitter_y.min();
  }

  // jitter z
  protected float get_jitter_z() {
    return jitter_z.get();
  }

  protected float get_jitter_z_raw() {
    return jitter_z.raw();
  }

  protected float get_jitter_z_max() {
    return jitter_z.max();
  }

  protected float get_jitter_z_min() {
    return jitter_z.min();
  }


  // SWING
  protected vec3 get_swing() {
    return vec3(get_swing_x(),get_swing_y(),get_swing_z());
  }

  // swing x
  protected float get_swing_x() {
    return swing_x.get();
  }

  protected float get_swing_x_raw() {
    return swing_x.raw();
  }

  protected float get_swing_x_max() {
    return swing_x.max();
  }

  protected float get_swing_x_min() {
    return swing_x.min();
  }

  // swing y
  protected float get_swing_y() {
    return swing_y.get();
  }

  protected float get_swing_y_raw() {
    return swing_y.raw();
  }

  protected float get_swing_y_max() {
    return swing_y.max();
  }

  protected float get_swing_y_min() {
    return swing_y.min();
  }

  // swing z
  protected float get_swing_z() {
    return swing_z.get();
  }

  protected float get_swing_z_raw() {
    return swing_z.raw();
  }

  protected float get_swing_z_max() {
    return swing_z.max();
  }

  protected float get_swing_z_min() {
    return swing_z.min();
  }


  // COL3
  // quantity
  protected float get_quantity() {
    return quantity.get();
  }

  protected float get_quantity_raw() {
    return quantity.raw();
  }

  protected float get_quantity_max() {
    return quantity.max();
  }

  protected float get_quantity_min() {
    return quantity.min();
  }
  
  // variety
  protected float get_variety() {
    return variety.get();
  }

  protected float get_variety_raw() {
    return variety.raw();
  }

  protected float get_variety_max() {
    return variety.max();
  }

  protected float get_variety_min() {
    return variety.min();
  }
  
  // life
  protected float get_life() {
    return life.get();
  }

  protected float get_life_raw() {
    return life.raw();
  }

  protected float get_life_max() {
    return life.max();
  }

  protected float get_life_min() {
    return life.min();
  }
  
  // flow
  protected float get_flow() {
    return flow.get();
  }

  protected float get_flow_raw() {
    return flow.raw();
  }

  protected float get_flow_max() {
    return flow.max();
  }

  protected float get_flow_min() {
    return flow.min();
  }
  
  // quality
  protected float get_quality() {
    return quality.get();
  }

  protected float get_quality_raw() {
    return quality.raw();
  }

  protected float get_quality_max() {
    return quality.max();
  }

  protected float get_quality_min() {
    return quality.min();
  }
  
  // area
  protected float get_area() {
    return area.get();
  }

  protected float get_area_raw() {
    return area.raw();
  }

  protected float get_area_max() {
    return area.max();
  }

  protected float get_area_min() {
    return area.min();
  }
  
  // angle
  protected float get_angle() {
    return angle.get();
  }

  protected float get_angle_raw() {
    return angle.raw();
  }

  protected float get_angle_max() {
    return angle.max();
  }

  protected float get_angle_min() {
    return angle.min();
  }
  
  // scope
  protected float get_scope() {
    return scope.get();
  }

  protected float get_scope_raw() {
    return scope.raw();
  }

  protected float get_scope_max() {
    return scope.max();
  }

  protected float get_scope_min() {
    return scope.min();
  }
  
  // scan
  protected float get_scan() {
    return scan.get();
  }

  protected float get_scan_raw() {
    return scan.raw();
  }

  protected float get_scan_max() {
    return scan.max();
  }

  protected float get_scan_min() {
    return scan.min();
  }
  
  // alignment
  protected float get_alignment() {
    return alignment.get();
  }

  protected float get_alignment_raw() {
    return alignment.raw();
  }

  protected float get_alignment_max() {
    return alignment.max();
  }

  protected float get_alignment_min() {
    return alignment.min();
  }
  
  // repulsion
  protected float get_repulsion() {
    return repulsion.get();
  }

  protected float get_repulsion_raw() {
    return repulsion.raw();
  }

  protected float get_repulsion_max() {
    return repulsion.max();
  }

  protected float get_repulsion_min() {
    return repulsion.min();
  }
  
  // attraction
  protected float get_attraction() {
    return attraction.get();
  }

  protected float get_attraction_raw() {
    return attraction.raw();
  }

  protected float get_attraction_max() {
    return attraction.max();
  }

  protected float get_attraction_min() {
    return attraction.min();
  }
  
  // density
  protected float get_density() {
    return density.get();
  }

  protected float get_density_raw() {
    return density.raw();
  }

  protected float get_density_max() {
    return density.max();
  }

  protected float get_density_min() {
    return density.min();
  }
  
  // influence
  protected float get_influence() {
    return influence.get();
  }

  protected float get_influence_raw() {
    return influence.raw();
  }

  protected float get_influence_max() {
    return influence.max();
  }

  protected float get_influence_min() {
    return influence.min();
  }
  
  // calm
  protected float get_calm() {
    return calm.get();
  }

  protected float get_calm_raw() {
    return calm.raw();
  }

  protected float get_calm_max() {
    return calm.max();
  }

  protected float get_calm_min() {
    return calm.min();
  }
  
  // spectrum
  protected float get_spectrum() {
    return spectrum.get();
  }

  protected float get_spectrum_raw() {
    return spectrum.raw();
  }

  protected float get_spectrum_max() {
    return spectrum.max();
  }

  protected float get_spectrum_min() {
    return spectrum.min();
  }


  // COL 4
  // grid
  protected float get_grid() {
    return grid.get();
  }

  protected float get_grid_raw() {
    return grid.raw();
  }

  protected float get_grid_max() {
    return grid.max();
  }

  protected float get_grid_min() {
    return grid.min();
  }
  
  // viscosity
  protected float get_viscosity() {
    return viscosity.get();
  }

  protected float get_viscosity_raw() {
    return viscosity.raw();
  }

  protected float get_viscosity_max() {
    return viscosity.max();
  }

  protected float get_viscosity_min() {
    return viscosity.min();
  }
  
  // diffusion
  protected float get_diffusion() {
    return diffusion.get();
  }

  protected float get_diffusion_raw() {
    return diffusion.raw();
  }

  protected float get_diffusion_max() {
    return diffusion.max();
  }

  protected float get_diffusion_min() {
    return diffusion.min();
  }
  
  // power
  protected float get_power() {
    return power.get();
  }

  protected float get_power_raw() {
    return power.raw();
  }

  protected float get_power_max() {
    return power.max();
  }

  protected float get_power_min() {
    return power.min();
  }

  // mass
  protected float get_mass() {
    return mass.get();
  }

  protected float get_mass_raw() {
    return mass.raw();
  }

  protected float get_mass_max() {
    return mass.max();
  }

  protected float get_mass_min() {
    return mass.min();
  }

  // COORD
  protected vec3 get_coord() {
    return vec3(get_coord_x(),get_coord_y(),get_coord_z());
  }
  
  // coord x
  protected float get_coord_x() {
    return coord_x.get();
  }

  protected float get_coord_x_raw() {
    return coord_x.raw();
  }

  protected float get_coord_x_max() {
    return coord_x.max();
  }

  protected float get_coord_x_min() {
    return coord_x.min();
  }

  // swing y
  protected float get_coord_y() {
    return coord_y.get();
  }

  protected float get_coordg_y_raw() {
    return coord_y.raw();
  }

  protected float get_coord_y_max() {
    return coord_y.max();
  }

  protected float get_coord_y_min() {
    return coord_y.min();
  }

  // swing z
  protected float get_coord_z() {
    return coord_z.get();
  }

  protected float get_coord_z_raw() {
    return coord_z.raw();
  }

  protected float get_coord_z_max() {
    return coord_z.max();
  }

  protected float get_coord_z_min() {
    return coord_z.min();
  }








  /**
  font
  */
  protected String get_font_path() {
    return font_item.get_path();
  }

  protected String get_font_name() {
    return font_item.get_name();
  }

  protected PFont get_font() {
    return font_item.get_font();
  }

  protected String get_font_type() {
    return font_item.get_type();
  }



  /**
  sound
  */
  protected float get_band(int target) {
    if(target >= 0 && target < band[ID_item].length) {
      return band[ID_item][target];
    } else {
      printErrTempo(180,"get_band(): target",target, "is out of the band range, value '0' is return");
      return 0;
    }
  }
  
  /**
  movie
  */
  protected int which_movie() {
    return which_movie[ID_item];
  }

  protected Movie get_movie() {
    if(movie[ID_item] != null) {
      return movie[ID_item];
    } else return null;
  }

  protected PImage get_bitmap() {
    if(bitmap[ID_item] != null) {
      return bitmap[ID_item];
    } else return null;
  }
  
  protected String get_text() {
    if(text_import[ID_item] != null) {
      return text_import[ID_item];
    } else return null;
  }

  protected ROPE_svg get_svg() {
    if(svg_import[ID_item] != null) {
      return svg_import[ID_item];
    } else return null;
  }














  
  /**
  deep method
  */
  private Costume get_costume_private() {
    if(costume == null) {
      costume = new Costume(p5);
    }
    String [] costume_split = new String[1];
    costume_split = split(item_costume,"/");

    String costume_romanesco = "unknow" ;
    if(costume_split[0] != null) {
      costume_romanesco = costume_split[get_costume_id()];
    } 

    if(costume_romanesco.equals("pixel") || costume_romanesco.equals("PIXEL") || costume_romanesco.equals("Pixel")) {
      if(!dimension) {
        costume.set_type(PIXEL_ROPE); 
      } else {
        costume.set_type(PIXEL_ROPE);
      }
    } else if(costume_romanesco.equals("point") || costume_romanesco.equals("POINT") || costume_romanesco.equals("Point")) {
      if(!dimension) {
        costume.set_type(POINT_ROPE); 
      } else {
        costume.set_type(SPHERE_LOW_ROPE);
      }
    } else if(costume_romanesco.equals("line") || costume_romanesco.equals("LINE") || costume_romanesco.equals("Line")) {
      if(!dimension) {
        costume.set_type(LINE_ROPE); 
      } else {
        costume.set_type(LINE_ROPE);
      }
    } else if(costume_romanesco.equals("ellipse") || costume_romanesco.equals("ELLIPSE") || costume_romanesco.equals("Ellipse") || costume_romanesco.equals("disc") || costume_romanesco.equals("DISC") || costume_romanesco.equals("Disc")) {
      if(!dimension) {
        costume.set_type(ELLIPSE_ROPE); 
      } else {
        costume.set_type(SPHERE_MEDIUM_ROPE);
      }
    } else if(costume_romanesco.equals("triangle") || costume_romanesco.equals("TRIANGLE") || costume_romanesco.equals("Triangle")) {
      if(!dimension) {
        costume.set_type(TRIANGLE_ROPE); 
      } else {
        costume.set_type(TETRAHEDRON_ROPE);
      }
    } else if(costume_romanesco.equals("rectangle") || costume_romanesco.equals("RECTANGLE") || costume_romanesco.equals("Rectangle") || costume_romanesco.equals("rect") || costume_romanesco.equals("RECT") || costume_romanesco.equals("Rect")) {
      if(!dimension) {
        costume.set_type(RECT_ROPE); 
      } else {
        costume.set_type(BOX_ROPE);
      }
    } else if(costume_romanesco.equals("pentagon") || costume_romanesco.equals("PENTAGON") || costume_romanesco.equals("Pentagon")) {
      if(!dimension) {
        costume.set_type(PENTAGON_ROPE); 
      } else {
        costume.set_type(PENTAGON_ROPE);
      }
    } else if(costume_romanesco.equals("cross") || costume_romanesco.equals("CROSS") || costume_romanesco.equals("Cross")) {
      if(!dimension) {
        costume.set_type(CROSS_BOX_2_ROPE); 
      } else {
        costume.set_type(CROSS_BOX_3_ROPE);
      }
    } 

      else if(costume_romanesco.equals("flower") || costume_romanesco.equals("FLOWER") || costume_romanesco.equals("Flower")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(5);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(5);
      }
    } else if(costume_romanesco.equals("flower 3") || costume_romanesco.equals("FLOWER 3") || costume_romanesco.equals("Flower 3")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(3);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(3);
      }
    } else if(costume_romanesco.equals("flower 5") || costume_romanesco.equals("FLOWER 5") || costume_romanesco.equals("Flower 5")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(5);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(5);
      }
    } else if(costume_romanesco.equals("flower 7") || costume_romanesco.equals("FLOWER 7") || costume_romanesco.equals("Flower 7")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(7);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(7);
      }
    } else if(costume_romanesco.equals("flower 9") || costume_romanesco.equals("FLOWER 9") || costume_romanesco.equals("Flower 9")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE); 
        costume.set_summit(9);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(9);
      }
    } else if(costume_romanesco.equals("flower 12") || costume_romanesco.equals("FLOWER 12") || costume_romanesco.equals("Flower 12")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE); 
        costume.set_summit(12);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(12);
      }
    } else if(costume_romanesco.equals("flower 24") || costume_romanesco.equals("FLOWER 24") || costume_romanesco.equals("Flower 24")) {
      if(!dimension) {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(24);
      } else {
        costume.set_type(FLOWER_ROPE);
        costume.set_summit(24);
      }
    }


      else if(costume_romanesco.equals("star") || costume_romanesco.equals("STAR") || costume_romanesco.equals("Star")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(5);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(5);
      }
    } else if(costume_romanesco.equals("star 4") || costume_romanesco.equals("STAR 4") || costume_romanesco.equals("Star 4")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(4);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(4);
      }
    } else if(costume_romanesco.equals("star 5") || costume_romanesco.equals("STAR 5") || costume_romanesco.equals("Star 5")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(5);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(5);
      }
    } else if(costume_romanesco.equals("star 6") || costume_romanesco.equals("STAR 6") || costume_romanesco.equals("Star 6")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(6);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(6);
      }
    } else if(costume_romanesco.equals("star 7") || costume_romanesco.equals("STAR 7") || costume_romanesco.equals("Star 7")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(7);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(7);
      }
    } else if(costume_romanesco.equals("star 8") || costume_romanesco.equals("STAR 8") || costume_romanesco.equals("Star 8")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(8);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(8);
      }
    } 

      else if(costume_romanesco.equals("super star 8") || costume_romanesco.equals("SUPER STAR 8") || costume_romanesco.equals("Super Star 8")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(8);
        costume.set_ratio(2.f,.5f,1.f,.5f);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(8);
        costume.set_ratio(2.f,.5f,1.f,.5f);
      }
    } else if(costume_romanesco.equals("super star 12") || costume_romanesco.equals("SUPER STAR 12") || costume_romanesco.equals("Super Star 12")) {
      if(!dimension) {
        costume.set_type(STAR_ROPE);
        costume.set_summit(12);
        costume.set_ratio(2.f,.5f,1.f,.5f,1.f,.5f);
      } else {
        costume.set_type(STAR_3D_ROPE);
        costume.set_summit(12);
        costume.set_ratio(2.f,.5f,1.f,.5f,1.f,.5f);
      }
    } 

      
      else if(costume_romanesco.equals("abc") || costume_romanesco.equals("ABC") || costume_romanesco.equals("Abc")) {
      if(!dimension) {
        costume.set_type(TEXT_ROPE); 
      } else {
        costume.set_type(TEXT_ROPE);
      }
    } 


      else if(costume_romanesco.equals("none") || costume_romanesco.equals("NONE") || costume_romanesco.equals("None") ||
              costume_romanesco.equals("nothing") || costume_romanesco.equals("NOTHING") || costume_romanesco.equals("Nothing") || 
              costume_romanesco.equals("null") || costume_romanesco.equals("NULL") || costume_romanesco.equals("Null")) {
      if(!dimension) {
        costume.set_type(NULL); 
      } else {
        costume.set_type(NULL);
      }
    } else {
      costume.set_type(NULL);
    }

    return costume;
  }
}












/**
Class Romanesco_manager
v 1.6.2
class manager inspired by Andreas Gysin work for The Abyss Project
@see https://github.com/ertdfgcvb/TheAbyss
*/





class Romanesco_manager {
  private ArrayList<Romanesco>romanesco_item_list;
  private ArrayList<Class>item_list;

  private Table index_item;
  private TableRow [] row_index_item;

  PApplet parent;
  String item_class_name [];
  int num_classes;
  Romanesco_manager(PApplet parent) {
    this.parent = parent;
    romanesco_item_list = new ArrayList<Romanesco>() ;
    //scan the existant classes
    item_list = scan_classes(parent,"Romanesco");
  }

  //ADD CLASSES
  private ArrayList<Class> scan_classes(PApplet parent, String super_Class_name) {
    ArrayList<Class> classes = new ArrayList<Class>();

    Class[] c = parent.getClass().getDeclaredClasses();
    String template = "Template";
    //create the index table
    for (int i=0; i<c.length; i++) {
      if (c[i].getSuperclass() != null && c[i].getSuperclass().getSimpleName().equals(super_Class_name)) {
        
        if(!c[i].getSimpleName().equals(template)) {
          classes.add(c[i]);
          num_classes = classes.size();
        } 
      }
    }
    create_index(num_classes) ;
    
    //init the String info
    item_class_name = new String[num_classes] ;
    for (int i = 0 ; i < item_class_name.length ; i++) {
      item_class_name[i] = ("");
    }
    
    //add class in Romanesco, plus add info in the String for the index
    int num = 0;
    for (int i = 0 ; i < c.length ; i++) {
      if (c[i].getSuperclass() != null && c[i].getSuperclass().getSimpleName().equals(super_Class_name)) {
        if(!c[i].getSimpleName().equals(template)) {
          item_class_name[num] = c[i].getSimpleName();
          num++;
        }
      }
    }
    begin_index() ;
    return classes;  
  }


  //create the index
  public void create_index(int num) {
    index_item = new Table() ;
    index_item.addColumn("Library Order");
    index_item.addColumn("Name");
    index_item.addColumn("ID");
    index_item.addColumn("Group");
    index_item.addColumn("Version");
    index_item.addColumn("Author");
    index_item.addColumn("Class name");
    index_item.addColumn("Pack");
    index_item.addColumn("Render");
    index_item.addColumn("Costume");
    index_item.addColumn("Mode");
    
    
    // add row
    row_index_item = new TableRow [num] ;
    for(int i = 0 ; i < row_index_item.length ; i++) {
      row_index_item[i] = index_item.addRow();
    }
    
    // create var for info item, need to be create here
    int num_plus_one = num+1;
    item_ID = new int[num_plus_one];
    item_name = new String[num_plus_one];
    item_author = new String[num_plus_one];
    item_version = new String[num_plus_one];
    item_pack = new String[num_plus_one];
    item_info = new String[num_plus_one];
    // init var
    for ( int i = 0 ; i < num_plus_one ; i++ ) {
      item_name [i] = "My name is Nobody";
      item_info [i] = "Sorry nobody write about me!";
      item_ID [i] = 0;
    }
  }

  // put information in the index
  public void begin_index() {
    for(int i = 0 ; i < row_index_item.length ; i++) {
      row_index_item[i].setString("Class name",item_class_name[i]);
      row_index_item[i].setInt("Library Order",i+1);
    }
  }

  /**
  EXTERNAL  VOID
  */
  public void finish_index() {
  // catch the different parameter from object class Romanesco
    for (int i=0 ; i < romanesco_item_list.size() ; i++ ) {
      Romanesco item = (Romanesco) romanesco_item_list.get(i);
      row_index_item[i].setString("Name",item.item_name);
      row_index_item[i].setInt("ID",item.ID_item);
      row_index_item[i].setInt("Group",item.ID_group);
      row_index_item[i].setString("Author",item.item_author);
      row_index_item[i].setString("References",item.item_references);
      row_index_item[i].setString("Version",item.item_version);
      row_index_item[i].setString("Pack",item.item_pack);
      row_index_item[i].setString("Costume",item.item_costume);
      row_index_item[i].setString("Mode",item.item_mode);
      row_index_item[i].setString("Slider",item.item_slider);
    }
    saveTable(index_item, preference_path+"index_romanesco_items.csv"); 
  }
  // ADD info for the user
  public void write_info_user() {
    // catch the different parameter from object class Romanesco
    for (int i=0 ; i < romanesco_item_list.size() ; i++) {
      Romanesco item = (Romanesco) romanesco_item_list.get(i);
      item_ID[item.ID_item] = item.ID_item;
      item_name[item.ID_item] = item.item_name;
      item_author[item.ID_item] = item.item_author;
      item_version[item.ID_item] = item.item_version;
      item_pack[item.ID_item] = item.item_pack;
    }
  }

  public int id_item_from_library(int index) {
    int id = -1 ;
    if(index < romanesco_item_list.size()) {
      Romanesco item = (Romanesco) romanesco_item_list.get(index);
      id = item.ID_item;
    }  
    return id;
  }
  

  /**
  get item
  */
  public ArrayList<Romanesco> get() {
    return romanesco_item_list;
  }
  public Romanesco get(int index) {
    if(index < romanesco_item_list.size()) {
      return romanesco_item_list.get(index);
    } else {
      return null;
    }  
  }
  
  
  public int size() {
    return item_list.size();
  }
  
  
  // add itemfrom the sub-classes
  public void add_item() {
    for(int i = 0 ; i < item_list.size() ; i++) {
      add_item(i);
    }
  }

  //
  private Romanesco add_item(int i) {
    if (i < 0 || i >= item_list.size()) {
      return null;
    }
    
    Romanesco item = null;
    try {
      Class c = item_list.get(i);
      Constructor[] constructors = c.getConstructors();
      item = (Romanesco)constructors[0].newInstance(parent);
      item.set_id(i+1);
      item.set_group(1);
    }
    catch (InvocationTargetException e) {
      System.out.println(e);
    } 
    catch (InstantiationException e) {
      System.out.println(e);
    } 
    catch (IllegalAccessException e) {
      System.out.println(e);
    } 
    //add item
    if (item != null) {
      romanesco_item_list.add(item);
    }
    return item;
  }
  


  public void set_item(String path) {
    Table slider_item_data = loadTable(path,"header");
    String [][] slider_name = new String[4][16];
    for(int i = 0 ; i < slider_item_data.getRowCount() ;i++) {
      TableRow row = slider_item_data.getRow(i);
      for(int line = 0 ; line < 4 ; line++) {
        String name = "";
        if(line == 0) {
          name = "slider item a";
        } else if(line == 1) {
          name = "slider item b";
        } else if(line == 2) {
          name = "slider item c";
        } else if(line == 3) {
          name = "slider item d";
        }
        if(row.getString("name").equals(name)) {
          for(int k = 0 ; k < slider_item_data.getColumnCount()-1 ; k++) {
            if(k < slider_name[line].length) {
              slider_name[line][k] = row.getString("col "+Integer.toString(k)) ;
            }
          }
        }
      }
    }
    for(Romanesco item : romanesco_item_list) {
      item.set_slider(slider_name);
    }
  }
  
  
  

  // SETUP
  public boolean init_items() {
    int num = 0 ;
    for (Romanesco item : romanesco_item_list) {
      item.motion_is(true);
      init_value_mouse[item.get_id()] = true;
      item.mode.set_name(item.item_mode.split("/"));

      num++;
      item.setup();
      println("setup of", item.item_name, item.get_id(), "is done");
      if(pos_item_ref[item.get_id()] == null) {
        pos_item_ref[item.get_id()] = vec3();
      }
      pos_item_ref[item.get_id()].set(item_setting_position[0][item.get_id()]);
    }

    if(num == romanesco_item_list.size()) {
      return true ;
    } else {
      return false;
    }
  }







  /**
  * HISTORIC
  * v 0.0.2
  * use to write and read the history
  */
  History historic = new History(20);

  protected void historic() {
    Script script = new Script();
    script.add("translate","world",finalSceneCamera);
    script.add("rotate:","world",finalEyeCamera);

    for (int i = 0 ; i < romanesco_item_list.size() ; i++ ) {
      Romanesco item = (Romanesco) romanesco_item_list.get(i);
      String family = item.get_name();
      script.add("show",family,item.show_is());
      script.add("id",family,item.get_id());
      script.add("group",family,item.get_group());
      script.add("parameter",family,item.parameter_is());
      script.add("sound",family,item.sound_is());
      script.add("action",family,item.action_is());
      script.add("costume",family,item.get_costume_id());
      script.add("mode",family,item.get_mode_id());

      // disposition
      script.add("translate",family,pos_item_final[item.get_id()]);
      script.add("rotate",family,dir_item_final[item.get_id()]);
      // STATE
      script.add("fill is",family,item.fill_is());
      script.add("stroke is",family,item.stroke_is());

      script.add("birth",family,item.birth_is());
      script.add("colour",family,item.colour_is());
      script.add("dimension",family,item.dimension_is());
      script.add("horizon",family,item.horizon_is());
      script.add("motion",family,item.motion_is());
      script.add("follow",family,item.follow_is());
      script.add("reverse",family,item.reverse_is());
      script.add("wire",family,item.wire_is());
      script.add("special",family,item.special_is());
      // SLIDER
      script.add("fill",family,item.get_fill());
      script.add("stroke",family,item.get_stroke());
      script.add("size",family,item.get_size());
      script.add("diameter",family,item.get_diameter());
      script.add("canvas",family,item.get_canvas());

      script.add("frequence",family,item.get_frequence());
      script.add("speed",family,item.get_speed());
      script.add("spurt",family,item.get_spurt());
      script.add("dir",family,item.get_dir());
      script.add("jitter",family,item.get_jitter());
      script.add("swing",family,item.get_swing());

      script.add("quantity",family,item.get_quantity());
      script.add("variety",family,item.get_variety());
      script.add("life",family,item.get_life());
      script.add("flow",family,item.get_flow());
      script.add("quality",family,item.get_quality());
      script.add("area",family,item.get_area());
      script.add("angle",family,item.get_angle());
      script.add("scope",family,item.get_scope());
      script.add("scan",family,item.get_scan());
      script.add("alignment",family,item.get_alignment());
      script.add("repulsion",family,item.get_repulsion());
      script.add("attraction",family,item.get_attraction());
      script.add("density",family,item.get_density());
      script.add("influence",family,item.get_influence());
      script.add("calm",family,item.get_calm());
      script.add("spectrum",family,item.get_spectrum());

      script.add("grid",family,item.get_grid());
      script.add("viscosity",family,item.get_viscosity());
      script.add("diffusion",family,item.get_diffusion());
      script.add("power",family,item.get_power());
      script.add("mass",family,item.get_mass());
      script.add("coord",family,item.get_coord());

    }
    historic.add(script);
  }

  protected int historic_size() {
    if(historic != null) {
      return historic.size();
    } else return 0;
  }

  protected void print_historic() {
    println(historic.get(0).get("grid","Grillo"));

  }

  /*
  protected Script get_script(int target) {
    if(historic == null) {
      return null;
    } else {
      if(target < historic.size()) {
        return historic.get(target);
      } else {
        return historic.get(historic.size()-1);
      }
    }
  }
  */


  


















  // DRAW
  public void show_item_3D(boolean movePos, boolean moveDir, boolean movePosAndDir) {
    // when you use the third order Romanesco understand the the first and the second are true
    if(movePosAndDir) {
      moveDir = true;
      movePos = true;
    }
    
    //the method
    for (Romanesco item : romanesco_item_list) {
      if (item.show_is()) {
        update_var_items(item);
        pushMatrix();
        add_ref_item(item.get_id());
        item_follower(item);
        if((key_v_long || reset_item_on_button_alert_is()) && item.action_is()) {
          item_move(movePos, moveDir, item.get_id());
        }
        final_pos_item(item);
        item.draw();
        popMatrix();
      } else {
        if(movie[item.get_id()] != null) movie[item.get_id()].pause();
      }
    }
  }


  public void show_item_2D() {
    for (Romanesco item : romanesco_item_list) {
      if (item.show_is()) {
        item.draw_2D();
      } else {
        if(movie[item.get_id()] != null) movie[item.get_id()].pause();
      }
    }
  }
}

/**
* Romanesco Manager
* 2013-2019
* v 1.7.2
*/
Romanesco_manager rom_manager;

public void romanesco_build_item() {
  rom_manager = new Romanesco_manager(this);
  rom_manager.add_item();
  rom_manager.set_item(preference_path+"gui_info_en.csv");
  rom_manager.finish_index();
  rom_manager.write_info_user();
  println("Romanesco setup done");
}




public void update_font_item() {
  for(int i = 0 ; i < rom_manager.size() ; i++) {
    Romanesco item = rom_manager.get(i);
    item.set_font(current_font);
  }
}




//Update the var of the object
int which_movie_ref, which_bitmap_ref, which_shape_ref, which_text_ref;
public void update_var_items(Romanesco item) {
  // Romanesco item = rom_manager.get(ID);
  int id = item.get_id();
  // info
  item_info_display[id] = displayInfo?true:false;
  
  //initialization
  if(!init_value_mouse[id]) { 
    mouse[id] = mouse[0].copy();
    pen[id] = pen[0].copy();
    init_value_mouse[id] = true;
  }
  if(!init_value_controller[id]) {
    item.set_font(current_font);
    update_slider_value(item) ;
    init_value_controller[id] = true;
    which_bitmap[id] = which_bitmap[0];
    which_text[id] = which_text[0];
    which_shape[id] = which_shape[0];
    which_movie[id] = which_movie[0];
  }

  if(item.parameter_is()) {
    if(which_bitmap_ref != which_bitmap[0]) {
      which_bitmap[id] = which_bitmap[0];
      which_bitmap_ref = which_bitmap[0];
    }

    if(which_text_ref !=  which_text[0]) {
      which_text[id] = which_text[0];
      which_text_ref = which_text[0];
    }

    if(which_movie_ref !=  which_movie[0]) {
      which_movie[id] = which_movie[0];
      which_movie_ref = which_movie[0];
    }

    if(which_shape_ref !=  which_shape[0]) {
      which_shape[id] = which_shape[0];
      which_shape_ref = which_shape[0];
    }

    item.set_font(current_font);
    update_slider_value(item);
  }
  update_var_sound(item);
  
  if(item.action_is()){
    if(key_space_long) {
      pen[id].set(pen[0]);
      mouse[id].set(mouse[0]);
    }
    if (key_n || birth_button_alert_is()) item.switch_birth();
    if (key_x) item.switch_colour();
    if (key_d || dimension_button_alert_is()) item.switch_dimension();
    if (key_h) item.switch_horizon();
    if (key_m) item.switch_motion();
    if (key_f) item.switch_follow();
    if (key_r) item.switch_reverse();
    if (key_w) item.switch_wire();
    if (key_s) item.switch_special();


    if (key_j)item.switch_fill();
    if (key_k) item.switch_stroke();

    clickLongLeft[id] = ORDER_ONE;
    clickLongRight[id] = ORDER_TWO;
    clickShortLeft[id] = clickShortLeft[0];
    clickShortRight[id] = clickShortRight[0];

    change_bitmap_from_pad(id);
    change_movie_from_pad(id);
    change_text_from_pad(id);
    change_svg_from_pad(id);

    if(item.motion_is()) {
      if(movie[id] != null) movie[id].loop();
    } else {
      if(movie[id] != null) movie[id].pause();
    }
  }
}









public void update_slider_value(Romanesco item) {
  int id = item.get_id();
  boolean init = first_opening_item[id];
  
  // COL 1
  update_slider_value_aspect(init,item);
  if (size_x_raw != size_x_ref || !init) item.set_size_x_raw(size_x_raw,2,0); 
  if (size_y_raw != size_y_ref || !init) item.set_size_y_raw(size_y_raw,2,0); 
  if (size_z_raw != size_z_ref || !init) item.set_size_z_raw(size_z_raw,2,0);
  if (diameter_raw != diameter_ref || !init) item.set_diameter_raw(diameter_raw,0,0); 
  if (canvas_x_raw != canvas_x_ref || !init) item.set_canvas_x_raw(canvas_x_raw,2,0); 
  if (canvas_y_raw != canvas_y_ref || !init) item.set_canvas_y_raw(canvas_y_raw,2,0); 
  if (canvas_z_raw != canvas_z_ref || !init) item.set_canvas_z_raw(canvas_z_raw,2,0);

  // COL 2
  if (frequence_raw != frequence_ref || !init) item.set_frequence_raw(frequence_raw,0,0); 
  if (speed_x_raw != speed_x_ref || !init) item.set_speed_x_raw(speed_x_raw,2,0); 
  if (speed_y_raw != speed_y_ref || !init) item.set_speed_y_raw(speed_y_raw,2,0); 
  if (speed_z_raw != speed_z_ref || !init) item.set_speed_z_raw(speed_z_raw,2,0);
  if (spurt_x_raw != spurt_x_ref || !init) item.set_spurt_x_raw(spurt_x_raw,2,0); 
  if (spurt_y_raw != spurt_y_ref || !init) item.set_spurt_y_raw(spurt_y_raw,2,0); 
  if (spurt_z_raw != spurt_z_ref || !init) item.set_spurt_z_raw(spurt_z_raw,2,0);
  if (dir_x_raw != dir_x_ref || !init) item.set_dir_x_raw(dir_x_raw,0,0); 
  if (dir_y_raw != dir_y_ref || !init) item.set_dir_y_raw(dir_y_raw,0,0); 
  if (dir_z_raw != dir_z_ref || !init) item.set_dir_z_raw(dir_z_raw,0,0);
  if (jitter_x_raw != jitter_x_ref || !init) item.set_jitter_x_raw(jitter_x_raw,0,0); 
  if (jitter_y_raw != jitter_y_ref || !init) item.set_jitter_y_raw(jitter_y_raw,0,0); 
  if (jitter_z_raw != jitter_z_ref || !init) item.set_jitter_z_raw(jitter_z_raw,0,0);
  if (swing_x_raw != swing_x_ref || !init) item.set_swing_x_raw(swing_x_raw,0,0); 
  if (swing_y_raw != swing_y_ref || !init) item.set_swing_y_raw(swing_y_raw,0,0); 
  if (swing_z_raw != swing_z_ref || !init) item.set_swing_z_raw(swing_z_raw,0,0);

  // COL 3
  if (quantity_raw != quantity_ref || !init) item.set_quantity_raw(quantity_raw,0,0);
  if (variety_raw != variety_ref || !init) item.set_variety_raw(variety_raw,0,0);
  if (life_raw != life_ref || !init) item.set_life_raw(life_raw,0,0);
  if (flow_raw != flow_ref || !init) item.set_flow_raw(flow_raw,0,0);
  if (quality_raw != quality_ref || !init) item.set_quality_raw(quality_raw,0,0);
  if (area_raw != area_ref || !init) item.set_area_raw(area_raw,2,0);
  if (angle_raw != angle_ref || !init) item.set_angle_raw(angle_raw,0,0);
  if (scope_raw != scope_ref || !init) item.set_scope_raw(scope_raw,0,0);
  if (scan_raw != scan_ref || !init) item.set_scan_raw(scan_raw,0,0);
  if (alignment_raw != alignment_ref || !init) item.set_alignment_raw(alignment_raw,0,0);
  if (repulsion_raw != repulsion_ref || !init) item.set_repulsion_raw(repulsion_raw,0,0);
  if (attraction_raw != attraction_ref || !init) item.set_attraction_raw(attraction_raw,0,0);
  if (density_raw != density_ref || !init) item.set_density_raw(density_raw,0,0);
  if (influence_raw != influence_ref || !init) item.set_influence_raw(influence_raw,0,0);
  if (calm_raw != calm_ref || !init) item.set_calm_raw(calm_raw,0,0);
  if (spectrum_raw != spectrum_ref || !init) item.set_spectrum_raw(spectrum_raw,0,0);

  // COL 4
  if (grid_raw != grid_ref || !init) item.set_grid_raw(grid_raw,0,0);
  if (viscosity_raw != viscosity_ref || !init) item.set_viscosity_raw(viscosity_raw,0,0);
  if (diffusion_raw != diffusion_ref || !init) item.set_diffusion_raw(diffusion_raw,0,0);
  if (power_raw != power_ref || !init) item.set_power_raw(power_raw,0,0);
  if (mass_raw != mass_ref || !init) item.set_mass_raw(mass_raw,0,0);
  if (coord_x_raw != coord_x_ref || !init) item.set_coord_x_raw(coord_x_raw,0,0); 
  if (coord_y_raw != coord_y_ref || !init) item.set_coord_y_raw(coord_y_raw,0,0); 
  if (coord_z_raw != coord_z_ref || !init) item.set_coord_z_raw(coord_z_raw,0,0);
  /** 
  make the obj has be never update in the future except by the moving slider 
  */
  first_opening_item[id] = true; 
}

vec4 fill_local_ref;
vec4 stroke_local_ref;
public void change_slider_ref() {
  fill_local_ref = vec4(fill_hue_raw,fill_sat_raw,fill_bright_raw,fill_alpha_raw);
  stroke_local_ref = vec4(stroke_hue_raw,stroke_sat_raw,stroke_bright_raw,stroke_alpha_raw);
}


public void update_slider_value_aspect(boolean init, Romanesco item) {
  int id = item.get_id();
  if(FULL_RENDERING) {
    if(!init) {
      fill_item_ref[id] = vec4(fill_hue_raw,fill_sat_raw,fill_bright_raw,fill_alpha_raw);
      fill_local_ref = vec4(fill_hue_raw,fill_sat_raw,fill_bright_raw,fill_alpha_raw);
      item.set_fill(fill_hue_raw,fill_sat_raw,fill_bright_raw,fill_alpha_raw);
      stroke_item_ref[id] = vec4(stroke_hue_raw,stroke_sat_raw,stroke_bright_raw,stroke_alpha_raw);
      stroke_local_ref = vec4(stroke_hue_raw,stroke_sat_raw,stroke_bright_raw,stroke_alpha_raw);
      item.set_stroke(stroke_hue_raw,stroke_sat_raw,stroke_bright_raw,stroke_alpha_raw);  
    }
    
    // FILL part
    bvec4 fill_is = bvec4();
    // check hsba value
    if(fill_local_ref.hue() != fill_hue_raw) fill_is.x = true;
    if(fill_local_ref.sat() != fill_sat_raw) fill_is.y = true;
    if(fill_local_ref.bri() != fill_bright_raw) fill_is.z = true;
    if(fill_local_ref.alp() != fill_alpha_raw) fill_is.w = true;

    if(fill_is.x) {
      item.set_fill(fill_hue_raw,fill_item_ref[id].sat(),fill_item_ref[id].bri(),fill_item_ref[id].alp());
      fill_item_ref[id] = to_hsba(item.get_fill());
    }

    if(fill_is.y) {
      item.set_fill(fill_item_ref[id].hue(),fill_sat_raw,fill_item_ref[id].bri(),fill_item_ref[id].alp());
      fill_item_ref[id] = to_hsba(item.get_fill());
    }

    if(fill_is.z) {
      item.set_fill(fill_item_ref[id].hue(),fill_item_ref[id].sat(),fill_bright_raw,fill_item_ref[id].alp());
      fill_item_ref[id] = to_hsba(item.get_fill());
    }

    if(fill_is.w) {
      item.set_fill(fill_item_ref[id].hue(),fill_item_ref[id].sat(),fill_item_ref[id].bri(),fill_alpha_raw); 
      fill_item_ref[id] = to_hsba(item.get_fill());
    }

    // zero security value
    if(fill_item_ref[id].hue() == 0) {
      fill_item_ref[id].hue(fill_hue_raw);
    }

    if(fill_item_ref[id].sat() == 0) {
      fill_item_ref[id].sat(fill_sat_raw);
    }

    if(fill_item_ref[id].bri() == 0) {
      fill_item_ref[id].bri(fill_bright_raw);
    }
    
    // STROKE part
    bvec4 stroke_is = bvec4();
    // check hsba value
    if(stroke_local_ref.hue() != stroke_hue_raw) stroke_is.x = true;
    if(stroke_local_ref.sat() != stroke_sat_raw) stroke_is.y = true;
    if(stroke_local_ref.bri() != stroke_bright_raw) stroke_is.z = true;
    if(stroke_local_ref.alp() != stroke_alpha_raw) stroke_is.w = true;
    

    if(stroke_is.x) {
      item.set_stroke(stroke_hue_raw,stroke_item_ref[id].sat(),stroke_item_ref[id].bri(),stroke_item_ref[id].alp());
      stroke_item_ref[id] = to_hsba(item.get_stroke());
    }

    if(stroke_is.y) {
      item.set_stroke(stroke_item_ref[id].hue(),stroke_sat_raw,stroke_item_ref[id].bri(),stroke_item_ref[id].alp());
      stroke_item_ref[id] = to_hsba(item.get_stroke());
    }

    if(stroke_is.z) {
      item.set_stroke(stroke_item_ref[id].hue(),stroke_item_ref[id].sat(),stroke_bright_raw,stroke_item_ref[id].alp());
      stroke_item_ref[id] = to_hsba(item.get_stroke());
    }

    if(stroke_is.w) {
      item.set_stroke(stroke_item_ref[id].hue(),stroke_item_ref[id].sat(),stroke_item_ref[id].bri(),stroke_alpha_raw); 
      stroke_item_ref[id] = to_hsba(item.get_stroke());
    }


    // zero security value
    if(stroke_item_ref[id].hue() == 0) {
      stroke_item_ref[id].hue(stroke_hue_raw);
    }

    if(stroke_item_ref[id].sat() == 0) {
      stroke_item_ref[id].sat(stroke_sat_raw);
    }

    if(stroke_item_ref[id].bri() == 0) {
      stroke_item_ref[id].bri(stroke_bright_raw);
    }

    // thickness
    if (thickness_raw != thickness_ref || !init) {
      item.set_thickness_raw(thickness_raw,0,0);
    }
  } else {
    // preview display
    item.set_fill(to_hsba(COLOR_FILL_ITEM_PREVIEW).array());
    item.set_stroke(to_hsba(COLOR_STROKE_ITEM_PREVIEW).array());
    item.set_thickness_raw(THICKNESS_ITEM_PREVIEW,0,0);
  }
}







//
public void update_var_sound(Romanesco item) {
  int id = item.get_id();
  if(item.sound_is()) {
    left[id] = left[0];// value(0,1)
    right[id] = right[0]; //float value(0,1)
    mix[id] = mix[0]; //   is average volume between the left and the right / float value(0,1)
    
    transient_value[0][id] = transient_value[0][0]; // is transient master detection on all spectrum : value 1,10 

    transient_value[1][id] = transient_value[1][0]; // is extra_bass transient detection by default : value 1,10 
    transient_value[2][id] = transient_value[2][0]; // is bass transient detection by default : value 1,10 
    transient_value[3][id] = transient_value[3][0]; // is medium transient detection by default : value 1,10 
    transient_value[4][id] = transient_value[4][0]; // is hight transient detection by default : value 1,10 


    tempo[id] = tempo[0]; // global speed of track  / float value(0,1)
    tempoBeat[id] = tempoBeat[0]; // speed of track calculate on the beat
    tempoKick[id] = tempoKick[0]; // speed of track calculate on the kick
    tempoSnare[id] = tempoSnare[0]; // speed of track calculate on the snare
    tempoHat[id] = tempoHat[0]; // speed of track calculte on the hat
    
    for (int i = 0 ; i <NUM_BANDS ; i++) {
      band[id][i] = band[0][i];
    }
  } else {
    left[id] = 1;// value(0,1)
    right[id] = 1; //float value(0,1)
    mix[id] = 1; //   is average volume between the left and the right / float value(0,1)
    
    transient_value[0][id] = 1; // is transient master detection on all spectrum : value 1,10 

    transient_value[1][id] = 1; // is extra_bass transient detection by default : value 1,10 
    transient_value[2][id] = 1; // is bass transient detection by default : value 1,10 
    transient_value[3][id] = 1; // is medium transient detection by default : value 1,10 
    transient_value[4][id] = 1; // is hight transient detection by default : value 1,10 
    
    tempo[id] = 1; // global speed of track  / float value(0,1)
    tempoBeat[id] = 1; // speed of track calculate on the beat
    tempoKick[id] = 1; // speed of track calculate on the kick
    tempoSnare[id] = 1; // speed of track calculate on the snare
    tempoHat[id] = 1; // speed of track calculte on the hat
    
    for (int i = 0 ; i < NUM_BANDS ; i++) {
      band[id][i] = 1 ;
    }
  }
}












// RESET list and item
public boolean reset(Romanesco item) {
  boolean state = false;
  //global delete
  if (key_backspace) state = true;
  //SPECIFIC DELETE when the paramer button of contrôleur is ON
  else if (key_delete) if (item.action_is() || item.parameter_is()) state = true ;
  return state;
}
























/**
Varom
V 0.1.0
2018-2019
*/
public class Varom {
  private float value = 0;
  private float min = 0;
  private float max = 1;

  private float raw = 0;
  private float min_raw = 0;
  private float max_raw = 0;
  // private float result;

  public Varom() {}


  public Varom(float raw, float min_raw, float max_raw, float min, float max) {
    set_min(min);
    set_max(max);
    set_min_raw(min_raw);
    set_max_raw(max_raw);
    set_raw(raw);
  }




  /**
  get
  */
  public float raw() {
    return raw;
  }

  public float get() {
    return value;
  }

  public float min() {
    return min;
  }

  public float max() {
    return max;
  }

  public float min_raw() {
    return min_raw;
  }

  public float max_raw() {
    return max_raw;
  }
  
  /**
  set
  */

  public void set(float value) {
    this.value = value;
  }
/*
  public void set_raw(float raw) {
    set_raw(raw,0,0);
  }
  */

  public void set_raw(float raw) {
    set_raw(raw,0,0);
  }

  public void set_raw(float raw, int begin, int end) {
    this.raw = raw;
    if(begin == 0 && end == 0) {
      value = map(this.raw,min_raw,max_raw,min,max);
    } else {
      value = map(this.raw,min_raw,max_raw,min,max,begin,end);
    }
  }

  public void set_min(float min) {
    this.min = min;
  }

  public void set_max(float max) {
    this.max = max;
  }

  public void set_min_raw(float min_raw) {
    this.min_raw = min_raw;
  }

  public void set_max_raw(float max_raw) {
    this.max_raw = max_raw;
  }
}
/**
CORE SCENE and PRESCENE 
2015-2019
v 1.9.0
*/





 












/**
curtain
*/
public void curtain() {
  rectMode(CORNER) ;
  fill (0) ; 
  noStroke() ;
  rect(-1,-1, width+2, height+2);
}











/**
MANAGE SAVE
v 0.0.5
*/
public void load_autosave() {
  load_save(autosave_path);
}

public void load_save(String path) {
  Table save = loadTable(path, "header");
  for (TableRow row : save.rows()) {
    String s = row.getString("Type");
    if(s.equals("Media")){
      String media_path = row.getString("Path");
      File f = new File(media_path);
      if(f.exists()) {
        add_media(media_path);
      } else {
        printErr("method load_save(): no file match with this path",media_path);
      }
    }
  }
}



/**
MANAGE DIALOGUE
v 0.0.5
*/
public void load_dial_controller() {
  if(frameCount%240 == 0) {
    Table dial_table = loadTable(preference_path +"dialogue_from_controller.csv","header");
    TableRow row = dial_table.getRow(0);
    float temp_reactivity = row.getFloat("mouse reactivity");
    mouse_reactivity = temp_reactivity *temp_reactivity;
  }
}























/**
Color Romanesco 
v 1.0.1.1
*/
//COLOR for internal use
int fond ;
int rouge, orange, jaune, vert, bleu, noir, blanc, gris  ;
public void color_setup() {
  rouge = color(10,100,100);
  orange = color(25,100,100);
  jaune = color(50,100,100) ;
  vert = color(150,100,100);
  bleu = color(235,100,100);
  noir = color(10,100,0);
  gris = color(10,50,50);
  blanc = color(0,0,100);
}









/**
PAD TRACKING
*/
public int pad_inc(int target, int pad) {
  if(pad == UP && key_up) {
    target --;
  } else if(pad == DOWN && key_down) {
    target ++;
  } else if(pad == LEFT && key_left) {
    target --;
  } else if(pad == RIGHT && key_right) {
    target ++;
  }
  return target;
}












/**
CAMERA COMPUTER 
v 1.3.0
*/
Capture cam;
String[] cameras ;
String[] cam_name ;
ivec2[] cam_size ;
int[] cam_fps ;
int which_cam = 0;
int ref_cam = -1;
ivec2 CAM_SIZE;
boolean CAMERA_AVAILABLE;
boolean BROADCAST;

boolean new_cam = true;
boolean stop_cam = false;
boolean init_cam = false;

public void camera_video_setup() {
  list_cameras() ;
  if(new_cam && which_cam > -1) launch_camera(which_cam) ;
}



public void select_camera(int target) {
  which_cam = target ;
}

public void video_camera_manager() {
  camera_video_setup();
  if(ref_cam != which_cam || which_cam == -1) {
    new_cam = true ;
    video_camera_stop() ;
    ref_cam = which_cam ;    
  }

  if (new_cam && which_cam > -1 ) {
    BROADCAST = true ;
    launch_camera(which_cam) ;
  }

  if (cam.available() && BROADCAST) {
    cam.read();
  }
}

public Capture get_cam() {
  return cam;
}

public ivec2 [] get_cam_size() {
  return cam_size ;
}

public String [] get_cam_name() {
  return cam_name;
}

public int [] get_cam_fps() {
  return cam_fps;
}





// annexe methode camera
public void launch_camera(int which_cam) {
  if(CAMERA_AVAILABLE) {
    // if(FULL_RENDERING) which_cam = 0 ; else which_cam = 7 ; // 4 is normal camera around 800x600 or 640x360 with 30 fps
    if(!init_cam) {
      init_camera(which_cam);
      init_cam = true;
    }
    CAM_SIZE = cam_size[which_cam].copy();
    // surface.setSize((int)cam_size[which_cam].x, (int)cam_size[which_cam].y);
    new_cam = false ;
  }
}

public void video_camera_stop() {
  cam.stop() ;
  init_cam = false ;
  BROADCAST = false ;
}




public void init_camera(int which_camra) {
  cam = new Capture(this, cameras[which_camra]);
  cam.start();     
}


public void list_cameras() {
  cameras = Capture.list();
  cam_name = new String[cameras.length] ;
  cam_size = new ivec2[cameras.length] ;
  cam_fps = new int[cameras.length] ;
  
  // about the camera
  if (cameras.length != 0) {
    CAMERA_AVAILABLE = true ;
    for(int i = 0 ; i < cameras.length ; i++) {
      String cam_data [] = split(cameras[i],",") ;
      // camera name
      cam_name[i] = cam_data [0].substring(5,cam_data[0].length()) ;
      // size camera
      String size = cam_data [1].substring(5,cam_data[1].length()) ;
      String [] sizeXY = split(size,"x") ;
      cam_size[i] = ivec2(Integer.parseInt(sizeXY[0]), Integer.parseInt(sizeXY[1])) ;  // Integer.parseInt("1234");
      // fps
      String fps = cam_data [2].substring(4,cam_data[2].length()) ;
      cam_fps[i] = Integer.parseInt(fps) ;
    }
  } else {
    CAMERA_AVAILABLE = false ;
  }
}







































/**
FONT MANAGER 
v 3.0.0
*/
PFont system_font;
public void load_system_font() {
  String prefix_default_path_font = import_path +"font/default_font/";
  system_font = loadFont(prefix_default_path_font+"SansSerif-10.vlw");
}

public void select_font(int target)  {
  if(target < font.length) {
    current_font = font[target];
  } else {
    current_font = font[0];
  }
  // current_font = font[target];
}

public void init_font() {
  current_font = font[0];
  for(int i = 0 ; i < rom_manager.size() ; i++) {
    Romanesco item = rom_manager.get(i);
   item.set_font(current_font);
  }
}









/**
MODE
v 0.0.1
*/
class Mode {
  String [] name;
  int id;

  Mode() {} 

  Mode(int id, String... name) {
    this.name = name;
    this.id = id;
  }

  public String get_name(int id) {
    return this.name[id];
  }

  public String [] get_name() {
    return this.name;
  }

  public int get_id() {
    return this.id;
  }

  // set
  public void set_id(int id) {
    this.id = id;
  }

  public void set_name(String... name) {
    this.name = name;
  }
}












/**
Camera Romanesco
Prescene and Scene
2013-2018
v 1.3.1
*/
//travelling
boolean goto_camera_pos_is, gotoCameraEye, travellingPriority;
//speed must be 1 or less
float speed_follow_camera_romanesco;

//CAMERA Stuff
boolean moveScene, moveEye;

vec3 targetPosCam = vec3();

// motion effect on camera
Motion motion_translate, motion_rotate;

//float ratio_speed_camera_inertia_rotate = 3;
float acc_camera_rope = .01f;
float dec_camera_rope = .01f;

float ref_speed_follow_cam;
float ref_cam_deceleration;
float ref_cam_ratio_rotate,ref_cam_ratio_translate;


// Camera SETUP
public void camera_setup() {
  float speed_cam_follow = ref_speed_follow_cam = .01f;
  float dec = ref_cam_deceleration = .1f;
  float ratio_rotate = ref_cam_ratio_rotate = 10;
  float ratio_translate = ref_cam_ratio_translate = 3;
  camera_setting(NUM_SETTING_CAMERA,speed_cam_follow,dec,ratio_rotate,ratio_translate);
  item_manipulation();
  item_manipulation_setting(NUM_SETTING_ITEM);
  final_camera_low_rendering();
  println("camera setup done");
}


// ANNEXE setting object manipulation
public void item_manipulation () {
  for ( int i = 0 ; i < NUM_ITEM_PLUS_MASTER ; i++ ) {
    pos_item[i] = vec3() ; 
    dir_item[i] = vec3() ;
    if(dir_item_final[i] == null) dir_item_final[i] = vec3() ;
  }
}

public void item_manipulation_setting (int num_setting_item) {
  for(int i = 0 ; i < num_setting_item ; i++) {
    for(int j = 0 ; j < NUM_ITEM_PLUS_MASTER ; j++) {
      if(item_setting_position [i][j] == null) {
        item_setting_position [i][j] = vec3();
      }
      if(item_setting_direction [i][j] == null) {
        item_setting_direction [i][j] = vec3();
      }
    }
  }
}

// ANNEXE setting camera manipulation
public void camera_setting(int num, float speed_follow, float deceleration, float inertia_rotate, float inertia_translate) {
  if (eyeCameraSetting != null && sceneCameraSetting != null ) {
    for ( int i = 0 ; i < num ; i++ ) {
       eyeCameraSetting[i] = vec3() ;
       sceneCameraSetting[i] = vec3() ;
    }
  }

  speed_follow_camera_romanesco = width / 1000 * speed_follow;

  float max_speed_inertia_rotate = width / 1000 * inertia_rotate;
  motion_rotate = new Motion(max_speed_inertia_rotate);
  motion_rotate.set_deceleration(deceleration);

  float max_speed_inertia_translate = width / 1000 * inertia_translate;
  motion_translate = new Motion(max_speed_inertia_translate);
  motion_translate.set_deceleration(deceleration);

  
  
}



/**
Item
Start setting position and direction 
v 0.0.1
*/
// direction
public void setting_start_direction(int ID, vec2 dir) {
  int which_setting = 0 ;
  setting_start_direction(ID, which_setting, (int)dir.x, (int)dir.y) ;
}

public void setting_start_direction(int ID, int dir_x, int dir_y) {
  int which_setting = 0 ;
  setting_start_direction(ID, which_setting, dir_x, dir_y) ;
}

public void setting_start_direction(int ID, int which_setting, int dir_x, int dir_y) {
  if(dir_item_final[ID] == null) dir_item_final[ID] = vec3();
  dir_item_final[ID].set(dir_x,dir_y,0);
  if(item_setting_direction [0][ID] == null) item_setting_direction [which_setting][ID] = vec3();
  item_setting_direction [0][ID] = vec3(dir_item_final[ID]);
  if(temp_item_canvas_direction[ID] == null) temp_item_canvas_direction[ID] = vec3();
  temp_item_canvas_direction[ID].x = map(item_setting_direction [which_setting][ID].y,0,360,0,width);
  temp_item_canvas_direction[ID].y = map(item_setting_direction [which_setting][ID].x,0,360,0,height);
}

// position
public void setting_start_position(int ID, vec3 pos) {
  int which_setting = 0 ;
  setting_start_position(ID, which_setting, (int)pos.x, (int)pos.y, (int)pos.z) ;
}

public void setting_start_position(int ID, int pos_x, int pos_y, int pos_z) {
  int which_setting = 0 ;
  setting_start_position(ID, which_setting, pos_x, pos_y, pos_z) ;
}

public void setting_start_position(int ID, int which_setting, int pos_x, int pos_y, int pos_z) {
  if(pos_item_final[ID] == null) pos_item_final[ID] = vec3() ;
  pos_item_final[ID].x = pos_x -(width/2) ;
  pos_item_final[ID].y = pos_y -(height/2) ;
  pos_item_final[ID].z = pos_z ;
  if(item_setting_position [which_setting][ID] == null) item_setting_position [which_setting][ID] = vec3() ;
  item_setting_position [which_setting][ID] = vec3(pos_item_final[ID]) ;
  mouse[ID] = vec3(pos_x, pos_y, pos_z) ;
}



















/**
GET
*/
public vec3 get_pos_item(int id_item) {
  vec3 pos = pos_item_final[id_item].copy() ;
  return pos.add(width/2, height/2,0) ;
}

public vec3 get_dir_item(int id_item) {
  return dir_item_final[id_item] ;
}



















/**
ITEM CAMERA
v 1.0.1
final position and direction for the items
Master and follower updating
*/
public void item_move(boolean movePos, boolean moveDir, int ID) {
  //position
  if (!movePos) {
    update_ref_position_mouse() ;
    update_ref_position(pos_item[ID], ID) ;
  }
  vec3 newPos = update_position_item(pos_item[ID], ID, movePos) ;
  pos_item_final[ID].set(newPos) ;

  //direction
  if (!moveDir) {
    update_ref_direction_mouse() ;
    update_ref_direction(ID) ;
  }
  //speed rotation
  float speed = width / 10 ; // 150 is medium speed rotation
  vec2 speedDirectionOfObject = vec2(speed /(float)width, speed /(float)height) ;
  
  dir_item_final[ID].set(update_direction_item(speedDirectionOfObject, ID, moveDir)) ;





  //RESET
  if(key_0 || reset_item_on_button_alert_is()) {
    pos_item_final[ID].set(item_setting_position [0][ID]);
    dir_item_final[ID].set(item_setting_direction [0][ID]) ;
    
    temp_item_canvas_direction[ID].set(0) ;
    reset_camera_direction_item[ID] = true ;
    int which = 0 ;
    reset_direction_item(which, ID) ; 
  }

  add_ref_item(ID) ;
}



public void item_follower(Romanesco item) {
  if(follower[item.get_id()]) {
    int ID_master = master_ID[item.get_id()];
    Romanesco item_master = rom_manager.get(ID_master);
    item.action_is(item_master.action_is()); 
  }
  add_ref_item(item.get_id()) ;
}

// Create ref position
public void add_ref_item(int ID) {
  pos_item[ID] = vec3(pos_item_final[ID]) ;
  dir_item[ID] = vec3(dir_item_final[ID]);
}

// reset
public void reset_direction_item (int which_setting, int ID) {
  if(reset_camera_direction_item[ID]) {
    if(item_setting_direction[which_setting][ID] == null) {
      item_setting_direction[which_setting][ID] = vec3() ;
    }
    temp_item_canvas_direction[ID].x = map(item_setting_direction [which_setting][ID].y, 0, 360, 0, width) ;

    temp_item_canvas_direction[ID].y = map(item_setting_direction [which_setting][ID].x, 0, 360, 0, height) ;
    update_ref_direction_mouse() ;
  }
}






// Update direction item
vec3 direction_mouse_ref;
public void update_ref_direction_mouse() {
  if(direction_mouse_ref == null) direction_mouse_ref = vec3() ;
  if(mouse[0] == null) mouse[0] = vec3() ;

  direction_mouse_ref.x = mouse[0].x ;
  direction_mouse_ref.y = mouse[0].y ;
  // special op with the wheel value, because this value is not constant
  direction_mouse_ref.z = 0 ;
  direction_mouse_ref.z -= wheel[0] ;
}


public void update_ref_direction(int ID) {
  if(dir_item_ref[ID] == null) {
    dir_item_ref[ID] = vec3(temp_item_canvas_direction[ID]) ; 
  } else {
    dir_item_ref[ID].set(temp_item_canvas_direction[ID]) ;
  }
}


public vec3 update_direction_item(vec2 speed, int ID, boolean authorization) {
  if(authorization) {
  //to create a only one ref position
    //create the delta between the ref and the mouse position
    vec3 delta = vec3() ;
    if(!reset_camera_direction_item[ID]) {
      delta = sub(mouse[0], direction_mouse_ref) ;
      temp_item_canvas_direction[ID] = add(delta, dir_item_ref[ID]) ;
      //rotation of the camera
      dir_item[ID].set(direction_canvas_to_polar(temp_item_canvas_direction[ID])) ;
    } else {
      dir_item[ID].set(direction_canvas_to_polar(temp_item_canvas_direction[ID])) ;
      reset_camera_direction_item[ID] = false ;
    }
  } 
  return dir_item[ID] ;
}




// Update position item
vec3 position_mouse_ref = vec3() ;

public void update_ref_position_mouse() {
  position_mouse_ref.x = mouse[0].x;
  position_mouse_ref.y = mouse[0].y;
  // special op with the wheel value, because this value is not constant
  position_mouse_ref.z = 0;
  position_mouse_ref.z -= wheel[0];
}

public void update_ref_position(vec3 pos, int ID) {
  pos_item_ref[ID].set(pos.x, pos.y, pos.z) ;
}

public vec3 update_position_item(vec3 pos, int ID, boolean authorization) {
  vec3 delta = vec3() ;
  // Z position with the wheel
  delta.z = wheel[0] -position_mouse_ref.z ;
  // X et Y pos with the mouse coordonate
  if (authorization) {
    //to create a only one ref position
    //create the delta between the ref and the mouse position
    delta.x = mouse[0].x -position_mouse_ref.x ;
    delta.y = mouse[0].y -position_mouse_ref.y ;
  } 

  // special op with the wheel value
  delta.z *= -1.f ;

  // PVector temp_pos = PVector.add(new PVector(pos_item_ref[ID].x,pos_item_ref[ID].y,pos_item_ref[ID].z), delta) ;
  pos = add(pos_item_ref[ID], delta) ;
  return pos ;
}





// FINAL POSITION
public void final_pos_item(Romanesco item) {
  int id = item.get_id();
  translate(pos_item_final[id]);
  rotateX(radians(dir_item_final[id].x));
  rotateY(radians(dir_item_final[id].y));
}

































































/**
MOVE CAMERA GLOBAL 
v 1.2.0
*/
float dirCamX,dirCamY,dirCamZ,
      centerCamX,centerCamY,centerCamZ,
      upX,upY,upZ ;
float focal, deformation ;
vec3 finalSceneCamera ;
vec2 finalEyeCamera ;
boolean reset_camera_romanesco ;



/**
Main method camera draw
*/
public void camera_romanesco_draw() {
  set_var_camera_romanesco();
  update_camera_romanesco(LEAPMOTION_DETECTED) ;

  // deformation and focal of the lenz camera
  paralaxe(focal,deformation);
  
  //camera order from the mouse or from the leap
  order_camera();

  start_camera();
  
  //to change the scene position with a specific point
  if(goto_camera_pos_is || gotoCameraEye ) {
    move_camera(sceneCamera, targetPosCam, speed_follow_camera_romanesco) ;
  }

  //catch ref camera
  catch_camera_info();
}






public void set_var_camera_romanesco() { 
  /* 
  this method need to be on the Prescene sketch and on the window.
  1. boolean prescene : On prescene, because on Scene we don't need to have a global view : boolean prescene
  2. boolean MOUSE_IN_OUT : because if we mode out the sketch the keyevent is not updated, and the camera stay in camera view 
  */
  if(FULL_RENDERING || (key_c_long && (MOUSE_IN_OUT || clickLongLeft[0] || clickLongRight[0]) && prescene)) {
    final_camera_full_rendering(); 
  } else {
    final_camera_low_rendering();
  }
}


public void final_camera_full_rendering() {
  // world rendering
  focal = map(value_slider_camera[0],0,360,28,200);
  deformation = map(value_slider_camera[1],0,360,-1,1);
  // camera
  dirCamX = map(value_slider_camera[2],0,360,0,width); // on controler is Eye X
  dirCamY = map(value_slider_camera[3],0,360,0,height); // on controler is Eye Y
  // dirCamZ = map(value_slider_camera[4],0,360,0,width)  ; // on controler is Eye Z
  
  centerCamX = map(value_slider_camera[4],0,360,0,width); // on controler is Position X
  centerCamY = map(180,0,360,0,height); // on controler is Position Y
  // centerCamZ = map(value_slider_camera[7],0,360,0,width)  ; // on controler is Position Z

  upX = map(value_slider_camera[5],0,360,-1,1);
  upY = 1 ; // not interesting
  upZ = 0 ; // not interesting

  // displacement of the scene
  vec3 displacement_scene = vec3(width/2, height/2, 0);
  
  // Check the special move camera
  vec3 compare_pos_scene = sub(finalSceneCamera, sceneCamera);

  // intertia camera
  float speed_follow_cam = .01f;
  float deceleration = map(value_slider_camera[7],0,360,.0001f,.02f);
  float ratio_rotate = map(value_slider_camera[8],0,360,0,10);
  float ratio_translate = map(value_slider_camera[9],0,360,0,10);


  if(ref_speed_follow_cam != speed_follow_cam || ref_cam_deceleration != deceleration || ref_cam_ratio_rotate != ratio_rotate || ref_cam_ratio_translate != ratio_translate) {
    camera_setting(NUM_SETTING_CAMERA,speed_follow_cam,deceleration,ratio_rotate,ratio_translate);
    ref_speed_follow_cam = speed_follow_cam;
    ref_cam_deceleration = deceleration;
    ref_cam_ratio_rotate = ratio_rotate;
    ref_cam_ratio_translate = ratio_translate;
  }

  boolean move_camera_is = false ; ;
  // displacement scene
  if(!compare_pos_scene.equals(displacement_scene)) {
    move_camera_is = true ; 
  } 
  // inertia
  if(motion_translate.velocity_is() || motion_rotate.velocity_is()) {
    move_camera_is = true ; 
  }

  if(reset_camera_romanesco) {
    move_camera_is = true ; 
    reset_camera_romanesco = false ;
  }
  

  // final camera position
  if (check_cursor_rotate(key_c_long) || move_camera_is) { 
    // eye
    if(finalEyeCamera == null) {
      finalEyeCamera = vec2(radians(eyeCamera.x),radians(eyeCamera.y) ) ;
    } else {
      finalEyeCamera.set(radians(eyeCamera.x),radians(eyeCamera.y) ) ;
    }
    // translate scene
    if(finalSceneCamera == null) {
      finalSceneCamera = vec3(add(sceneCamera, displacement_scene)) ;
    } else {
      finalSceneCamera.set(add(sceneCamera, displacement_scene)) ;
    } 
  }
}


public void final_camera_low_rendering() {
  // default setting camera from Processing.org example, like the camera above
  /*
  float dirCamX = width/2.0 ; // eye X
  float dirCamY = height/2.0 ; // eye Y
  float dirCamZ = (height/2.0) / tan(PI*30.0 / 180.0) ; // // eye Z
  float centerCamX = width/2.0 ; // Position X
  float centerCamY = height/2.0 ; // Position Y
  float centerCamZ = 0 ; // Position Z
  float upX = 0 ;
  float upY = 1 ;
  float upZ = 0 ;
  */
   // world rendering
  focal = 40 ; // 28-200
  deformation = 0 ; // -1 to 1 
  // camera
  dirCamX = width/2.0f ; // eye X
  dirCamY = height/2.0f ; // eye Y
  dirCamZ = (height/2.0f) / tan(PI*30.0f / 180.0f) ; // eye Z
  
  centerCamX = width/2.0f ; // Position X
  centerCamY = height/2.0f ; // Position Y
  centerCamZ = 0 ; // Position Z
  
  upX = 0 ;
  upY = 1 ;
  upZ = 0 ;
  // final camera position
  finalSceneCamera = new vec3 (width/2,height,-width);
  float longitude = -45;
  float latitude = 0;
  finalEyeCamera = new vec2(longitude,latitude);
}



//CATCH a ref position and direction of the camera
vec3 posCamRef = vec3();
vec3 eyeCamRef = vec3();
//boolean security to catch the reference camera when you reset the position of this one
boolean catchCam = true ;
public void catch_camera_info() {
  if(catchCam) {
    posCamRef = get_pos_camera();
    eyeCamRef = get_eye_camera();
  }
  catchCam = false;
}




//camera order from the mouse or from the leap
public void order_camera() {
  boolean authorization = key_c_long;
  if(authorization || reset_camera_button_alert_is()) {
    if(ORDER_ONE || ORDER_THREE) {
      moveScene = true; 
    } else {
      moveScene = false;
    } 
    if(ORDER_TWO || ORDER_THREE) {
      moveEye = true; 
    } else {
      moveEye = false;
    }
      
    //update z position of the camera
    sceneCamera.z -= wheel[0];
      
    // change camera position
    if (key_enter) {
      travelling(posCamRef);
    }

    if (key_0 || reset_camera_button_alert_is()) {
      reset_camera(0);
    }
  } else if (!authorization || (ORDER_ONE && ORDER_ONE && ORDER_THREE)) {
    moveScene = false;
    moveEye = false;
  }  
}


//start camera with speed setting
boolean switch_rotate_YZ ;
public void start_camera() {
  pushMatrix();
  camera(dirCamX, dirCamY, dirCamZ, centerCamX, centerCamY, centerCamZ, upX, upY, upZ);
  beginCamera();
  // scene position
  translate(finalSceneCamera) ;
  // scene orientation direction
  /* 
  eyeCamera, is not a good terminilogy 
  because the real eye camera is not use here. Here we just move the world. 
  */
  rotateX(finalEyeCamera.x) ;
  if(key_b) {
    if(switch_rotate_YZ) {
      switch_rotate_YZ = false; 
    } else {
      switch_rotate_YZ = true;
    }
  }

  if(switch_rotate_YZ) {
    rotateY(finalEyeCamera.y);
    rotateZ(0) ;
  } else {
    rotateY(0) ;
    rotateZ(finalEyeCamera.y);
  }
}

//stop
public void stop_camera() {
  popMatrix();
  endCamera();
  stop_paralaxe();
}





// update the position of the scene (camera) and the orientation
vec3 cursor_final_translate;
vec3 cursor_final_rotate;
vec3 mouse_ref_inertia_translate;
vec3 mouse_ref_inertia_rotate;

int wheelCheckRef = 0;

boolean reset_inertia = true;
boolean cursor_move_scene_is = false;
boolean cursor_move_eye_is = false;

public void update_camera_romanesco(boolean leapMotion) {
  if(cursor_final_translate == null) {
    cursor_final_translate = mouse[0].copy();
  } 

  if(cursor_final_rotate == null) {
    cursor_final_rotate = mouse[0].copy();
  } 

  if(mouse_ref_inertia_translate == null) {
    mouse_ref_inertia_translate = mouse[0].copy();
  } 

  if(mouse_ref_inertia_rotate == null) {
    mouse_ref_inertia_translate = mouse[0].copy();
  } 

  // make ref
  if(key_c_long) {
    if (moveScene) {
      mouse_ref_inertia_translate = mouse[0].copy(); 
    } else {
      mouse_ref_inertia_translate.set(mouse[0]); 
    }

    if (moveEye) {
      if(mouse_ref_inertia_rotate == null) {
        mouse_ref_inertia_rotate = mouse[0].copy(); 
      } else {
        mouse_ref_inertia_rotate.set(mouse[0]); 
      }
    }
  } 


  
  // create new pos
  if(key_c_long) { 
    // scene / translate
    if(moveScene || motion_translate.velocity_is()) {
      cursor_final_translate.set(update_cursor(motion_translate, mouse_ref_inertia_translate, cursor_final_translate)) ;
      cursor_move_scene_is = true ;
    } else {
      cursor_move_scene_is = false ;
    }

    // eye / rotate
    if(moveEye || motion_rotate.velocity_is()) {
      cursor_final_rotate.set(update_cursor(motion_rotate, mouse_ref_inertia_rotate, cursor_final_rotate)) ;
      cursor_move_eye_is = true ;
    } else {
      cursor_move_eye_is = false ;
    }
  } else {
    if(motion_translate.velocity_is()) {
      cursor_final_translate.set(update_cursor(motion_translate, mouse_ref_inertia_translate, cursor_final_translate)) ;
    }

    // eye / rotate
    if(motion_rotate.velocity_is()) {
      cursor_final_rotate.set(update_cursor(motion_rotate, mouse_ref_inertia_rotate, cursor_final_rotate)) ;
    } 
  }
  
  //update pos
  update_position_camera(cursor_move_scene_is, leapMotion, cursor_final_translate) ;
  update_direction_camera(cursor_move_eye_is, cursor_final_rotate) ;
 

  // reset inertia
  if(reset_inertia) {
    motion_translate.reset();
    motion_rotate.reset();
    reset_inertia = false ;
  } 

  if(key_space_long) {
    reset_inertia = true ;   
  } 
}

public vec3 update_cursor(Motion motion, vec3 ref, vec3 cursor_final) {
  return motion.leading(ref, cursor_final) ;
}

/**
check camera
*/
// check if the mouse move or not, it's use to update or not the position of the world.
// we must use that to don't update the scene when we load the save scene setting

// translate
vec3 mouse_camera_translate_ref  ;
public boolean check_cursor_translate(boolean authorization) {
  boolean cursor_move_is ;
  if(authorization && (!compare(mouse_camera_translate_ref, cursor_final_translate) || wheelCheckRef != wheel[0])) {
    cursor_move_is = true ; 
  } else {
    cursor_move_is = false ;
  }

  // create ref
  wheelCheckRef = wheel[0] ;
  if(mouse_camera_translate_ref == null) {
    mouse_camera_translate_ref = cursor_final_translate.copy();
  } else {
    mouse_camera_translate_ref.set(cursor_final_translate);
  }
  return cursor_move_is ;
}

// rotate
vec3 mouse_camera_rotate_ref  ;
public boolean check_cursor_rotate(boolean authorization) {
  boolean cursor_move_is ;
  if(authorization && (!compare(mouse_camera_rotate_ref, cursor_final_rotate) || wheelCheckRef != wheel[0])) {
    cursor_move_is = true ; 
  } else {
    cursor_move_is = false ;
  }

  // create ref
  wheelCheckRef = wheel[0] ;
  if(cursor_final_rotate == null) {
    cursor_final_rotate = vec3();
  }

  if(mouse_camera_rotate_ref == null) {
    mouse_camera_rotate_ref = cursor_final_rotate.copy();
  } else {
    mouse_camera_rotate_ref.set(cursor_final_rotate) ;
  }
  return cursor_move_is ;
}





// move camera to target
public void move_camera(vec3 origin, vec3 target, float speed_follow) {
  if(!moveScene) {
    sceneCamera.set(follow(origin,target,speed_follow));
  }
  if(!moveEye && (goto_camera_pos_is || gotoCameraEye)) {
    eyeCamera.set(back_eye());
  }
}


// CHANGE CAMERA POSITION
public void reset_camera(int ID) {
  reset_camera_romanesco = true;

  eyeCamera.set(eyeCameraSetting[ID]);
  sceneCamera.set(sceneCameraSetting[ID]);

  tempEyeCamera.set(0);
  goto_camera_pos_is = false;
  gotoCameraEye = false;

  motion_translate.reset();
  motion_rotate.reset();

  cursor_final_translate.set(mouse[0]);
  cursor_final_rotate.set(mouse[0]);
  mouse_ref_inertia_translate.set(mouse[0]);
  mouse_ref_inertia_translate.set(mouse[0]);

  update_direction_camera(!reset_camera_romanesco,eyeCamera);
  update_position_camera(!reset_camera_romanesco,false,sceneCamera);
}













//GET
public vec3 get_eye_camera() { 
  return eyeCamera; 
}

public vec3 get_pos_camera() { 
  return sceneCamera; 
}




//INIT FOLLOW
float distFollowRef = 0 ;
vec3 eyeBackRef;
//travelling with only camera position
public void travelling(vec3 target) {
  distFollowRef = dist(target, sceneCamera) ;
  
  targetPosCam = target ;
  if(eyeBackRef == null) {
    eyeBackRef = get_eye_camera().copy();
  } else {
    eyeBackRef.set(get_eye_camera());
  }
  
  if(abs_position == null) {
    abs_position = vec3();
  } else {
    abs_position.set(0);
  }
  goto_camera_pos_is = true;
  gotoCameraEye = true;
}
//END INIT FOLLOW



float speedX  ;
float speedY  ;
    
public vec3 back_eye() {
  vec3 eye = vec3();

  if(gotoCameraEye) {
    if(current_dist_to_target > 2 ) {
      travellingPriority = true ;
      if (eyeBackRef.x < 180) {
        eye.x = map(current_dist_to_target,distFollowRef,0,eyeBackRef.x,0); 
      } else {
        eye.x = map(current_dist_to_target,distFollowRef,0,eyeBackRef.x,360);
      }
      if (eyeBackRef.y < 180) {
        eye.y = map(current_dist_to_target,distFollowRef,0,eyeBackRef.y,0); 
      } else {
        eye.y = map(current_dist_to_target,distFollowRef,0,eyeBackRef.y,360);
      }
      //stop the calcul
      if(eye.x < 2 || eye.x > 358 ) eye.x = 0;
      if(eye.y < 2 || eye.y > 358 ) eye.y = 0; 
      if(eye.x == 0  && eye.y == 0) {
        gotoCameraEye = false ;
        travellingPriority = false ;
      }
    } else {
      //speed of the eye to return to original position
      // float speedBackEye = 3.;
      float speedBackEye = .2f;
      float ratioX = eyeBackRef.x / frameRate *speedBackEye ;
      float ratioY = eyeBackRef.y / frameRate *speedBackEye ;
      speedX += ratioX;
      speedY += ratioY;
      if (eyeBackRef.x < 180 && !travellingPriority ) {
        eye.x = eyeBackRef.x -speedX; 
      } else {
        eye.x = eyeBackRef.x +speedX;
      }
      if (eyeBackRef.y < 180 && !travellingPriority ) {
        eye.y = eyeBackRef.y -speedY; 
      } else {
        eye.y = eyeBackRef.y +speedY;
      }
      // to stop the calcul
      if(eye.x < 2 || eye.x > 358 ) eye.x = 0 ;
      if(eye.y < 2 || eye.y > 358 ) eye.y = 0 ;  
      
      if(eye.x == 0  && eye.y == 0) {
        travellingPriority = false;
        gotoCameraEye = false;
        speedX = 0;
        speedY = 0;
      }
    }
  } 
  return eye;
}


//MAIN VOID
vec3 speed_by_axes;
//calculate new position to go at the new target camera
vec3 dist_to_target_updated;
float current_dist_to_target = 0 ;
vec3 current_pos_camera;
vec3 abs_position;
/*
vec3 follow(vec3 origin, vec3 target, float speed) {
  vec3 PVorigin = new PVector(origin.x, origin.y, origin.z) ;
  vec3 PVtarget = new PVector(target.x, target.y, target.z) ;
  return vec3(follow(PVorigin, PVtarget, speed)) ;
}
*/

public vec3 follow(vec3 origin, vec3 target, float speed) {
  //very weird I must inverse the value to have the good result !
  //and change again at the end of the algorithm
  target.x = -target.x ;
  target.y = -target.y ;
  target.z = -target.z ;
  
  //updated the distance in realtime
  if(dist_to_target_updated == null) {
    dist_to_target_updated = sub(current_pos_camera,target).copy();
  } else {
    dist_to_target_updated.set(sub(current_pos_camera,target));
  }

  current_dist_to_target = dist(current_pos_camera,target);

  
  //calculate the speed to go to target
  vec3 abs_dist_value = vec3(abs(dist_to_target_updated.x),abs(dist_to_target_updated.y),abs(dist_to_target_updated.z));
  abs_dist_value.normalize() ;
  //speed_by_axes = PVector.div(abs_dist_value, 1.0 / speed) ; 
  if(speed_by_axes == null) {
    speed_by_axes = mult(abs_dist_value, speed);
  } else {
    speed_by_axes.set(mult(abs_dist_value, speed));
  }



  vec3 range_to_stop = vec3(5) ; 
  //calculate the new absolute position
  // XYZ
  if ( (dist_to_target_updated.x > range_to_stop.x || dist_to_target_updated.x < -range_to_stop.x) && 
       (dist_to_target_updated.y > range_to_stop.y || dist_to_target_updated.y < -range_to_stop.y) && 
       (dist_to_target_updated.y > range_to_stop.z || dist_to_target_updated.y < -range_to_stop.z))  {
    if (origin.x < target.x )  abs_position.x += speed_by_axes.x ;  else abs_position.x -= speed_by_axes.x ;
    if (origin.y < target.y )  abs_position.y += speed_by_axes.y ;  else abs_position.y -= speed_by_axes.y ;
    if (origin.z < target.z )  abs_position.z += speed_by_axes.z ;  else abs_position.z -= speed_by_axes.z ;
  // XY  
  } else if ( (dist_to_target_updated.x > range_to_stop.x || dist_to_target_updated.x < -range_to_stop.x) && 
              (dist_to_target_updated.y > range_to_stop.y || dist_to_target_updated.y < -range_to_stop.y)) {
    if (origin.x < target.x )  abs_position.x += speed_by_axes.x ;  else abs_position.x -= speed_by_axes.x ;
    if (origin.y < target.y )  abs_position.y += speed_by_axes.y ;  else abs_position.y -= speed_by_axes.y ;
    abs_position.z += 0 ;
  // XZ
  } else if ( (dist_to_target_updated.x > range_to_stop.x || dist_to_target_updated.x < -range_to_stop.x) && 
              (dist_to_target_updated.y > range_to_stop.z || dist_to_target_updated.y < -range_to_stop.z))  {
    if (origin.x < target.x )  abs_position.x += speed_by_axes.x ;  else abs_position.x -= speed_by_axes.x ;
    abs_position.y += 0 ;
    if (origin.z < target.z )  abs_position.z += speed_by_axes.z ;  else abs_position.z -= speed_by_axes.z ;
  // YZ
  } else if ( (dist_to_target_updated.y > range_to_stop.y || dist_to_target_updated.y < -range_to_stop.y) && 
              (dist_to_target_updated.y > range_to_stop.z || dist_to_target_updated.y < -range_to_stop.z))  {
    abs_position.x += 0 ;
    if (origin.y < target.y )  abs_position.y += speed_by_axes.y ;  else abs_position.y -= speed_by_axes.y ;
    if (origin.z < target.z )  abs_position.z += speed_by_axes.z ;  else abs_position.z -= speed_by_axes.z ;
  // X
  } else if ( (dist_to_target_updated.x > range_to_stop.x || dist_to_target_updated.x < -range_to_stop.x)) {
    if (origin.x < target.x )  abs_position.x += speed_by_axes.x ;  else abs_position.x -= speed_by_axes.x ;
    abs_position.y += 0 ;
    abs_position.z += 0 ;
  // Y  
  } else if ( (dist_to_target_updated.y > range_to_stop.y || dist_to_target_updated.y < -range_to_stop.y))  {
    abs_position.x += 0 ;
    if (origin.y < target.y )  abs_position.y += speed_by_axes.y ;  else abs_position.y -= speed_by_axes.y ;
    abs_position.z += 0 ;
  // Z
  } else if ( (dist_to_target_updated.y > range_to_stop.z || dist_to_target_updated.y < -range_to_stop.z))  {
    abs_position.x += 0 ;
    abs_position.y += 0 ;
    if (origin.z < target.z )  abs_position.z += speed_by_axes.z ;  else abs_position.z -= speed_by_axes.z ;
  // IT'S DONE, NOTHING TO DO NOW
  } else {  
    abs_position.x += 0 ;
    abs_position.y += 0 ;
    abs_position.z += 0 ;
    goto_camera_pos_is = false ;
  }
  
  //very weird I must inverse the value to have the good result !
  target.x = -target.x ;
  target.y = -target.y ;
  target.z = -target.z ;

  //finalize the newposition of the point
  current_pos_camera.set(add(origin,abs_position));
  
  return current_pos_camera ;
}

































/**
PERSPECTIVE
*/
public void paralaxe() {
  float aspect = PApplet.parseFloat(width)/PApplet.parseFloat(height) ;
  float fov = 1.0f ;
  float cameraZ = (height/2.0f) / tan(fov/2.0f);
  perspective(fov, aspect, cameraZ *.02f, cameraZ*100.0f);
}


public void paralaxe(float focal, float deformation) {
  // ratio deformation
  float aspect = PApplet.parseFloat(width)/PApplet.parseFloat(height) ;
  aspect += deformation ;
  // focal
  focal = constrain(focal, 28,200) ;
  focal = map(focal,28,200,140,5) ;
  float fov = radians(focal) ;
  // this algo is from Processing example
  float cameraZ = (height/2.0f) / tan(fov/2.0f);
  
  // this algo is from Processing example
  perspective(fov, aspect, cameraZ *.02f, cameraZ*100.0f);
}

// use to stop perspective correction for the info display
public void stop_paralaxe() {
  perspective();
}

























/**
GRID 
v 0.0.2
*/
public void grid_romanesco(boolean showGrid) {
  if(showGrid)  {
    float thickness = .1f;
    // Very weird it's necessary to pass by PVector, if we don't do that when we use camera the grid disappear
    vec3 size_background = vec3(width *100, height *100, height *7.5f) ;
    vec3 size_grid = mult(size_background,vec3(.2f,.2f,1));

    int posTxt = 10 ;
    
    textSize(10) ;
    textAlign(LEFT, BOTTOM);
    strokeWeight(thickness);

    grid(size_grid) ;
    axe_x(size_grid, posTxt) ;
    axe_y(size_grid, posTxt) ;
    axe_z(size_grid, posTxt) ;
  }
}

// void axe_x(PVector size, int pos) {
public void axe_x(vec3 size, int pos) {
  fill(0xffD31216) ;
  stroke(0xffD31216) ; 

  text("X LINE XXX", pos,-pos) ;

  noFill() ;
  line( -size.x,0,0,
        size.x,0,0) ;

}
// void axe_y(PVector size, int pos) {
public void axe_y(vec3 size, int pos) {
    fill(0xff2DA308) ;
    stroke(0xff2DA308) ; 

    pushMatrix() ;
    rotateZ(radians(-90)) ;
    text("Y LINE YYY", pos, -pos) ;
    popMatrix() ;

    noFill() ;
    line( 0,-size.y,0,
          0,size.y,0) ;

}
// void axe_z(PVector size, int pos) {
public void axe_z(vec3 size, int pos) {
    fill(0xffEFB90F) ;
    stroke(0xffEFB90F) ; 

    pushMatrix() ;
    rotateY(radians(90)) ;
    text("Z LINE ZZZ", pos, -pos) ;
    popMatrix() ;

    noFill() ;
    line( 0,0,-size.z,
          0,0,size.z) ;

}

// void grid(PVector size) {
public void grid(vec3 size) {
  noFill() ;
  stroke(0xff596F91) ;
  // int size_grid = (int)size.z ;
  int step = 50 ;
  //horizontal grid
  for ( float i = -size.z ; i <= size.z ; i = i+step ) {
    if(i != 0 ) line( i, 0, -size.z, 
                      i, 0, size.z) ;
  }
}





























/**

Camera Engine version 6.0.3

*/
private vec3 posSceneMouseRef = vec3();
private vec3 posEyeMouseRef = vec3();
private vec3 posSceneCameraRef= vec3();
private vec3 posEyeCameraRef = vec3();
private vec3 eyeCamera = vec3();
private vec3 sceneCamera = vec3();
private vec3 deltaScenePos = vec3();
private vec3 deltaEyePos = vec3();
private vec3 tempEyeCamera = vec3();
private boolean newRefSceneMouse = true;
private boolean newRefEyeMouse = true;

// Update Camera position
/* We move the scene 
*/

public void update_position_camera(boolean authorization, boolean leapMotionDetected, vec3 pos_cursor) {
  if(authorization) {
    //create the ref to calcul the new position of the Scene
    if(newRefSceneMouse) {
      posSceneCameraRef.set(sceneCamera);
      posSceneMouseRef.set(pos_cursor);
      //to create a only one ref position
      newRefSceneMouse = false;
    }

    //create the delta between the ref and the mouse position
    deltaScenePos = sub(pos_cursor, posSceneMouseRef);
    if (leapMotionDetected) {
      sceneCamera = add(deltaScenePos.mult(-1), posSceneCameraRef);
    } else {
      sceneCamera = add(deltaScenePos, posSceneCameraRef);
    }
  } else {
    //change the boolean to true for the next mousepressed
    newRefSceneMouse = true;
  }
}
//


// Update Camera EYE position
public void update_direction_camera(boolean authorization, vec3 pos_cursor) {
  if(authorization) {
    //create the ref to calcul the new position of the Scene
    if(newRefEyeMouse) {
      posEyeCameraRef.set(tempEyeCamera);
      posEyeMouseRef.set(pos_cursor);
    }
    //to create a only one ref position
    newRefEyeMouse = false ;
    
    //create the delta between the ref and the mouse position
    deltaEyePos = sub(pos_cursor, posEyeMouseRef);
    tempEyeCamera = add(deltaEyePos, posEyeCameraRef);

    // direction of the camera
   //  return direction_canvas_to_polar(tempEyeCamera) ;
    eyeCamera.set(direction_canvas_to_polar(tempEyeCamera));
  } else {
    //change the boolean to true for the next mousepressed
    newRefEyeMouse = true;
  }  
}


// EYE POSITION two solutions
/*
Solution 1
We must use this one with le leapmotion information, because with the leapmotion device
there is no "pmouse" information.
*/
vec3 eyeMemory ;
public vec3 direction_canvas_to_polar(vec3 direction_canvas) {
  float temp_dir_x = map(direction_canvas.y,0,height,0,360);
  float temp_dir_y = map(direction_canvas.x,0,width,0,360);
  vec3 eyeP3D = vec3(temp_dir_x,temp_dir_y,0);
  return eyeP3D;
}


/*
solution 2
we can use this better void when we don't use the leapmotion */

// Solution interesting but there is problem with it ??????????
public PVector eyeAdvanced(PVector PreviousPos, PVector pos, PVector speed) {
  PVector eyeP3D = new PVector() ;
  // eyeP3D.x += (PreviousPos.y -pos.y) *speed.y;
  // eyeP3D.y += (PreviousPos.x -pos.x) *-speed.x;
  eyeP3D.x += (PreviousPos.y -pos.y) *speed.y;
  eyeP3D.y += (PreviousPos.x -pos.x) *-speed.x;
  
  if(eyeP3D.x > 360) eyeP3D.x = 0 ;
  if(eyeP3D.x < 0) eyeP3D.x = 360 ;
  if(eyeP3D.y > 360) eyeP3D.y = 0 ; 
  if(eyeP3D.y < 0) eyeP3D.y = 360 ;
  return eyeP3D ;
}






/**
* FX BACKGROUND
* v 1.2.4
* 2019-2019
*/
ArrayList<FX> fx_background_manager;
public void init_fx_background() {
  if(FULL_RENDERING) {
    fx_background_manager = new ArrayList<FX>();
    get_fx_bg_path();
    if(fx_bg_path_exist()) {
      println("FX BACKGROUND shader loaded");
    } else {
      printErr("fx background path filter",get_fx_bg_path(),"don't exists");
    }
    setting_fx_background(fx_background_manager);
    write_fx_backgound_index(fx_background_manager);
  }
}


public void fx_background(int which_shader) {
  if(FULL_RENDERING) {
    update_fx_background_slider();
    update_fx_background(fx_background_manager);

    for(FX fx : fx_background_manager) {
      if(which_shader == fx.get_id()) {
        select_fx_background(fx);
        break;
      }
    } 
  }
}




vec4 fx_bg_col = vec4();
vec2 fx_bg_pos = vec2();
float fx_bg_size;
float fx_bg_strength;
float fx_bg_num;
float fx_bg_quality; 
vec2 fx_bg_speed = vec2();
float fx_bg_angle;
float fx_bg_threshold;
public void update_fx_background_slider() {
  fx_bg_col.x(map(value_slider_background[0],0,MAX_VALUE_SLIDER,0,1));
  fx_bg_col.y(map(value_slider_background[1],0,MAX_VALUE_SLIDER,0,1));
  fx_bg_col.z(map(value_slider_background[2],0,MAX_VALUE_SLIDER,0,1));
  fx_bg_col.w(map(value_slider_background[3],0,MAX_VALUE_SLIDER,0,1));

  fx_bg_pos.x(map(value_slider_background[4],0,MAX_VALUE_SLIDER,0,1));
  fx_bg_pos.y(map(value_slider_background[5],0,MAX_VALUE_SLIDER,0,1));

  fx_bg_size = map(value_slider_background[6],0,MAX_VALUE_SLIDER,0,1);

  fx_bg_strength = map(value_slider_background[7],0,MAX_VALUE_SLIDER,0,1);

  fx_bg_num = map(value_slider_background[8],0,MAX_VALUE_SLIDER,0,1);

  fx_bg_quality = map(value_slider_background[9],0,MAX_VALUE_SLIDER,0,1);
  
  fx_bg_speed.x(map(value_slider_background[10],0,MAX_VALUE_SLIDER,0,1));
  fx_bg_speed.y(map(value_slider_background[11],0,MAX_VALUE_SLIDER,0,1));

  fx_bg_angle = map(value_slider_background[12],0,MAX_VALUE_SLIDER,0,1);

  fx_bg_threshold = map(value_slider_background[13],0,MAX_VALUE_SLIDER,0,1);
}























/**
* BACKGROUND SHADER
* v 0.4.0
* 2013-2019
*/

int fx_background_num;
public void setting_fx_background(ArrayList<FX> fx_list) {
  setting_fx_bg_classic(fx_list);
  setting_fx_bg_cellular(fx_list);
  setting_fx_bg_heart(fx_list);
  setting_fx_bg_necklace(fx_list);
  // setting_fx_bg_neon(fx_list);
  setting_fx_bg_psy(fx_list);
  setting_fx_bg_snow(fx_list);
  setting_fx_bg_voronoi_hex(fx_list);
}

public void update_fx_background(ArrayList<FX> fx_list) {
  boolean move_fx_bg_is = true;
  update_fx_bg_classic(fx_list,move_fx_bg_is,fx_bg_col);
  update_fx_bg_cellular(fx_list,move_fx_bg_is,fx_bg_col,fx_bg_quality,fx_bg_num,fx_bg_speed);
  update_fx_bg_heart(fx_list,move_fx_bg_is,vec3(fx_bg_col),fx_bg_quality,fx_bg_num,fx_bg_angle,fx_bg_strength,fx_bg_speed.x);  
  update_fx_bg_necklace(fx_list,move_fx_bg_is,fx_bg_pos,fx_bg_col.w,fx_bg_num,fx_bg_size,fx_bg_speed.x);
  // update_fx_bg_neon(fx_list,move_fx_bg_is,fx_bg_pos,fx_bg_speed.x);
  update_fx_bg_psy(fx_list,move_fx_bg_is,fx_bg_num,fx_bg_speed.x);
  update_fx_bg_snow(fx_list,move_fx_bg_is,fx_bg_pos,vec3(fx_bg_col),fx_bg_speed.x,fx_bg_quality);
  update_fx_bg_voronoi_hex(fx_list,move_fx_bg_is,vec3(fx_bg_col),fx_bg_size,fx_bg_speed,fx_bg_strength,fx_bg_threshold);
}



// classic
String setting_fx_bg_classic = "Classic";
public void setting_fx_bg_classic(ArrayList<FX> fx_list) {
  // no shader to download at this time !!!
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2013-2019";
  String [] slider = {"hue","saturation","brightness","refresh"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_classic,NO_FX,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}

public void update_fx_bg_classic(ArrayList<FX> fx_list, boolean move_is, vec4 colour) {
  if(move_is) {
    fx_set_colour(fx_list,setting_fx_bg_classic,colour.array());
  }
}



// cellular
String setting_fx_bg_cellular = "Cellular";
public void setting_fx_bg_cellular(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Josh P";
  String pack = "Base 2016-2019";
  String [] slider = {"hue","saturation","brightness","refresh","quality","quantity","speed X","speed Y"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_cellular,FX_BG_CELLULAR,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}

public void update_fx_bg_cellular(ArrayList<FX> fx_list, boolean move_is, vec4 colour, float quality, float num, vec2 speed) {
  if(move_is) {
    fx_set_colour(fx_list,setting_fx_bg_cellular,colour.array());
    int final_num = (int)map(num*num*num,0,1,0,20);
    fx_set_num(fx_list,setting_fx_bg_cellular,final_num);
    float sx = map(speed.x*speed.x,0,1,0,.2f);
    float sy = map(speed.y*speed.y,0,1,0,.2f);
    fx_set_speed(fx_list,setting_fx_bg_cellular,sx,sy);
    quality = map(quality,0,1,0,.2f);
    fx_set_quality(fx_list,setting_fx_bg_cellular,quality);
  }
}


// heart
String setting_fx_bg_heart = "Heart";
public void setting_fx_bg_heart(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Josh P";
  String pack = "Base 2016-2019";
  String [] slider = {"hue","saturation","brightness","refresh","quality","quantity","angle","strength","speed X"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_heart,FX_BG_HEART,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}

public void update_fx_bg_heart(ArrayList<FX> fx_list, boolean move_is, vec3 colour, float quality, float num, float angle, float strength, float speed) {
  if(move_is) {
    fx_set_colour(fx_list,setting_fx_bg_heart,colour.array());
    fx_set_quality(fx_list,setting_fx_bg_heart,quality);
    int final_num = ceil(map(num,0,1,1,10));
    fx_set_num(fx_list,setting_fx_bg_heart,final_num);

    angle = map(angle,0,1,0,TAU);
    fx_set_angle(fx_list,setting_fx_bg_heart,angle);
    strength = map(strength,0,1,1,5);
    fx_set_strength(fx_list,setting_fx_bg_heart,strength);

    fx_set_speed(fx_list,setting_fx_bg_heart,speed*speed*speed);
  }
}


// necklace
String setting_fx_bg_necklace = "Necklace";
public void setting_fx_bg_necklace(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Sandbox";
  String pack = "Base 2016-2019";
  String [] slider = {"refresh","quantity","size","speed X","position X","position Y"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_necklace,FX_BG_NECKLACE,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}

public void update_fx_bg_necklace(ArrayList<FX> fx_list, boolean move_is, vec2 pos, float alpha, float num, float size, float speed) {
  if(move_is) {
    fx_set_alpha(fx_list,setting_fx_bg_necklace,alpha);
    float px = map(pos.x,0,1,0,2);
    float py = map(pos.y,0,1,-1,1);
    fx_set_pos(fx_list,setting_fx_bg_necklace,px,py);
    int final_num = ceil(map(num*num,0,1,10,100));
    fx_set_num(fx_list,setting_fx_bg_necklace,final_num);
    fx_set_speed(fx_list,setting_fx_bg_necklace,speed*speed);
    fx_set_size(fx_list,setting_fx_bg_necklace,size);
  }
}





// neon
String setting_fx_bg_neon = "Neon";
public void setting_fx_bg_neon(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Sandbox";
  String pack = "Base 2016-2019";
  String [] slider = {"position X","position Y","speed X"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_neon,FX_BG_NEON,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}


public void update_fx_bg_neon(ArrayList<FX> fx_list, boolean move_is, vec2 pos, float speed) {
  if(move_is) {
    fx_set_pos(fx_list,setting_fx_bg_neon,pos.array());
    fx_set_speed(fx_list,setting_fx_bg_neon,speed);
  }
}







// psy
String setting_fx_bg_psy = "Psy";
public void setting_fx_bg_psy(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Sandbox";
  String pack = "Base 2016-2019";
  String [] slider = {"quantity","speed X"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_psy,FX_BG_PSY,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}


public void update_fx_bg_psy(ArrayList<FX> fx_list, boolean move_is, float num, float speed) {
  if(move_is) {
    int final_num = num < .5f ? 2 : 3;
    fx_set_num(fx_list,setting_fx_bg_psy,final_num);
    float final_speed = map(speed*speed*speed,0,1,.005f,.3f);
    fx_set_speed(fx_list,setting_fx_bg_psy,final_speed);
  }
}

















// snow
String setting_fx_bg_snow = "Snow";
public void setting_fx_bg_snow(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Sandbox";
  String pack = "Base 2016-2019";
  String [] slider = {"hue","saturation","brightness","speed X","quality"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_snow,FX_BG_SNOW,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}

public void update_fx_bg_snow(ArrayList<FX> fx_list, boolean move_is, vec2 pos, vec3 colour, float speed, float quality) {
  if(move_is) {
    fx_set_pos(fx_list,setting_fx_bg_snow,pos.array());
    fx_set_colour(fx_list,setting_fx_bg_snow,colour.array());
    float final_speed = map(speed*speed*speed,0,1,.01f,.7f);
    fx_set_speed(fx_list,setting_fx_bg_snow,final_speed);
    quality = map(quality*quality,0,1,0,.85f);
    fx_set_quality(fx_list,setting_fx_bg_snow,quality);
  }
}








// voronoi hex
String setting_fx_bg_voronoi_hex = "Voronoi Hex";
public void setting_fx_bg_voronoi_hex(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "MOJO from ISF";
  String pack = "Base 2019-2019";
  String [] slider = {"hue","saturation","brightness","size","speed X","speed Y","threshold","strength"};
  int id = fx_background_num;
  init_fx(fx_list,setting_fx_bg_voronoi_hex,FX_BG_VORONOI_HEX,id,author,pack,version,revision,slider,null);
  fx_background_num++;
}



public void update_fx_bg_voronoi_hex(ArrayList<FX> fx_list, boolean move_is, vec3 colour, float size, vec2 speed, float strength, float threshold) {
  if(move_is) {
    fx_set_colour(fx_list,setting_fx_bg_voronoi_hex,colour.array());
    size = map(size*size,0,1,1,11.2f);
    fx_set_size(fx_list,setting_fx_bg_voronoi_hex,size);
    speed.pow(2);
    fx_set_speed(fx_list,setting_fx_bg_voronoi_hex,speed.array());
    fx_set_strength(fx_list,setting_fx_bg_voronoi_hex,map(strength,0,1,-0.05f,0.05f));
    fx_set_threshold(fx_list,setting_fx_bg_voronoi_hex,map(threshold,0,1,.01f,.4f));
    fx_set_mode(fx_list,setting_fx_bg_voronoi_hex,0);
  }
}


























// info to gui
public void write_fx_backgound_index(ArrayList<FX> fx_list) {
  Table index_fx_bg = new Table();
  index_fx_bg.addColumn("Name");
  index_fx_bg.addColumn("Author");
  index_fx_bg.addColumn("Version");
  index_fx_bg.addColumn("Pack");
  index_fx_bg.addColumn("Slider");
  

  int num = fx_background_num; // +1 cause of the special force field fx
  TableRow [] info_fx_bg = new TableRow [num];

  for(int i = 0 ; i < info_fx_bg.length ; i++) {
    info_fx_bg[i] = index_fx_bg.addRow();
  }


  for(int i = 0 ; i < fx_background_num ; i++) {
    FX fx = get_fx(fx_list,i); 
    info_fx_bg[i].setString("Name",fx.get_name());
    info_fx_bg[i].setString("Author",fx.get_author());
    info_fx_bg[i].setString("Version",fx.get_version());
    info_fx_bg[i].setString("Pack",fx.get_pack());
    String s = "";
    int max =  fx.get_name_slider().length;
    for(int k = 0 ; k < max ; k++) {
      if(k < max - 1) {
        s += (fx.get_name_slider()[k]+"/");
      } else {
        s += (fx.get_name_slider()[k]);
      }
    }
    info_fx_bg[i].setString("Slider",s);
  }

  saveTable(index_fx_bg, preference_path+"index_fx_bg.csv"); 
}







































/** 
* BACKGROUND
* 2013-2019
* v 1.0.1
*/
vec4 colorBackground, colorBackgroundRef, colorBackgroundPrescene;
public void init_background() {
  colorBackgroundRef = vec4();
  colorBackground = vec4();
  colorBackgroundPrescene = vec4(0,0,20,g.colorModeA) ;
}

PImage background_romanesco;
int mode_bg_romanesco;
public void set_background(PImage img, int mode) {
  background_romanesco = img;
  mode_bg_romanesco = mode;
}

public void background_romanesco() {
  // in preview mode the background is always on, to remove the trace effect
  if(!FULL_RENDERING) { 
    background_button_is(false) ;
    colorBackground = colorBackgroundPrescene.copy() ;
    background_rope(0,0,get_layer().colorModeZ *.2f,get_layer().colorModeA) ;
  } else if(FULL_RENDERING) {
    if(background_button_is()) {

      if(background_romanesco == null) {
        // println("ALIEN is in the SPACE",background_romanesco,frameCount);
        if(which_shader == 0) {
          // check if the color model is changed after the shader used
          if(get_layer().colorMode != 3 || get_layer().colorModeX != 360 || get_layer().colorModeY != 100 || get_layer().colorModeZ !=100 || get_layer().colorModeA !=100) {
            colorMode(HSB,360,100,100,100);
          }
          // choice the rendering color palette for the classic background
          if(FULL_RENDERING) {
            // check if the slider background are move, if it's true update the color background
            if(!compare(colorBackgroundRef,update_background())) {
              colorBackground.set(update_background()) ;
            } else {
              colorBackgroundRef.set(update_background()) ;
            }
            background_rope(colorBackground) ;
          }
          background_rope(colorBackground) ;
        } else {
          fx_background(which_shader); 
        }
      } else {
        if(background_romanesco.width > 0 && background_romanesco.height > 0) {
          if(background_romanesco.pixels == null) {
            background_romanesco.loadPixels();
          }
          background(background_romanesco,mode_bg_romanesco);
        }
        
      }
    }
    set_background(null,0);
  }
}

// ANNEXE VOID BACKGROUND
public vec4 update_background() {
  //to smooth the curve of transparency background
  // HSB
  float hue_bg = map(value_slider_background[0],0,MAX_VALUE_SLIDER,0,HSBmode.hue());
  float saturation_bg = map(value_slider_background[1],0,MAX_VALUE_SLIDER,0,HSBmode.sat());
  float brigthness_bg = map(value_slider_background[2],0,MAX_VALUE_SLIDER,0,HSBmode.bri());
  // ALPHA
  float factorSmooth = 2.5f;
  float nx = norm(value_slider_background[3],.0f,MAX_VALUE_SLIDER);
  float alpha = pow (nx, factorSmooth);
  alpha = map(alpha,0,1,.8f,HSBmode.alp());
  return vec4(hue_bg,saturation_bg,brigthness_bg,alpha) ;
}




/**
FILTER
* 2018-2019
* v 0.1.5
* here is calling classic FX ROPE + FX FORCE FIELD
*/
ArrayList<FX> fx_manager;


float sl_fx_color_x;
float sl_fx_color_y;
float sl_fx_color_z;
float sl_fx_pos_x;
float sl_fx_pos_y;
float sl_fx_size_x;
float sl_fx_size_y;
float sl_fx_strength_x;
float sl_fx_strength_y;
float sl_fx_quantity;
float sl_fx_quality;
float sl_fx_speed;
float sl_fx_angle;
float sl_fx_threshold;
public void update_fx_post_slider() {
  sl_fx_color_x = map(value_slider_fx[0],0,MAX_VALUE_SLIDER,0,1);
  sl_fx_color_y = map(value_slider_fx[1],0,MAX_VALUE_SLIDER,0,1);
  sl_fx_color_z = map(value_slider_fx[2],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_pos_x = map(value_slider_fx[3],0,MAX_VALUE_SLIDER,0,1);
  sl_fx_pos_y = map(value_slider_fx[4],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_size_x = map(value_slider_fx[5],0,MAX_VALUE_SLIDER,0,1);
  sl_fx_size_y = map(value_slider_fx[6],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_strength_x = map(value_slider_fx[7],0,MAX_VALUE_SLIDER,0,1);
  sl_fx_strength_y = map(value_slider_fx[8],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_quantity = map(value_slider_fx[9],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_quality = map(value_slider_fx[10],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_speed = map(value_slider_fx[11],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_angle = map(value_slider_fx[12],0,MAX_VALUE_SLIDER,0,1);

  sl_fx_threshold = map(value_slider_fx[13],0,MAX_VALUE_SLIDER,0,1);
}









public void init_fx_post() {
  if(FULL_RENDERING) {
    fx_manager = new ArrayList<FX>();

    // FORCE FIELD FX
    type_field = r.FLUID;
    pattern_field = r.BLANK;
    set_type_force_field(type_field);
    init_force_field();
    // set_different_force_field();
    println("init filter FORCE FIELD");
    // warp force
    init_warp_force();
    println("init filter FORCE WARP FX");


    // FX CLASSIC
    // set path fx shader;
    // set_fx_post_path(sketchpath()+"data/shader/fx_post/");
    // set_fx_post_path(preference_path+"shader/fx_post/");
    get_fx_post_path();
    if(fx_post_path_exist()) {
      println("FX CLASSIC shader loaded");
    } else {
      printErr("fx path filter",get_fx_post_path(),"don't exists");
    }

    setting_fx_classic(fx_manager);

    // CLASSIC FX + FORCE FIELD FX
    write_fx_post_index();
  }
}


boolean move_filter_fx;
boolean extra_filter_fx;
int num_special_fx;
int ref_num_active_fx;
ArrayList<Integer>active_fx;
int fx_classic_num;
public void fx_post() {
  move_filter_fx = fx_button_is(1);
  extra_filter_fx = fx_button_is(2);

  // add fx
  if(extra_filter_fx) {
    if(active_fx == null) {
      active_fx = new ArrayList<Integer>();
    }

    boolean add_fx = true;
    if(active_fx.size() > 0) {  
      for(Integer i : active_fx) {
        if(i == which_fx) {
          add_fx = false;
          break;
        }
      }
    }
    if(add_fx) {
      active_fx.add(which_fx);
    }
  }

  if(active_fx != null) {
    if(reset_fx_button_alert_is()) {
      active_fx.clear();
    }
  }
  if(active_fx != null && ref_num_active_fx != active_fx.size()) {
    save_dial_scene(preference_path);
    ref_num_active_fx = active_fx.size();
  }
  

  if(FULL_RENDERING && fx_button_is(0)) {
    update_fx_post_slider();
    update_fx_post(fx_manager);
    if(extra_filter_fx && active_fx != null && active_fx.size() > 0) {
      for(int i : active_fx) {
        draw_fx(i);
      }
    } else {
      draw_fx(which_fx);
    }
  } 
}



int which_current_movie;
boolean draw_fx_before_rendering_is;
public boolean draw_fx_before_rendering_is() {
  return draw_fx_before_rendering_is;
}

public void draw_fx(int which) {
  draw_fx_before_rendering_is = false;
  // select fx 
  num_special_fx = 1 ;
  if(which < num_special_fx) {
    apply_force_field();
    warp_force(sl_fx_strength_x,sl_fx_speed,vec3(sl_fx_color_x,sl_fx_color_y,sl_fx_color_z));
   } else {
    int target = which- num_special_fx; // min 1 cause the first one is a special one;
    for(int i = 0 ; i < fx_classic_num ; i++) {
      if(target == i) {
        if(get_fx(fx_manager,target).get_type() == FX_WARP_TEX_A) {
          if(fx_pattern == null) {
            draw_fx_pattern(16,16,2,RGB,true);
          } else {
            draw_fx_pattern(16,16,2,RGB,reset_fx_button_alert_is());
          }
          select_fx_post(g,get_fx_pattern(0),get_fx_pattern(1),get_fx(fx_manager,target));
        } else if (get_fx(fx_manager,target).get_type() == FX_DATAMOSH) {
          draw_fx_before_rendering_is = true;
          if(movie[which_current_movie] == null) {
            for(int which_movie = 0 ; which_movie < rom_manager.size() ; which_movie++) {
              if(movie[which_movie] != null) {
                which_current_movie = which_movie;
                break;
              }
            }         
          } else {
            movie[which_current_movie].loop();
            select_fx_post(movie[which_current_movie],null,null,get_fx(fx_manager,target));
          }
        } else {
          select_fx_post(g,null,null,get_fx(fx_manager,target));
        }      
      }
    }
  }
}





/**
UTIL FILTER
*/
PImage [] fx_pattern;
public PImage get_fx_pattern(int which) {
  if(fx_pattern != null && which < fx_pattern.length) {
    return fx_pattern[which];
  } else {
    return null;
  }
}


public void draw_fx_pattern(int w, int h, int num, int mode, boolean event) {
  if(fx_pattern == null || num < fx_pattern.length) {
    fx_pattern = new PImage[num];
  }
  for(int i = 0; i < fx_pattern.length ; i++) {
    if(event || fx_pattern[i] == null) {
      if(mode == RGB) {
        fx_pattern[i] = generate_fx_pattern(3,w,h); // warp RGB
      } else if(mode == GRAY) {
        fx_pattern[i] = generate_fx_pattern(0,w,h); // warp GRAY
      } 
    }
  }  
}


public PGraphics generate_fx_pattern(int mode, int sx, int sw) {
  vec3 inc = vec3(random(1)*random(1),random(1)*random(1),random(1)*random(1));
  if(mode == 0) {
    // black and white
    return pattern_noise(sx,sw,inc.x);
  } else if(mode == 3) {
    // rgb
    return pattern_noise(sx,sw,inc.array());
  } else return null;
}


public void write_fx_post_index() {
  Table index_fx = new Table();
  index_fx.addColumn("Name");
  index_fx.addColumn("Author");
  index_fx.addColumn("Version");
  index_fx.addColumn("Pack");
  index_fx.addColumn("Slider");
  

  int num = fx_classic_num+1; // +1 cause of the special force field fx
  TableRow [] info_fx = new TableRow [num];

  for(int i = 0 ; i < info_fx.length ; i++) {
    info_fx[i] = index_fx.addRow();
  }

  info_fx[0].setString("Name","Force");
  info_fx[0].setString("Author","Stan le Punk");
  info_fx[0].setString("Version","0.1.0");
  info_fx[0].setString("Pack","Base 2014");


  for(int i = 0 ; i < fx_classic_num ; i++) {
    FX fx = get_fx(fx_manager,i); 
    int target = i+1;
    info_fx[target].setString("Name",fx.get_name());
    info_fx[target].setString("Author",fx.get_author());
    info_fx[target].setString("Version",fx.get_version());
    info_fx[target].setString("Pack",fx.get_pack());
    String s = "";
    int max =  fx.get_name_slider().length;
    for(int k = 0 ; k < max ; k++) {
      if(k < max - 1) {
        s += (fx.get_name_slider()[k]+"/");
      } else {
        s += (fx.get_name_slider()[k]);
      }
    }
    info_fx[target].setString("Slider",s);
  }
  saveTable(index_fx, preference_path+"index_fx.csv"); 

}













































/**
FX ROMANESCO
* classic FX class
* v 0.0.1
* 2019-2019
*/

public void setting_fx_classic(ArrayList<FX> fx_list) {
  setting_fx_blur_circular(fx_list);
  setting_fx_blur_gaussian(fx_list);
  setting_fx_blur_radial(fx_list);

  setting_fx_datamosh(fx_list);

  setting_fx_dither_bayer(fx_list);

  setting_fx_haltone_dot(fx_list);
  setting_fx_haltone_line(fx_list);

  setting_fx_pixel(fx_list);

  setting_fx_split_rgb(fx_list);

  setting_fx_threshold(fx_list);

  setting_fx_warp_proc(fx_list);
  setting_fx_warp_tex(fx_list);
}



public void update_fx_post(ArrayList<FX> fx_list) {
  update_fx_blur_circular(fx_list,move_filter_fx,sl_fx_quantity,sl_fx_strength_x);
  update_fx_blur_gaussian(fx_list,move_filter_fx,sl_fx_strength_x);
  update_fx_blur_radial(fx_list,move_filter_fx,vec2(sl_fx_pos_x,sl_fx_pos_y),sl_fx_strength_x);

  update_fx_datamosh(fx_list,move_filter_fx,sl_fx_strength_x,sl_fx_threshold,vec3(sl_fx_color_x,sl_fx_color_y,sl_fx_color_z));
  
  int mode_dither = 1 ; // rgb
  update_fx_dither_bayer(fx_list,move_filter_fx,vec3(sl_fx_color_x,sl_fx_color_y,sl_fx_color_z),mode_dither);
  
  update_fx_haltone_dot(fx_list,move_filter_fx,vec2(sl_fx_pos_x,sl_fx_pos_y),sl_fx_quantity,sl_fx_angle);
  update_fx_haltone_line(fx_list,move_filter_fx,vec2(sl_fx_pos_x,sl_fx_pos_y),sl_fx_quantity,sl_fx_angle);

  update_fx_pixel(fx_list,move_filter_fx,sl_fx_quantity,vec2(sl_fx_size_x,sl_fx_size_y),vec3(sl_fx_color_x,sl_fx_color_y,sl_fx_color_z));

  update_fx_split_rgb(fx_list,move_filter_fx,vec2(sl_fx_strength_x,sl_fx_strength_y),sl_fx_speed);
  
  int mode_threshold = 1; // rgb
  update_fx_threshold(fx_list,move_filter_fx,vec3(sl_fx_color_x,sl_fx_color_y,sl_fx_color_z),mode_threshold);
  
  update_fx_warp_proc(fx_list,move_filter_fx,sl_fx_strength_x,sl_fx_speed);
  update_fx_warp_tex(fx_list,move_filter_fx,sl_fx_strength_x);

}


/**
* blur circular
*/
String set_blur_circular = "blur circular";
public void setting_fx_blur_circular(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"quantity","strength X"};
  int id = fx_classic_num;
  init_fx(fx_list,set_blur_circular,FX_BLUR_CIRCULAR,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_blur_circular(ArrayList<FX> fx_list, boolean move_is, float num, float str_x) {
  if(move_is) {
    int iteration = (int)map(num,0,1,2,64);
    fx_set_num(fx_list,set_blur_circular,iteration);

    int max_blur = width;
    float str = (str_x*str_x)*max_blur;
    fx_set_strength(fx_list,set_blur_circular,str);
  }
}



/**
* gaussian blur
*/
String set_blur_gaussian = "blur gaussian";
public void setting_fx_blur_gaussian(ArrayList<FX> fx_list) {
  String version = "0.0.3";
  int revision = 3;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"strength X"};
  int id = fx_classic_num;
  init_fx(fx_list,set_blur_gaussian,FX_BLUR_GAUSSIAN,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_blur_gaussian(ArrayList<FX> fx_list, boolean move_is, float strength_x) {
  if(move_is) {
    int max_blur = height/10;
    float str = strength_x*max_blur;
    fx_set_strength(fx_list,set_blur_gaussian,str);
  }
}




/**
* blur radial
*/
String set_blur_radial = "blur radial";
public void setting_fx_blur_radial(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"position X","position Y","strength X"};
  int id = fx_classic_num;
  init_fx(fx_list,set_blur_radial,FX_BLUR_RADIAL,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_blur_radial(ArrayList<FX> fx_list, boolean move_is, vec2 pos,float strength) {
  if(move_is) {
    fx_set_pos(fx_list,set_blur_radial,pos.x,pos.y);
        
    float str = (strength*strength)*(height/20);
    fx_set_strength(fx_list,set_blur_radial,str);
  }
}




/**
* datamosh
*/
String set_datamosh = "datamosh";
public void setting_fx_datamosh(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Alexandre Rivaux refactoring by Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"red","green","blue","strength X","threshold"};
  int id = fx_classic_num;
  init_fx(fx_list,set_datamosh,FX_DATAMOSH,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_datamosh(ArrayList<FX> fx_list, boolean move_is, float strength, float threshold, vec3 colour) {
  if(move_is) {
    fx_set_strength(fx_list,set_datamosh, map(strength,0,1,-100,100));
    fx_set_threshold(fx_list,set_datamosh, (1.0f -threshold) *0.1f);
    vec2 offset_red = vec2(-colour.red(), colour.red()).mult(.1f);
    vec2 offset_green = vec2(-colour.gre(), colour.gre()).mult(.1f);
    vec2 offset_blue = vec2(-colour.blu(), colour.blu()).mult(.1f);
    fx_set_pair(fx_list,set_datamosh,0, offset_red.array());
    fx_set_pair(fx_list,set_datamosh,1, offset_green.array());
    fx_set_pair(fx_list,set_datamosh,2, offset_blue.array());
  }
}





/**
* dither bayer
*/
String set_dither_bayer = "dither bayer";
public void setting_fx_dither_bayer(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Mattias / Shader Toy";
  String pack = "Base 2019";
  String [] slider = {"red","green","blue"};
  int id = fx_classic_num;
  init_fx(fx_list,set_dither_bayer,FX_DITHER_BAYER_8,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_dither_bayer(ArrayList<FX> fx_list, boolean move_is, vec3 colour, int mode) {
  if(move_is) {
    fx_set_mode(fx_list,set_dither_bayer,mode);
    fx_set_level_source(fx_list,set_dither_bayer,colour.array());
  }
}









/**
* halftone line
*/
String set_halftone_dot = "halftone dot";
public void setting_fx_haltone_dot(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"position X","position Y","angle","quantity"};
  int id = fx_classic_num;
  init_fx(fx_list,set_halftone_dot,FX_HALFTONE_DOT,id,author,pack,version,revision,slider,null);
  fx_classic_num++; 
}

public void update_fx_haltone_dot(ArrayList<FX> fx_list, boolean move_is, vec2 pos, float quantity, float angle) {
  if(move_is) {
    float pix_size = map(quantity,0,1,height/4,2); 
    fx_set_size(fx_list,set_halftone_dot,pix_size);  

    angle = map(angle,0,1,-TAU,TAU);
    fx_set_angle(fx_list,set_halftone_dot,angle);

    fx_set_threshold(fx_list,set_halftone_dot,1);

    fx_set_pos(fx_list,set_halftone_dot,pos.array());
  }
}
















/**
* halftone line
*/
String set_halftone_line = "halftone line";
public void setting_fx_haltone_line(ArrayList<FX> fx_list) {
  String version = "0.0.2";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"position X","position Y","quantity","angle"};
  int id = fx_classic_num;
  init_fx(fx_list,set_halftone_line,FX_HALFTONE_LINE,id,author,pack,version,revision,slider,null);
  fx_classic_num++; 
}

public void update_fx_haltone_line(ArrayList<FX> fx_list, boolean move_is, vec2 pos, float num, float angle) {
  if(move_is) {
    fx_set_mode(fx_list,set_halftone_line,0); 

    int num_line = (int)map(num,0,1,20,100); 
    fx_set_num(fx_list,set_halftone_line,num_line);  

    // pass nothing with this two parameter
    // fx_set_quality(set_halftone_line,quality);
    // fx_set_threshold(set_halftone_line,threshold);

    angle = map(angle,0,1,-TAU,TAU);
    fx_set_angle(fx_list,set_halftone_line,angle);

    fx_set_pos(fx_list,set_halftone_line,pos.array());
  }
}






/**
* pixel
* v 0.0.2
*/
String set_pixel = "pixel";
// boolean effect_pixel_is;
public void setting_fx_pixel(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"quantity","size X","size Y","red","green","blue"};
  int id = fx_classic_num;
  init_fx(fx_list,set_pixel,FX_PIXEL,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_pixel(ArrayList<FX> fx_list, boolean move_is, float num, vec2 size, vec3 hsb) {

  if(move_is) {
    float sx = map(size.x *size.x *size.x,0,1,1,width);
    float sy = map(size.y *size.y *size.y,0,1,1,height);
    fx_set_size(fx_list,set_pixel,sx,sy);

    int palette_num = (int)map(num,0,1,2,16);
    fx_set_num(fx_list,set_pixel,palette_num);
    
    float h = hsb.x; // from 0 to 1 where
    float s = hsb.y; // from 0 to 1 where
    float b = hsb.z; // from 0 to 1 where
    if(s < 0) s = 0; else if (s > 1) s = 1;
    if(b < 0) b = 0; else if (b > 1) s = 1;
    fx_set_level_source(fx_list,set_pixel,h,s,b); // not used ????

    fx_set_event(fx_list,set_pixel,0,false);
  }
}




/**
* split
* v 0.0.2
*/
String set_split_rgb = "split rgb";
public void setting_fx_split_rgb(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"strength X","strength Y","speed"};
  int id = fx_classic_num;
  init_fx(fx_list,set_split_rgb,FX_SPLIT_RGB,id,author,pack,version,revision,slider,null);
  fx_classic_num++; 
}


public void update_fx_split_rgb(ArrayList<FX> fx_list, boolean move_is, vec2 str, float speed) {
  if(move_is) {
    vec2 strength = map(str.pow(2),0,1,0,6);

    vec2 offset_red = vec2().cos_wave(frameCount,speed*.2f,speed *.5f);
    offset_red.x = map(offset_red.x,-1,1,-strength.x,strength.x);
    offset_red.y = map(offset_red.y,-1,1,-strength.y,strength.y);

    vec2 offset_green = vec2().sin_wave(frameCount,speed *.2f,speed *.1f);
    offset_green.x = map(offset_green.x,-1,1,-strength.x,strength.x);
    offset_green.y = map(offset_green.y,-1,1,-strength.y,strength.y);

    vec2 offset_blue = vec2().cos_wave(frameCount,speed*.1f,speed *.2f);
    offset_blue.x = map(offset_blue.x,-1,1,-strength.x,strength.x);
    offset_blue.y = map(offset_blue.y,-1,1,-strength.y,strength.y);

    fx_set_pair(fx_list,set_split_rgb,0,offset_red.array());
    fx_set_pair(fx_list,set_split_rgb,1,offset_green.array());
    fx_set_pair(fx_list,set_split_rgb,2,offset_blue.array());
  }
}




/**
* dither bayer
*/
String set_threshold = "threshold";
public void setting_fx_threshold(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"red","green","blue"};
  int id = fx_classic_num;
  init_fx(fx_list,set_threshold,FX_THRESHOLD,id,author,pack,version,revision,slider,null);
  fx_classic_num++;
}

public void update_fx_threshold(ArrayList<FX> fx_list, boolean move_is, vec3 colour, int mode) {
  if(move_is) {
    fx_set_mode(fx_list,set_threshold,mode);
    fx_set_level_source(fx_list,set_threshold,colour.array());
  }
}




/**
* warp proc
* v 0.0.1
*/
String set_warp_proc = "warp proc";
public void setting_fx_warp_proc(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"strength X","speed"};
  int id = fx_classic_num;
  init_fx(fx_list,set_warp_proc,FX_WARP_PROC,id,author,pack,version,revision,slider,null);
  fx_classic_num++; 
}


public void update_fx_warp_proc(ArrayList<FX> fx_list, boolean move_is, float str, float speed) {
  if(move_is) {
    float max = map(str,0,1,1,height/20);
    float strength = sin(frameCount *(speed*speed)) *max;
    fx_set_strength(fx_list,set_warp_proc,strength);
  }
}


/**
* warp tex
* v 0.0.1
*/
String set_warp_tex = "warp tex";
public void setting_fx_warp_tex(ArrayList<FX> fx_list) {
  String version = "0.0.1";
  int revision = 1;
  String author = "Stan le Punk";
  String pack = "Base 2019";
  String [] slider = {"strength X"};
  int id = fx_classic_num;
  init_fx(fx_list,set_warp_tex,FX_WARP_TEX_A,id,author,pack,version,revision,slider,null);
  fx_classic_num++; 
}


public void update_fx_warp_tex(ArrayList<FX> fx_list, boolean move_is, float str) {
  if(move_is) {
    fx_set_strength(fx_list,set_warp_tex,str);
  }
}





























/**
* FORCE WARP
* X SPECIAL
* this FX is linked with item and call a huge method and 
* class Force Field and class Force
* 2018-2019
* v 0.0.5
*/
Warp_Force warp_force_romanesco;
public void init_warp_force() {
  if(warp_force_romanesco == null) {
    warp_force_romanesco = new Warp_Force();
    warp_force_romanesco.add(g);
  }
}


public void warp_force(float strength, float speed, vec3 colour) {
  strength *= strength;
  strength = map(strength,0,1,0,10);
  
  // cycling
  float cycling = 1;
  float ratio = map(speed,0,1,0,.8f);
  if(ratio > 0) {
    ratio = (ratio*ratio*ratio);
    cycling = abs(sin(frameCount *ratio));
  }

  vec4 refresh_warp_force = vec4(colour.x,colour.y,colour.z,1);
  if(ratio > 0) {
    refresh_warp_force.mult(cycling);
  }
  warp_force_romanesco.refresh(refresh_warp_force);
  warp_force_romanesco.shader_init();
  warp_force_romanesco.shader_filter(extra_filter_fx);
  warp_force_romanesco.shader_mode(0);
  // here Force_field is pass
  warp_force_romanesco.show(force_field_romanesco,strength);

  if(warp_force_reset) {
    warp_force_romanesco.reset();
    warp_force_reset = false;
  }

}




boolean warp_force_reset;
public void warp_force_keyPressed(char c_1) {
  if(key == c_1) {
    println("Reset Warp Force",frameCount);
    warp_force_reset = true;
  }
}
























































/**
FORCE
2018-2018
v 0.0.7
*/
// FORCE
int ref_cell_size =20;
int type_field;
int pattern_field;
Force_field force_field_romanesco;
public void init_force_field() {
  int num_spot_minimum = 2;
  init_force_field(num_spot_minimum);
}
public void init_force_field(int num_spot) {
  int range_detection = 5;
  int type = get_type_force_field();
  int pattern = get_pattern_force_field();
  if(num_spot < 2) num_spot = 2;
  if(type == r.FLUID) {
    force_field_romanesco = new Force_field(ref_cell_size,r.FLUID,r.BLANK);
    force_field_romanesco.add_spot(num_spot);
  } else if(type == r.MAGNETIC) {
    force_field_romanesco = new Force_field(ref_cell_size,r.MAGNETIC,r.BLANK);
    force_field_romanesco.add_spot(num_spot);
    force_field_romanesco.set_spot_detection(range_detection);
  } else if(type == r.GRAVITY){
    // println("init_force_field();",ref_cell_size,r.GRAVITY,r.BLANK);
    force_field_romanesco = new Force_field(ref_cell_size,r.GRAVITY,r.BLANK);
    force_field_romanesco.add_spot(num_spot);
    force_field_romanesco.set_spot_detection(range_detection);
  }

  

  if(pattern == r.PERLIN) {
    force_field_romanesco = new Force_field(ref_cell_size,r.STATIC,r.PERLIN);
  } else if(pattern == r.CHAOS) {
    force_field_romanesco = new Force_field(ref_cell_size,r.STATIC,r.CHAOS);
  } else if(pattern == r.EQUATION) {
    force_field_romanesco = new Force_field(ref_cell_size,r.STATIC,r.EQUATION);
  }

  init_dynamic_force_field();
}




// USE only at the itit setup :(
public void init_dynamic_force_field() {
  for(int i = 0 ; i < force_field_romanesco.get_spot_num() ; i++) {
    float x = random(width);
    float y = random(height);
    force_field_romanesco.set_spot_pos(x,y,i);
  }

  // fluid setting
  set_force_fluid_frequence(2/frameRate);
  set_force_fluid_viscosity(.001f);
  set_force_fluid_diffusion(1.f);
  // magnetic setting
  set_force_magnetic_tesla(20,-20);
  set_force_magnetic_diam(50);
  // gravity setting
  set_force_gravity_mass(25);

}





public void apply_force_field() {
  if(FULL_RENDERING && (fx_button_is(0) || update_force_field_is())) {
    update_force_field();
  }
  update_force_field_is(false);
}






// type
int type_force_field;
public int get_type_force_field() {
  return type_force_field;
}



// set pattern
int pattern_force_field;
public int get_pattern_force_field() {
  return pattern_force_field;
}




public int get_cell_force_field() {
  return ref_cell_size;
}




boolean puppet_master_force_field_is = false ;
public boolean puppet_master_is() {
  return puppet_master_force_field_is;
}

public void puppet_master(boolean is) {
  puppet_master_force_field_is = is;
}




public void update_force_field() {
  if(force_field_romanesco.get_type() == r.MAGNETIC || force_field_romanesco.get_type() == r.GRAVITY) {
    force_field_romanesco.refresh();
  }
  force_field_romanesco.update();
}











// SET
public void set_type_force_field(int type) {
  type_force_field = type;
}


public void set_cell_force_field(int size) {
  ref_cell_size = size;
}


public void set_pattern_force_field(int pattern) {
  pattern_force_field = pattern;
}
// detection
public void set_spot_detection_force_field(int detection) {
  force_field_romanesco.set_spot_detection(detection);
}

// SET DIFFERENT FORCE FIELD





// set force field fluid
public void set_force_fluid_frequence(float frequence) {
  force_field_romanesco.set_frequence(frequence);
}

public void set_force_fluid_viscosity(float viscosity) {
  force_field_romanesco.set_viscosity(viscosity); // back to normal
}

public void set_force_fluid_diffusion(float diffusion) {
  force_field_romanesco.set_diffusion(diffusion);
}

// set force field magnetic
public void set_force_magnetic_tesla(int... tesla) {
  if(tesla.length <= force_field_romanesco.get_spot_num()) {
    int index =0;
    for(int i = 0 ; i < force_field_romanesco.get_spot_num() ;i++) {
      force_field_romanesco.set_spot_tesla(tesla[index],i);
      index++;
      if(index >= tesla.length) index = 0;
    }   
  } 
}

public void set_force_magnetic_diam(int... diam) {
  if(diam.length <= force_field_romanesco.get_spot_num()) {
    int index =0;
    for(int i = 0 ; i < force_field_romanesco.get_spot_num() ;i++) {
      force_field_romanesco.set_spot_diam(vec2(diam[index]),i);
      index++;
      if(index >= diam.length) index = 0;
    }   
  }
}


public void set_force_gravity_mass(int... mass) {
  if(mass.length <= force_field_romanesco.get_spot_num()) {
    int index =0;
    for(int i = 0 ; i < force_field_romanesco.get_spot_num() ;i++) {
      force_field_romanesco.set_spot_mass(mass[index],i);
      index++;
      if(index >= mass.length) index = 0;
    }   
  }
}












/**
FORCE FIELD MANAGER
*/
public Force_field get_force_field() {
  return force_field_romanesco;
}

boolean update_force_romanesco_is;
public void update_force_field_is(boolean is) {
  update_force_romanesco_is = true;
}

public boolean update_force_field_is() {
  return update_force_romanesco_is;
}









/**
SPOT ROMANESCO MANAGER
*/
public int get_spot_num() {
  return force_field_romanesco.get_spot_num();
}

public void add_spot(int num) {
  for(int i = 0 ; i < num ; i++) {
    force_field_romanesco.add_spot();
  }
}

public void clear_spot() {
  force_field_romanesco.clear_spot();
}


public void set_spot_pos(vec pos, int index) {
  force_field_romanesco.set_spot_pos(pos,index);
}

public void set_spot_pos(float x, float y, int index) {
  force_field_romanesco.set_spot_pos(vec2(x,y),index);  
}


public vec3 [] get_spot_pos() {
  vec3 [] pos = new vec3[force_field_romanesco.get_spot_num()];
  for(int i = 0 ; i < pos.length ; i++) {
    pos[i] = force_field_romanesco.get_spot_pos(i);
  }
  return pos;
}

public float [] get_spot_mass() {
  float [] mass = new float[force_field_romanesco.get_spot_num()];
  for(int i = 0 ; i < mass.length ; i++) {
    mass[i] = force_field_romanesco.get_spot_mass(i);
  }
  return mass;
}


public int [] get_spot_tesla() {
  int [] tesla = new int[force_field_romanesco.get_spot_num()];
  for(int i = 0 ; i < tesla.length ; i++) {
    tesla[i] = force_field_romanesco.get_spot_tesla(i);
  }
  return tesla;
}



public vec3 get_spot_pos(int index) {
  if(index < force_field_romanesco.get_spot_num()) {
    return force_field_romanesco.get_spot_pos(index);
  } else {
    return null;
  }
}






/**
* LIGHT SHADER 
* 1.4.4
* 2015-2019
*/
vec3 var_light_pos  ;
vec3 var_light_dir  ;
/**
In this time we just use the var_light_pos with the pos light, may be in the future it's possible to use the couple
*/
public void light_position_setup() {
  var_light_pos = vec3(width/2, height/2, -width *2) ;
  var_light_dir = vec3(width/2, height/2, width *2) ;
}

public void light_position_draw(vec3 mouse, int wheel) {
  if(key_l_long && !key_shift_long ) {
    var_light_pos.x = mouse.x ;
    var_light_pos.y = mouse.y ;
    var_light_pos.z += wheel ;
  }
  if(key_l_long && key_shift_long) {
    var_light_dir.x = mouse.x ;
    var_light_dir.y = mouse.y ;
    var_light_dir.z += wheel ;
  }
}


// INTERNAL VAR
PShader light_shader;

vec4 [] color_light ;
vec4 [] color_light_ref ;
vec3 [] color_setting ;

vec3 [] dir_light ;
vec3 [] dir_light_ref ;

vec3 [] pos_light ;
vec3 [] pos_light_ref ;

boolean [] on_off_light, on_off_light_action ;


public void shader_setup() {
  String path = ("shader/fx_light/") ;
  light_shader = loadShader(path+"light_pix_frag_romanesco.glsl", path+"light_pix_vert_romanesco.glsl");
  shader(light_shader);
}

public void light_setup() {
  int num_light = 3 ;
  color_light = new vec4[num_light] ;
  color_light_ref = new vec4[num_light] ;
  color_setting = new vec3[num_light] ;
  dir_light = new vec3[num_light] ;
  dir_light_ref = new vec3[num_light] ;
  pos_light = new vec3[num_light] ;
  pos_light_ref = new vec3[num_light] ;
  on_off_light = new boolean[num_light] ;
  on_off_light_action  = new boolean[num_light] ;

  for (int i = 0 ; i < num_light ; i++ ) {
    color_light[i] = vec4(0,100,100,100); 
    color_light_ref[i] = vec4() ;
    dir_light[i] = vec3(0,0,-1); 
    dir_light_ref[i] = dir_light[i].copy();
    pos_light[i] = vec3(width/2,height/2, width *2); 
    pos_light_ref[i] = vec3() ;
  }
}


















//DRAW
public void light_call_shader() {
  shader(light_shader);
}



public void light_update_position_direction() {
  light_value_romanesco(value_slider_light, ambient_button_is(), light_1_button_is(), light_2_button_is(), light_1_action_button_is(), light_2_action_button_is()) ;
  // DIRECTIONAL and  SPOT LIGHT UPDATE
  vec6 range_input_direction_3D = new vec6(0,width,   0,height,  -width, width) ;
  vec6 range_input_position_3D = new vec6(0,width,   0,height,  -width, width) ;
  vec6 range_output_position_3D = new vec6(0,width,   0,height,  -width, width) ;

  // Position and direction of the directional light
  if(light_1_action_button_is()) {
    dir_light[1] = light_direction(var_light_dir, range_input_direction_3D, on_off_light_action[1], dir_light[1],  dir_light_ref[1]).copy() ;
    pos_light[1] = light_position(var_light_pos, range_input_position_3D, range_output_position_3D, on_off_light_action[1], pos_light[1],  pos_light_ref[1]).copy() ;
    color_light[1] = light_color(color_setting [1], MAX_VALUE_SLIDER, HSBmode, color_light[1], color_light_ref[1]).copy() ;
  }
  if(light_2_action_button_is()) {
    dir_light[2] = light_direction(var_light_dir, range_input_direction_3D, on_off_light_action[2], dir_light[2],  dir_light_ref[2]).copy() ;
    vec3 reverse_var_pos = vec3(map(var_light_pos.x,0,width,width,0), map(var_light_pos.y,0,height,height,0),var_light_pos.z) ;
    pos_light[2] = light_position(reverse_var_pos, range_input_position_3D, range_output_position_3D, on_off_light_action[2], pos_light[2],  pos_light_ref[2]).copy() ;
    color_light[2] = light_color(color_setting [2], MAX_VALUE_SLIDER, HSBmode, color_light[2], color_light_ref[2]).copy() ;
  }
}


public void light_display() {
  // ambient light
  if(on_off_light[0]){ 
    vec4 newRef = vec4( map(color_setting [0].hue(),0,MAX_VALUE_SLIDER,0,HSBmode.hue()), 
                        map(color_setting[0].sat(),0,MAX_VALUE_SLIDER,0,HSBmode.sat()), 
                        map(color_setting [0].bri(),0,MAX_VALUE_SLIDER,0,HSBmode.bri()),
                        HSBmode.alp()) ;
    if(!compare(newRef, color_light_ref[0])) color_light[0] = newRef.copy() ;
    color_light_ref[0] = newRef.copy() ;
    ambientLightPix(color_light[0]) ;
  }
  // Spot light one
 
  float angle = TAU /2 ;
  float concentration = 10 ;
  // vec6 range_input_direction_3D = new vec6(0,width,   0,height,  -width, width) ;

  // display light
  if(on_off_light[1]) {
    light_spot_display(color_light[1], pos_light[1], dir_light[1], angle, concentration);
  }
  if(on_off_light[2]) {
    light_spot_display(color_light[2], pos_light[2], dir_light[2], angle, concentration);
  }
}



public void shader_draw() {
  // Color value fro the global vertex
  vec4 rgba = new vec4(1,1,1,.5f) ; // it's OPENGL data between 0 to 1, the range is between -1 to 1, you can go beyond but take care at your life !

  light_shader.set("colorVertex",rgba.red(),rgba.gre(),rgba.blu());
  light_shader.set("alphaVertex",rgba.alp());
  
  // vertex position
  vec3 canvas = vec3(1,1,1) ;
  light_shader.set("canvas",canvas.x,canvas.y,canvas.z);
  light_shader.set("zoom", 1.f);
}



















/**
DIRECTIONAL LIGHT
*/
/**
open a list of lights with a max of height lights
@param vec4 [] colour RGBa float component value 0-255
@param vec4 [] dir xyz float component value -1 to 1
*/

// Display light
/**
Here we use a direction of light
*/
public void light_directional_display(vec4 rgba, vec3 dir) {
  rgba = check_colorMode_for_alpha(rgba).copy();
  directionalLight(rgba.red(),rgba.gre(),rgba.blu(),dir.x,dir.y,dir.z);
}
// END DIRECTIONAL LIGHT







// AMBIENT LIGHT
public void ambientLightPix(vec4 rgba) {
  rgba = check_colorMode_for_alpha(rgba).copy();
  ambientLight(rgba.red(),rgba.gre(),rgba.blu());
}

public void ambientLightPix(vec4 rgba, vec3 pos) {
  rgba = check_colorMode_for_alpha(rgba).copy();
  ambientLight(rgba.red(),rgba.gre(),rgba.blu(),pos.x,pos.y,pos.z);
}









// POINT LIGTH
//////////////
/**
Here we use a position of light
*/
public void light_point_display(vec4 rgba, vec3 pos) {
  rgba = check_colorMode_for_alpha(rgba).copy();
  pointLight(rgba.red(),rgba.gre(),rgba.blu(), pos.x,pos.y,pos.z);
}


/**
SPOT LIGHT
*/
public void light_spot_display(vec4 rgba, vec3 pos, vec3 dir, float angle, float concentration) {
  rgba = check_colorMode_for_alpha(rgba).copy() ;
  spotLight(rgba.red(),rgba.gre(),rgba.blu(), pos.x,pos.y,pos.z, dir.x,dir.y,dir.z, angle, concentration) ;
}




/**
GLOBAL SHADER
*/
// update color
public vec4 light_color(vec3 value, int max, vec4 color_univers, vec4 color_light, vec4 color_light_ref) {
  vec4 newRefColor = vec4(map(value.x, 0, max, 0, color_univers.x), map(value.y,0, max, 0, color_univers.y), map(value.z, 0, max, 0, color_univers.z),color_univers.w) ;
  if(!compare(newRefColor, color_light_ref)) color_light = newRefColor.copy() ;
  return newRefColor ;
}

// update direction
public vec3 light_direction(vec3 var, vec6 range3D, boolean authorization, vec3 dir, vec3 dir_ref) {
  if(authorization) {
    
    vec3 newRefDir = vec3(map(var.x,range3D.a(),range3D.b(), -1,1),
                          map(var.y,range3D.c(),range3D.d(), -1,1),
                          map(var.z,range3D.e(),range3D.f(), -1,1)) ;
    if(!compare(newRefDir, dir_ref)) dir = newRefDir.copy() ;
    dir_ref = newRefDir.copy() ; 
  }
  return dir_ref  ;
}


// update position
public vec3 light_position(vec3 var, vec6 range3D, vec6 range3D_target,boolean authorization, vec3 pos, vec3 pos_ref) {
  if(authorization) {
    vec3 newRefPos = vec3(map(var.x,range3D.a(),range3D.b(), range3D_target.a(),range3D_target.b()),
                          map(var.y,range3D.c(),range3D.d(), range3D_target.c(),range3D_target.d()),
                          map(var.z,range3D.e(),range3D.f(), range3D_target.e(),range3D_target.f())) ;
    if(!compare(newRefPos, pos_ref)) pos = newRefPos.copy() ;
    pos_ref = newRefPos.copy() ; 
  }
  return pos_ref  ;
}

/**
check the color mode of your skecth, if this one is on RGB, you must apply the alpha on RGB component, else in HSB you must apply only on SB components 
*/
public vec4 check_colorMode_for_alpha(vec4 rgba) {
  float alpha_norm = map(rgba.alp(),0,g.colorModeA,0,1);

  if(g.colorMode == 1) {
    // rgba.x *= alpha_norm;
    // rgba.y *= alpha_norm;
    // rgba.z *= alpha_norm; 

    // rgba.r *= alphaNormal; // before earthquake ROPE 0.3.0
    // rgba.g *= alphaNormal; // before earthquake ROPE 0.3.0
    // rgba.b *= alphaNormal; // before earthquake ROPE 0.3.0
    rgba.red(rgba.x *alpha_norm);
    rgba.gre(rgba.y *alpha_norm);
    rgba.blu(rgba.z *alpha_norm);
  } else {
    rgba.sat(rgba.y *alpha_norm);
    rgba.bri(rgba.z *alpha_norm);
    // rgba.y *= alpha_norm; 
    // rgba.z *= alpha_norm;

    // rgba.g *= alphaNormal; // before earthquake ROPE 0.3.0
    // rgba.b *= alphaNormal; // before earthquake ROPE 0.3.0
  }
  return rgba ;
}



public void light_value_romanesco(float [] value, boolean onOffLightAmbient,  boolean onOffDirLightOne, boolean onOffDirLightTwo, boolean onOffDirLightOneAction, boolean onOffDirLightTwoAction) {
  color_setting [0] = vec3(value[0],value[1],value[2]);
  color_setting [1] = vec3(value[3],value[4],value[5]);
  color_setting [2] = vec3(value[6],value[7],value[8]);

  on_off_light[0] = onOffLightAmbient ;
  on_off_light[1] = onOffDirLightOne ;
  on_off_light[2] = onOffDirLightTwo ;
  // on_off_light_action[0] = true ;
  on_off_light_action[1] = onOffDirLightOneAction ;
  on_off_light_action[2] = onOffDirLightTwoAction ;
}

/**

MEthod to test without Romanesco system
This method is not use in the software

*/
public void light_value_dev() {
    // color_setting [0] = vec3(abs(cos(frameCount*.001)) *360,abs(cos(frameCount*.01) *360),abs(sin(frameCount*.1) *360))
  // float hue = abs(cos(frameCount*.001)) *360 ;
  //float saturation = map(mouseX, 0, width, 0,360) ;
  // float brightness = map(mouseY, 0, height, 0,360) ;
  float hue = sin(frameCount *.005f) *360 ;
  float saturation = 360 ;
  float brightness = sin(frameCount *.002f) *360 ;

  color_setting [0] = vec3(hue,saturation,brightness); // (360,360,360) not (360,100,100) it's a reason why we must map the value
  color_setting [1] = vec3(280,360,360) ;
  color_setting [2] = vec3(0,360,360) ;
  
  var_light_pos = vec3(mouseX,mouseY,200)  ; 
  var_light_dir = vec3(0,0,1) ;
   // var_light_pos = new PVector(mouseX,mouseY,sin(frameCount *.1) *500)  ;
  
 //  var_light_dir = new PVector(mouseX,mouseY,sin(frameCount *.1) *500)  ;
  // on_off_light[0] = true ;
  on_off_light[1] = true ;
  on_off_light[2] = true ;
  on_off_light_action[0] = true ;
  on_off_light_action[1] = true ;
  on_off_light_action[2] = true ;
}










/*
MANAGE MEDIA
v 1.0.2
*/
public void media_init_path() {
  update_movie_path();
  update_svg_path();
  update_text_path();
  update_bitmap_path();
}
public void media_update(int frequence) {
  if(frameCount%frequence == 0) {
    update_movie_path();
    update_svg_path();
    update_text_path();
    update_bitmap_path();
    thread("load_autosave");
  }
}


/**
svg
*/
ROPE_svg[] svg_import;
String svg_current_path;
String [] svg_path;
public void load_svg(int id) {
  // which_bitmap is the int return from the dropdown menu
  if(which_shape[id] > svg_path.length ) which_shape[id] = 0;

  if(svg_path != null && svg_path.length > 0 && which_shape[id] < svg_path.length && svg_path[which_shape[id]] != null) {
    svg_current_path = svg_path[which_shape[id]];
    if(!svg_current_path.equals(svg_path_ref[id])) {
      svg_import[id] = new ROPE_svg(this, svg_current_path, "bricks");
    }
    svg_path_ref[id] = svg_current_path;
  }
}

public void update_svg_path() {
  svg_path = new String[svg_files.size()];
  for (int i = 0; i < svg_files.size(); i++) {
    File f = (File) svg_files.get(i);
    if(f.exists()) {
      svg_path[i] = f.getAbsolutePath();
    }   
  }
}

public void change_svg_from_pad(int ID) {
  which_shape[ID] = pad_inc(which_shape[ID],UP);
  which_shape[ID] = pad_inc(which_shape[ID],DOWN);
  which_shape[ID] = pad_inc(which_shape[ID],RIGHT);
  which_shape[ID] = pad_inc(which_shape[ID],LEFT);

  if(which_shape[ID] < 0) {
    which_shape[ID] = svg_path.length -1;
  } else if (which_shape[ID] >= svg_path.length) {
     which_shape[ID] = 0;
  }
}





/**
text
*/
String[] text_import ;
String [] text_path;
public void load_txt(int id) {
  // which_text is the int return from the dropdown menu
  if(text_path != null && text_path.length > 0 && which_text[id] < text_path.length && text_path[which_text[id]] != null) {
    if(which_text[id] > text_path.length ) which_text[id] = 0;
    text_import[id] = importText(text_path[which_text[id]]);
  } else {
    text_import[id] = "Big Brother has been burning all books.\nCheck the controller if there is any text imported";
  }    
}


public void update_text_path() {
  text_path = new String[text_files.size()] ;
  for (int i = 0; i < text_files.size(); i++) {
    File f = (File) text_files.get(i);
    if(f.exists()) {
      text_path[i] = f.getAbsolutePath();
    }   
  }
}

public void change_text_from_pad(int ID) {
  which_text[ID] = pad_inc(which_text[ID],UP);
  which_text[ID] = pad_inc(which_text[ID],DOWN);
  which_text[ID] = pad_inc(which_text[ID],RIGHT);
  which_text[ID] = pad_inc(which_text[ID],LEFT);

  if(which_text[ID] < 0) {
    which_text[ID] = text_path.length -1;
  } else if (which_text[ID] >= text_path.length) {
     which_text[ID] = 0;
  }
}






/**
bitmap
*/
PImage[] bitmap ;
String [] bitmap_path ;
public void load_bitmap(int id) {
  if(which_bitmap[id] > bitmap_path.length) {
    which_bitmap[id] = 0;
  }
  if(bitmap_path != null && bitmap_path.length > 0 && which_bitmap[id] < bitmap_path.length && bitmap_path[which_bitmap[id]] != null) {
    String bitmap_current_path = bitmap_path[which_bitmap[id]];
    if(!bitmap_current_path.equals(bitmap_path_ref[id])) {
      bitmap[id] = loadImage(bitmap_current_path);
    }
    bitmap_path_ref[id] = bitmap_current_path;
  }
}

public void update_bitmap_path() {
  bitmap_path = new String[bitmap_files.size()] ;
  for (int i = 0; i < bitmap_files.size(); i++) {
    File f = (File) bitmap_files.get(i);
    if(f.exists()) {
      bitmap_path[i] = f.getAbsolutePath();
    }   
  }
}


public void change_bitmap_from_pad(int id) {
  which_bitmap[id] = pad_inc(which_bitmap[id],UP);
  which_bitmap[id] = pad_inc(which_bitmap[id],DOWN);
  which_bitmap[id] = pad_inc(which_bitmap[id],RIGHT);
  which_bitmap[id] = pad_inc(which_bitmap[id],LEFT);

  if(which_bitmap[id] < 0) {
    which_bitmap[id] = bitmap_path.length -1;
  } else if (which_bitmap[id] >= bitmap_path.length) {
     which_bitmap[id] = 0;
  }
}






/**
movie 
*/
public void load_movie(boolean change_movie_is, int id) {
  boolean new_movie_is = check_for_new_movie();
  if(movie_path.length > 0 && which_movie[id] < movie_path.length && (new_movie_is || change_movie_is)) {
    setting_movie(id,movie_path[which_movie[id]]);
  }  
}


public void change_movie_from_pad(int id) {
  which_movie[id] = pad_inc(which_movie[id],UP);
  which_movie[id] = pad_inc(which_movie[id],DOWN);
  which_movie[id] = pad_inc(which_movie[id],RIGHT);
  which_movie[id] = pad_inc(which_movie[id],LEFT);

  if(which_movie[id] < 0) {
    which_movie[id] = movie_path.length -1;
  } else if (which_movie[id] >= movie_path.length) {
    which_movie[id] = 0;
  }
}








float [] movie_time;
String [] movie_path;
String [] movie_path_ref;
public boolean check_for_new_movie() {
  boolean new_movie_is = false;
  if(movie_path_ref == null || movie_path_ref.length != movie_path.length) {
    new_movie_is = true;
    movie_path_ref = new String[movie_path.length];
    movie_time = new float[movie_path.length];
  }
  
  // in case there a same quantity of ref we must check if the path ref is the same
  if(!new_movie_is)
  for(int i = 0 ; i < movie_files.size() ; i++) {
    try {
      new_movie_is = !movie_path_ref[i].equals(movie_path[i]);
    }
    catch (ArrayIndexOutOfBoundsException e) {
      printErrTempo(60,"boolean check_for_new_movie() catch: ArrayIndexOutOfBoundsException");

    }
    catch(Exception e){
        printErrTempo(60,"boolean check_for_new_movie() catch: Some Other exception");
     }
    
    if(new_movie_is) {
      break;
    }
  }

  // in case there is a new movie make a new ref path
  if(new_movie_is) {
    for(int i = 0 ; i < movie_path_ref.length && i < movie_files.size() ; i++) {
      movie_path_ref[i] = movie_path[i];
    }
  }
  return new_movie_is;
}


public void update_movie_path() {
  if(movie_path == null || movie_path.length != movie_files.size()) {
    movie_path = new String[movie_files.size()] ;
  }
  for (int i = 0; i < movie_files.size(); i++) {
    File f = (File) movie_files.get(i);
    if(f.exists()) {
      movie_path[i] = f.getAbsolutePath();
    }   
  }
}


// Movie Manager
public void setting_movie(int id, String path) {
  if(movie[id] != null) {
    movie[id].stop();
  }
  if(ext(path,"mov") || ext(path,"MOV") || ext(path,"avi") || ext(path,"AVI") || ext(path,"mp4") || ext(path,"MP4") || ext(path,"mkv") || ext(path,"MKV")) {
    println(path);
    movie[id] = new Movie(this,path);
    movie[id].loop();
    movie[id].pause();
  } else {
    printErrTempo(240,"ROMANESCO don't find the movie:",id,path);
  }
}

public void movieEvent(Movie m) {
  m.read(); 
}

/*
void classic_movie(int id, int place, boolean full_width, boolean full_height) {
  int pos_x = 0;
  int pos_y = 0;
  int size_x = movie[id].width;
  int size_y = movie[id].height;

  // Size in the Scene
  if(full_width && full_height) {
    size_x = width;
    size_y = height;
  } else if(!full_width && !full_height) {
    size_x = movie[id].width;
    size_y = movie[id].height;
  } else if(full_width && !full_height) {
    size_x = width;
    float ratio = (float)width / (float)movie[id].width ;
    size_y = int(movie[id].height *ratio);
  } else if(!full_width && full_height) {
    size_y = height ;
    float ratio = (float)height / (float)movie[id].height ;
    size_x = int(movie[id].width *ratio) ;
  }
  
  // position in the Scene
  if(place == CENTER) {
    pos_x = width/2 - (size_x/2) ;
    pos_y = height/2  - (size_y/2);
  }

  // show movie
  image(movie[id], pos_x, pos_y, size_x, size_y) ;
}
*/








/**
TEXT MANAGER
*/
String importRaw [];
public String importText(String path) {
  importRaw = loadStrings(path) ;
  return join(importRaw, "") ;
}







/**
OSC CORE 
v 1.6.1
*/
public void OSC_setup() {
  OSC_controller_setup();
  if(IAM.equals("prescene") && LIVE) {
    OSC_prescene_setup();
  } else if(IAM.equals("scene")) {
    OSC_scene_setup();
  }
}


public void OSC_update() {
  if(IAM.equals("prescene") && LIVE) {
    if(mousePressed || keyPressed) {
      send_message(true);
    }
    write_osc_event();
    join_osc_data();
  } else if(IAM.equals("scene")) {
    update_OSC_data();
  }
}
  

OscP5 osc_receive_controller_general;
OscP5 osc_receive_controller_item;
public void OSC_controller_setup() {
  osc_receive_controller_general = new OscP5(this,10000);
  osc_receive_controller_item = new OscP5(this,10001);
  println("receive OSC setup done");
}






















/**
* SEND OSC
* use to send info from prescene to scene
* commnande key, mouse, leapmotion.
* this part is used when the sketch is build like a prescene
*
* 2014-2019
* v 1.4.1
* 
*/
NetAddress [] ad_scene ;
String [] ID_address_scene ;
String toScene = ("Message from Prescene to Scene") ;
OscP5 osc_send_scene;

int port_send_scene = 9_100 ;

public void OSC_prescene_setup() {
  OSC_thread_send_scene_setup();
  println("send OSC setup done");
}

public void OSC_thread_send_scene_setup() {
  osc_send_scene = new OscP5(this, port_send_scene);
  //send
  if (DEV_MODE == false) {
    String [] addressIP = loadStrings(preference_path+"network/IP_address_mirror.txt") ;
    String join_address = join(addressIP,"") ;
    String [] temp = split(join_address,"/") ;

    int num_valid_address = 0 ;
    for(int i = 0 ; i < temp.length ; i++) {
      if(temp[i].equals("IP_address") || temp[i].equals("")) {
        // nothing happens
      } else {
        num_valid_address++;
      }   
    }
    if (youCanSendToScene) {
      ID_address_scene = new String[num_valid_address] ;
      ad_scene = new NetAddress[num_valid_address] ;
    }
    
    for(int i = 0 ; i < num_valid_address ; i++) {
      ID_address_scene[i] = temp[i+1];
    }

    for(int i = 0 ; i < ad_scene.length ; i++) {
      ad_scene[i] = new NetAddress(ID_address_scene[i], port_send_scene);
    }
  } else if(DEV_MODE == true) {
    ad_scene = new NetAddress[1];
    ad_scene[0] = new NetAddress("127.0.0.1", port_send_scene);
  }

  if(IAM.equals("prescene") && LIVE) {
    for(int i = 0 ; i < data_osc_prescene.length ; i++) {
      data_osc_prescene[i] = "0";
    }
  }
}


boolean send_message_is ;
public boolean send_message_is() {
  return send_message_is;
}

public void send_message(boolean send_message_is) {
  this.send_message_is = send_message_is;
}



// OSC prescene send
public void OSC_send() {
  OscMessage message_prescene_to_scene = new OscMessage("Prescene");
  message_prescene_to_scene.add(toScene);

  //send
  if(ad_scene == null) {
    printErr("OSC_send(): prescene app exit because the global variable 'DEV_MODE' must be false");
    // exit();
  } else {
    if(MIROIR) {
      for(int i = 0 ; i < ad_scene.length ; i++) {
        println("void OSC_send():",ad_scene[i]);
        osc_send_scene.send(message_prescene_to_scene,ad_scene[i]);
      } 
    } else if(!MIROIR) {
      osc_send_scene.send(message_prescene_to_scene,ad_scene[0]);
      dataPrescene = message_prescene_to_scene.get(0).stringValue();
    }  
  }
}


// OSC prescene write
public void write_osc_event() {
  if (key_a) data_osc_prescene [1] = ("1"); else data_osc_prescene [1] = ("0");
  if (key_b) data_osc_prescene [2] = ("1"); else data_osc_prescene [2] = ("0");
  if (key_c) data_osc_prescene [3] = ("1"); else data_osc_prescene [3] = ("0");
  if (key_d) data_osc_prescene [4] = ("1"); else data_osc_prescene [4] = ("0");
  if (key_e) data_osc_prescene [5] = ("1"); else data_osc_prescene [5] = ("0");
  if (key_f) data_osc_prescene [6] = ("1"); else data_osc_prescene [6] = ("0");
  if (key_g) data_osc_prescene [7] = ("1"); else data_osc_prescene [7] = ("0");
  if (key_h) data_osc_prescene [8] = ("1"); else data_osc_prescene [8] = ("0");
  if (key_i) data_osc_prescene [9] = ("1"); else data_osc_prescene [9] = ("0");
  if (key_j) data_osc_prescene [10] = ("1"); else data_osc_prescene [10] = ("0");
  if (key_k) data_osc_prescene [11] = ("1"); else data_osc_prescene [11] = ("0");
  if (key_l) data_osc_prescene [12] = ("1"); else data_osc_prescene [12] = ("0");
  if (key_m) data_osc_prescene [13] = ("1"); else data_osc_prescene [13] = ("0");
  if (key_n) data_osc_prescene [14] = ("1"); else data_osc_prescene [14] = ("0");
  if (key_o) data_osc_prescene [15] = ("1"); else data_osc_prescene [15] = ("0");
  if (key_p) data_osc_prescene [16] = ("1"); else data_osc_prescene [16] = ("0");
  if (key_q) data_osc_prescene [17] = ("1"); else data_osc_prescene [17] = ("0");
  if (key_r) data_osc_prescene [18] = ("1"); else data_osc_prescene [18] = ("0");
  if (key_s) data_osc_prescene [19] = ("1"); else data_osc_prescene [19] = ("0");
  if (key_t) data_osc_prescene [20] = ("1"); else data_osc_prescene [20] = ("0");
  if (key_u) data_osc_prescene [21] = ("1"); else data_osc_prescene [21] = ("0");
  if (key_v) data_osc_prescene [22] = ("1"); else data_osc_prescene [22] = ("0");
  if (key_w) data_osc_prescene [23] = ("1"); else data_osc_prescene [23] = ("0");
  if (key_x) data_osc_prescene [24] = ("1"); else data_osc_prescene [24] = ("0");
  if (key_y) data_osc_prescene [25] = ("1"); else data_osc_prescene [25] = ("0");
  if (key_z) data_osc_prescene [26] = ("1"); else data_osc_prescene [26] = ("0");

  if (key_A) data_osc_prescene[27] = ("1"); else data_osc_prescene[27] = ("0");
  if (key_B) data_osc_prescene[28] = ("1"); else data_osc_prescene[28] = ("0");
  if (key_C) data_osc_prescene[29] = ("1"); else data_osc_prescene[29] = ("0");
  if (key_D) data_osc_prescene[30] = ("1"); else data_osc_prescene[30] = ("0");
  if (key_E) data_osc_prescene[31] = ("1"); else data_osc_prescene[31] = ("0");
  if (key_F) data_osc_prescene[32] = ("1"); else data_osc_prescene[32] = ("0");
  if (key_G) data_osc_prescene[33] = ("1"); else data_osc_prescene[33] = ("0");
  if (key_H) data_osc_prescene[34] = ("1"); else data_osc_prescene[34] = ("0");
  if (key_I) data_osc_prescene[35] = ("1"); else data_osc_prescene[35] = ("0");
  if (key_J) data_osc_prescene[36] = ("1"); else data_osc_prescene[36] = ("0");
  if (key_K) data_osc_prescene[37] = ("1"); else data_osc_prescene[37] = ("0");
  if (key_L) data_osc_prescene[38] = ("1"); else data_osc_prescene[38] = ("0");
  if (key_M) data_osc_prescene[39] = ("1"); else data_osc_prescene[39] = ("0");
  if (key_N) data_osc_prescene[40] = ("1"); else data_osc_prescene[40] = ("0");
  if (key_O) data_osc_prescene[41] = ("1"); else data_osc_prescene[41] = ("0");
  if (key_P) data_osc_prescene[42] = ("1"); else data_osc_prescene[42] = ("0");
  if (key_Q) data_osc_prescene[43] = ("1"); else data_osc_prescene[43] = ("0");
  if (key_R) data_osc_prescene[44] = ("1"); else data_osc_prescene[44] = ("0");
  if (key_S) data_osc_prescene[45] = ("1"); else data_osc_prescene[45] = ("0");
  if (key_T) data_osc_prescene[46] = ("1"); else data_osc_prescene[46] = ("0");
  if (key_U) data_osc_prescene[47] = ("1"); else data_osc_prescene[47] = ("0");
  if (key_V) data_osc_prescene[48] = ("1"); else data_osc_prescene[48] = ("0");
  if (key_W) data_osc_prescene[49] = ("1"); else data_osc_prescene[49] = ("0");
  if (key_X) data_osc_prescene[50] = ("1"); else data_osc_prescene[50] = ("0");
  if (key_Y) data_osc_prescene[51] = ("1"); else data_osc_prescene[51] = ("0");
  if (key_Z) data_osc_prescene[52] = ("1"); else data_osc_prescene[52] = ("0");
  //FREE

  if (key_1) data_osc_prescene[53] = ("1"); else data_osc_prescene[53] = ("0");
  if (key_2) data_osc_prescene[54] = ("1"); else data_osc_prescene[54] = ("0");
  if (key_3) data_osc_prescene[55] = ("1"); else data_osc_prescene[55] = ("0");
  if (key_4) data_osc_prescene[56] = ("1"); else data_osc_prescene[56] = ("0");
  if (key_5) data_osc_prescene[57] = ("1"); else data_osc_prescene[57] = ("0");
  if (key_6) data_osc_prescene[58] = ("1"); else data_osc_prescene[58] = ("0");
  if (key_7) data_osc_prescene[59] = ("1"); else data_osc_prescene[59] = ("0");
  if (key_8) data_osc_prescene[60] = ("1"); else data_osc_prescene[60] = ("0");
  if (key_9) data_osc_prescene[61] = ("1"); else data_osc_prescene[61] = ("0");
  if (key_0) data_osc_prescene[62] = ("1"); else data_osc_prescene[62] = ("0");
  

  // if (key_a_long) data_osc_prescene[63] = ("1"); else data_osc_prescene[63] = ("0");
  //if (key_b_long) data_osc_prescene[64] = ("1"); else data_osc_prescene[64] = ("0");
  if (key_c_long) data_osc_prescene[65] = ("1"); else data_osc_prescene[65] = ("0");
  //if (key_d_long) data_osc_prescene[66] = ("1"); else data_osc_prescene[66] = ("0");
  //if (key_e_long) data_osc_prescene[67] = ("1"); else data_osc_prescene[67] = ("0");
  //if (key_f_long) data_osc_prescene[68] = ("1"); else data_osc_prescene[68] = ("0");
  //if (key_g_long) data_osc_prescene[69] = ("1"); else data_osc_prescene[69] = ("0");
  //if (key_h_long) data_osc_prescene[70] = ("1"); else data_osc_prescene[70] = ("0");
  //if (key_i_long) data_osc_prescene[71] = ("1"); else data_osc_prescene[71] = ("0");
  //if (key_j_long) data_osc_prescene[72] = ("1"); else data_osc_prescene[72] = ("0");
  //if (key_k_long) data_osc_prescene[73] = ("1"); else data_osc_prescene[73] = ("0");
  if (key_l_long) data_osc_prescene[74] = ("1"); else data_osc_prescene[74] = ("0");
  //if (key_m_long) data_osc_prescene[75] = ("1"); else data_osc_prescene[75] = ("0");
  if (key_n_long) data_osc_prescene[76] = ("1"); else data_osc_prescene[76] = ("0");
  //if (key_o_long) data_osc_prescene[77] = ("1"); else data_osc_prescene[77] = ("0");
  //if (key_p_long) data_osc_prescene[78] = ("1"); else data_osc_prescene[78] = ("0");
  //if (key_q_long) data_osc_prescene[79] = ("1"); else data_osc_prescene[79] = ("0");
  //if (key_r_long) data_osc_prescene[80] = ("1"); else data_osc_prescene[80] = ("0");
  //if (key_s_long) data_osc_prescene[81] = ("1"); else data_osc_prescene[81] = ("0");
  //if (key_t_long) data_osc_prescene[82] = ("1"); else data_osc_prescene[82] = ("0");
  //if (key_u_long) data_osc_prescene[83] = ("1"); else data_osc_prescene[83] = ("0");
  if (key_v_long) data_osc_prescene[84] = ("1"); else data_osc_prescene[84] = ("0");
  //if (key_w_long) data_osc_prescene[85] = ("1"); else data_osc_prescene[85] = ("0");
  //if (key_x_long) data_osc_prescene[86] = ("1"); else data_osc_prescene[86] = ("0");
  //if (key_y_long) data_osc_prescene[87] = ("1"); else data_osc_prescene[87] = ("0");
  //if (key_z_long) data_osc_prescene[88] = ("1"); else data_osc_prescene[88] = ("0");
  

  // SPECIAL TOUCH
  if (key_space_long) data_osc_prescene[89] = ("1"); else data_osc_prescene[89] =("0");
  if (key_shift_long) data_osc_prescene[90] = ("1"); else data_osc_prescene[90] = ("0");

  //data_osc_prescene [91] = ("");
  // .../...
  //data_osc_prescene [99] = ("");

  if (key_space) data_osc_prescene[100] = ("1") ; else data_osc_prescene[100] =("0") ;
  if (key_enter) data_osc_prescene[101] = ("1") ; else data_osc_prescene[101] = ("0") ;
  if (key_return) data_osc_prescene[102] = ("1") ; else data_osc_prescene[102] = ("0") ;
  if (key_delete) data_osc_prescene[103] = ("1") ; else data_osc_prescene[103] = ("0") ;
  if (key_backspace) data_osc_prescene[104] = ("1") ; else data_osc_prescene[104] = ("0") ;
  if (key_alt) data_osc_prescene[105] = ("1") ; else data_osc_prescene[105] = ("0") ;
  if (key_ctrl) data_osc_prescene[106] = ("1") ; else data_osc_prescene[106] = ("0") ;
  if (key_cmd) data_osc_prescene[107] = ("1") ; else data_osc_prescene[107] = ("0") ;

  if (key_up) data_osc_prescene[108] = ("1") ; else data_osc_prescene[108] = ("0") ;
  if (key_down) data_osc_prescene[109] = ("1") ; else data_osc_prescene[109] = ("0") ;
  if (key_right) data_osc_prescene[110] = ("1") ; else data_osc_prescene[110] = ("0") ;
  if (key_left) data_osc_prescene[111] = ("1") ; else data_osc_prescene[111] = ("0") ;

  
  //data_osc_prescene [112] = ("");
  // .../...
  //data_osc_prescene [119] = ("");

  data_osc_prescene[120] = float_to_String_3(pen[0].x); 
  data_osc_prescene[121] = float_to_String_3(pen[0].y); 
  data_osc_prescene[122] = float_to_String_1(pen[0].z); 

  data_osc_prescene[123] = float_to_String_3(norm(mouse[0].x, 0, width)); 
  data_osc_prescene[124] = float_to_String_3(norm(mouse[0].y,0,height));
  data_osc_prescene[125] = float_to_String_3(norm(mouse[0].z,-depth_scene,depth_scene));

  if (clickShortLeft[0]) data_osc_prescene[126] = ("1"); else data_osc_prescene[126] = ("0");
  if (clickShortRight[0]) data_osc_prescene[127] = ("1"); else data_osc_prescene[127] = ("0");
  if (clickLongLeft[0]) data_osc_prescene[128] = ("1"); else data_osc_prescene[128] = ("0");
  if (clickLongRight[0]) data_osc_prescene[129] = ("1"); else data_osc_prescene[129] = ("0");

  data_osc_prescene[130] = int_to_String(wheel[0]);


  // ORDER
  if (ORDER_ONE) data_osc_prescene[131] = ("1") ; else data_osc_prescene[131] = ("0");
  if (ORDER_TWO) data_osc_prescene[132] = ("1") ; else data_osc_prescene[132] = ("0");
  if (ORDER_THREE) data_osc_prescene[133] = ("1") ; else data_osc_prescene[133] = ("0");
  if (LEAPMOTION_DETECTED) data_osc_prescene[134] = ("1") ; else data_osc_prescene[134] = ("0");

}


public void join_osc_data() {
  toScene = join(data_osc_prescene, "/") ;
}

















































































/**
* RECEPTION OSC
* v 0.0.1
*
*
*
*
*
*/
/**
EVENT & THREAD
v 0.0.2
*/
int security_to_dont_duplicate_osc_packet ;
public void oscEvent(OscMessage receive) {
  if(security_to_dont_duplicate_osc_packet != frameCount) {
    controller_reception(receive);
    if(IAM.equals("scene")) {
      prescene_reception(receive);
    }
  }
  security_to_dont_duplicate_osc_packet = frameCount;
}




/**
* PRESCENE RECEPTION
* 2013-2019
*v 1.1.0
* this part is used when the sketch is build like a scene
*
*/
String dataPrescene = ("") ;
String from_prescene_boolean_load_save = ("") ;
OscP5 osc_receive_prescene ;

// OSC prescene setup 
public void OSC_scene_setup() {
  int port_receive_prescene = 9_100 ;

  osc_receive_prescene = new OscP5(this, port_receive_prescene);
  println("OSC Scene setup done");
}

public void prescene_reception(OscMessage m) {
  if(m.addrPattern().equals("Prescene")) {  
    catch_data_from_precene(m);
    data_osc_prescene = split(dataPrescene,'/');
  } 
}

public void catch_data_from_precene(OscMessage receive) { 
  dataPrescene = receive.get(0).stringValue();
  if(receive.arguments().length > 2 ) {
    from_prescene_boolean_load_save = receive.get(2).stringValue();
  }
}

public void update_OSC_data() {
  translate_event_prescene() ;
}

public void translate_event_prescene() {
  if(data_osc_prescene[1].equals("0") ) key_a = false; else key_a = true;
  if(data_osc_prescene[2].equals("0") ) key_b = false; else key_b = true;
  if(data_osc_prescene[3].equals("0") ) key_c = false; else key_c = true;
  if(data_osc_prescene[4].equals("0") ) key_d = false; else key_d = true;
  if(data_osc_prescene[5].equals("0") ) key_e = false; else key_e = true;
  if(data_osc_prescene[6].equals("0") ) key_f = false; else key_f = true;
  if(data_osc_prescene[7].equals("0") ) key_g = false; else key_g = true;
  if(data_osc_prescene[8].equals("0") ) key_h = false; else key_h = true;
  if(data_osc_prescene[9].equals("0") ) key_i = false; else key_i = true;
  if(data_osc_prescene[10].equals("0") ) key_j = false; else key_j = true;
  if(data_osc_prescene[11].equals("0") ) key_k = false; else key_k = true;
  if(data_osc_prescene[12].equals("0") ) key_l = false; else key_l = true;
  if(data_osc_prescene[13].equals("0") ) key_m = false; else key_m = true;
  if(data_osc_prescene[14].equals("0") ) key_n = false; else key_n = true;
  if(data_osc_prescene[15].equals("0") ) key_o = false; else key_o = true;
  if(data_osc_prescene[16].equals("0") ) key_p = false; else key_p = true;
  if(data_osc_prescene[17].equals("0") ) key_q = false; else key_q = true;
  if(data_osc_prescene[18].equals("0") ) key_r = false; else key_r = true;
  if(data_osc_prescene[19].equals("0") ) key_s = false; else key_s = true;
  if(data_osc_prescene[20].equals("0") ) key_t = false; else key_t = true;
  if(data_osc_prescene[21].equals("0") ) key_u = false; else key_u = true;
  if(data_osc_prescene[22].equals("0") ) key_v = false; else key_v = true;
  if(data_osc_prescene[23].equals("0") ) key_w = false; else key_w = true;
  if(data_osc_prescene[24].equals("0") ) key_x = false; else key_x = true;
  if(data_osc_prescene[25].equals("0") ) key_y = false; else key_y = true;
  if(data_osc_prescene[26].equals("0") ) key_z = false; else key_z = true;

  if(data_osc_prescene[27].equals("0") ) key_A = false; else key_A = true;
  if(data_osc_prescene[28].equals("0") ) key_B = false; else key_B = true;
  if(data_osc_prescene[29].equals("0") ) key_C = false; else key_C = true;
  if(data_osc_prescene[30].equals("0") ) key_D = false; else key_D = true;
  if(data_osc_prescene[31].equals("0") ) key_E = false; else key_E = true;
  if(data_osc_prescene[32].equals("0") ) key_F = false; else key_F = true;
  if(data_osc_prescene[33].equals("0") ) key_G = false; else key_G = true;
  if(data_osc_prescene[34].equals("0") ) key_H = false; else key_H = true;
  if(data_osc_prescene[35].equals("0") ) key_I = false; else key_I = true;
  if(data_osc_prescene[36].equals("0") ) key_J = false; else key_J = true;
  if(data_osc_prescene[37].equals("0") ) key_K = false; else key_K = true;
  if(data_osc_prescene[38].equals("0") ) key_L = false; else key_L = true;
  if(data_osc_prescene[39].equals("0") ) key_M = false; else key_M = true;
  if(data_osc_prescene[40].equals("0") ) key_N = false; else key_N = true;
  if(data_osc_prescene[41].equals("0") ) key_O = false; else key_O = true;
  if(data_osc_prescene[42].equals("0") ) key_P = false; else key_P = true;
  if(data_osc_prescene[43].equals("0") ) key_Q = false; else key_Q = true;
  if(data_osc_prescene[44].equals("0") ) key_R = false; else key_R = true;
  if(data_osc_prescene[45].equals("0") ) key_S = false; else key_S = true;
  if(data_osc_prescene[46].equals("0") ) key_T = false; else key_T = true;
  if(data_osc_prescene[47].equals("0") ) key_U = false; else key_U = true;
  if(data_osc_prescene[48].equals("0") ) key_V = false; else key_V = true;
  if(data_osc_prescene[49].equals("0") ) key_W = false; else key_W = true;
  if(data_osc_prescene[50].equals("0") ) key_X = false; else key_X = true;
  if(data_osc_prescene[51].equals("0") ) key_Y = false; else key_Y = true;
  if(data_osc_prescene[52].equals("0") ) key_Z = false; else key_Z = true;
 
  if(data_osc_prescene[53].equals("0") ) key_1 = false; else key_1 = true;
  if(data_osc_prescene[54].equals("0") ) key_2 = false; else key_2 = true;
  if(data_osc_prescene[55].equals("0") ) key_3 = false; else key_3 = true;
  if(data_osc_prescene[56].equals("0") ) key_4 = false; else key_4 = true;
  if(data_osc_prescene[57].equals("0") ) key_5 = false; else key_5 = true;
  if(data_osc_prescene[58].equals("0") ) key_6 = false; else key_6 = true;
  if(data_osc_prescene[59].equals("0") ) key_7 = false; else key_7 = true;
  if(data_osc_prescene[60].equals("0") ) key_8 = false; else key_8 = true;
  if(data_osc_prescene[61].equals("0") ) key_9 = false; else key_9 = true;
  if(data_osc_prescene[62].equals("0") ) key_0 = false; else key_0 = true;

  if(data_osc_prescene[65].equals("0")) key_c_long = false; else key_c_long = true;
  if(data_osc_prescene[74].equals("0")) key_l_long = false; else key_l_long = true;
  if(data_osc_prescene[76].equals("0")) key_n_long = false; else key_n_long = true;
  if(data_osc_prescene[84].equals("0")) key_v_long = false; else key_v_long = true;
   
  // SPECIAL TOUCH
  if(data_osc_prescene[89].equals("0") ) key_space_long = false; else key_space_long = true;
  if(data_osc_prescene[90].equals("0")) key_shift_long = false; else key_shift_long = true;
  
  if(data_osc_prescene[100].equals("0") ) key_space = false; else key_space = true;
  if(data_osc_prescene[101].equals("0") ) key_enter = false; else key_enter = true;
  if(data_osc_prescene[102].equals("0") ) key_return = false; else key_return = true;
  if(data_osc_prescene[103].equals("0") ) key_delete = false; else key_delete = true;
  if(data_osc_prescene[104].equals("0") ) key_backspace = false; else key_backspace = true;
  if(data_osc_prescene[105].equals("0") ) key_alt = false; else key_alt = true;
  if(data_osc_prescene[106].equals("0") ) key_ctrl = false; else key_ctrl = true;
  if(data_osc_prescene[107].equals("0") ) key_cmd = false; else key_cmd = true;

  if(data_osc_prescene[108].equals("0") ) key_up = false; else key_up = true;
  if(data_osc_prescene[109].equals("0") ) key_down = false; else key_down = true;
  if(data_osc_prescene[110].equals("0") ) key_right = false; else key_right = true;
  if(data_osc_prescene[111].equals("0") ) key_left = false; else key_left = true;



  //PEN
  pen[0].x = Float.valueOf(data_osc_prescene[120].replaceAll(",",".")) ;
  pen[0].y = Float.valueOf(data_osc_prescene[121].replaceAll(",",".")) ;
  pen[0].z = Float.valueOf(data_osc_prescene[122].replaceAll(",",".")) ;
  // create a temp mouse pos, to temporize the difference of the frame rate between the Préscène and the Scène.

  float x = map(Float.valueOf(data_osc_prescene[123].replaceAll(",",".")),0,1,0, width);
  float y = map(Float.valueOf(data_osc_prescene[124].replaceAll(",",".")),0,1,0,height);
  float z = map(Float.valueOf(data_osc_prescene[125].replaceAll(",",".")),0,1,-750,750);
  // absolute mouse pos
  mouse[0].x = x +mouse[0].x *.5f ;
  mouse[0].y = y +mouse[0].y *.5f ;
  mouse[0].z = z +mouse[0].z *.5f ;
  // Mouse button
  if(data_osc_prescene[126].equals("0")) clickShortLeft[0] = false; else clickShortLeft[0] = true;
  if(data_osc_prescene[127].equals("0")) clickShortRight[0] = false; else clickShortRight[0] = true;
  if(data_osc_prescene[128].equals("0")) clickLongLeft[0] = false; else clickLongLeft[0] = true;
  if(data_osc_prescene[129].equals("0")) clickLongRight[0] = false; else clickLongRight[0] = true;
  //WHEEL
  wheel[0] = Integer.parseInt(data_osc_prescene[130]);
  

  // ORDER
  if(data_osc_prescene[131].equals("0")) ORDER_ONE = false; else ORDER_ONE = true;
  if(data_osc_prescene[132].equals("0")) ORDER_TWO = false; else ORDER_TWO = true;
  if(data_osc_prescene[133].equals("0")) ORDER_THREE = false; else ORDER_THREE = true;
  if(data_osc_prescene[134].equals("0")) LEAPMOTION_DETECTED = false; else LEAPMOTION_DETECTED = true;
}

















/** 
* CONTROLLER RECEPTION
*/
boolean controller_osc_is = false ;
public void controller_reception(OscMessage receive) {
  if(receive.addrPattern().equals("Controller general")) {
    thread_data_controller_general(receive);
    controller_osc_is = true;
  }

  if(receive.addrPattern().equals("Controller item")) {
    thread_data_controller_item(receive);
    controller_osc_is = true;
  }
}


public void thread_data_controller_general(OscMessage receive) {
  int rank = 0 ;
  receive_data_menu_bar(receive,rank); 

  rank += NUM_TOP_BUTTON;
  receive_data_general_dropdown(receive,rank);

  rank += NUM_DROPDOWN_GENERAL;
  //rank += 7;
  receive_data_general_button(receive,rank);

  rank += NUM_MID_BUTTON;  
  receive_data_general_slider(receive,rank,rank +NUM_MOLETTE_GENERAL); // NUM_SLIDER_GENERAL 
}


public void thread_data_controller_item(OscMessage receive) {
  int rank = 0 ;
  receive_data_slider_item(receive,rank); // num arg = NUM_SLIDER_ITEM
  rank += NUM_SLIDER_ITEM;
  receive_data_button_item(receive,rank); // num arg = NUM_ITEM_PLUS_MASTER *BUTTON_ITEM_CONSOLE
  rank += (NUM_ITEM *BUTTON_ITEM_CONSOLE);
  receive_data_dropdown_costume_item(receive,rank); // num arg = NUM_ITEM_PLUS_MASTER
  rank += NUM_ITEM;
  receive_data_dropdown_mode_item(receive,rank); // num arg = NUM_ITEM_PLUS_MASTER

}



// local method
public boolean to_bool(OscMessage receive, int index) {
  Object obj = receive.arguments()[index];
  if(obj instanceof Integer) {
    int i = (int)obj;
    if(i == 0) return false ; else return true;
  } if(obj instanceof Float) {
    float f = (float)obj;
    if(f == 0) return false ; else return true;
  } else {
    if(IAM.equals("prescene")) {
      // not possible to use print when the presne is used because the rendering prescene and scene is from the same sketch
      printErr("OSC message index",index, "cannot be cast by default false value has be used");
    }
    return false;
  }
}



public void receive_data_menu_bar(OscMessage receive, int in) {
  curtain_button_is(to_bool(receive,0+in));
  // reset button alert
  reset_camera_button_alert_is(to_bool(receive,1+in));
  reset_item_on_button_alert_is(to_bool(receive,2+in));
  reset_fx_button_alert_is(to_bool(receive,3+in));
  // misc
  birth_button_alert_is(to_bool(receive,4+in));
  dimension_button_alert_is(to_bool(receive,5+in));
/*
  if(birth_button_is()) println("receive_data_menu_bar() :birth",birth_button_is(),frameCount);
  if(dimension_button_is()) println("receive_data_menu_bar: dimension",dimension_button_is(),frameCount);
  */
}

public void receive_data_general_dropdown(OscMessage receive, int in) {
  which_shader = receive.get(0+in).intValue(); // shader
  which_fx = receive.get(1+in).intValue(); // filter
  select_font(receive.get(2+in).intValue()); // font
  which_text[0] = receive.get(3+in).intValue(); // text
  which_bitmap[0] = receive.get(4+in).intValue(); // bitmap
  which_shape[0] = receive.get(5+in).intValue(); // shape
  which_movie[0] = receive.get(6+in).intValue(); // movie
}


public void receive_data_general_button(OscMessage receive, int in) {
  int target = 0;
  background_button_is(to_bool(receive,target+in));
  target++;
  for(int i = 0 ; i < fx_button_is.length ; i++) {
    fx_button_is(i,to_bool(receive,target+in));
    target++;
  }
  ambient_button_is(to_bool(receive,target+in));
  target++;
  ambient_action_button_is(to_bool(receive,target+in));
  target++;
  light_1_button_is(to_bool(receive,target+in));
  target++;
  light_1_action_button_is(to_bool(receive,target+in));
  target++;
  light_2_button_is(to_bool(receive,target+in));
  target++;
  light_2_action_button_is(to_bool(receive,target+in));
  target++;
  for(int i = 1 ; i < transient_button_is.length ; i++) {
    transient_button_is(i,to_bool(receive,target+in));
    target++;
  }
  // index_osc finish at 12
}

public void receive_data_general_slider(OscMessage receive, int in, int out) {
  int in_background = in ;
  int out_background = in_background +NUM_MOLETTE_BACKGROUND;

  int in_fx =  out_background;
  int out_fx = in_fx +NUM_MOLETTE_FX;

  int in_light =  out_fx;
  int out_light = in_light +NUM_MOLETTE_LIGHT;

  int in_sound =  out_light;
  int out_sound = in_sound +NUM_MOLETTE_SOUND;

  int in_sound_setting =  out_sound;
  int out_sound_setting = in_sound_setting +NUM_MOLETTE_SOUND_SETTING;

  int in_camera =  out_sound_setting;
  int out_camera = in_camera +NUM_MOLETTE_CAMERA;

  for (int i = in ; i < out ; i++) {
    if(i < out_background) {
      value_slider_background[i -in] = receive.get(i).intValue();
    } else if(i >= in_fx && i < out_fx) {
      value_slider_fx[i -in_fx] = receive.get(i).intValue();
    } else if(i >= in_light && i < out_light) {
      value_slider_light[i -in_light] = receive.get(i).intValue();
    } else if(i >= in_sound && i < out_sound) {
      value_slider_sound[i -in_sound] = receive.get(i).intValue();
    } else if(i >= in_sound_setting && i < out_sound_setting) {
      value_slider_sound_setting[i -in_sound_setting] = receive.get(i).intValue();
    } else if(i >= in_camera && i < out_camera) {
      value_slider_camera[i -in_camera] = receive.get(i).intValue();
    }
  } 
}


public void receive_data_slider_item(OscMessage receive, int in) {
  for (int i = 0 ; i < NUM_MOLETTE_ITEM ; i++) {
    int index = in + i;
    value_slider_item[i] = Float.valueOf(receive.get(index).intValue());
  }
}


public void receive_data_button_item(OscMessage receive, int in) {
  int num = BUTTON_ITEM_CONSOLE;
  for (int i = 0 ; i < NUM_ITEM ; i++) {
    int index = in + (i*num);
    Romanesco item = rom_manager.get(i);
    item.show_is(to_bool(receive,index+0));
    item.parameter_is(to_bool(receive,index+1));
    item.sound_is(to_bool(receive,index+2));
    item.action_is(to_bool(receive,index+3));
  }
}

public void receive_data_dropdown_mode_item(OscMessage receive, int in) {
  for (int i = 0 ; i < NUM_ITEM ; i++) {
    int index = i+in;
    Romanesco item = rom_manager.get(i);
    item.mode.set_id(receive.get(index).intValue());
  }
}

public void receive_data_dropdown_costume_item(OscMessage receive, int in) {
  for (int i = 0 ; i < NUM_ITEM ; i++) {
    int index = i+in;
    int target = i+1;
    Romanesco item = rom_manager.get(i);
    item.set_costume_id(receive.get(index).intValue());
  }
}



















/**
* RENDERING
* 2016-2019
* v 1.2.1
*/
public void rendering() {
  boolean show_is = true;
  // setting display
  if(curtain_button_is()) {
    show_is = false;
  }
  if(IAM.equals("presecene") && LIVE) {
    show_is = true;
  }

  // display
  if(show_is) {
    rendering_background(USE_LAYER,0);
    if(draw_fx_before_rendering_is()) {
      fx_post();
    }
    rendering_item_3D(USE_LAYER,1);
    rendering_item_2D(USE_LAYER,1);
    if(!draw_fx_before_rendering_is()) {
      fx_post();
    }
    rendering_info(USE_LAYER);
  } else {
    rendering_curtain(USE_LAYER);   
  }
}








public void rendering_item_3D(boolean use_layer_is, int which_layer) {
  if(use_layer_is) {
    get_layer(which_layer);
    begin_layer();
    rendering_item_final_3D();
    end_layer();
  } else {
    rendering_item_final_3D();
  }
}


public void rendering_item_final_3D() {
  camera_romanesco_draw();
  // light
  light_position_draw(mouse[0], wheel[0]); // not in the conditional because we need to display in the info box
  light_update_position_direction();
  if(FULL_RENDERING) {
    light_call_shader();
    light_display();
    shader_draw();
  }
  
  //use romanesco object
  rom_manager.show_item_3D(ORDER_ONE,ORDER_TWO,ORDER_THREE);

  grid_romanesco(show_info_camera);
  stop_camera();
}




public void rendering_background(boolean use_layer_is, int which_layer) {
  if(use_layer_is) {
    select_layer(which_layer);
    begin_layer();
    background_romanesco();
    end_layer();
  } else {
    background_romanesco();
  }
}



public void rendering_item_2D(boolean use_layer_is, int which_layer) {
  if(use_layer_is) {
    get_layer(which_layer);
    begin_layer();
    rom_manager.show_item_2D();
    end_layer();
  } else {
    rom_manager.show_item_2D();
  }
}



public void rendering_curtain(boolean use_layer_is) {
  if(use_layer_is) {
    get_layer(get_layer_num() -1);
    begin_layer();
    curtain();
    end_layer();
  } else {
    curtain();
  }
}

public void rendering_info(boolean use_layer_is) {
  if(use_layer_is) {
    get_layer(get_layer_num() -1);
    begin_layer();
    info();
    end_layer();
  } else {
    info();
  }
}






























/**
INIT Romanesco
*/
boolean init_romanesco = true ;
public void init_romanesco() {
  rectMode(CORNER);
  textAlign(LEFT);
  
  if(init_romanesco) {
    int which_setting = 0 ;
    for(int i = 0 ; i < NUM_ITEM_PLUS_MASTER ; i ++) {
      reset_direction_item (which_setting, i) ;
      update_ref_direction(i) ;
      // check for null before start
      if(dir_item_final[i] == null) dir_item_final[i] = vec3() ;
      if(pos_item_final[i] == null) {
        float x = -(width/2) ;
        float y = -(height/2) ;
        pos_item_final[i] = vec3(x,y,0) ;
      }
    }
    init_romanesco = false ;
  }
}




/**
DISPLAY SETUP
2015-2019
v 1.3.1
*/
String displayMode = ("");
int depth_scene;
public void display_setup(int frame_rate, int num_layer) {
  if(IAM.equals("scene")) {
    background_rope(0);
    noCursor();
  }
  frameRate(frame_rate);
  colorMode(HSB,HSBmode);
  //colorMode(HSB,HSBmode.hue(),HSBmode.sat(),HSBmode.bri(),HSBmode.alp());

  set_screen();
  depth_scene = height;

  // resize layer
  if(USE_LAYER) {
    init_layer(width,height,num_layer);
    for(int i = 0 ; i < get_layer_num() ; i++) {
      select_layer(i);
      begin_layer();
      colorMode(HSB,HSBmode);
      // colorMode(HSB,HSBmode.hue(),HSBmode.sat(),HSBmode.bri(),HSBmode.alp());
      end_layer();
    }
  } 
}


public void set_screen() {
  Table configurationScene = loadTable(preference_path +"sceneProperty.csv","header");
  TableRow row = configurationScene.getRow(0);
  ivec2 window = ivec2(width,height);
  int target_screen = row.getInt("whichScreen");

  if(FULL_RENDERING) {
    if(!DEV_MODE) {
      window.x = row.getInt("width"); 
      window.y = row.getInt("height");
    }
 
    if(!FULL_SCREEN) {
      if(!DEV_MODE) window.set(resize_screen(window,target_screen));
      load_window_location(window);
      surface.setSize(window.x,window.y);
    } else {
      println("The",IAM,"is on the screen",target_screen,"on",get_display_num(),"screen available");    
      int ox = get_screen_location(target_screen).x;
      int oy = get_screen_location(target_screen).y;
      surface.setLocation(ox,oy);
      int sx = get_screen_size(target_screen).x;
      int sy = get_screen_size(target_screen).y;
      surface.setSize(sx,sy);
      for(int i = 0 ; i < get_display_num() ; i++) {
        println("screen",i,"location",get_screen_location(i));
        println("screen",i,"size",get_screen_size(i));
      }
      println("target screen",target_screen,"location:",ox,oy);
      println("target screen",target_screen,"size:",sx,sy);
      window.set(sx,sy);
    }   
  } else {
    window.set(row.getInt("preview_width"),row.getInt("preview_height"));
    load_window_location(window);
    surface.setSize(window.x,window.y);
  }
  scene_width = window.x;
  scene_height = window.y;
  println(IAM,"screen size:",window); 
}

// resize_screen_if_parameter_is_too_big
public ivec2 resize_screen(ivec2 window, int target) {
  if(window.x >= get_screen_size(target).x) {
    window.x = get_screen_size(target).x -100;
  }
  if(window.y >= get_screen_size(target).y) {
    window.y = get_screen_size(target).y -100;
  }
  return window;
}
























/**
OPENING
2018-2018
*/
public void opening_display_message() {
  if(IAM.equals("scene")) {
  // if(IAM.equals("scene") || !LIVE) {
    background_rope(0);
    message_opening();
  } else if(IAM.equals("prescene") && FULL_RENDERING) {
    background_rope(0);
    message_opening();
  }
}


public void message_opening() {
  fill(blanc);
  stroke(blanc);
  textSize(48);
  textAlign(CENTER);
  start_matrix();
  translate(width/2, height/2, abs(sin(frameCount * .005f)) *(height/2)) ;
  text(nameVersion.toUpperCase(),0,-12);
  textSize(24);
  text(prettyVersion+"." + version,0,16);
  text("rendering " +IAM,0,36);
  stop_matrix() ;
  textAlign(LEFT) ;
}
































































































/**
MIROIR
v 0.1.0
*/
boolean syphon_on_off  ;
SyphonServer server ;
public void syphon_settings() {
  PJOGL.profile=1;
}

public void syphon_setup() {
  String name_syphon = (nameVersion + " " + prettyVersion +"."+version) ;
  server = new SyphonServer(this, name_syphon);
  println("Syphon setup done") ;
}

public void syphon_draw() {
  if(key_y) syphon_on_off = !syphon_on_off ;
  if(syphon_on_off) server.sendScreen();
}






















/**
DISPLAY INFO
v 0.3.0
*/
boolean displayInfo, show_info_camera ;
int posInfo = 2 ;
public void info() {
  sounda.info(displayInfo);
  int color_text = color(0,0,100);
  int color_bg = color(0,100,100,50);

  if (displayInfo) {
    //perspective() ;
    show_info_rendering(color_bg,color_text) ;
    show_info_item(color_bg,color_text) ;
  }
  if (show_info_camera) {
    show_info_camera(color_text);
  }
}

public void show_info_rendering(int bg_txt, int txt) {
  noStroke() ;
  fill(bg_txt) ;
  rectMode(CORNER) ;
  textAlign(LEFT) ;
  rect(0,-5,width, 15*posInfo) ;
  posInfo = 2 ;
  fill(txt) ;
  textFont(system_font,10);
  //INFO SIZE and RENDERER
  String displayModeInfo ;
  if (displayMode.equals("Classic") ) displayModeInfo = ("classic") ; else displayModeInfo = displayMode ;
  String infoRendering =("");
  if(FULL_RENDERING) infoRendering = ("Full rendering") ; else infoRendering = ("Preview rendering") ;
  text("Size " + width + "x" + height + " / "  + infoRendering + " / Render mode " + displayModeInfo + " / FrameRate " + (int)frameRate, 15,15) ;
  // INFO SYPHON
  text("Syphon " +syphon_on_off + " / press “y“ to on/off the Syphon",15, 15 *posInfo ) ;
  posInfo += 1 ;
  //INFO MOUSE and PEN
  text("Mouse " + mouseX + " / " + mouseY + " molette " + wheel[0] + " pen orientation " + (int)deg360(vec2(pen[0].x,pen[0].y)) +"°   stylet pressur " + PApplet.parseInt(pen[0].z *10),15, 15 *posInfo ) ;  
  posInfo += 1 ;
  // LIGHT INFO
  text("Directional light ONE || pos " + PApplet.parseInt(pos_light[1].x)+ " / " + PApplet.parseInt(pos_light[1].y) + " / "+ PApplet.parseInt(pos_light[1].z) + " || dir " + decimale(dir_light[1].x,2) + " / " + decimale(dir_light[1].y,2) + " / "+ decimale(dir_light[1].z,2),15, 15 *posInfo  ) ;
  posInfo += 1 ;
  text("Directional light TWO || pos " + PApplet.parseInt(pos_light[2].x)+ " / " + PApplet.parseInt(pos_light[2].y) + " / "+ PApplet.parseInt(pos_light[2].z) + " || dir " + decimale(dir_light[2].x,2) + " / " + decimale(dir_light[2].y,2) + " / "+ decimale(dir_light[2].z,2),15, 15 *posInfo  ) ;
  posInfo += 1 ;
  //INFO SOUND
  if (get_time_track() > 1 ) text("the track play until " +get_time_track() + " – tempo " + get_tempo_name() + " " + get_tempo() , 15,15 *(posInfo)) ; else text("no track detected ", 15, 15 *(posInfo)) ;
  posInfo += 1 ;
  text("right " + get_right(100), 15, 15 *(posInfo)) ;  
  text("left "  + get_left(100),  50, 15 *(posInfo)) ;
  posInfo += 1 ;
}


int posInfoObj = 1 ;
public void show_info_item(int color_bg, int color_text) {
  noStroke() ;
  fill(color_bg) ;
  rectMode(CORNER) ;
  textAlign(LEFT) ;
  float heightBox = 15*posInfoObj ;
  rect(0, height -heightBox,width, heightBox) ;
  fill(color_text) ;
  textFont(system_font,10);
  
  posInfoObj = 1 ;
  for(int i = 0 ; i < NUM_ITEM_PLUS_MASTER ; i++) {
    Romanesco item = rom_manager.get(i);
    if(item != null) {
      if(item.show_is()) {
        posInfoObj += 1 ;
        String position = ("x:" +(int)pos_item[i].x + " y:" + (int)pos_item[i].y+ " z:" + (int)pos_item[i].z) ;
        text(item_name[i] + " - Coord " + position + " - " + item_info[item_ID[i]], 10, height -(15 *(posInfoObj -1))) ;
      }
    }   
  }
}











//INFO 3D
public void show_info_camera(int txt) {
  String posCam = ( PApplet.parseInt(-1 *sceneCamera.x ) + " / " + PApplet.parseInt(sceneCamera.y) + " / " +  PApplet.parseInt(sceneCamera.z -height/2));
  String eyeDirectionCam = (PApplet.parseInt(eyeCamera.x) + " / " + PApplet.parseInt(eyeCamera.y));
  fill(txt); 
  textFont(system_font,10);
  textAlign(RIGHT);
  text("Position " +posCam, width/2 -30 , height/2 -30);
  text("Direction " +eyeDirectionCam, width/2 -30 , height/2 -15);
}


//REPERE 3D
public void repere(int size, PVector pos, String name) {
  pushMatrix() ;
  translate(pos.x +20 , pos.y -20, pos.z) ;
  fill(blanc) ;
  text(name, 0,0) ;
  popMatrix() ;
  line(-size +pos.x,pos.y, pos.z,size +pos.x, pos.y, pos.z) ;
  line(pos.x,-size +pos.y, pos.z, pos.x,size +pos.y, pos.z) ;
  line(pos.x, pos.y,-size +pos.z, pos.x, pos.y,size +pos.z) ;
}

//repere cross
public void repere(int size) {
  line(-size,0,0,size,0,0) ;
  line(0,-size,0,0,size,0) ;
  line(0,0,-size,0,0,size) ;
}












/**
SOUND
v 1.4.0
*/
Sounda sounda;
int [] transient_section_id;

public void sound_setup() {
  int length_analyze = 512 ;
  sounda = new Sounda(length_analyze);

  float scale_spectrum_sound = .11f ;
  sounda.set_spectrum(NUM_BANDS, scale_spectrum_sound);

  int len = sounda.buffer_size();
  int section_1 = len/8 ;
  int section_2 = len/3 ;
  int section_3 = len - (len/6);
  set_section_analyze(section_1,section_2,section_3);
  set_transient();
  sounda.set_tempo();
}

public void sound_draw() {
  // setting
  sounda.audio_buffer(r.MIX);
  update_volume_setting();
  update_section_setting();
  update_transient_setting();
  // update
  sounda.update_spectrum(true);
  transient_romanesco();
  spectrum_romaneco();
  tempo_romanesco();
  
  /*
  println("in out 0",sounda.get_section_in(0),sounda.get_section_out(0));
  println("in out 1",sounda.get_section_in(1),sounda.get_section_out(1));
  println("in out 2",sounda.get_section_in(2),sounda.get_section_out(2));
  println("in out 3",sounda.get_section_in(3),sounda.get_section_out(3));
  */
  
}

















/**
ROMANESCO SOUND DRAW
*/
public void tempo_romanesco() {
  tempo[0] = sounda.get_tempo();
  tempoKick[0] = sounda.get_tempo();
  tempoSnare[0] = sounda.get_tempo();
  tempoHat[0] = sounda.get_tempo();
}

public void spectrum_romaneco() {
  for (int i = 0 ; i < sounda.spectrum_size() ; i++ ) {
    band[0][i] = sounda.get_spectrum(i);
  }
}

public void transient_romanesco() {
  int max_transient_value = 10 ;
  float back_factor = .95f;
  // transient global
  boolean transient_global_is = false; 
  for(int i = 1 ; i < transient_button_is.length ; i++) {
    if(transient_button_is(i)) {
      transient_global_is = true;
      break;
    }
  }
  if(transient_global_is && sounda.transient_is()) {    
    transient_value[0][0] = max_transient_value;
  } else {
    transient_value[0][0] *= back_factor;
  }

  // give catch value `0` from the lib because here we use `0` for the master transient
  for(int i = 1 ; i < transient_button_is.length ; i++) {
    if(transient_button_is(i) && sounda.transient_is(i-1)) {
      transient_value[i][0] = max_transient_value;   
    } else {
      transient_value[i][0] *= back_factor;
    }
  }
}


public boolean transient_is(int index) {
  boolean is = false ;
  if(index > 0 && index < sounda.section_size()) {
    is = sounda.transient_is(index);
  } else if(index == 0) {
    for(int i = 0 ; i < sounda.section_size() ;i++) {
      if(sounda.transient_is(i)) {
        is = sounda.transient_is(i);
        break;
      }
    }
  }
  if(index >= sounda.section_size()) {
    printErr("method transient_is():",index,"is out of sounda.section_size()");
  }
  return is;
}

















/**
UPDATE SETTING SOUND
*/
public void update_section_setting() {
  int cut_section_1 = (int)map(value_slider_sound_setting[0],0,360,0,sounda.buffer_size());
  int cut_section_2 = (int)map(value_slider_sound_setting[1],0,360,0,sounda.buffer_size());
  int cut_section_3 = (int)map(value_slider_sound_setting[2],0,360,0,sounda.buffer_size());
  set_section_analyze(cut_section_1,cut_section_2,cut_section_3);
}

public void update_transient_setting() {
  vec2 [] transient_threshold = new vec2[4];
  for(int i = 0 ; i < transient_threshold.length ; i++) {
    int index = i*2;
    float threshold_low = map(value_slider_sound_setting[index+3],0,360,4,0);
    float threshold_high = map(value_slider_sound_setting[index+4],0,360,4,0);
    transient_threshold[i] = vec2(threshold_low,threshold_high);
    sounda.set_transient(i,transient_threshold[i]);
  }
}

public void update_volume_setting() {
  float vol_left_controller = map(value_slider_sound[0],0,MAX_VALUE_SLIDER,0,1.3f);
  left[0] = map(sounda.get_left(),-.07f,.1f,0,vol_left_controller);
  
  float col_right_controller = map(value_slider_sound[1],0,MAX_VALUE_SLIDER,0,1.3f);
  right[0] = map(sounda.get_right(),-.07f,.1f,0,col_right_controller);
  
  float vol_mix = map(((value_slider_sound[0] +value_slider_sound[1]) *.5f),0,MAX_VALUE_SLIDER,0,1.3f);
  mix[0] = map(sounda.get_mix(),  -.07f,.1f,0,vol_mix);
  
  //volume
  if(left[0] < 0 ) left[0] = 0;
  if(left[0] > 1 ) left[0] = 1.f; 
  if(right[0] < 0 ) right[0] = 0;
  if(right[0] > 1 ) right[0] = 1.f; 
  if(mix[0] < 0 ) mix[0] = 0;
  if(mix[0] > 1 ) mix[0] = 1.f;
}













/**
SET
*/
public void set_section_analyze(int... section_entry) {
  int len = sounda.buffer_size();
  int num_part = section_entry.length +1;
  ivec2 [] in_out = new ivec2[num_part];
  int part = len/(num_part*2);
  in_out[0] = ivec2(0,section_entry[0]); 
  in_out[1] = ivec2(section_entry[0],section_entry[1]);
  in_out[2] = ivec2(section_entry[1],section_entry[2]);
  in_out[3] = ivec2(section_entry[2],len);
  sounda.set_section(in_out);
}

public void set_transient() {
  vec2 [] transient_part_threshold = new vec2[sounda.section_size()];
  transient_part_threshold[0] = vec2(.1f, 2.5f);
  transient_part_threshold[1] = vec2(.1f, 2.5f);
  transient_part_threshold[2] = vec2(.1f, 2.5f);
  transient_part_threshold[3] = vec2(.1f, 2.5f);

  sounda.init_transient(transient_part_threshold);
  sounda.set_transient_low_pass(20);     
  sounda.set_transient_smooth_slow(3.f);
  sounda.set_transient_smooth_fast(21.f);
  sounda.set_transient_ratio_log(100,50,40,30); 
  sounda.set_transient_threshold_low(.05f,.08f,.12f,.16f);
  sounda.set_transient_threshold_high(.8f,.3f,.25f,.20f);
}
















/**
GET
*/
public int band_length() {
  return band[0].length;
}

public float get_time_track() {
  if(sounda != null) {
    return sounda.get_time_track();
  } else {
    float f = Float.NaN ;
    return f;
  }
}

public boolean sound_is() {
  return sounda.sound_is();
}

public float get_right(int target_sample) {
  return sounda.get_right(target_sample);
}

public float get_left(int target_sample) {
  return sounda.get_left(target_sample);
}

public float get_mix(int target_sample) {
  return sounda.get_mix(target_sample);
}


public String get_tempo_name() {
  return sounda.get_tempo_name();
} 

public int get_tempo() {
  return sounda.get_tempo();
}
/**
Script
v 0.0.3
2018-2018
*/



public class Script {
  ArrayList <ArrayList> data_list;

  ArrayList <Data_boolean> data_boolean;
  ArrayList <Data_int> data_int;
  ArrayList <Data_float> data_float;
  ArrayList <Data_long> data_long;
  ArrayList <Data_String> data_String;
  ArrayList <Data_ivec> data_ivec;
  ArrayList <Data_vec> data_vec;


  long time_millis;
  Timestamp timestamp;
  public Script(){
    time_millis = new Date().getTime();
    timestamp = new Timestamp(time_millis);
    data_list = new ArrayList<ArrayList>();

    data_boolean = new ArrayList<Data_boolean>();
    data_int = new ArrayList<Data_int>();
    data_float = new ArrayList<Data_float>();
    data_long = new ArrayList<Data_long>();
    data_String = new ArrayList<Data_String>();
    data_ivec = new ArrayList<Data_ivec>();
    data_vec = new ArrayList<Data_vec>();

    data_list.add(data_boolean);
    data_list.add(data_int);
    data_list.add(data_float);
    data_list.add(data_long);
    data_list.add(data_String);
    data_list.add(data_ivec);
    data_list.add(data_vec);


  }



  /**
  get data
  */
    /**
  get
  */
  public String get_timestamp() {
    String s = ""+timestamp;
    return s;
  }

  public long get_time() {
    return time_millis;
  }

  public Object get(String name, String family) {
    
    Object result = null ;
    for(ArrayList list : data_list) {
      if(list != null) {
        for(Object obj : list) {
          boolean is = false;
          if(obj instanceof Data) {
            Data d = (Data)obj;
            if(d.get_name().equals(name) && d.get_family().equals(family)) {
              is = true;
            }
          }

          //
          if(obj instanceof Data_boolean) {
            Data_boolean d = (Data_boolean)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_int) {
            Data_int d = (Data_int)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_float) {
            Data_float d = (Data_float)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_long) {
            Data_long d = (Data_long)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_String) {
            Data_String d = (Data_String)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_ivec) {
            Data_ivec d = (Data_ivec)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else if(obj instanceof Data_vec) {
            Data_vec d = (Data_vec)obj;
            if(is) {
              result = d.get();
              break;
            }
          } else {
            break;
          }
        }
      }
    }
    return result;
  }


  

  /**
  add part
  */
  public void add(Object arg) {
    add("nobody","unknow",arg);
  }

  public void add(String name, Object arg) {
    add(name,"unknow",arg);
  }

  public void add(String name, String family, Object arg) {
    if(arg instanceof Boolean) add_boolean(name,family,(boolean)arg);
    else if(arg instanceof Float) add_float(name,family,(float)arg);
    else if(arg instanceof Integer) add_int(name,family,(int)arg);
    else if(arg instanceof Long) add_long(name,family,(long)arg);
    else if(arg instanceof String) add_String(name,family,(String)arg);
    else if(arg instanceof ivec) add_ivec(name,family,(ivec)arg);
    else if(arg instanceof vec) add_vec(name,family,(vec)arg);
  }
  
  public void add(Object... f) {
    for(int i = 0 ; i < f.length ; i++) {
      add("nobody",f[i]);
    }
  }

  private void add_boolean(String name, String family, boolean arg) {
    Data_boolean data = new Data_boolean(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(0).add(data);
  }
  private void add_int(String name, String family, int arg) {
    Data_int data = new Data_int(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(1).add(data);
  }

  private void add_float(String name, String family, float arg) {
    Data_float data = new Data_float(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(2).add(data);
  }

  private void add_long(String name, String family, long arg) {
    Data_long data = new Data_long(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(3).add(data);
  }

  private void add_String(String name, String family, String arg) {
    Data_String data = new Data_String(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(4).add(data);
  }

  private void add_ivec(String name, String family, ivec arg) {
    Data_ivec data = new Data_ivec(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(5).add(data);
  }
  
  private void add_vec(String name, String family, vec arg) {
    Data_vec data = new Data_vec(arg);
    data.set_name(name);
    data.set_family(family);
    data_list.get(6).add(data);
  }

  /**
  class DATA
  */
  private abstract class Data {
    private String name;
    private String family;



    public void set_name(String name) {
      this.name = name;
    }

    public void set_family(String family) {
      this.family = family;
    }

    public String get_name() {
      return name;
    }

    public String get_family() {
      return family;
    }
  }
  
  private class Data_boolean extends Data {
    private boolean arg;
    private Data_boolean(boolean arg) {
      super();
      this.arg = arg;
    }
    protected boolean get() {
      return arg;
    }
  }

  private class Data_int extends Data {
    private int arg;
    private Data_int(int arg) {
      super();
      this.arg = arg;
    }
    protected int get() {
      return arg;
    }
  }

  private class Data_float extends Data {
    private float arg;
    private Data_float(float arg) {
      super();
      this.arg = arg;
    }

    protected float get() {
      return arg;
    }
  }

  private class Data_long extends Data {
    private long arg;
    private Data_long(long arg) {
      super();
      this.arg = arg;
    }

    protected long get() {
      return arg;
    }
  }

  private class Data_String extends Data {
    private String arg;
    private Data_String(String arg) {
      super();
      this.arg = arg;
    }

    protected String get() {
      return arg;
    }
  }

  private class Data_ivec extends Data {
    private ivec arg;
    private Data_ivec( ivec arg) {
      super();
      if(arg instanceof ivec2) {
        this.arg = ((ivec2)arg).copy();
      } else if(arg instanceof ivec3) {
        this.arg = ((ivec3)arg).copy();
      } else if(arg instanceof ivec4) {
        this.arg = ((ivec4)arg).copy();
      } else if(arg instanceof ivec5) {
        this.arg = ((ivec5)arg).copy();      
      } else if(arg instanceof ivec6) {
        this.arg = ((ivec6)arg).copy();
      }
    }

    protected ivec get() {
      return arg;
    }
  }


  private class Data_vec extends Data {
    private vec arg;
    private Data_vec(vec arg) {
      super();
      //this.arg = Vec(arg);
      if(arg instanceof vec2) {
        this.arg = ((vec2)arg).copy();
      } else if(arg instanceof vec3) {
        this.arg = ((vec3)arg).copy();
      } else if(arg instanceof vec4) {
        this.arg = ((vec4)arg).copy();
      } else if(arg instanceof vec5) {
        this.arg = ((vec5)arg).copy();        
      } else if(arg instanceof vec6) {
        this.arg = ((vec6)arg).copy();
      }
    }

    protected vec get() {
      return arg;
    }
  }
}
/**
* History manage class Script
2018-2018
v 0.0.1
*/
public class History {
  private ArrayList<Script>history;
  private int max = 1;

  public History() {
    history = new ArrayList<Script>();
  }

  public History(int max) {
    this.max = max;
    history = new ArrayList<Script>();
  }

  public void set_max(int max) {
    this.max = max;
  }

  public int size() {
    return history.size();
  }

  public void clear() {
    history.clear();
  }

  public void remove(int target) {
    if(target >= 0 && target < history.size()) {
      history.remove(target);
    }
  }

  public void add(Script script) {
    history.add(script);
    if(history.size() > max) history.remove(0);
  }

  public ArrayList<Script> get() {
    return history;
  }

  public Script get(int target) {
    target = history.size() - target -1;
    if(target < 0) target = 0;
    return history.get(target);
  }
}
/**
* VARIABLE
* 2015-2019
* v 1.11.1
*/
boolean scene, prescene;
boolean miroir_on_off = false;

boolean check_size = false;

// In the Miroir and Scene sketch presceneOnly must be true for the final work.
Boolean internet = true;
String bigBrother = ("BIG BROTHER DON'T WATCHING YOU !!");

//init var
//GLOBAL
public void scene_variables_setup() {
  for (int i = 0 ; i < data_osc_prescene.length ; i++) {
    data_osc_prescene[i] = ("0");
  }
  
  for (int i = 0 ; i < NUM_ITEM ; i++ ) {
    pen[i] = vec3();
    mouse[i] = vec3();
    wheel[i] = 0;
  }
  println("Rendering variables setup done");
}
















/**
GLOBAL VARIABLE
*/
/**
keyboard
*/
//short _key
boolean key_a, key_b, key_c, key_d, key_e, key_f, key_g, key_h, key_i, key_j, key_k, key_l, key_m, key_n, key_o, key_p, key_q, key_r, key_s, key_t, key_u, key_v, key_w, key_x, key_y, key_z;
boolean key_A, key_B, key_C, key_D, key_E, key_F, key_G, key_H, key_I, key_J, key_K, key_L, key_M, key_N, key_O, key_P, key_Q, key_R, key_S, key_T, key_U, key_V, key_W, key_X, key_Y, key_Z;
boolean key_left, key_right, key_up, key_down; 
boolean key_0, key_1, key_2, key_3, key_4, key_5, key_6, key_7, key_8, key_9;
boolean key_space, key_backspace, key_delete, key_enter, key_return, key_shift, key_alt, key_esc, key_ctrl, key_cmd;
//long touch
boolean key_c_long, key_l_long, key_n_long, key_v_long;
boolean key_space_long, key_shift_long; 

String data_osc_prescene[] = new String [135]; 



//to pass processing in an embeded class, you must call the PApplet too in your class
PApplet papplet = this ;
// use for the border of window (top and right)
java.awt.Insets insets; 


boolean OPEN_APP = false;
// WINDOW VAR
int MIN_WINDOW_WIDTH = 128; 
int MIN_WINDOW_HEIGHT = 128;

int scene_width,scene_height;

// Max value whi is return from the slider controller
int MAX_VALUE_SLIDER = 360;





//spectrum for the color mode and more if you need
vec4 HSBmode = new vec4 (360,100,100,100) ; // give the color mode in HSB
//path to open the controleur
String findPath ; 

// MOUSE DETECTION
// return if the cursor (mouse) is in the sketch or not
boolean MOUSE_IN_OUT = true ;


// BOOLEAN COMMAND
// command from leap motion, mouse or other devices if we code for that :)
boolean ORDER, ORDER_ONE, ORDER_TWO, ORDER_THREE ;
boolean LEAPMOTION_DETECTED ;


//spectrum band
int NUM_BANDS = 128;

int button_item_num  ; 
// VAR item
int COLOR_FILL_ITEM_PREVIEW; 
int COLOR_STROKE_ITEM_PREVIEW;
int THICKNESS_ITEM_PREVIEW = 2;
int NUM_ITEM;
int NUM_ITEM_PLUS_MASTER;
int NUM_SETTING_ITEM;
int BUTTON_ITEM_CONSOLE = 4;


// button
boolean [] transient_button_is;
boolean [] fx_button_is = new boolean[NUM_BUTTON_FX];
boolean curtain_button_is;
boolean reset_camera_button_is;
boolean reset_item_on_button_is;
boolean reset_fx_button_is;
boolean birth_button_is;
boolean dimension_button_is;
boolean background_button_is;
boolean ambient_button_is,ambient_action_is;
boolean light_1_button_is,light_1_action_button_is;
boolean light_2_button_is,light_2_action_button_is;

int which_shader;
int which_fx; 


// media
int [] which_bitmap, which_text, which_shape, which_movie;

String [] bitmap_path_ref, svg_path_ref;

Movie[] movie;

//SLIDER
// becareful if the number of MISC SLIDERS is upper than OBJ SLIDER, that can be a problem in the future.
float value_slider_background [] = new float [NUM_MOLETTE_BACKGROUND];
float value_slider_fx [] = new float [NUM_MOLETTE_FX];
float value_slider_light [] = new float [NUM_MOLETTE_LIGHT];
float value_slider_sound [] = new float [NUM_MOLETTE_SOUND];
float value_slider_sound_setting [] = new float [NUM_MOLETTE_SOUND_SETTING];
float value_slider_camera [] = new float [NUM_MOLETTE_CAMERA];
float value_slider_item []  = new float [NUM_MOLETTE_ITEM];






/**
Var item
*/
//MISC var
//info object
String [] item_info, item_name, item_author, item_version, item_pack;
int [] item_ID;
boolean [] item_info_display;
//for the leap motion ?
int objectLeapID[];
//BUTTON CONTROLER
boolean objectParameter[];

//raw
float fill_hue_raw, fill_sat_raw, fill_bright_raw, fill_alpha_raw;
float stroke_hue_raw, stroke_sat_raw, stroke_bright_raw, stroke_alpha_raw;
float thickness_raw; 
float size_x_raw, size_y_raw, size_z_raw;
float canvas_x_raw, canvas_y_raw, canvas_z_raw;
float diameter_raw;

float frequence_raw;
float speed_x_raw, speed_y_raw, speed_z_raw;
float spurt_x_raw, spurt_y_raw, spurt_z_raw;
float dir_x_raw, dir_y_raw, dir_z_raw;
float jitter_x_raw, jitter_y_raw, jitter_z_raw;
float swing_x_raw, swing_y_raw, swing_z_raw;

float quantity_raw, variety_raw; 
float life_raw, flow_raw, quality_raw;

float area_raw, angle_raw, scope_raw, scan_raw;
float alignment_raw, repulsion_raw, attraction_raw, density_raw;

float influence_raw, calm_raw, spectrum_raw;

float grid_raw;
float viscosity_raw, diffusion_raw;
float power_raw;
float mass_raw;
float coord_x_raw, coord_y_raw, coord_z_raw;


// ref value
float fill_hue_ref, fill_sat_ref, fill_bright_ref, fill_alpha_ref;
float stroke_hue_ref, stroke_sat_ref, stroke_bright_ref, stroke_alpha_ref;
float thickness_ref; 
float size_x_ref, size_y_ref, size_z_ref;
float diameter_ref;
float canvas_x_ref, canvas_y_ref, canvas_z_ref;
// col B
float frequence_ref;
float speed_x_ref, speed_y_ref, speed_z_ref;
float spurt_x_ref, spurt_y_ref, spurt_z_ref;
float dir_x_ref,dir_y_ref,dir_z_ref;
float jitter_x_ref, jitter_y_ref, jitter_z_ref;
float swing_x_ref, swing_y_ref, swing_z_ref;
// col C
float quantity_ref, variety_ref;
float life_ref, flow_ref, quality_ref;
float area_ref, angle_ref, scope_ref, scan_ref;

float alignment_ref, repulsion_ref, attraction_ref, density_ref;
float influence_ref, calm_ref, spectrum_ref;
// col D
float grid_ref;
float viscosity_ref, diffusion_ref;

float power_ref;
float mass_ref;
float coord_x_ref,coord_y_ref,coord_z_ref;


/**
String name
Used for SCENE don't delete
*/
String fill_hue_name = "fill_hue";     
String fill_sat_name = "fill_sat";     
String fill_bright_name= "fill_bright";     
String fill_alpha_name = "fill_alpha";

String stroke_hue_name = "stroke_hue"; 
String stroke_sat_name = "stroke_sat"; 
String stroke_bright_name= "stroke_bright"; 
String stroke_alpha_name = "stroke_alpha";

String thickness_name = "thickness"; 

String size_x_name = "size_x";     
String size_y_name = "size_y";     
String size_z_name = "size_z";

String diameter_name = "diameter";

String canvas_x_name = "canvas_x"; 
String canvas_y_name = "canvas_y"; 
String canvas_z_name = "canvas_z";

String frequence_name = "frequence" ;

String speed_x_name = "speed_x"; 
String speed_y_name = "speed_y"; 
String speed_z_name = "speed_z";

String spurt_x_name = "spurt_x"; 
String spurt_y_name= "spurt_y"; 
String spurt_z_name = "spurt_z";

String dir_x_name = "dir_x"; 
String dir_y_name = "dir_y"; 
String dir_z_name = "dir_z";

String jitter_x_name = "jitter_x"; 
String jitter_y_name = "jitter_y"; 
String jitter_z_name = "jitter_z";

String swing_x_name = "swing_x"; 
String swing_y_name = "swing_y"; 
String swing_z_name = "swing_z";

String quantity_name = "quantity"; 
String variety_name = "variety"; 

String life_name = "life"; 
String flow_name = "flow"; 
String quality_name = "quality";

String area_name = "area"; 
String angle_name = "angle"; 
String scope_name = "scope"; 
String scan_name = "scan";

String alignment_name = "alignment"; 
String repulsion_name = "repulsion"; 
String attraction_name = "attraction"; 
String density_name = "density";

String influence_name = "influence"; 
String calm_name = "calm"; 
String spectrum_name = "spectrum";

String grid_name = "grid"; 
String viscosity_name = "viscosity"; 
String diffusion_name = "diffusion";

String power_name = "power"; 
String mass_name = "mass";

String pos_x_name = "pos_x"; 
String pos_y_name = "pos_y"; 
String pos_z_name = "pos_z";






































// item target final
boolean [] first_opening_item; // used to check if this object is already opening before
vec4 [] fill_item_ref,stroke_item_ref;



//BUTTON
int [] value_button_item;

//position
vec3 [] pos_item_final;
vec3 [] pos_item;
vec3 [] pos_item_ref;


// direction
boolean [] reset_camera_direction_item;
vec3 [] temp_item_canvas_direction;
vec3 [] dir_item;
vec3 [] dir_item_final;
vec3 [] dir_item_ref;

// master and follower
int [] master_ID;
boolean [] follower;
//setting and save
int NUM_SETTING_CAMERA;
int numSettingOrientationObject = 1;
vec3 [][] item_setting_position;
vec3 [][] item_setting_direction;
vec3 [] eyeCameraSetting, sceneCameraSetting;

//position of object and wheel
vec3 [] mouse, pen;
boolean [] clickShortLeft, clickShortRight, clickLongLeft, clickLongRight;
int wheel[];


//font
ROFont current_font;
















//MISC
//var to init the data of the object when is switch ON for the first time
boolean [] init_value_mouse, init_value_controller;
//parameter for the super class
float [] left,right,mix;
// transient
float [][] transient_value;
// spectrum
float band[][];
//tempo
float [] tempo, tempoBeat, tempoKick, tempoSnare, tempoHat;
























/**
CREATE VAR 
v 1.1.0
*/
public void create_variable() {
  NUM_ITEM = rom_manager.size();
  NUM_ITEM_PLUS_MASTER = NUM_ITEM +1;

  NUM_SETTING_ITEM = 1;
  NUM_SETTING_CAMERA = 1;

  create_var_misc();
  create_var_sound();

  create_var_P3D(NUM_SETTING_CAMERA);
  create_var_cursor();
  create_var_item_slider();
  create_var_item_manipulation(NUM_SETTING_ITEM);

  println("variables setup done");
}

// misc var
public void create_var_misc() {
  objectLeapID = new int[NUM_ITEM_PLUS_MASTER];
  item_info_display = new boolean[NUM_ITEM_PLUS_MASTER];

  // IMAGE
  bitmap = new PImage[NUM_ITEM_PLUS_MASTER];
  which_bitmap = new int[NUM_ITEM_PLUS_MASTER];
  bitmap_path_ref = new String[NUM_ITEM_PLUS_MASTER];
  // SVG
  svg_import = new ROPE_svg[NUM_ITEM_PLUS_MASTER];
  which_shape = new int[NUM_ITEM_PLUS_MASTER];
  svg_path_ref = new String[NUM_ITEM_PLUS_MASTER];

  // Movie
  movie = new Movie[NUM_ITEM_PLUS_MASTER];
  // moviePath = new String[NUM_ITEM_PLUS_MASTER];
  which_movie = new int[NUM_ITEM_PLUS_MASTER];
  //movie_path_ref = new String[NUM_ITEM_PLUS_MASTER];
  // TEXT
  text_import = new String [NUM_ITEM_PLUS_MASTER];
  which_text = new int[NUM_ITEM_PLUS_MASTER];


  //MISC
  //var to init the data of the object when is switch ON for the first time
  init_value_mouse = new boolean [NUM_ITEM_PLUS_MASTER];
  init_value_controller = new boolean [NUM_ITEM_PLUS_MASTER];
}





// var cursor
public void create_var_cursor() {
  //position of object and wheel
   mouse  = new vec3[NUM_ITEM_PLUS_MASTER];
   clickShortLeft = new boolean [NUM_ITEM_PLUS_MASTER];
   clickShortRight = new boolean [NUM_ITEM_PLUS_MASTER];
   clickLongLeft = new boolean [NUM_ITEM_PLUS_MASTER];
   clickLongRight = new boolean [NUM_ITEM_PLUS_MASTER];
   wheel = new int [NUM_ITEM_PLUS_MASTER];
  //pen info
   pen = new vec3[NUM_ITEM_PLUS_MASTER];
}




// P3D
public void create_var_P3D(int num_setting_camera) {
   // setting and save
   eyeCameraSetting = new vec3 [num_setting_camera];
   sceneCameraSetting = new vec3 [num_setting_camera];
   
   reset_camera_direction_item = new boolean[NUM_ITEM_PLUS_MASTER];
   pos_item_ref = new vec3[NUM_ITEM_PLUS_MASTER];
   pos_item = new vec3[NUM_ITEM_PLUS_MASTER];
   dir_item = new vec3[NUM_ITEM_PLUS_MASTER];
}

public void create_var_sound() {
  // volume 
   left = new float [NUM_ITEM_PLUS_MASTER];
   right = new float [NUM_ITEM_PLUS_MASTER];
   mix  = new float [NUM_ITEM_PLUS_MASTER];
   // transient
   transient_button_is = new boolean[5];
   transient_value = new float[5][NUM_ITEM_PLUS_MASTER]; // beat[ID_item]
   // spectrum
   band = new float [NUM_ITEM_PLUS_MASTER][NUM_BANDS];
   // tempo
   tempo = new float [NUM_ITEM_PLUS_MASTER];
   tempoBeat = new float [NUM_ITEM_PLUS_MASTER];
   tempoKick = new float [NUM_ITEM_PLUS_MASTER];
   tempoSnare = new float [NUM_ITEM_PLUS_MASTER];
   tempoHat = new float [NUM_ITEM_PLUS_MASTER];
}



public void create_var_item_manipulation(int num_item_setting) {
  pos_item_final = new vec3 [NUM_ITEM_PLUS_MASTER] ;
  item_setting_position = new vec3 [num_item_setting] [NUM_ITEM_PLUS_MASTER];

  dir_item_final = new vec3 [NUM_ITEM_PLUS_MASTER];
  dir_item_ref = new vec3 [NUM_ITEM_PLUS_MASTER];
  temp_item_canvas_direction = new vec3 [NUM_ITEM_PLUS_MASTER];
  item_setting_direction = new vec3 [num_item_setting] [NUM_ITEM_PLUS_MASTER];

  // master and follower
  master_ID = new int[NUM_ITEM_PLUS_MASTER];
  follower = new boolean[NUM_ITEM_PLUS_MASTER];
}  

public void create_var_item_slider() {
  first_opening_item = new boolean[NUM_ITEM_PLUS_MASTER] ; // used to check if this object is already opening before
  fill_item_ref = new vec4[NUM_ITEM_PLUS_MASTER];
  stroke_item_ref = new vec4[NUM_ITEM_PLUS_MASTER];
}

















/**
INIT VAR 
*/
public void init_variable_item_min_max() {
  float ratio_min_deci = .1f;
  float ratio_min_centi = .01f;
  float ratio_min_milli = .001f;
  float ratio_max = TAU;

  float min_size = .1f;
  float max_size = width;
  
  for(Romanesco item : rom_manager.get()) {
    // COL 1
    item.set_fill_hue_min_max(0,MAX_VALUE_SLIDER,0,360);
    item.set_fill_sat_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.sat());
    item.set_fill_bright_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.bri());
    item.set_fill_alpha_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.alp());

    item.set_stroke_hue_min_max(0,MAX_VALUE_SLIDER,0,360);
    item.set_stroke_sat_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.sat());
    item.set_stroke_bright_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.bri());
    item.set_stroke_alpha_min_max(0,MAX_VALUE_SLIDER,0,HSBmode.alp());

    item.set_thickness_min_max(0,MAX_VALUE_SLIDER,min_size,max_size *ratio_min_centi);
    item.set_size_x_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_milli,max_size);
    item.set_size_y_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_milli,max_size);
    item.set_size_z_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_milli,max_size);
    item.set_diameter_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_milli,max_size);

    item.set_canvas_x_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci,max_size *ratio_max);
    item.set_canvas_y_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci,max_size *ratio_max);
    item.set_canvas_z_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci,max_size *ratio_max);
    // COL 2
    item.set_frequence_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_speed_x_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_speed_y_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_speed_z_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_spurt_x_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_spurt_y_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_spurt_z_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_dir_x_min_max(0,MAX_VALUE_SLIDER,0,TAU);
    item.set_dir_y_min_max(0,MAX_VALUE_SLIDER,0,TAU);
    item.set_dir_z_min_max(0,MAX_VALUE_SLIDER,0,TAU);

    item.set_jitter_x_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_jitter_y_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_jitter_z_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_swing_x_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_swing_y_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_swing_z_min_max(0,MAX_VALUE_SLIDER,0,1);
    // COL 3
    item.set_quantity_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_variety_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_life_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_flow_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_quality_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_area_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci, max_size *ratio_max);
    item.set_angle_min_max(0,MAX_VALUE_SLIDER,0,TAU);
    item.set_scope_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci, max_size *ratio_max);
    item.set_scan_min_max(0,MAX_VALUE_SLIDER,0,TAU);

    item.set_alignment_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_repulsion_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_attraction_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_density_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_influence_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_calm_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_spectrum_min_max(0,MAX_VALUE_SLIDER,0,360);
    // COL 4
    item.set_grid_min_max(0,MAX_VALUE_SLIDER,max_size *ratio_min_deci, max_size *ratio_max);
    item.set_viscosity_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_diffusion_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_power_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_mass_min_max(0,MAX_VALUE_SLIDER,0,1);

    item.set_coord_x_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_coord_y_min_max(0,MAX_VALUE_SLIDER,0,1);
    item.set_coord_z_min_max(0,MAX_VALUE_SLIDER,0,1);
  }
}


// init var item
public void init_variable_item() {
  for (int i = 0 ; i < NUM_ITEM_PLUS_MASTER ; i++ ) {
    // master follower
    master_ID[i] = 0;
    follower[i] = false;

    reset_camera_direction_item[i] = true;
    temp_item_canvas_direction[i] = vec3();
    pen[i] = vec3();
    // use the 250 value for "z" to keep the position light on the front
    mouse[i] = vec3();
    wheel[i] = 0;
  
    Romanesco item = rom_manager.get(i);
    if(item != null) {
      item.init();
      item.set_size_raw(width *.5f);
      item.set_diameter_raw(10);
      item.set_canvas_raw(width);

      item.set_frequence_raw(0);

      item.set_speed_raw(0);
      item.set_spurt_raw(0);
      item.set_dir_raw(0);
      item.set_jitter_raw(0);
      item.set_swing_raw(0);

      item.set_quantity_raw(.1f);
      item.set_variety_raw(0);
      item.set_life_raw(.1f);
      item.set_flow_raw(0);
      item.set_quality_raw(.1f);

      item.set_area_raw(width);
      item.set_angle_raw(0);
      item.set_scope_raw(width);
      item.set_scan_raw(PI/2);

      item.set_alignment_raw(0);
      item.set_repulsion_raw(0);
      item.set_attraction_raw(0);
      item.set_density_raw(0);

      item.set_influence_raw(0);
      item.set_calm_raw(0);
      item.set_spectrum_raw(0);

      item.set_grid_raw(width);
      item.set_viscosity_raw(0);
      item.set_diffusion_raw(0);
      item.set_power_raw(0);
      item.set_mass_raw(0);
      item.set_coord_raw(0);
    }
   
  }
    // init global var for the color obj preview mode display
  COLOR_FILL_ITEM_PREVIEW = color(0,0,100,30); 
  COLOR_STROKE_ITEM_PREVIEW = color(0,0,100,30);
}



public boolean items_loaded_is() {
  return rom_manager.init_items();
}


public void init_slider_variable_world() {
  // value from 0 to 360
  // camera setting default before loading data
  value_slider_camera[0] = 100; // lens
  value_slider_camera[1] = 180;
  value_slider_camera[2] = 180;
  value_slider_camera[3] = 180;
  value_slider_camera[4] = 180;
  value_slider_camera[5] = 180;
  value_slider_camera[6] = 180;
  value_slider_camera[7] = 20; // speed rotation
  value_slider_camera[8] = 20; // speed move
  // background
  value_slider_background[0] = g.colorModeX;
  value_slider_background[1] = g.colorModeY;
  value_slider_background[2] = 0;
  value_slider_background[3] = g.colorModeA;
}















/**
button general var setting
*/
/**
ALERT BUTTON
*this button must became false immetiatly after using
*/
// general button alert
public boolean reset_camera_button_alert_is() {
  return reset_camera_button_is;
}

public boolean reset_item_on_button_alert_is() {
  return reset_item_on_button_is;
}

public boolean reset_fx_button_alert_is() {
  return reset_fx_button_is;
}

// misc
public boolean birth_button_alert_is() {
  return birth_button_is;
}

public boolean dimension_button_alert_is() {
  return dimension_button_is;
}


// set boolean button alert
// reset
public void reset_camera_button_alert_is(boolean is) {
  reset_camera_button_is = is;
}

public void reset_item_on_button_alert_is(boolean is) {
  reset_item_on_button_is = is;
}

public void reset_fx_button_alert_is(boolean is) {
  reset_fx_button_is = is;
}

// misc
public void birth_button_alert_is(boolean is) {
  birth_button_is = is;
}

public void dimension_button_alert_is(boolean is) {
  dimension_button_is = is;
}


// set false button alert
boolean button_alert_is = false;
public void reset_button_alert() {
  if(reset_camera_button_alert_is() && button_alert_is) {
    reset_camera_button_alert_is(false);
    button_alert_is = false;
  }

  if(reset_item_on_button_alert_is() && button_alert_is) {
    reset_item_on_button_alert_is(false);
    button_alert_is = false;
  }

  if(reset_fx_button_alert_is() && button_alert_is) {
    reset_fx_button_alert_is(false);
    button_alert_is = false;
  }

  if(birth_button_alert_is() && button_alert_is) {
    birth_button_alert_is(false);
    button_alert_is = false;
  }

  if(dimension_button_alert_is()&& button_alert_is) {
    dimension_button_alert_is(false);
    button_alert_is = false;
  }

  if(reset_camera_button_alert_is() 
  || reset_item_on_button_alert_is() 
  || reset_fx_button_alert_is() 
  || birth_button_alert_is() 
  || dimension_button_alert_is()) {
    button_alert_is = true;
  }
}






/**
CLASSIC BUTTON
*/
// general button classic
public boolean curtain_button_is() {
  return curtain_button_is;
}

public boolean background_button_is() {
  return background_button_is;
}

public boolean ambient_button_is() {
  return ambient_button_is;
}

public boolean light_1_button_is() {
  return light_1_button_is;
}

public boolean light_2_button_is() {
  return light_2_button_is;
}

public boolean ambient_action_button_is() {
  return ambient_action_is;
}

public boolean light_1_action_button_is() {
  return light_1_action_button_is;
}

public boolean light_2_action_button_is() {
  return light_2_action_button_is;
}

public boolean transient_button_is(int index) {
  return transient_button_is[index];
}

public boolean fx_button_is(int index) {
  return fx_button_is[index];
}


// set boolean
public void curtain_button_is(boolean is) {
  curtain_button_is = is;
}


public void background_button_is(boolean is) {
  background_button_is = is;
}

public void ambient_button_is(boolean is) {
  ambient_button_is = is;
}

public void light_1_button_is(boolean is) {
  light_1_button_is = is;
}

public void light_2_button_is(boolean is) {
  light_2_button_is = is;
}

public void ambient_action_button_is(boolean is) {
  ambient_action_is = is;
}

public void light_1_action_button_is(boolean is) {
  light_1_action_button_is = is;
}

public void light_2_action_button_is(boolean is) {
  light_2_action_button_is = is;
}


public void transient_button_is(int index, boolean is) {
  transient_button_is[index] = is;
}

public void fx_button_is(int index, boolean is) {
  fx_button_is[index] = is;
}



















/**
UPDATE DATA from CONTROLER and PRESCENE
v 0.0.2
Those value are used to updated the object data value, and updated at the end of the loop the temp value
*/
public void update_raw_item_value() {
  int minSource = 0 ;
  int smooth_slider = 2 ;
  // COL 1

  int col = NUM_SLIDER_ITEM_BY_COL *0;
  // fill
  fill_hue_raw = map(value_slider_item[col+0],0,MAX_VALUE_SLIDER,0,g.colorModeX);
  fill_sat_raw = map(value_slider_item[col+1],0,MAX_VALUE_SLIDER,0,g.colorModeY);    
  fill_bright_raw = map(value_slider_item[col+2],0,MAX_VALUE_SLIDER,0,g.colorModeZ);  
  fill_alpha_raw = map(value_slider_item[col+3],0,MAX_VALUE_SLIDER,0,g.colorModeA);
  // stroke
  stroke_hue_raw = map(value_slider_item[col+4],0,MAX_VALUE_SLIDER,0,g.colorModeX); 
  stroke_sat_raw = map(value_slider_item[col+5],0,MAX_VALUE_SLIDER,0,g.colorModeY);  
  stroke_bright_raw = map(value_slider_item[col+6],0,MAX_VALUE_SLIDER,0,g.colorModeZ);  
  stroke_alpha_raw = map(value_slider_item[col+7],0,MAX_VALUE_SLIDER,0,g.colorModeA);
  // 
  thickness_raw = value_slider_item[col+8];

  // size
  size_x_raw = value_slider_item[col+9];
  size_y_raw = value_slider_item[col+10];
  size_z_raw = value_slider_item[col+11];
  // size font
  diameter_raw = value_slider_item[col+12];
  // canvas
  canvas_x_raw = value_slider_item[col+13];
  canvas_y_raw = value_slider_item[col+14];
  canvas_z_raw = value_slider_item[col+15];

  col = NUM_SLIDER_ITEM_BY_COL *1;
  // frequence raw
  frequence_raw = value_slider_item[col+0];
  // speed
  speed_x_raw = value_slider_item[col+1];
  speed_y_raw = value_slider_item[col+2];
  speed_z_raw = value_slider_item[col+3];
  // spurt
  spurt_x_raw = value_slider_item[col+4];
  spurt_y_raw = value_slider_item[col+5];
  spurt_z_raw =value_slider_item[col+6];
  // direction
  dir_x_raw = value_slider_item[col+7];
  dir_y_raw = value_slider_item[col+8];
  dir_z_raw = value_slider_item[col+9];
  // jitter
  jitter_x_raw = value_slider_item[col+10];
  jitter_y_raw = value_slider_item[col+11];
  jitter_z_raw = value_slider_item[col+12];
  // spurt
  swing_x_raw = value_slider_item[col+13];
  swing_y_raw = value_slider_item[col+14];
  swing_z_raw = value_slider_item[col+15];

  col = NUM_SLIDER_ITEM_BY_COL *2;
  // misc
  quantity_raw = value_slider_item[col+0];
  variety_raw = value_slider_item[col+1];
  // bio
  life_raw = value_slider_item[col+2];
  flow_raw = value_slider_item[col+3];
  quality_raw = value_slider_item[col+4];
  // radar
  area_raw = value_slider_item[col+5];
  angle_raw = value_slider_item[col+6];
  scope_raw = value_slider_item[col+7];
  scan_raw = value_slider_item[col+8];

  // force or behavior
  alignment_raw = value_slider_item[col+9];
  repulsion_raw = value_slider_item[col+10];
  attraction_raw = value_slider_item[col+11];
  density_raw = value_slider_item[col+12];

  influence_raw = value_slider_item[col+13];
  calm_raw = value_slider_item[col+14];
  spectrum_raw = value_slider_item[col+15];

  col = NUM_SLIDER_ITEM_BY_COL *3;
  grid_raw = value_slider_item[col+0];

  viscosity_raw = value_slider_item[col+1];
  diffusion_raw = value_slider_item[col+2]; 

  power_raw = value_slider_item[col+3];
  mass_raw = value_slider_item[col+4]; 
  coord_x_raw = value_slider_item[col+5];
  coord_y_raw = value_slider_item[col+6];
  coord_z_raw = value_slider_item[col+7];
  

  /*
  value_slider_item[col+8]
  value_slider_item[col+9]
  value_slider_item[col+10]
  value_slider_item[col+11]
  value_slider_item[col+12]
    value_slider_item[col+13]
  value_slider_item[col+14]
  value_slider_item[col+15]
  */

}




/* Those temp value are used to know is the object value must be updated */
// value used to know if the value slider have change or nor 
// col A
public void update_slider_ref() {
  // COL 1
  fill_hue_ref = fill_hue_raw;
  fill_sat_ref = fill_sat_raw;    
  fill_bright_ref = fill_bright_raw;   
  fill_alpha_ref = fill_alpha_raw;

  stroke_hue_ref = stroke_hue_raw; 
  stroke_sat_ref = stroke_sat_raw;  
  stroke_bright_ref = stroke_bright_raw; 
  stroke_alpha_ref = stroke_alpha_raw;

  thickness_ref = thickness_raw;

  size_x_ref = size_x_raw;
  size_y_ref = size_y_raw;
  size_z_ref = size_z_raw;

  diameter_ref = diameter_raw;

  canvas_x_ref = canvas_x_raw;
  canvas_y_ref = canvas_y_raw;
  canvas_z_ref = canvas_z_raw;

  // COL 2
  // misc
  frequence_ref = frequence_raw;
  // speed
  speed_x_ref = speed_x_raw;
  speed_y_ref = speed_y_raw;
  speed_z_ref = speed_z_raw;
  // spurt
  spurt_x_ref = spurt_x_raw;
  spurt_y_ref = spurt_y_raw;
  spurt_z_ref = spurt_z_raw;
  // direction
  dir_x_ref = dir_x_raw;
  dir_y_ref = dir_y_raw;
  dir_z_ref = dir_z_raw;
  // jitter
  jitter_x_ref = jitter_x_raw;
  jitter_y_ref = jitter_y_raw;
  jitter_z_ref = jitter_z_raw;
  // direction
  swing_x_ref = swing_x_raw;
  swing_y_ref = swing_y_raw;
  swing_z_ref = swing_z_raw;

  // COL 3
  quantity_ref = quantity_raw;
  variety_ref = variety_raw;

  life_ref = life_raw;
  flow_ref = flow_raw;
  quality_ref = quality_raw;

  area_ref = area_raw;
  angle_ref = angle_raw;
  scope_ref = scope_raw;
  scan_ref = scan_raw;
  // force
  alignment_ref = alignment_raw;
  repulsion_ref = repulsion_raw;
  attraction_ref = attraction_raw;
  density_ref = density_raw;

  influence_ref = influence_raw;
  calm_ref = calm_raw;
  spectrum_ref = spectrum_raw;

  // COL 4
  grid_ref = grid_raw;
  viscosity_ref = viscosity_raw;
  diffusion_ref = diffusion_raw;

  power_ref = power_raw;
  mass_ref = mass_raw;

  coord_x_ref = coord_x_raw;
  coord_y_ref = coord_y_raw;
  coord_z_ref = coord_z_raw;
}


//SHORTCUT VAR
//SOUND
public float all_transient(int ID) {
  float val = 0 ;
  for(int i = 1 ; i < transient_value.length ; i++) {
    val += transient_value[i][ID] *.25f;
  }
  return val ;
}

/**
ROMANESCO MASKING
v 1.0.0
2018-2018

WARNING
The method is advence for border mask but not for the option with different bloclk mask
*/
boolean border_is;
boolean default_mask_is = true;
public void masking(boolean change_is) {
  // use border mask setting: masking(change_is,0,0,0);
  masking(change_is,0,0,0);
}
/**
master method
*/
// PGraphics pg_mask;
public void masking(boolean change_is, int type_mask, int num_mask, int num_point_mask) {
  if(type_mask == 0) {
    border_is = true ;
    if(border_is) {
      if(display_mask_is(0)) {
        masking_border(change_is, default_mask_is);
      }
    }
  } else {
    masking_blocks(change_is, num_mask, num_point_mask);  
  }

  
  boolean mask_state_is = false;
  for(int i = 0 ; i < display_mask.length ; i++){
    if(display_mask[i]) {
      mask_state_is = true;
      break;
    }
  }

  // vertex solution
  if(get_mask_border() != null && mask_state_is) {
    g.image(get_mask_border(),0,0);
  }
  /*
  // pixel set solution
  println("DISPLAY MASK",pg_mask,mask_state_is,display_mask.length);
  if(pg_mask != null && mask_state_is) {
    pg_mask.loadPixels();
    loadPixels();
    for(int i = 0 ; i < pg_mask.pixels.length ; i++) {
      if(pg_mask.pixels[i] == r.BLACK) {
        g.pixels[i] = r.BLACK;
      } else if(pg_mask.pixels[i] == r.RED) {
        g.pixels[i] = r.RED;
      } else if(pg_mask.pixels[i] == r.WHITE) {
        g.pixels[i] = r.WHITE;
      }
    }
    updatePixels();
  }
  */

  if(change_is) {
    mask_border_reset();
  }
}
























/**
border mask
*/
Masking mask_border;
boolean init_mask_is ;
public void masking_border(boolean change_is, boolean default_mask_is) {
  if(!init_mask_is) {
    // build mask
    if(mask_border == null || default_mask_is) {
      masking_border_default();
      println("set default mask");
      mask_border = new Masking(coord_connected,coord_block_1,coord_block_2,coord_block_3,coord_block_4);
      init_mask_is = true;
    } else if(mask_loaded_is) {
      println("set load mask");
      mask_border = new Masking(coord_connected,coord_block_1,coord_block_2,coord_block_3,coord_block_4);
      mask_loaded_is = false;
      init_mask_is = true;
    }
  } else {
    // display mask
    if(mask_border != null && display_mask_is(0)) {
      mask_border.draw(change_is);
    }
  }

  // save
  if(change_is) {
    save_mask_border();
  }
}




public void save_mask_border() {
  coord_connected = mask_border.get_coord();
  coord_block_1 = mask_border.get_coord_block_1();
  coord_block_2 = mask_border.get_coord_block_2();
  coord_block_3 = mask_border.get_coord_block_3();
  coord_block_4 = mask_border.get_coord_block_4();
  //write_file_mask_mapping(get_file_mask_mapping());
  write_file_masking();
  save_file_masking(get_file_masking(),sketchPath(1)+ "/save/last_border_mask.csv");
}

ivec2 [] coord_connected;
ivec2 [] coord_block_1,coord_block_2,coord_block_3,coord_block_4;
public void masking_border_default() {
  int marge = 40;
  coord_connected = new ivec2 [8];
  // outside
  coord_connected[0] = ivec2(0,0);
  coord_connected[1] = ivec2(width,0);
  coord_connected[2] = ivec2(width,height);
  coord_connected[3] = ivec2(0,height);
  // inside
  coord_connected[4] = ivec2(marge,marge);
  coord_connected[5] = ivec2(width-marge,marge);
  coord_connected[6] = ivec2(width-marge,height-marge);
  coord_connected[7] = ivec2(marge,height-marge);
  
  // coord_block_1
  coord_block_1 = new ivec2 [2];
  coord_block_1[0] = ivec2(width -width/3,marge);
  coord_block_1[1] = ivec2(width/3,marge);

  // coord_block_2
  coord_block_2 = new ivec2 [0];

  // coord_block_3
  coord_block_3 = new ivec2 [2];
  coord_block_3[0] = ivec2(width/3,height-marge);
  coord_block_3[1] = ivec2(width-width/3,height-marge);

  // coord_block_4
  coord_block_4 = new ivec2 [0];
}


public void mask_border_reset() {
  if(mask_border == null) {
    masking_border(true,true);
  } else {
    mask_border.reset();
  }
  
}

public PGraphics get_mask_border() {
  if(mask_border == null) {
    return null;
  } else {
    return mask_border.get_mask();
  }
}









































/**
block mask
*/

/**
block mask
*/
Masking [] masks;
Coord_mask [] coord_mask;

public void masking_blocks(boolean change_is, int num, int num_point_mask) {
  if(masks == null) {
    coord_mask = new Coord_mask[num];
    masks = new Masking[coord_mask.length];
    // pg_mask = createGraphics(width,height);
    
    data_masking_blocks(coord_mask, num_point_mask);
    for(int i = 0 ; i < num ; i++) {
      masks[i] = new Masking(coord_mask[i].get());
    }
  } else {
    if(display_mask_is(0)) {
      for(int i = 0 ; i < num ;i++) {
        if(display_mask_is(i+1)) {
          masks[i].draw(change_is);
        }
      }
    }    
  }
}





// blocks
public void data_masking_blocks(Coord_mask [] coord, int num_points_by_mask) {
  int marge = 100;

  for(int i = 0 ; i < coord.length ; i++) {
    ivec2 [] coord_mask = new ivec2[num_points_by_mask];
    ivec2 p = ivec2((int)random(marge,width-marge),(int)random(marge,height-marge));
    for(int k = 0 ; k < coord_mask.length ; k++) {
      int range = marge/2 ;
      coord_mask[k] = ivec2(p.x + PApplet.parseInt(random(-range,range)),p.y + PApplet.parseInt(random(-range,range)));
    }
    coord[i] = new Coord_mask(coord_mask);
  }
}

class Coord_mask {
  ivec2 [] coord;
  Coord_mask(ivec2 [] coord_pos) {
    this.coord = new ivec2[coord_pos.length];
    for(int i = 0 ; i < this.coord.length ;i++) {
      this.coord[i]= ivec2(coord_pos[i]);
    }
  }

  public ivec2 [] get() {
    return coord;
  }

  public void set(int i,int x, int y) {
    if(coord[i] != null) {
      coord[i].set(x,y);
    } else {
      coord[i] = ivec2(x,y);
    }
  }
}
/*
Mapping [] masks;
void mask_mapping_2_blocks(boolean change_is) {
  if(masks == null) {
    data_mask_mapping_blocks();
    masks = new Mapping[num_mask_mapping];
    masks[0] = new Mapping(coord_mask_0);
    masks[1] = new Mapping(coord_mask_1);
  } else {
    masks[0].draw(change_is);
    masks[1].draw(change_is);
  }
}

// blocks
ivec2 [] coord_mask_0, coord_mask_1;
int num_mask_mapping;
void data_mask_mapping_blocks() {
  int marge = 40;
  coord_mask_0 = new ivec2[4];
  coord_mask_0[0] = ivec2(0,0);
  coord_mask_0[1] = ivec2(width,0);
  coord_mask_0[2] = ivec2(width,marge);
  coord_mask_0[3] = ivec2(0,marge);

  coord_mask_1 = new ivec2[4];
  coord_mask_1[0] = ivec2(0,height-marge);
  coord_mask_1[1] = ivec2(width,height-marge);
  coord_mask_1[2] = ivec2(width,height);
  coord_mask_1[3] = ivec2(0,height);

  num_mask_mapping = 2;
}
*/



















public void keyPressed_mask_set(char c) {
  if(key == c) {
    if(!display_mask[0]) {
      display_mask[0] = true;
    }
    set_mask();
  }
}

public void keyPressed_mask_border_hide(char c) {
  if(key == c) {
    display_mask[0] = !!((display_mask[0] == false));
  }
}


public void keyPressed_mask_save(char c) {
  if(key == c) {
    save_mask();
  }
}


public void keyPressed_mask_load(char c) {
  if(key == c) {
    selectInput("Select a file to load data mask:", "load_save_mask");
  }
}











public void enable_mask_is_on_top_for_bug_reason() {
  char [] key_num_under_num = {'0','1','2','3','4','5','6','7','8','9'};
  /*
  char [] key_num_under_num = new char[10];
  key_num_under_num[0] = '0';
  key_num_under_num[1] = '1';
  key_num_under_num[2] = '2';
  key_num_under_num[3] = '3';
  key_num_under_num[4] = '4';
  key_num_under_num[5] = '5';
  key_num_under_num[6] = '6';
  key_num_under_num[7] = '7';
  key_num_under_num[8] = '8';
  key_num_under_num[9] = '9'; 
  */

  for(int i = 0 ; i < display_mask.length && i < key_num_under_num.length ; i++) {
    if(key == key_num_under_num[i]) {
      display_mask[i] = !!((display_mask[i] == false));
      if(display_mask[i]) display_mask[0] = true;
      break;
    }
  } 
}

// boolean [] display_mask = {true,true,true,true,true,true,true,true,true,true};
boolean [] display_mask;

public void init_masking() {
  display_mask = new boolean[10];
  for(int i = 0 ; i < display_mask.length ; i++) {
    display_mask[i] = false;
  }
}






/**
DATA CONTROL
v 0.1.0
SET and RETURN / boolean, int...
use to dial between the keyboard, the controller and the user
the mess
*/
boolean set_mask_is;
public void set_mask() {
  set_mask_is = !!((set_mask_is == false));
}

public boolean set_mask_is() {
  return set_mask_is;
}

public boolean display_mask_is(int target) {
  if(target < display_mask.length && target >= 0) {
    return display_mask[target];
  } else return false;
}

public void enable_mask() {
  enable_mask_is_on_top_for_bug_reason();

/**
the method is not with her family for bug reason...Java or Processing that's create an exception due of key_num_under_num[3] = '"';
problem to manage double quote assignation in char.
the char assignation must be write before the key and keyCode interrogation ?
*/
  /*
  char [] key_num_under_num = new char[10];
  key_num_under_num[0] = 'à'; 
  key_num_under_num[1] = '&';
  key_num_under_num[2] = 'é';
  key_num_under_num[3] = '"';
  key_num_under_num[4] = '\'';
  key_num_under_num[5] = '(';
  key_num_under_num[6] = '§';
  key_num_under_num[7] = 'è';
  key_num_under_num[8] = '!';
  key_num_under_num[9] = 'ç';
  for(int i = 0 ; i < display_mask.length && i < key_num_under_num.length ; i++) {
    if(key == key_num_under_num[i]) {
      display_mask[i] = !!((display_mask[i] == false)); 
      break;
    }
  } 
  */
}
































/**
load data save
*/
boolean mask_loaded_is ;
public void load_save_mask(File selection) {
  if (selection == null) {
    println("No file has been selected for data mask");
  } else {
    Table t = loadTable(selection.getAbsolutePath(),"header");
    set_file_masking(t);
    // mask border part
    if(get_file_masking().getRowCount() > 7) {
      int target = 0;
      for (TableRow row : get_file_masking().findRows("coord_connected", "name")) {
        int x = row.getInt("x");
        int y = row.getInt("y");
        coord_connected[target].set(x,y);
        target++;
      }
      target = 0;
      for (TableRow row : get_file_masking().findRows("coord_block_1", "name")) {
        int x = row.getInt("x");
        int y = row.getInt("y");
        coord_block_1[target].set(x,y);
        target++ ;
      }
      target = 0;
      for (TableRow row : get_file_masking().findRows("coord_block_2", "name")) {
        int x = row.getInt("x");
        int y = row.getInt("y");
        coord_block_2[target].set(x,y);
        target++ ;
      }
      target = 0;
      for (TableRow row : get_file_masking().findRows("coord_block_3", "name")) {
        int x = row.getInt("x");
        int y = row.getInt("y");
        coord_block_3[target].set(x,y);
        target++ ;
      }
      target = 0;
      for (TableRow row : get_file_masking().findRows("coord_block_4", "name")) {
        int x = row.getInt("x");
        int y = row.getInt("y");
        coord_block_4[target].set(x,y);
        target++ ;
      }
      // mapping block indépendant
      for (TableRow row : get_file_masking().findRows("Total_mask", "name")) {
        int num = row.getInt("num");
        coord_mask = new Coord_mask[num];
        break;
      }
      
      // find num
      masks = new Masking[coord_mask.length];
      for(int i = 0 ; i < masks.length ; i++) {
        for (TableRow row : get_file_masking().findRows("coord_mask_"+i, "name")) {
          int x = row.getInt("x");
          int y = row.getInt("y");
          coord_mask[i].set(target,x,y);
        }

        // data_mask_mapping_blocks(coord_mask, num_point_mask);
        /*
        for(int i = 0 ; i < num ; i++) {
          masks[i] = new Mapping(coord_mask[i].get());
        }
        */
      }

    }
    init_mask_is = false;
    default_mask_is = false;
    mask_loaded_is = true;
    // mask_mapping(false);
  }  
}





























/**
SAVE MASKING
*/
/**
SAVE / LOAD
v 0.0.5
*/
public void save_mask() {
  write_file_masking();
  selectOutput("Select a file to write to:", "selected_file_to_save"); 
}


public void selected_file_to_save(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
  } else {
    println("User selected",selection.getAbsolutePath(),"for save force file");
    save_file_masking(get_file_masking(),selection.getAbsolutePath()+".csv");
  }
}

// mask file
Table file_msk;
public Table get_file_masking() {
  return file_msk;
}

public void set_file_masking(Table t) {
  file_msk = t ;
}

public void save_file_masking(Table s_msk, String path) {
  if(s_msk != null) {
    saveTable(s_msk, path);
  }
} 

public void write_file_masking() {
  file_msk = new Table();
  file_msk.addColumn("name");
  file_msk.addColumn("num");
  file_msk.addColumn("is");
  file_msk.addColumn("x");
  file_msk.addColumn("y");

  TableRow newRow;
  newRow = file_msk.addRow();
  newRow = file_msk.addRow();
  newRow.setString("name", "Total_mask");
  int num_mask = 4;
  newRow.setInt("num", num_mask);

  if(coord_connected != null) {
    for(int i = 0 ; i < coord_connected.length ;i++) {
      newRow = file_msk.addRow();
      newRow.setString("name", "coord_connected");
      newRow.setString("is", "true");
      newRow.setInt("x", coord_connected[i].x);
      newRow.setInt("y", coord_connected[i].y);
    }
  }
  
  if(coord_block_1 != null) {
    for(int i = 0 ; i < coord_block_1.length ;i++) {
      newRow = file_msk.addRow();
      newRow.setString("name", "coord_block_1");
      newRow.setString("is", "true");
      newRow.setInt("x", coord_block_1[i].x);
      newRow.setInt("y", coord_block_1[i].y);
    }
  }

  if(coord_block_2 != null) {
    for(int i = 0 ; i < coord_block_2.length ;i++) {
      newRow = file_msk.addRow();
      newRow.setString("name", "coord_block_2");
      newRow.setString("is", "true");
      newRow.setInt("x", coord_block_2[i].x);
      newRow.setInt("y", coord_block_2[i].y);
    }
  }

  if(coord_block_3 != null) {
    for(int i = 0 ; i < coord_block_3.length ;i++) {
      newRow = file_msk.addRow();
      newRow.setString("name", "coord_block_3");
      newRow.setString("is", "true");
      newRow.setInt("x", coord_block_3[i].x);
      newRow.setInt("y", coord_block_3[i].y);
    }
  }

  if(coord_block_4 != null) {
    for(int i = 0 ; i < coord_block_4.length ;i++) {
      newRow = file_msk.addRow();
      newRow.setString("name", "coord_block_4");
      newRow.setString("is", "true");
      newRow.setInt("x", coord_block_4[i].x);
      newRow.setInt("y", coord_block_4[i].y);
    }
  }

  // save block indépendant
  /*
  if(coord_mask != null && coord_mask.length > 0) {
    for(int i = 0 ; i < coord_mask.length ;i++) {
      if(coord_mask[i] != null) {
        newRow = file_msk.addRow();
        newRow.setString("name", "coord_mask_" +i);
        newRow.setInt("num", coord_mask[i].get().length);
        for(int k = 0 ; k < coord_mask[i].get().length ; k++) {
          newRow = file_msk.addRow();
          newRow.setString("name", "coord_mask_" +i);
          newRow.setString("is", "true");
          newRow.setInt("x", masks[i].get_coord()[k].x);
          newRow.setInt("y", masks[i].get_coord()[k].x);
        }
      }     
    }
    
  }
  */
}
/**
* CLASS AGENT 
* v 1.2.2
* 2016-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Life
*/


/*
* INTERFACE AGENT 0.1.2
*/
interface Agent {
  float CLOCK = 1.5f ;
  int TIME_TO_BE_CARRION = 600 ;

  /**
  GET
  */
  public short get_ID() ;
  public int get_life() ;
  public int get_stamina() ;
  public Genome get_genome() ;
  public boolean get_alive() ;
  public vec3 get_pos() ;

  public vec3 get_size() ;
  public int get_mass() ;
  public float get_density() ;


  public int get_alpha_cursor() ;
  public float get_alpha_back() ;
  public float get_alpha_front() ;

  /**
  get home
  */
  public vec4 get_home() ;
  public vec3 get_home_pos() ;
  public int get_home_id() ;


  /**
  METHOD
  */
  public void growth() ;
  /**
  aspect
  */

  public void costume();
  public void set_costume(int which);
  public void set_costume(Costume costume);
  
  public void aspect(vec4 f, vec4 s, float t) ;

  public Costume get_costume();
  public vec4 get_fill_style();
  public vec4 get_stroke_style();
  public float get_thickness();

  public vec4 get_melanin() ;

  public vec4 get_first_colour() ;
  public vec4 get_second_colour() ;
  public vec4 get_third_colour() ;


  /**
  SET
  */
  /**
  set home
  */
  public void set_home(vec4 home) ;
  public void set_home(vec3 pos, int id_home) ;
  public void set_home_pos(vec3 pos) ;
  public void set_home_ID(int id_home) ;

  /**
  set aspect
  */
  public void set_aspect(vec4 fill_style, vec4 stroke_style, float thickness) ;
  public void set_fill(vec4 fill_style) ;
  public void set_stroke(vec4 stroke_style) ;
  public void set_thickness(float thickness) ;
  public void set_alpha(vec3 alpha_behavior) ;
  /**
  set coor, motion...
  */
  public void set_pos(vec pos) ; 
  /**
  set caracterictic
  */
  public void set_nutrient_quality(int nutrient_quality) ;

  /**
  INFO
  */
  public void info(vec4 colour, int size_text)  ;
}

/**

END INTERFACE AGENT

*/































/**



Agent_model ABSTRACT CLASS 0.2.0

*/
abstract class Agent_model implements Agent {
  String name ;
  short ID = 0 ; 
  int gender = 0 ; // 0 for female, 1 for male, 2 for ermaphrodite
  int generation = 0 ;
  int num_children = 0 ;
  int num_heterozygous = 0 ;
  int num_homozygous = 0 ;
  int num_pregnancy = 0 ;


  /**
  feed
  */
  boolean satiate ;
  float gourmet = 2.f ;
  float speed_feeding = .2f ;

  boolean hunger_bool, starving_bool ;


  /**
  life param
  */
  int age = 0 ;
  int dead_since = 0 ;

  boolean alive = true ;
  boolean carrion = false ;

  int life ;
  int life_expectancy = 1  ;

  int stamina, stamina_ref ;
  int nutrient_quality = 1 ;
  // size
  vec3 size, size_ref, size_max ;
  int mass, mass_ref ;
  float density = 1 ;
  /**
  colour use by ADN
  */
  vec4 melanin ;
  vec4 first_colour, second_colour, third_colour ;
  /**
  aspect 
  not use in the ADN, just for display
  */
  vec4 fill_style = vec4(0,0,0,g.colorModeA) ;
  vec4 stroke_style = vec4(0,0,0,g.colorModeA) ;
  float thickness = 1 ;

  Costume costume; // costume 0 is point in Z_costume_rope library

  int alpha_cursor = 0 ;
  float alpha_back = 1.f ;
  float alpha_front = 1.f ;
  /**
  pos
  */
  vec3 pos = vec3() ;

  /**
  home
  */
  vec4 home ;


 /**
 home
  */
  public void set_home(vec4 home) {
    if(this.home != null) {
      this.home.set(home) ;
    } else {
      this.home = home.copy() ;
    }
  }

  public void set_home(vec3 pos, int id_home) {
    if(this.home != null) {
      this.home.set(pos.x, pos.y, pos.z, id_home) ;
    } else {
      this.home = vec4(pos.x, pos.y, pos.z, id_home) ;
    }
  }

  public void set_home_pos(vec3 pos) {
    if(this.home != null) {
      this.home.set(pos.x, pos.y, pos.z, this.home.w) ;
    } else {
      this.home = vec4(pos.x, pos.y, pos.z, -1) ;
    }
  }

  public void set_home_ID(int id_home) {
    if(this.home != null) {
      this.home.set(this.home.x, this.home.y, this.home.z, id_home) ;
    } else {
      this.home = vec4(0, 0, 0, id_home) ;
    }
  }

  /**
  reproduction
  */
  Genome genome ;
  Genome genome_father ;

  int maturity ;
  int fertility_cycle ;
  int fertility_time_ref  ;
  int pregnant_term   ;
  
  int fertility_time ;

  boolean fertility = false ;
  int fertility_rate = 1 ;
  int pregnant_time = 0  ;
  boolean pregnant = false ;
  
  // only use for female
  int reproduction_area ;
  int sex_appeal ;
  // int factor_reproduction_area_female = 2 ;
  // int factor_reproduction_area_male = 20 ;
  /**
  GET
  */
  public short get_ID() { 
    return ID ; 
  }
  public int get_life() { 
    return life ; 
  }
  public Genome get_genome() { 
    return genome ;
  }
  public boolean get_alive() { 
    return alive ;
  }
  public vec3 get_size() { 
    return size ; 
  }
  public int get_stamina() { 
    return stamina ; 
  }

  public int get_mass() { 
    return mass ; 
  }

  public float get_density() { 
    return density ; 
  }

  public vec3 get_pos() { 
    return pos ;
  }

 /**
  get home
  */
  public vec4 get_home() { 
    return home ;
  }

  public vec3 get_home_pos() { 
    if(home != null) return vec3(home.x, home.y, home.z) ; else return null ;
  }

  public int get_home_id() { 
    if(home != null) return (int)home.w ; else return -1 ;
  }

  
  /**
  get style
  */
  public Costume get_costume() { 
    return costume; 
  }
  public vec4 get_fill_style() { 
    return fill_style ; 
  }
  public vec4 get_stroke_style() { 
    return stroke_style ; 
  }
  public float get_thickness() { 
    return thickness ; 
  }

  public vec4 get_melanin() { 
    return first_colour ; 
  }

  public vec4 get_first_colour() { 
    return first_colour ; 
  }
  public vec4 get_second_colour() { 
    return second_colour ; 
  }
  public vec4 get_third_colour() { 
    return third_colour ; 
  }


  /**
  get alpha
  */
  public int get_alpha_cursor() {
    return alpha_cursor ;
  }
  public float get_alpha_back() {
    return alpha_back ;
  }
  public float get_alpha_front() {
    return alpha_front ;
  }


  /**
  set reproduction
  */
  public void set_maturity(int maturity) {
    this.maturity = PApplet.parseInt(maturity) ;
  }

  public void set_fertility_cycle(int fertility_cycle) {
    this.fertility_cycle = PApplet.parseInt(fertility_cycle) ;
  }

  public void set_fertility_time(int fertility_time) {
    this.fertility_time_ref = PApplet.parseInt(fertility_time) ;
  }

  public void set_pregnant_term(int pregnant_term) {
    this.pregnant_term = PApplet.parseInt(pregnant_term) ;
  }
  
  public void set_fertility_rate(int rate) {
    this.fertility_rate = rate ;
  }

  public void set_reproduction_area(int reproduction_area) {
    this.reproduction_area = reproduction_area ;
  }


  /**
  set feeding
  */
  public void set_gourmet(float gourmet) {
    this.gourmet = abs(gourmet) +1.1f ;
  }

  public void set_nutrient_quality(int nutrient_quality) {
    this.nutrient_quality = nutrient_quality ;
  }

  public void set_speed_feeding(int speed_feeding) {
    this.speed_feeding = 1 ;
  }


  /**
  set aspect
  */
  public void set_aspect(vec4 fill_style, vec4 stroke_style, float thickness) {
    this.fill_style.set(fill_style) ;
    this.stroke_style.set(stroke_style) ;
    this.thickness = thickness ;
  }

  public void set_fill(vec4 fill_style) {
    this.fill_style.set(fill_style) ;
  }

  public void set_stroke(vec4 stroke_style) {
    this.stroke_style.set(stroke_style) ;
  }

  public void set_thickness(float thickness) {
    this.thickness = thickness ;
  }


  // void set_alpha(int alpha_cursor, float alpha_back, float alpha_front) {
  public void set_alpha(vec3 alpha_behavior) {
    this.alpha_cursor = (int)alpha_behavior.x ;
    this.alpha_back = abs(alpha_behavior.y) ;
    this.alpha_front = alpha_behavior.z ;
  }

  /**
  set caracteristic
  */
  public void set_density(float density) {
    this.density = density ;
  }

  public void set_size(int size) {
    if(this.size != null) {
      this.size = vec3(size) ;
    } else this.size.set(size) ;
  }

  public void set_size(vec3 size) {
    if(this.size != null) {
      this.size = vec3(size) ;
    } else this.size.set(size) ;
  }

  public void set_life(int life_expectancy) {
    this.life_expectancy = life_expectancy ;
  }


  /**
  set misc
  */
  public void set_ID(short ID) {
    this.ID = ID ;
  }

  public void set_alive(boolean alive) {
    this.alive = alive ;
  }





  /**
  METHOD
  */
    /**
  reproduction method

  */
  public void fertility(int time) {
    if(time%fertility_cycle == 0 && !pregnant) {
      fertility = fertility?false:true ;
    }
    if(fertility && fertility_time > 0 ) fertility_time-- ;
    if(fertility_time <= 0) {
      fertility_time = fertility_time_ref ;
      fertility = false ;
    }
  }

  public void reproduction() {
    pregnant = true ;
    fertility = false ;
    pregnant_time = pregnant_term ;
  }
  
  
  public void pregnant() {
    if(pregnant_time > 0 && pregnant) pregnant_time-- ;
  }
  
  public boolean birth() {
    if(pregnant_time <= 0 && pregnant) {
      pregnant = false ;
      return true ;
    } else return false ;
  }


  /**
  growth

  */
  public void growth() {
    age() ;
    life() ;
    if(life < 0 || stamina <= 0) {
      alive = false ;
    }
    
    if(stamina <= 0) {
      stamina = 0 ;
    }
    if(stamina > stamina_ref) {
      stamina = stamina_ref ;
    }
  }

  
  /**
  life statement
  */
  public void life() {
    life-- ;
  }

  public void age() {
    age++ ;
  }

  /**
  maturity
  */

  public void maturity() {
    if(maturity > 0) maturity-- ;
  }


  /**
  ASPECT
  */
  public void aspect(float thickness) {
    if(thickness <= 0) { 
      noStroke() ;
      fill(fill_style) ;
    } else { 
      strokeWeight(thickness) ;
      stroke(stroke_style) ;
      fill(fill_style) ;
    }
  }
  
  public void aspect(vec4 c_fill, vec4 c_stroke, float thickness) {
    if(thickness <= 0) { 
      noStroke() ;
      fill(c_fill) ;
    } else { 
      strokeWeight(thickness) ;
      stroke(c_stroke) ;
      fill(c_fill) ;
    }
  }




  /**
  COSTUME
  */
  public void costume() {
    this.costume.draw(pos,size,vec3());
  }

  public void set_costume(Costume costume) {
    this.costume = costume;
  }

  public void set_costume(int which_costume) {
    this.costume.set_type(which_costume);
  }



















  /**
  INFO


  */
  /**
  info print
  */
  public void info(vec4 colour, int size_text) {
    if(starving_bool) {
      vec4 colour_starving = vec4() ;
      float ratio_speed_warning = .05f ;
      float alpha = abs(sin(frameCount *ratio_speed_warning)) ;
      colour_starving.set(colour.x, colour.y, colour.z, colour.w *alpha) ;
      info_visual(colour_info(colour_starving, satiate, pregnant, fertility)) ;
      info_text(colour_info(colour_starving, satiate, pregnant, fertility), size_text) ;
    } else {
      info_visual(colour_info(colour, satiate, pregnant, fertility)) ;
      info_text(colour_info(colour, satiate, pregnant, fertility), size_text) ;
    }

  }
  /**
  fake
  */
  public void info_visual(vec4 colour) {

  }

  public void info_text(vec4 colour, int size) {

  }
  



  public void info_print_caracteristic() {
    println("CARACTERISTIC",this.name) ;
    println(this.name, "size", this.size) ;
    println(this.name, "life expectancy", this.life_expectancy) ;
    println(this.name, "stamina max", this.stamina_ref) ;
    println(this.name, "nutrient quality", this.nutrient_quality) ;
    println(this.name, "food exigency", this.gourmet) ;

  }

  public vec4 colour_info(vec4 original_colour) {
    return colour_info(original_colour, true, false, false) ;
  }

  public vec4 colour_info(vec4 original_colour, boolean satiate, boolean pregnant, boolean fertility) {
    vec4 colour = vec4(original_colour) ;
    if(!satiate) colour.z = g.colorModeZ *.5f ;
    if(pregnant) colour.y = g.colorModeY *.1f ;
    if(fertility) colour.y = g.colorModeY *.45f ;
    return colour ;
  }
}
/** 

END CLASS AGENT METHOD

*/







































/**

CLASS AGENT DYNAMIC 0.2.2
@author Stan le Punk

*/
abstract class Agent_dynamic extends Agent_model {
  /**
  target
  */
  vec2 ID_target = vec2(-1) ;
  vec3 pos_target = vec3(0) ;
  Agent target ;


  /**
  carnivore
  */
  boolean killing   ;
  int attack = 1 ;
  int kill_zone ;
  int time_track ;
  int max_time_track = PApplet.parseInt(360 *CLOCK) ;

  /**
  sense
  */
  int sense_range ;

  /**
  reproduction
  */
  int sex_appeal ;
  float multiple_pregnancy = 0 ;

  /**
  satisfaction
  */
  // int threshold_migration ;
  int level_satisfaction, level_dissatisfaction ;
  int threshold_satisfation  ;
  int threshold_dissatisfaction  ;

  /**
  Feed
  */
  int step_hunger ;
  int leptin ; // step satiating peptid coded on OB gene chromosome 7
  int hunger  ;
  int starving = 1 ;
  int eat_zone ;
 // int greed  ;
 //  int greed = int(180 *CLOCK) ; // num of frame before stop to eat :)

  float digestion = 2 ;

  //behavior
  int max_watching = 600 ;

  // STATEMENT
  boolean watching = true ;
  boolean eating ;
  boolean tracking ;
  boolean tracking_partner ;

  /**
  motion, pos, coord
  */
  vec3 motion = vec3() ;
  vec3 dir = vec3() ;
  vec3 velocity_xyz = vec3() ;
  float velocity, velocity_ref ;

  float vel_slow_4 = .1f ;
  float vel_slow_3 = .25f ;
  float vel_slow_2 = .5f ;
  float vel_slow_1 = .75f ;
  float vel_normal = 1.f ;
  float vel_fast_1 = 1.25f ;
  float vel_fast_2 = 1.5f ;
  float vel_fast_3 = 2.f ;
  float vel_fast_4 = 3.f ;

  /**
  misc or out or real caracteristic...
  */
  // watching variable
//  int size_target_flora ;
  int time_watching = 0 ;
  // MISC
Info_Object style ;


  /**
  CONSTRUCTOR 
  Dynamic Agent from caracteristic

  @param vec3 pos, give the x,y,z coord of the agent
  @param int size, give a data to give size to the agent
  @param int life, give the life and and use to give the maximum life of the agent
  @param int stamina, give the stamina and and use to give the maximum stamina of the agent
  @param int velocity, give the maximum of motion speed of your agent.
  @param String name... no comment !
  */
  Agent_dynamic(Info_dict carac, Info_Object style, int gender) {
  // Agent_dynamic(int size, int stamina, int life_expectancy, int velocity, int sense_range, String name, vec2 sex_appeal, int gender) {
    // set aspect
    this.style = style ;
    set_aspect((vec4)style.catch_obj(1), (vec4)style.catch_obj(2), (float)style.catch_obj(3)) ;

    // catch caracteristic
    String temp_name = "Nobody" ;
    vec3 temp_size = vec3(1) ;
    float temp_density = 1 ;

    int temp_stamina = 1 ;
    int temp_velocity = 0 ;
    int temp_sense_range = 1 ;
    int temp_life_expectancy = MAX_INT ;
    int species_life_cycle = MAX_INT ;
    vec2 temp_sex_appeal = vec2(1) ;
    float temp_multiple_pregnancy = 0 ;
    
    vec4 temp_first = vec4(1) ;
    vec4 temp_second = vec4(1) ;
    vec4 temp_third = vec4(1) ;

    vec4 temp_melanin = vec4(0) ;
    //
    float range_norm = .15f ;
    //

    if (carac.get("name") != null) temp_name = (String) carac.get("name")[0].catch_obj(0) ;

    if (carac.get("size") != null && carac.get("size")[0].catch_obj(0) instanceof vec3) {
      temp_size = (vec3)carac.get("size")[0].catch_obj(0) ;
      temp_size.x = random_gaussian(temp_size.x) ;
      temp_size.y = random_gaussian(temp_size.y) ;
      temp_size.z = random_gaussian(temp_size.z) ;
    }
    if (carac.get("density") != null) temp_density = random_gaussian((int)carac.get("density")[0].catch_obj(0), range_norm) ;

    if (carac.get("stamina") != null) temp_stamina = (int) random_gaussian((int)carac.get("stamina")[0].catch_obj(0)) ;
    if (carac.get("velocity") != null) temp_velocity = (int) random_gaussian((int)carac.get("velocity")[0].catch_obj(0)) ;
    if (carac.get("sense_range") != null) temp_sense_range = (int) random_gaussian((int)carac.get("sense_range")[0].catch_obj(0)) ;
    // colour
    
    if (carac.get("first_colour") != null && carac.get("first_colour")[0].catch_obj(0) instanceof vec4) {
      temp_first = (vec4)carac.get("first_colour")[0].catch_obj(0) ;
      temp_first.x = random_gaussian(temp_first.x, range_norm) ;
      temp_first.y = random_gaussian(temp_first.y, range_norm) ;
      temp_first.z = random_gaussian(temp_first.z, range_norm) ;
      temp_first.w = random_gaussian(temp_first.w, range_norm) ;
    }
    if (carac.get("second_colour") != null && carac.get("second_colour")[0].catch_obj(0) instanceof vec4) {
      temp_second = (vec4)carac.get("second_colour")[0].catch_obj(0) ;
      temp_second.x = random_gaussian(temp_second.x, range_norm) ;
      temp_second.y = random_gaussian(temp_second.y, range_norm) ;
      temp_second.z = random_gaussian(temp_second.z, range_norm) ;
      temp_second.w = random_gaussian(temp_second.w, range_norm) ;
    }
    if (carac.get("third_colour") != null && carac.get("third_colour")[0].catch_obj(0) instanceof vec4) {
      temp_third = (vec4)carac.get("third_colour")[0].catch_obj(0) ;
      temp_third.x = random_gaussian(temp_third.x, range_norm) ;
      temp_third.y = random_gaussian(temp_third.y, range_norm) ;
      temp_third.z = random_gaussian(temp_third.z, range_norm) ;
      temp_third.w = random_gaussian(temp_third.w, range_norm) ;
    }
    // melanin
    if (carac.get("melanin") != null && carac.get("melanin")[0].catch_obj(0) instanceof vec4) {
      temp_melanin = (vec4)carac.get("melanin")[0].catch_obj(0) ;
      temp_melanin.x = random_gaussian(temp_melanin.x, range_norm) ;
      temp_melanin.y = random_gaussian(temp_melanin.y, range_norm) ;
      temp_melanin.z = random_gaussian(temp_melanin.z, range_norm) ;
      temp_melanin.w = random_gaussian(temp_melanin.w, range_norm) ;
    }

    // agent
    if (carac.get("life_expectancy") != null) temp_life_expectancy = (int) random_gaussian((int)carac.get("life_expectancy")[0].catch_obj(0)) ;
    // species
    if (carac.get("life_expectancy") != null) species_life_cycle = (int) random_gaussian((int)carac.get("life_expectancy")[0].catch_obj(0)) ;
    if (carac.get("sex_appeal") != null) {
      Object obj = carac.get("sex_appeal")[0].catch_obj(0) ;
      if(obj instanceof vec2) { 
        vec2 temp = (vec2) obj ;
        temp_sex_appeal.x = random_gaussian(temp.x);
        temp_sex_appeal.y = random_gaussian(temp.y);
      }
    }




    if(carac.get("multiple_pregnancy") != null) temp_multiple_pregnancy = random_gaussian((Float)carac.get("multiple_pregnancy")[0].catch_obj(0)) ;

    init_var_life_cycle(temp_life_expectancy, species_life_cycle, temp_size, temp_density) ;

    // genome info
    this.size = this.size_ref = this.size_max = temp_size ;
    this.density = temp_density ;
    this.mass = this.mass_ref = PApplet.parseInt((size.x +size.y +size.z) *.3f *this.density) ;

    this.stamina_ref = this.stamina = temp_stamina ;
    this.velocity = this.velocity_ref = temp_velocity ;
    this.name = temp_name ;
    this.sense_range = this.mass + temp_sense_range ;
    this.multiple_pregnancy = temp_multiple_pregnancy ;

    this.first_colour = temp_first.copy() ;
    this.second_colour = temp_second.copy() ;
    this.third_colour = temp_third.copy() ;

    this.melanin = temp_melanin.copy() ;

    this.gender = gender ;
    /**




    use 
    StringDict and floatDict





    */


    
    init_ID() ;
    init_dir() ;
    up_generation() ;

    int female_area_ratio = (int)temp_sex_appeal.x ;
    int male_area_ratio = (int)temp_sex_appeal.y ;
    set_reproduction(temp_sex_appeal) ;

    set_hunger_cycle() ;
    
    build_archetype_genome( temp_size, 
                            temp_density,
                            temp_life_expectancy,
                            temp_velocity, 
                            temp_sense_range, 
                            temp_name, 
                            temp_sex_appeal,
                            temp_multiple_pregnancy,
                            species_life_cycle,
                            temp_first,
                            temp_second,
                            temp_third,
                            temp_melanin,
                            generation,  
                            gender) ;

  }




  /**
  CONSTRUCTOR 
  Dynamic Agent from mother and father Genome
  */
  Agent_dynamic(Genome mother, Genome father, Info_Object style) {
    // aspect
    this.style = style ;
    set_aspect((vec4)style.catch_obj(1), (vec4)style.catch_obj(2), (float)style.catch_obj(3)) ;

    init_ID() ;
    init_dir() ;
    // update gene generation from mother line
    this.generation = (int)(Float.parseFloat(mother.get_gene("1").data_left_arm)) ;



    // create child genome
    genome = genotype(mother, father) ;
    // write mutation info in the genome

    

   
    
    // setting
    // chromosome String
    this.name = (String) genome.get_gene_product(1,0).catch_obj(0) ;


    // chromosome Float
    this.size = vec3((Float)genome.get_gene_product(0,0).catch_obj(0), (Float)genome.get_gene_product(0,1).catch_obj(0), (Float)genome.get_gene_product(0,2).catch_obj(0)) ;


    // generation is genome.get_gene_product(0,3).catch_obj(0)
    this.stamina_ref = this.stamina = PApplet.parseInt((Float)genome.get_gene_product(0,4).catch_obj(0));
    int life_expectancy_temp = PApplet.parseInt((Float)genome.get_gene_product(0,5).catch_obj(0)) ;

    this.velocity = this.velocity_ref = PApplet.parseInt((Float)genome.get_gene_product(0,6).catch_obj(0)) ;

    /*
    * this var is updated in the method init_var_life_cycle()
    */
    this.sense_range = PApplet.parseInt( (Float)genome.get_gene_product(0,7).catch_obj(0)) ;
    // sex appeal
    vec2 sex_appeal = vec2((Float)genome.get_gene_product(0,8).catch_obj(0), (Float)genome.get_gene_product(0,9).catch_obj(0)) ;
    // multi_pregnancy
    this.multiple_pregnancy = (Float)genome.get_gene_product(0,10).catch_obj(0) ;

    // cycle life
    int species_life_cycle = PApplet.parseInt((Float)genome.get_gene_product(0,11).catch_obj(0)) ;

    this.first_colour = vec4((Float)genome.get_gene_product(0,12).catch_obj(0), (Float)genome.get_gene_product(0,13).catch_obj(0),(Float)genome.get_gene_product(0,14).catch_obj(0), (Float)genome.get_gene_product(0,15).catch_obj(0)) ;
    this.second_colour = vec4((Float)genome.get_gene_product(0,16).catch_obj(0), (Float)genome.get_gene_product(0,17).catch_obj(0),(Float)genome.get_gene_product(0,18).catch_obj(0), (Float)genome.get_gene_product(0,19).catch_obj(0)) ;
    this.third_colour = vec4((Float)genome.get_gene_product(0,20).catch_obj(0), (Float)genome.get_gene_product(0,21).catch_obj(0),(Float)genome.get_gene_product(0,22).catch_obj(0), (Float)genome.get_gene_product(0,23).catch_obj(0)) ;

    this.melanin = vec4((Float)genome.get_gene_product(0,24).catch_obj(0), (Float)genome.get_gene_product(0,25).catch_obj(0),(Float)genome.get_gene_product(0,26).catch_obj(0), (Float)genome.get_gene_product(0,27).catch_obj(0)) ;
    
    this.density = (Float)genome.get_gene_product(0,28).catch_obj(0) ;
    
    up_generation() ;
    genome.mutation_data(0, 1, String.valueOf(generation), true, true);


    init_var_life_cycle(life_expectancy_temp, species_life_cycle, this.size, this.density) ;
    set_reproduction(sex_appeal) ;

    set_hunger_cycle() ;

    if((String) genome.get_gene_product("XX").catch_obj(0) == "X") {
      this.gender = 0  ; 
    } else { 
      this.gender = 1 ;
    }
  }




  /**
  GENOME
  */
  public void build_archetype_genome(vec3 size, float density, int life_expectancy, int velocity, int sense_range, String name, vec2 sex_appeal, float multiple_pregnancy, int species_life_cycle, 
                              vec4 first_colour, vec4 second_colour, vec4 third_colour, vec4 melanin, 
                              int generation, int gender) {
    float [] data_float = new float[42] ;
    data_float[0] = size.x ;
    data_float[1] = size.y ;
    data_float[2] = size.z ;

    data_float[3] = generation ;
    data_float[4] = stamina ;
    data_float[5] = life_expectancy ;
    data_float[6] = velocity ;

    data_float[7] = sense_range ;

    data_float[8] = sex_appeal.x ;
    data_float[9] = sex_appeal.y ;

    data_float[10] = multiple_pregnancy ;
    data_float[11] = species_life_cycle ;

    data_float[12] = first_colour.x ;
    data_float[13] = first_colour.y ;
    data_float[14] = first_colour.z ;
    data_float[15] = first_colour.w ;

    data_float[16] = second_colour.x ;
    data_float[17] = second_colour.y ;
    data_float[18] = second_colour.z ;
    data_float[19] = second_colour.w ;

    data_float[20] = third_colour.x ;
    data_float[21] = third_colour.y ;
    data_float[22] = third_colour.z ;
    data_float[23] = third_colour.w ;

    data_float[24] = melanin.x ;
    data_float[25] = melanin.y ;
    data_float[26] = melanin.z ;
    data_float[27] = melanin.w ;

    data_float[28] = density ;

    String [] data_string = new String[1] ;
    data_string[0] = name ;
    genome = archetype(data_float, data_string, gender) ;
  }
















  /**
  INIT
  */
  /**
  internal setting for constructor
  based on arbitrary life cycle model
  */
  public void init_var_life_cycle(int life_expectancy, int species_life_expectancy, vec3 size, float density) {

    this.life_expectancy = life_expectancy ;
    this.life = life_expectancy ;
    maturity = this.life_expectancy / 15 ;
    // we use species life expectancy to don't hava variation between the agent of same species
    fertility_cycle = species_life_expectancy / 45 ;
    fertility_time_ref = fertility_cycle / 5 ;
    pregnant_term = fertility_cycle *10  ;

    this.threshold_satisfation = this.life_expectancy /10 ;
    this.threshold_dissatisfaction = this.life_expectancy /10  ;

    this.mass = this.mass_ref = PApplet.parseInt((size.x +size.y +size.z) *.3f *density) ;

    this.sense_range = this.mass +this.sense_range ;

  }
  public void init_ID() {
    this.ID = (short) Math.round(random(Short.MAX_VALUE)) ;
  }

  public void up_generation() {
    this.generation++ ;
  }

  public void init_dir() {
    this.dir = vec3().rand(-1,1);
  }















  /**
  SET 1.0.1
   
  */
  /**
  internal set
  */
  public void set_hunger_cycle() {
    set_step_hunger(this.mass +this.stamina)  ;
    set_leptin(2.5f) ;
    set_hunger(this.step_hunger *2.f) ;
    if(hunger > step_hunger) satiate = true ;
  }


  public void set_reproduction(vec2 sex_appeal_ratio) {
    if(this.gender == 0) {
      this.reproduction_area = this.mass *2 ; 
      this.sex_appeal = PApplet.parseInt(this.mass *sex_appeal_ratio.x) ; 
    } else if (this.gender == 1) { 
      this.reproduction_area = this.mass *2 ; 
      this.sex_appeal = PApplet.parseInt(this.mass *sex_appeal_ratio.y) ; 
    }
  }
 

  /**
  set food
 */

  public void set_starving(int starving) {
    if(starving <= 0) starving = abs(starving) ;
    this.starving = starving ;
  }

  public void set_step_hunger(float step_hunger) {
    if(step_hunger <= 0) step_hunger = abs(step_hunger) ;
    this.step_hunger = (int)step_hunger ;
  }

  public void set_leptin(float level) {
    if(level <= 0) level = abs(level) ;
    this.leptin = PApplet.parseInt(this.step_hunger *level) ;
  }

  public void set_hunger(float hunger) {
    if(hunger <= 0) hunger = abs(hunger) ;
    this.hunger = (int)hunger ;
  }



  public void set_digestion(float digestion) {
    if(digestion <= 0) {
      println("Negative value, we use the absolute value.") ;
      this.digestion = abs(digestion) ;
    } else {
      this.digestion = digestion ;
    }
  }

  /**
  set motion
  */
  public void set_dir(vec3 dir) {
    this.dir.set(dir) ;
  }

  public void set_velocity(float velocity) {
    this.velocity = velocity ;
  }

  public void set_pos(vec pos) {
    if(pos instanceof vec3) {
      vec3 temp_pos = (vec3) pos ;
      this.pos.set(temp_pos) ;
      this.motion.set(temp_pos) ;
    }
    if(pos instanceof vec2) {
      vec2 temp_pos = (vec2) pos ;
      this.pos.set(temp_pos.x, temp_pos.y,0) ;
      this.motion.set(this.pos) ;
    }
  }



  /**
  set hunting and picking
  */
  public void set_watching(int  max_watching) {
    this.max_watching = max_watching ;
  }

  /**
  set carnivore
  */
  public void set_kill_zone(int radius) {
    this.kill_zone = radius ;
  }

  public void set_attack(int attack) {
    this.attack = attack ;
  }

  public void set_max_time_track(int max) {
    this.max_time_track = PApplet.parseInt(max *CLOCK) ;
  }
  /**

  */



















  /**
  GET pos
  */
  public vec3 get_pos_target() {
    return pos_target ;
  }
  public vec3 get_pos() {
    return pos ;
  }
  /**

  */















/**
FOODING

COMMON HUNT & SEARCH

*/
  // follow
  public void follow(Agent target) {
    if(target instanceof Agent_dynamic) {
      Agent_dynamic a = (Agent_dynamic) target ;
      pos_target.set(a.pos) ;
      dir.set(target_direction(a.pos, pos)) ;
    } else if (target instanceof Agent_static) {
      Agent_static a = (Agent_static) target ;
      pos_target.set(a.pos) ;
      dir.set(target_direction(a.pos, pos)) ;
    }
  }

  // distance to target
  public float dist_to_target(Agent target) {
    float dist = MAX_INT ;
    if(target instanceof Agent_dynamic) {
      Agent_dynamic a = (Agent_dynamic) target ;
      dist = dist(a.pos, pos) ;
      if(dist < sense_range) {
        pos_target.set(a.pos) ;
      } 
    } else if(target instanceof Agent_static) {
      Agent_static a = (Agent_static) target ;
      dist = dist(a.pos, pos) ;
      if(dist < sense_range) {
        pos_target.set(a.pos) ;
      } 
    }
    return dist ;
  }
  

  // track
  public void track(Agent target) {
    boolean target_alive = false ;
    if(target instanceof Agent_dynamic) {
      Agent_dynamic a = (Agent_dynamic) target ;
      target_alive = a.alive ; 
    } else {
      Agent_static a = (Agent_static) target ;
      target_alive = a.alive ; 
    }

    if(target_alive) {
      track_in_progress() ;
      follow(target) ;
    } else {
      track_stop() ;
    } 
  }

  public void track_in_progress() {
    time_track += 1 ;
    tracking = true ; 
    watching = false ;
  }

  public void track_stop() {
    time_track = 0 ;
    tracking = false ; 
    watching = true ;
  }

  // focus on target
  public boolean focus_target(ArrayList<Agent> list_target) {
    boolean check = false ;
    int pointer = (int)ID_target.x ;
    int ID = (int)ID_target.y ;
    if(pointer >= 0 && pointer < list_target.size()) {
      target = list_target.get((int)ID_target.x) ;
      if(target.get_ID() == ID) { 
        check = true ; 
      } else {
        for(Agent target_in_list : list_target) {
          if (target_in_list.get_ID() == ID ) {
            target = target_in_list ;
            check = true ;
            break ;
          } else check = false ;
        }
      }
    } else check = false ;
    return check ;
  }









  /**
  PICKING METHOD – for the herbivore by the way :)

  */
  // dist_ref_watch_flora value is used to compare the distace with the other flora in the range sens and avoid to change target if the target is before in the list
  float dist_ref_watch_flora = MAX_INT ;
  float ratio_food_ref = 0 ;

  public void watch(Flora f, ArrayList<Agent> list_target) {
    // if(time_watching < max_watching && !starving_bool) {
    if(time_watching < max_watching && !eating) {
      // change target
      if(starving_bool && focus_target(list_target)) {
        // check the previous target if there is one
        Agent target = list_target.get((int)ID_target.x) ;
        if(target instanceof Flora) {
          Flora target_flora = (Flora) target ;
          targeting(target_flora, list_target, true) ;
        }
      } else if (!starving_bool) {
        // search for target
        boolean ratio_food = false ;
        if(ratio_food_ref < ratio_food (f.mass, f.mass_ref, f.nutrient_quality, gourmet)) {
          ratio_food = true ;
        }
        targeting(f, list_target, ratio_food) ;
      } else {
        time_watching = 0 ;
      }
    }
  }


  // local method
  public void targeting(Flora target, ArrayList<Agent> list_target, boolean ratio_food) {
    float dist = dist(target.pos,pos) ;
    boolean threshold_quantity = threshold_food_quantity(target.mass, target.mass_ref, gourmet) ;
    /*
    if(!watching && !eating && !satiate && !tracking) {
      int tempo = 30 ;
      printTempo(tempo, "ID:",ID, "pos x:", (int)pos.x, "y:",(int)pos.y, "z:",(int)pos.z) ;
      printTempo(tempo, "ID:",ID, "target:", target.ID) ;
      printTempo(tempo, "ID:",ID, "target pos:", (int)target.pos.x, "y:",(int)target.pos.y, "z:",(int)target.pos.z) ;
      printTempo(tempo, "ID:",ID, "target size:", (int)target.size) ;
      printTempo(tempo, "ID:",ID, "dist:",  dist) ;
      printTempo(tempo, "ID:",ID, "range:", sense_range) ;
      printTempo(tempo, "ID:",ID, "dist ref flora:", dist_ref_watch_flora) ;
      printTempo(tempo, "ID:",ID, "threshold quality:", threshold_quantity, "ratio food:", ratio_food) ;
      printTempo(tempo, "--") ;
    }
    */
    if(dist < sense_range && dist < dist_ref_watch_flora && threshold_quantity && ratio_food) {
      ID_target.set(list_target.indexOf(target), target.ID) ;
      set_target(target) ;
      tracking = true ;
    } else {
      watching = true ;
    }
  }

  public void reset_watching_var() {
    dist_ref_watch_flora = MAX_INT ;
    ratio_food_ref = 0 ;
  }

  // set target
  public void set_target(Flora f) {
    // make ref of the best target / pray
    ratio_food_ref = ratio_food(f.mass, f.mass_ref, f.nutrient_quality, gourmet) ;
    dist_ref_watch_flora = dist(f.pos,pos) ;
    // 
    pos_target.set(f.pos) ;
    time_watching ++ ;
    watching = false ; 
  }

















  /**
  HUNTING METHOD – for the carnivore by the way

  */
  public void kill(Agent_dynamic target) {
    if(dist(target.pos,pos) < kill_zone && target.alive ) {
      pos_target.set(target.pos) ;
      target.stamina -= 1 *attack ;
    } else {
      //
    }
  }





















  /**
   FOODING, EATING, STARVING & Co 0.5.0

  */
  /**
  add stamina
  */
  public void eat_flesh(Agent_static a) {
    if(dist(a.pos,pos) < eat_zone && !a.alive && threshold_food_quantity(a.mass, a.mass_ref, gourmet)) {
      pos_target.set(a.pos) ;
      float calories = a.nutrient_quality *speed_feeding *digestion ;
      a.mass -= speed_feeding ;
      a.size.sub(speed_feeding *.33f) ;
      hunger += calories ;
      stamina += calories ;
      eating = true ;
    } else {
      eating = false ;
    }
  }

  public void eat_veg(Flora f) {
    if(dist(f.pos,pos) < eat_zone && threshold_food_quantity(f.mass, f.mass_ref, gourmet) ) {
      pos_target.set(f.pos) ;
      float calories = f.nutrient_quality *speed_feeding *digestion ;
      f.stamina -= (speed_feeding *.01f);
      f.mass -= (speed_feeding *.01f) ;
      f.size.sub(speed_feeding *.0033f) ;
      hunger += calories ;
      stamina += calories ;
      eating = true ;
      // re init var comparator
      reset_watching_var() ;
      dir.set(0) ;
    } else {
      eating = false ;
    }
  }

  /**
  remove stamina
  */
  // Fint starving_count ;
  public void hunger() {
    // hunger state
    if(hunger < step_hunger) {
      hunger_bool = true ; 
    } else {
      hunger_bool = false ;
    }
    // starving state
    if(hunger < (step_hunger /2)) {
      starving_bool = true ;
    } else {
      starving_bool = false ;
    }

    // hunger evolution
    if(frameCount%(1 +PApplet.parseInt(frameRate *CLOCK)) == 0) {
      if (hunger <= 0) {
        stamina -= starving ;
      } else {
        hunger -= starving ;
      }
    }
  }


//  int start_eating ;
  public void time_to_eat() {
    if(hunger_bool) {
      satiate = false ;
    } else {
      if (hunger > leptin) {
        satiate = true ; 
      }
    }
  }



  public boolean threshold_food_quantity(float size, float size_ref, float gourmet) {
    if(size > (size_ref / gourmet) ) return true ; else return false ;
  }

  public float ratio_food (float size, float size_ref, float nutrient_quality, float step) {
    return (size -(size_ref / step )) *nutrient_quality ;
  }
  /**

  */













  
  /**
  MOTION 1.0.1

  */
  public void motion() {
    velocity_update() ;
    velocity_xyz.set(velocity) ;
    velocity_xyz.mult(dir) ;
    motion.add(velocity_xyz) ;
    if(ENVIRONMENT == 2 ) pos.set(motion.x, motion.y, 0) ; else if(ENVIRONMENT == 3 ) pos.set(motion.x, motion.y, motion.z) ;
  }


  public void change_direction() {
    dir.set(vec3().rand(-1,1)) ;
  }


  public void velocity_update() {
    float ratio = vel_normal ;
    if(starving_bool) {
     // printTempo(90, "Starving") ;
      // starving
      if(tracking) {
        ratio = vel_fast_2 *vel_slow_1 ;
      //  printTempo(90, "tracking", ratio) ;
      }
      if(watching) {
        ratio = vel_normal *vel_slow_1  ;
     //   printTempo(90, "watching", ratio) ;
      }
      if(tracking_partner) {
        ratio = vel_fast_1 *vel_slow_1  ;
     //   printTempo(90, "tracking_partner", ratio) ;
      }
      if(satiate) {
        ratio = vel_normal *vel_slow_1 ;
     //   printTempo(90, "satiate", ratio) ;
      }
    } else {
      // normal
      if(tracking) ratio = vel_fast_2 ;
      if(watching) ratio = vel_normal ;
      if(tracking_partner) ratio = vel_fast_1 ;
      if(satiate) ratio = vel_normal ;
    }
    this.velocity = this.velocity_ref *ratio ;
  }
  public void rebound(vec6 limit, boolean rebound_on_limit) {
    if(ENVIRONMENT == 2 ) {
      rebound(limit.a(), limit.b(), limit.c(), limit.d(), 0, 0, rebound_on_limit) ;
    } else if(ENVIRONMENT == 3) {
      rebound(limit.a(), limit.b(), limit.c(), limit.d(), limit.e(), limit.f(), rebound_on_limit) ;
    }
  }
  
  public void rebound(float left, float right, float top, float bottom, float front, float back, boolean rebound_on_limit) {
    vec3 pos_temp = vec3(pos.x, pos.y, pos.z);
    vec3 dir_temp = vec3(dir.x, dir.y, dir.z);
    
    if(rebound_on_limit) {
      dir_temp.set(rebound(left, right, top, bottom, front, back, pos_temp, dir_temp)) ;
      dir.set(dir_temp) ;
    } else {
      vec3 motion_temp = vec3(motion.x, motion.y,motion.z) ;
      motion_temp.set(jump(left, right, top, bottom, front, back, motion_temp)) ;
      motion.set(motion_temp) ;
    }
  }


  // rebound
  public vec3 rebound(float left, float right, float top, float bottom, float front, float back, vec3 pos, vec3 dir) {
    // here we use size to have a physical rebound
    float effect = this.mass ;

    left -=effect ;
    right +=effect ;
    top -=effect ;
    bottom +=effect ;
    front -=effect;
    back +=effect;
    

    // detection x
    if(pos.x > right) {
      dir.x *= -1 ;
      pos.x = right ;
    } else if (pos.x < left) {
      dir.x *= -1 ;
      pos.x = left ;
    } 
    // detection y
    if(pos.y > bottom) {
      dir.y *= -1 ;
      pos.y = bottom ;
    } else if (pos.y < top) {
      dir.y *= -1 ;
      pos.y = top ;
    } 
    // detection z
    if(pos.z > back) {
      dir.z *= -1 ;
      pos.z = front ;
    } else if (pos.z < front) {
      dir.z *= -1 ;
      pos.z = back ;
    } 
    return vec3(dir) ;
  }

  // jump
  public vec3 jump(float left, float right, float top, float bottom, float front, float back, vec3 motion) {
    // here we use sense_range to find a good jump
    int effect = this.mass ;
    // effect = 0 ;
    left -=effect ;
    right +=effect ;
    top -=effect ;
    bottom +=effect ;
    front -=effect;
    back +=effect;

    if(pos.x > right) {
      motion.x = left ;
    } else if (pos.x < left) {
      motion.x = right ;
    }
    // detection y
    if(pos.y > bottom) {
      motion.y = top ;
    } else if (pos.y < top) {
      motion.y = bottom  ;
    }
    // detection z
    if(pos.z > back) {
      motion.z = front ;
    } else if (pos.z < front) {
      motion.z = back ;
    }
    return vec3(motion) ;
  }
  /**

  */

















  /**
  STATEMENT

  */


  boolean just_after_satiate ;

  public void statement() {
    int change_activity_every_frame = 300 ;

    maturity() ;
    time_to_eat() ;
    welfare() ;

    // migration
    if(starving_bool) {
      migration(change_activity_every_frame) ;
    }
    
    // chill attitude > walk time
    if(satiate) {
      float new_ratio_velocity_normalize = .5f ;
      if(just_after_satiate) { 
        chill(1, new_ratio_velocity_normalize) ;
        just_after_satiate = false ;
      }
      chill(change_activity_every_frame, new_ratio_velocity_normalize)  ;
    } else {
      velocity = velocity_ref ;
      just_after_satiate = true ;
    }

    if(!alive) dir.set(vec3(0)) ;
  }

  /**
  BEHAVIOR GLOBAL

  */
  /**
  welfare
  */
  public void welfare() {
    // modify by satiating
    level_satisfaction(satiate) ;
   // if(frameCount%300 == 0 )println(ID, level_satisfaction, level_dissatisfaction) ;
  }

  public void level_satisfaction(boolean satisfaction) {
    if(!satiate) {
      if(level_dissatisfaction < threshold_dissatisfaction) level_dissatisfaction++ ;
      if(level_satisfaction > 0) level_satisfaction-- ;
    } else {
      if(level_satisfaction < threshold_satisfation) level_satisfaction++ ;
      if(level_dissatisfaction > 0) level_dissatisfaction-- ;
    }
  }



  /**
  chill
  */
  public void chill(int step, float ratio_speed_motion) {
    if(frameCount%step == 0) {
      // velocity = velocity_ref *ratio_speed_motion ;
      //dir.set(vec3("RANDOM", 1)) ;
      change_direction() ;
    }
  }


  /**
  migration

  */
  public void migration(int step) {
    if(frameCount%step == 0) {
      change_direction() ;
    }
  }






  /**
  INFO

  */
  public void info_visual(vec4 colour) {
    vec3 pos_temp = vec3(0) ;
    aspect(vec4(0), colour_info(colour, satiate, pregnant, fertility), 1) ;
    start_matrix() ;
    translate(pos) ;
    ellipse(pos_temp.x, pos_temp.y, size.x *2, size.y *2) ;
    stop_matrix() ;
  }

  public void info_text(vec4 colour, int size_text) {
    aspect(colour_info(colour, satiate, pregnant, fertility), colour_info(colour, satiate, pregnant, fertility), 1) ;
    vec2 pos_text = vec2(0) ;
    start_matrix() ;
    translate(pos) ;
    textSize(size_text) ;
    textAlign(CENTER) ;
    float [] space = {0, 1.2f, 2.4f, 3.6f } ;
    text(name , pos_text.x, pos_text.y +(size_text *space[0])) ;
    text("Generation " + generation + " Gender " + gender, pos_text.x, pos_text.y +(size_text *space[1])) ;
    text(stamina + " " + size + " " + size_ref, pos_text.x, pos_text.y +(size_text *space[2])) ;
    if(alive) {
      if (eating) {
        text("I'm eating", pos_text.x, pos_text.y +(size_text *space[3])) ;
      } else {
        if(satiate) {
          text("I'm satiating", pos_text.x, pos_text.y +(size_text *space[3])) ;
        } else {
          text("I'm hungry", pos_text.x, pos_text.y +(size_text *space[3])) ;
        }
      }
    } else {
      if(!carrion) {
        text("I'm dead", pos_text.x, pos_text.y +(size_text *space[3])) ; 
      } else {
        text("I'm carrion", pos_text.x, pos_text.y +(size_text *space[3])) ; 
      }
    }
    stop_matrix() ;
  }

  /**
  Print

  */

  public void info_print() {
    // basic Agent info
    println(this.name + " " +this.getClass().getSimpleName()) ;
    info_print_caracteristic() ;
    info_print_motion() ;
    info_print_life() ;
    info_print_feeding() ;
    info_print_hunting_picking() ;
  }


  public void info_print_motion() {
    println("MOTION",this.name) ;
    println(this.ID, "velocity", this.velocity_ref) ;
    println(this.ID, "current velocity", this.velocity) ;
    println(this.ID, "position", this.pos) ;
    println(this.ID, "direction", this.dir) ;
    println(this.ID, "motion", this.motion) ;
  }


  public void info_print_life() {
    println("LIFE",this.name) ;
    println(this.ID, "life", this.life) ;
    println(this.ID, "stamina", this.stamina) ;
    println(this.ID, "alive", this.alive) ;
    println(this.ID, "carrion", this.carrion) ;
  }

  public void info_print_feeding() {
    println("FEED",this.name) ;
    println(this.ID, "satiate", this.satiate) ;
    println(this.ID, "eating", this.eating) ;
    println(this.ID, "hunger level", this.hunger) ;
    println(this.ID, "hunger", this.hunger_bool) ;
    println(this.ID, "starving", this.starving_bool) ;
  }

  public void info_print_hunting_picking() {
    println("HUNT / PICK",this.name) ;
    println(this.ID, "watching", this.watching) ;
    println(this.ID, "tracking", this.tracking) ;
  }








  /**
  LOG 0.1.1

  */
  Table log_a_d ;
  TableRow [] tableRow_a_d ;
  Info_Object [] info_a_d  ;
  int col_num = 4 ;
  int row_num = 30 ;
  boolean log_is ;

  public boolean log_is() {
    return log_is ;
  }

  // build
  public void build_log() {
    log_is = true ;
    log_a_d = new Table();
    tableRow_a_d = new TableRow[row_num] ;
    info_a_d = new Info_Object [row_num] ;
    for (int i = 0 ; i < row_num ; i++) {
      tableRow_a_d[i] = log_a_d.addRow();
    }
    

    // Col
    String [] col_name = new String[col_num] ;
    col_name[0] = "Agent" ;
    col_name[1] = "value x" ;
    col_name[2] = "value y" ;
    col_name[3] = "value z" ;
    // row
    String [] row_name = new String[row_num] ;
    int rank = 0 ;
    row_name[rank++] = "Name" ;
    // row_name[rank++] = "Species" ;
    // row_name[rank++] = "ID" ;
    row_name[rank++] = "Gender" ;
    row_name[rank++] = "Generation" ;
    row_name[rank++] = "Sex appeal" ;
    row_name[rank++] = "Multiple pregnancy" ;
    row_name[rank++] = "Pregnancy" ;
    row_name[rank++] = "Children" ;
    row_name[rank++] = "Homozygous" ;
    row_name[rank++] = "Heterozygous" ;

    row_name[rank++] = "Life" ;

    row_name[rank++] = "Size" ;

    row_name[rank++] = "Stamina" ;

    row_name[rank++] = "Sense range" ;
    
    row_name[rank++] = "Velocity" ;
    row_name[rank++] = "Position" ;

    row_name[rank++] = "Satiate" ;
    row_name[rank++] = "Starving" ;
    row_name[rank++] = "Hunger" ;
    row_name[rank++] = "Leptin" ;
    row_name[rank++] = "Eating" ;

    row_name[rank++] = "Watching" ;
    row_name[rank++] = "Tracking" ;

    row_name[rank++] = "Alive" ;
    row_name[rank++] = "Carrion" ;

    row_name[rank++] = "Log sequence" ;
    buildTable(log_a_d, tableRow_a_d, col_name, row_name) ;
  } 
  
  // update
  public void log(int tempo) {
    if(frameCount%tempo == 0) {
      int rank = 0 ;
      info_a_d[rank++] = new Info_Object ("Name", name, this.getClass().getSimpleName(), ID) ;
      if(gender ==0 ) info_a_d[rank++] = new Info_Object ("Gender", "Female") ; else info_a_d[rank++] = new Info_Object ("Gender", "Male") ;
      info_a_d[rank++] = new Info_Object ("Generation", generation) ;
      info_a_d[rank++] = new Info_Object ("Sex appeal", sex_appeal) ;
      info_a_d[rank++] = new Info_Object ("Multiple pregnancy", multiple_pregnancy) ;
      info_a_d[rank++] = new Info_Object ("Pregnancy", num_pregnancy) ;
      info_a_d[rank++] = new Info_Object ("Children", num_children) ;
      info_a_d[rank++] = new Info_Object ("Heterozygous", num_heterozygous) ;
      info_a_d[rank++] = new Info_Object ("Homozygous", num_homozygous) ;

      info_a_d[rank++] = new Info_Object ("Life", life, life_expectancy) ;

      info_a_d[rank++] = new Info_Object ("Size", size, size_ref) ;

      info_a_d[rank++] = new Info_Object ("Stamina", stamina, stamina_ref) ;

      info_a_d[rank++] = new Info_Object ("Sense range", sense_range) ;
      
      info_a_d[rank++] = new Info_Object ("Velocity", velocity) ;
      info_a_d[rank++] = new Info_Object ("Position", (int)pos.x, (int)pos.y, (int)pos.z) ;
      // info
      info_a_d[rank++] = new Info_Object ("Satiate", satiate) ;
      info_a_d[rank++] = new Info_Object ("Starving", starving_bool) ;
      info_a_d[rank++] = new Info_Object ("Hunger", hunger) ;
      info_a_d[rank++] = new Info_Object ("Leptin", leptin) ;
      info_a_d[rank++] = new Info_Object ("Eating", eating) ;

      info_a_d[rank++] = new Info_Object ("Watching", watching) ;
      info_a_d[rank++] = new Info_Object ("Tracking", tracking) ;

      info_a_d[rank++] = new Info_Object ("Alive", alive) ;
      info_a_d[rank++] = new Info_Object ("Carrion", carrion) ;
      
      info_a_d[rank++] = new Info_Object ("Log sequence", SEQUENCE_LOG) ;
      //
      setTable(log_a_d, tableRow_a_d, info_a_d) ;
 
      //
      saveTable(log_a_d, "log/Log_"+save_date()+"/agent/agent_specific_"+name+"/Seq_"+SEQUENCE_LOG+"_Time_"+hour()+"'"+minute()+"''"+second()+"'''/log_"+name+"_"+SEQUENCE_LOG+"_"+ID+".csv");
    }
  }
}

/**

END AGENT DYNAMIC CLASS

*/








































/**


Agent Static 0.2.1


*/
abstract class Agent_static extends Agent_model {
  /**
  specific
  */ 
  int speed_growth = 1 ;
  float need = 1.f ;


  /**
  Constructor

  */
  Agent_static(vec3 pos, vec3 size, int life_expectancy, String name) {
    this.pos.set(pos) ;
    this.life_expectancy = life_expectancy ;
    this.life = life_expectancy ;
    this.name = name ;
    this.ID = (short) Math.round(random(Short.MAX_VALUE)) ;
    this.size = this.size_ref = this.size_max  = size ;
    density = 1 ;
    this.mass = this.mass_ref = PApplet.parseInt((size.x +size.y +size.z) *.3f *this.density) ;
  }

  Agent_static(Info_dict carac, Info_Object style, int gender) {
    String temp_name = "Nobody" ;
    vec3 temp_size = vec3(1) ;
    float temp_density = 1 ;

    vec4 temp_first = vec4(1) ;
    vec4 temp_second = vec4(1) ;
    vec4 temp_third = vec4(1) ;
    vec4 temp_melanin = vec4(1) ;
    // 
    float range_norm = .15f ;
    // 

    this.ID = (short) Math.round(random(Short.MAX_VALUE)) ;
    if (carac.get("name") != null) temp_name = (String) carac.get("name")[0].catch_obj(0) ;

    if (carac.get("size") != null && carac.get("size")[0].catch_obj(0) instanceof vec3) {
      temp_size = (vec3)carac.get("size")[0].catch_obj(0) ;
      temp_size.x = random_gaussian(temp_size.x) ;
      temp_size.y = random_gaussian(temp_size.y) ;
      temp_size.z = random_gaussian(temp_size.z) ;
    }
    if (carac.get("density") != null) temp_density = random_gaussian((int)carac.get("density")[0].catch_obj(0), range_norm) ;

    
    if (carac.get("first_colour") != null) {
      temp_first = (vec4)carac.get("first_colour")[0].catch_obj(0) ;
      temp_first.x = random_gaussian(temp_first.x, range_norm) ;
      temp_first.y = random_gaussian(temp_first.y, range_norm) ;
      temp_first.z = random_gaussian(temp_first.z, range_norm) ;
      temp_first.w = random_gaussian(temp_first.w, range_norm) ;
    }
    if (carac.get("second_colour") != null) {
      temp_second = (vec4)carac.get("second_colour")[0].catch_obj(0) ;
      temp_second.x = random_gaussian(temp_second.x, range_norm) ;
      temp_second.y = random_gaussian(temp_second.y, range_norm) ;
      temp_second.z = random_gaussian(temp_second.z, range_norm) ;
      temp_second.w = random_gaussian(temp_second.w, range_norm) ;
    }
    if (carac.get("third_colour") != null) {
      temp_third = (vec4)carac.get("second_colour")[0].catch_obj(0) ;
      temp_third.x = random_gaussian(temp_third.x, range_norm) ;
      temp_third.y = random_gaussian(temp_third.y, range_norm) ;
      temp_third.z = random_gaussian(temp_third.z, range_norm) ;
      temp_third.w = random_gaussian(temp_third.w, range_norm) ;
    }

     // melanin
    if (carac.get("melanin") != null && carac.get("melanin")[0].catch_obj(0) instanceof vec4) {
      temp_melanin = (vec4)carac.get("melanin")[0].catch_obj(0) ;
      temp_melanin.x = random_gaussian(temp_melanin.x, range_norm) ;
      temp_melanin.y = random_gaussian(temp_melanin.y, range_norm) ;
      temp_melanin.z = random_gaussian(temp_melanin.z, range_norm) ;
      temp_melanin.w = random_gaussian(temp_melanin.w, range_norm) ;
    }

    this.name = temp_name ;
    this.size = this.size_ref = this.size_max = temp_size ;
    this.density = temp_density ;
    this.mass = this.mass_ref = PApplet.parseInt((size.x +size.y +size.z) *.3f *this.density) ;

    this.first_colour = temp_first.copy() ;
    this.second_colour = temp_second.copy() ;
    this.third_colour = temp_third.copy() ;

    this.gender = gender ;
  }
  
  /**
  set position
  * set_pos(arg) is not in the abstract class because for the dynamic agent the method is specific.
  */
  public void set_pos(vec pos) {
    if(pos instanceof vec3) {
      vec3 temp_pos = (vec3) pos ;
      this.pos.set(temp_pos) ;
    }
    if(pos instanceof vec2) {
      vec2 temp_pos = (vec2) pos ;
      this.pos.set(temp_pos.x, temp_pos.y,0) ;
    }
  }

  /**
  carrion
  */

  public void carrion() {
    int threshold = 2 ;
    if(!alive) {
      dead_since += PApplet.parseInt(1.f *CLOCK) ;
      if(this.mass < this.mass_ref / threshold || dead_since > TIME_TO_BE_CARRION) carrion = true ; 
      else carrion = false ;
    } 
  }

  /**
  info
  */
  public void info_text(vec4 colour, int size_text) {
    aspect(colour, colour, 1) ;
    vec2 pos_text = vec2(0) ;
    start_matrix() ;
    translate(pos) ;
    textSize(size_text) ;
    textAlign(CENTER) ;
    text(name, pos_text.x, pos_text.y) ;
    text(stamina + " " + mass + " " + mass_ref, pos_text.x, pos_text.y +(size_text *1.2f) ) ;
    textSize(16) ;
    if(alive) {
      text("I'm alive", pos_text.x, pos_text.y +(size_text *2.4f) ) ;
    } else {
      text("I'm dead", pos_text.x, pos_text.y +(size_text *2.4f) ) ;
    }
    stop_matrix() ;
  }
}
/**
END Agent Static
*/
/**
DYNAMIC SUB CLASS 
v 1.0.1

*/
/**
SUB CLASS HERBIVORE 0.2.1

*/
class Herbivore extends Agent_dynamic {

  // Herbivore(int size, int stamina, int life_expectancy, int velocity, int sense_range, String name, vec2 sex_appeal, int gender) {
  Herbivore(Info_dict carac, Info_Object style, int gender) {

    // super(size, stamina, life_expectancy, velocity, sense_range, name, sex_appeal, gender) ;
    super(carac, style, gender) ;
    // not in the genome
    set_kill_skill(this.mass) ;
  }


  Herbivore(Genome mother, Genome father, Info_Object style) {
    super(mother,father, style) ;
    // not in the genome
    set_kill_skill(this.mass) ;
  }

  public void set_kill_skill(int mass) {
    eat_zone = PApplet.parseInt(mass *1.2f) ;
  }



  /**
  info
  */
  public void info_visual(vec4 colour) {
    aspect(vec4(),colour_info(colour, satiate, pregnant, fertility), 1) ;
    vec3 pos_temp = vec3(0) ;
    start_matrix() ;
    translate(pos) ;
    ellipse(pos_temp.x, pos_temp.y, sense_range*2, sense_range*2) ;
    ellipse(pos_temp.x, pos_temp.y, eat_zone *2, eat_zone *2) ;
    ellipse(pos_temp.x, pos_temp.y, mass *2, mass *2) ;
    stop_matrix() ;
  }
  
  // print
  public void info_print_herbivore() {
    println("INFO",this.name) ;
    println("No particular info for the moment") ;
  }
}
/**
SUB CLASS HERBIVORE

*/









/**
SUB CLASS OMNIVORE 0.2.1

*/
class Omnivore extends Agent_dynamic {
  /*
  Omnivore(int size, int stamina, int life_expectancy, int velocity, int sense_range, String name, vec2 sex_appeal, int gender) {
    super(size, stamina, life_expectancy, velocity, sense_range, name, sex_appeal, gender) ;
    */
  Omnivore(Info_dict carac, Info_Object style, int gender) {
    super(carac, style, gender) ;
    // not in the genome
    set_kill_skill(this.mass) ;
  }


  Omnivore(Genome mother, Genome father, Info_Object style) {
    super(mother,father, style) ;
    // not in the genome
    set_kill_skill(this.mass) ;
  }

  public void set_kill_skill(int mass) {
  	kill_zone = PApplet.parseInt(mass *2) +mass ;
  	eat_zone = PApplet.parseInt(mass *1.2f) ;
  }

  /**
  info
  */
  public void info_visual(vec4 colour) {
    aspect(vec4(),colour_info(colour, satiate, pregnant, fertility), 1) ;
    vec3 pos_temp = vec3(0) ;
    start_matrix() ;
    translate(pos) ;
    ellipse(pos_temp.x, pos_temp.y, sense_range*2, sense_range*2) ;
    ellipse(pos_temp.x, pos_temp.y, eat_zone *2, eat_zone *2) ;
    ellipse(pos_temp.x, pos_temp.y, mass *2, mass *2) ;
    stop_matrix() ;
  }
  
  // print
  public void info_print_herbivore() {
    println("INFO",this.name) ;
    println("No particular info for the moment") ;
  }
}
/**
SUB CLASS OMNIVORE end

*/










/**
SUB CLASS CARNIVORE 0.2.1

*/
class Carnivore extends Agent_dynamic {
  /*
  Carnivore(int size, int stamina, int life_expectancy, int velocity, int sense_range, String name, vec2 sex_appeal, int gender) {
  super(size, stamina, life_expectancy, velocity, sense_range, name, sex_appeal, gender) ;
  */
  Carnivore(Info_dict carac, Info_Object style, int gender) {
    super(carac, style, gender) ;
    // not in the genome
    set_kill_skill(this.mass) ;

  }

  Carnivore(Genome mother, Genome father, Info_Object style) {
    super(mother,father, style) ;
    // not in the genome
    set_kill_skill(this.mass) ;
  }


  public void set_kill_skill(int mass) {
    kill_zone = PApplet.parseInt(mass *2) +mass ;
    eat_zone = PApplet.parseInt(mass *1.2f) ;
  }

  /**
  info
  */
  public void info_visual(vec4 colour) {
    vec3 pos_temp = vec3(0) ;
    aspect(vec4(), colour_info(colour, satiate, pregnant, fertility), 1) ;
    start_matrix() ;
    translate(pos) ;
    // info feed
    ellipse(pos_temp.x, pos_temp.y, sense_range*2, sense_range*2) ;
    ellipse(pos_temp.x, pos_temp.y, kill_zone *2, kill_zone *2) ;
    ellipse(pos_temp.x, pos_temp.y, eat_zone *2, eat_zone *2) ;
    ellipse(pos_temp.x, pos_temp.y, mass *2, mass *2) ;
    // info reproduction
    stop_matrix() ;
  }

  // print
  public void info_print_carnivore() {
    println("INFO",this.name) ;
    println("time track", PApplet.parseInt(time_track));
  }
}
/**
END SUB CLASS CARNIVORE

*/
















/**
SUB CLASS BACTERIUM 0.2.0

*/
class Bacterium extends Agent_dynamic {
  float humus_prod_ratio = .25f ;
  float humus_production  ;
   vec2 sex_appeal = vec2() ;

  /*
  Bacterium(int size, int stamina, int life_expectancy, int velocity, int sense_range, String name, int gender) {
    super(size, stamina, life_expectancy, velocity, sense_range, name, vec2(), gender) ;
    */
  Bacterium(Info_dict carac, Info_Object style, int gender) {
    super(carac, style, gender) ;
    set_kill_skill(this.mass) ;
  }
  
  // intern
  public void set_kill_skill(int mass) {
    eat_zone = PApplet.parseInt(mass *2) ;
  }
  
  // extern
  public void set_humus_prod(float prod) {
    this.humus_prod_ratio = prod ;
  }



  public void watch(Agent_static a, boolean info) {
    if(dist(a.pos,pos) < sense_range && !a.alive ) {
      pos_target.set(a.pos) ;
      watching = false ; 
    } else {
      watching = true ;
    }
  }




   // Method
  public void eat(Agent_static target, boolean info) {
    humus_production = 0 ;
    if(dist(target.pos,pos) < eat_zone ) {
      pos_target.set(target.pos) ;
      float calories = speed_feeding *humus_prod_ratio ;

      target.mass -= speed_feeding ;
      target.size.sub(speed_feeding *.33f) ;
      hunger += (calories *digestion) ;
      humus_production = calories *humus_prod_ratio ;
      stamina += (calories *.75f) ;
      eating = true ;
    } else {
      eating = false ;
    }
  }

  public float get_humus_production() {
    return humus_production ;
  }


  public void pick(Agent_static a) {
    if (!watching) dir.set(target_direction(a.pos,pos)) ; 
  }

  public boolean picking() {
    if (watching) return false ; else return true ;
  }
  

  /**
  info
  */
  public void info_visual(vec4 colour) {
    aspect(vec4(), colour_info(colour, satiate, pregnant, fertility), 1) ;
    vec3 pos_temp = vec3 (0) ;
    start_matrix() ;
    translate(pos) ;
    ellipse(pos_temp.x, pos_temp.y, sense_range*2, sense_range*2) ;
    ellipse(pos_temp.x, pos_temp.y, eat_zone *2, eat_zone *2) ;
    ellipse(pos_temp.x, pos_temp.y, mass *2, mass *2) ;
    stop_matrix() ;
  }


  // print
  public void info_print_bacterium() {
    println("INFO",this.name) ;
    println("No particular info for the moment") ;
  }
}
/**
END SUB CLASS BACTERIUM

*/
/**

DYNAMIC SUB CLASS END

*/

























/**

STATIC SUB CLASS 1.0.0

*/
/**
SUB CLASS FLORA 0.2.0

*/
class Flora extends Agent_static {

   Flora(vec3 pos, vec3 size, int life_expectancy,  String name) {
      super(pos, size, life_expectancy, name) ;
      this.mass = PApplet.parseInt((size.x + size.y + size.z) *.33f) ;
      this.stamina = this.stamina_ref = this.mass ;
   }
   /**
   Set Flora
   */
   public void set_growth(int speed) {
   	this.speed_growth = speed ;
   }

   public void set_need(float need) {
   	this.need = need ;
   }

   // Statement
   public void statement() {
     // if(size > size_max) size = size_max ;
     if(!size.equals(size_ref)) {
      size_ref.set(size) ;
      mass = PApplet.parseInt(size.average()) ;
     }
     if(stamina > stamina_ref) stamina = stamina_ref ;
   }

   public void feeding(Biomass biomass) {
      if(biomass.humus > 0) {
         if(frameCount%(180 *CLOCK) == 0 ) {
            this.mass += speed_growth ;
            this.size.add(speed_growth *.33f) ;
            this.stamina += speed_growth ;
            biomass.humus_update(-need) ;
         }
      }
   }
   /**
   // info
   */
   public void info_visual(vec4 colour) {
      vec3 pos_temp = vec3(0) ;
      aspect(vec4(), colour_info(colour), 1) ;
      start_matrix() ;
      translate(pos) ;
      // info feed
      strokeWeight(2) ;
      point(pos_temp) ;
      // info reproduction
      stop_matrix() ;
   }
   
   public void info_print_flora() {
   	println("INFO",this.name) ;
      println("No particular info for the moment") ;
   }
}
/**
END SUB CLASS FLORA

*/











/**
SUB CLASS DEAD 0.1.0

*/
class Dead extends Agent_static {
   /**
   MUST BE IMPROVE
   */
	Dead(vec3 pos, vec3 size, vec3 size_ref, int nutrient_quality, String name) {
    // int life = 0 ;
    super(pos, size, 0, name + " dead") ;

		this.nutrient_quality = nutrient_quality ;
		this.size_ref = size_ref ;
    this.mass = (int)size.average() ;
		this.alive = false ;
		vec4 colour_of_death = vec4(0,0,30,g.colorModeA);
		fill_style.set(colour_of_death) ;
		stroke_style.set(colour_of_death) ;

	}

   Dead(Info_dict carac, Info_Object style, int gender) {
      super(carac, style, gender) ;
      this.alive = false ;
   }

	/**
   // info
   */
   public void info_visual(vec4 colour) {
      vec3 pos_temp = vec3(0) ;
      aspect(vec4(), colour_info(colour), 1) ;
      start_matrix() ;
      translate(pos) ;

      strokeWeight(2) ;
      point(pos_temp) ;
 
      stop_matrix() ;
   }
   
   
   public void info_print_dead() {
   	println("INFO",this.name) ;
      println("No particular info for the moment") ;
   }
}
/**
SUB CLASS DEAD END

*/
/**
* DYNAMIC SUB METHOD 
* 0.2.2
* 2016-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Life
*/




/**
METHOD HERBIVORE 1.0.1

*/
/**
build herbivore method 0.0.5
*/
public void build_herbivore(ArrayList<Agent> list,  Info_dict carac, Info_Object style, int num) {
  int gender = 0 ;
  for(int i = 0 ; i < num ; i++) {
    if(gender > 1) gender = 0 ;
    String name = "human" ;
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      add_herbivore(list, pos, carac, gender, style) ;
    } else {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_herbivore(list, pos, carac, gender, style) ;
    }
    gender++ ;
  }
}

/**
add method
*/
public void add_herbivore(ArrayList<Agent> list, vec2 pos, Info_dict carac, int gender, Info_Object style) {
   vec3 final_pos = vec3(pos) ;
   add_herbivore(list, final_pos, carac, gender, style) ;
}

public void add_herbivore(ArrayList<Agent> list, vec3 pos, Info_dict carac, int gender, Info_Object style) {
  Agent h = new Herbivore(carac, style, gender) ;
  list.add(h) ;
  set_herbivore(h, pos, carac, style) ;
}

/**
set herbivore
*/
// set born
public void set_herbivore(Agent a, vec3 pos, Info_dict carac, Info_Object style) {
  float gourmet = (float) carac.get("gourmet")[0].catch_obj(0) ;
  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;
  int starving = (int) carac.get("starving")[0].catch_obj(0) ;
  float digestion = (float) carac.get("digestion")[0].catch_obj(0) ;

  a.set_costume((Costume)style.catch_obj(0)) ;
  a.set_fill((vec4)style.catch_obj(1)) ;
  a.set_stroke((vec4)style.catch_obj(2)) ;
  a.set_thickness((float)style.catch_obj(3)) ;
  a.set_alpha((vec3)style.catch_obj(4)) ;
  a.set_pos(pos) ;
  a.set_nutrient_quality(nutrient_quality) ;

  if(a instanceof Agent_dynamic) {
    Agent_dynamic a_d = (Agent_dynamic) a ;
    a_d.set_starving(starving) ;
    a_d.set_gourmet(gourmet) ;
    a_d.set_digestion(digestion) ;
  }
}

// set colour
boolean original_herbivore_aspect = true ;
vec4 fill_colour_herbivore, stroke_colour_herbivore ;
float thickness_herbivore ; 

public void set_aspect_herbivore(vec4 fill_colour, vec4 stroke_colour, float thickness) {
  original_herbivore_aspect = false ;
  if(fill_colour_herbivore == null) fill_colour_herbivore = vec4(fill_colour) ; else fill_colour_herbivore.set(fill_colour) ;
  if(stroke_colour_herbivore == null) stroke_colour_herbivore = vec4(stroke_colour) ; else stroke_colour_herbivore.set(stroke_colour) ;
  thickness_herbivore = thickness ;
}
/**
Reproduction specific part for each species
*/
/**
Female Reproduction
*/
public void reproduction_female_herbivore(ArrayList<Agent> list_female, ArrayList<Agent> list_male, ArrayList<Agent> list_child, Info_dict carac, Info_Object style) {
  //int count_female_fertile = 0 ;
  for (Agent female : list_female) {
    if(female instanceof Agent_dynamic) {
      Agent_dynamic f = (Agent_dynamic) female ;
      f.fertility(frameCount) ;
      if(f.fertility) {
        // count_female_fertile++ ;
        if (check_male_reproducer(female, list_male)) {
          f.reproduction() ;
        }
      } 
      f.pregnant() ;

      if(f.birth()) {
        delivery(f, f.genome, f.genome_father, list_child, carac, style) ;
      }
    }
  }
}
/**
HERBIVORE update 0.1.1
*/
public void herbivore_update(ArrayList<Dead> list_dead, ArrayList<Agent>... all_list) {
  for(ArrayList list : all_list) {
    update_die(list_dead, list) ;
    update_growth(list) ;
    update_motion(list) ;
    update_statement(list) ;
    if(LOG_ECOSYSTEM) update_log(list, FRAME_RATE_LOG) ;
  }
}
/**
HERBIVORE METHOD END

*/













/**
OMNIVORE METHOD 1.0.0

*/
/**
Build Omnivore 0.0.1

*/
public void build_omnivore(ArrayList<Agent> list, Info_dict carac, Info_Object style, int num) {
  int gender = 0 ;
  for(int i = 0 ; i < num ; i++) {
    if(gender > 1) gender = 0 ;
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      // add_omnivore(list_h, pos, carac.get("size"), carac.get("stamina"), carac.get("life"), carac.get("velocity"), carac.get("sense_range"), name, gender, carac.get("nutrient_quality"), colour) ;
      add_omnivore(list, pos, carac, gender, style) ;
    } else {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_omnivore(list, pos, carac, gender, style) ;
    }
    gender++ ;
  }
}

public void add_omnivore(ArrayList<Agent> list, vec2 pos, Info_dict carac, int gender, Info_Object style) {
   vec3 final_pos = vec3(pos) ;
   add_omnivore(list, final_pos, carac, gender, style) ;
}

public void add_omnivore(ArrayList<Agent> list, vec3 pos, Info_dict carac, int gender, Info_Object style) {
  // send data to constructor
  // Agent o = new Omnivore(size, stamina, life_expectancy, velocity, sense_range, name, sex_appeal, gender) ;
  Agent o = new Omnivore(carac, style, gender) ;

  list.add(o) ;
  set_omnivore(o, pos, carac, style) ;
}

/**
local method
*/
/**
set
*/
public void set_omnivore(Agent a, vec3 pos, Info_dict carac, Info_Object style) {
  int attack = (int) carac.get("attack")[0].catch_obj(0) ;
  float gourmet = (float) carac.get("gourmet")[0].catch_obj(0) ;
  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;
  int starving = (int) carac.get("starving")[0].catch_obj(0) ;
  float digestion = (float) carac.get("digestion")[0].catch_obj(0) ;

  a.set_costume((int)style.catch_obj(0)) ;
  a.set_fill((vec4)style.catch_obj(1)) ;
  a.set_stroke((vec4)style.catch_obj(2)) ;
  a.set_thickness((float)style.catch_obj(3)) ;
  a.set_pos(pos) ;
  a.set_nutrient_quality(nutrient_quality) ;

  if(a instanceof Agent_dynamic) {
    Agent_dynamic a_d = (Agent_dynamic) a ;
    a_d.set_attack(attack) ;
    a_d.set_gourmet(gourmet) ;
    a_d.set_starving(starving) ;
    a_d.set_digestion(digestion) ;
    // set_omnivore(n_a, pos, nutrient_quality, colour) ;
  }
}


/**
Female Reproduction
*/
public void reproduction_female_omnivore(ArrayList<Agent> list_female, ArrayList<Agent> list_male, ArrayList<Agent> list_child, Info_dict carac, Info_Object style) {
  // int count_female_fertile = 0 ;
  for (Agent female : list_female) {
    if(female instanceof Agent_dynamic) {
      Agent_dynamic f = (Agent_dynamic) female ;
      f.fertility(frameCount) ;
      if(f.fertility) {
        // count_female_fertile++ ;
        if (check_male_reproducer(female, list_male)) {
          f.reproduction() ;
        }
      } 
      f.pregnant() ;

      if(f.birth()) {
        delivery(f, f.genome, f.genome_father, list_child, carac, style) ;
      }
    }
  }
}

/**
Omnivore update 0.0.1
*/

public void omnivore_update(ArrayList<Dead> list_dead, ArrayList<Agent>... all_list) {
  for(ArrayList list : all_list) {
    update_die(list_dead, list) ;
    update_growth(list) ;
    update_motion(list) ;
    update_statement(list) ;
    if(LOG_ECOSYSTEM) update_log(list, FRAME_RATE_LOG) ;
  }
}
/**
OMNIVORE METHOD END

*/












/**
CARNIVORE METHOD 1.0.0

*/
/**
CARNIVORE build 0.1.0
*/
public void build_carnivore(ArrayList<Agent> list, Info_dict carac, Info_Object style, int num) {
  int gender = 0 ;
  for(int i = 0 ; i < num ; i++) {
    if(gender > 1) gender = 0 ;
    String name = "ALIEN" ;
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      add_carnivore(list, pos, carac, gender, style) ;
    } else {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_carnivore(list, pos, carac, gender, style) ;
    }
    gender++ ;
  }
}

public void add_carnivore(ArrayList<Agent> list, vec2 pos, Info_dict carac, int gender, Info_Object style) {
   vec3 final_pos = vec3(pos) ;
   add_carnivore(list, final_pos, carac, gender, style) ;
}
public void add_carnivore(ArrayList<Agent> list, vec3 pos, Info_dict carac, int gender, Info_Object style) {
    // recover data
    /*
  String name = (String) carac.get("name")[0].catch_obj(0) ;
  int size = (int) carac.get("size")[0].catch_obj(0) ;
  int stamina = (int)carac.get("stamina")[0].catch_obj(0) ;
  int velocity = (int)carac.get("velocity")[0].catch_obj(0) ;
  int sense_range = (int) carac.get("sense_range")[0].catch_obj(0) ;
  int life_expectancy =(int) carac.get("life_expectancy")[0].catch_obj(0) ;
  vec2 sex_appeal = (vec2)carac.get("sex_appeal")[0].catch_obj(0) ;
  */
  // send data to constructor
  // Agent c = new Carnivore(size, stamina, life_expectancy, velocity, sense_range, name, sex_appeal, gender) ;
  Agent c = new Carnivore(carac, style, gender) ;
  list.add(c) ;
  set_carnivore(c, pos, carac, style) ;

}

public void set_carnivore(Agent c, vec3 pos, Info_dict carac, Info_Object style) {
  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;
  int attack = (int) carac.get("attack")[0].catch_obj(0) ;
  float gourmet = (float) carac.get("gourmet")[0].catch_obj(0) ;
  int starving = (int) carac.get("starving")[0].catch_obj(0) ;
  float digestion = (float) carac.get("digestion")[0].catch_obj(0) ;

  c.set_costume((Costume)style.catch_obj(0)) ;
  c.set_fill((vec4)style.catch_obj(1)) ;
  c.set_stroke((vec4)style.catch_obj(2)) ;
  c.set_thickness((float)style.catch_obj(3)) ;
  c.set_pos(pos) ;
  c.set_nutrient_quality(nutrient_quality) ;

  if(c instanceof Agent_dynamic) {
    Agent_dynamic a_d = (Agent_dynamic) c ;
    a_d.set_attack(attack) ;
    a_d.set_gourmet(gourmet) ;
    a_d.set_starving(starving) ;
    a_d.set_digestion(digestion) ;
  }
}

/**
set colour carnivore
*/
boolean original_carnivore_aspect = true ;
vec4 fill_colour_carnivore, stroke_colour_carnivore ;
float thickness_carnivore ; 
public void set_aspect_carnivore(vec4 fill_colour, vec4 stroke_colour, float thickness) {
  original_carnivore_aspect = false ;
  if(fill_colour_carnivore == null) fill_colour_carnivore = vec4(fill_colour) ; else fill_colour_carnivore.set(fill_colour) ;
  if(stroke_colour_carnivore == null) stroke_colour_carnivore = vec4(stroke_colour) ; else stroke_colour_carnivore.set(stroke_colour) ;
  thickness_carnivore = thickness ;
}

/**
Female Reproduction
*/
public void reproduction_female_carnivore(ArrayList<Agent> list_female, ArrayList<Agent> list_male, ArrayList<Agent> list_child, Info_dict carac, Info_Object style) {
  // int count_female_fertile = 0 ;
  for (Agent female : list_female) {
    if(female instanceof Agent_dynamic) {
      Agent_dynamic f = (Agent_dynamic) female ;
      f.fertility(frameCount) ;
      if(f.fertility) {
        // count_female_fertile++ ;
        if (check_male_reproducer(female, list_male)) {
          f.reproduction() ;
        }
      } 
      f.pregnant() ;

      if(f.birth()) {
        delivery(f, f.genome, f.genome_father, list_child, carac, style) ;
      }
    }
  }
}

/**
CARNIVORE update 0.2.0
*/
public void carnivore_update(ArrayList<Dead> list_dead, ArrayList<Agent>... all_list) {
  for(ArrayList list : all_list) {
    update_die(list_dead, list) ;
    update_growth(list) ;
    update_motion(list) ;
    update_statement(list) ;
    if(LOG_ECOSYSTEM) update_log(list, FRAME_RATE_LOG) ;
  }
}
/**
CARNIVORE METHOD END

*/









/**
BACTERIUM METHOD

*/
/**
BUILD BACTERIUM 0.1.0
*/
public void build_bacterium(ArrayList<Agent> list, Info_dict carac, Info_Object style, int num) {
  for(int i = 0 ; i < num ; i++) {
    String name = "bacterium" ;
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      add_bacterium(list, pos, carac, style) ;
    } else {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_bacterium(list, pos, carac, style) ;
    }
  }
}

public void add_bacterium(ArrayList<Agent> list, vec2 pos, Info_dict carac, Info_Object style) {
  vec3 final_pos = vec3(pos) ; // in case 2D world
  add_bacterium(list, final_pos, carac, style) ;
}

public void add_bacterium(ArrayList<Agent> list, vec3 pos, Info_dict carac, Info_Object style) {
  int gender = 0 ;
  Agent b = new Bacterium(carac, style, gender) ;
  list.add(b) ;
  set_bacterium(b, pos, carac, style) ;
}




public void set_bacterium(Agent b, vec3 pos, Info_dict carac, Info_Object style) {
  float digestion = (float) carac.get("digestion")[0].catch_obj(0) ;
  int starving = (int) carac.get("starving")[0].catch_obj(0) ;
  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;
  
  b.set_costume((Costume)style.catch_obj(0)) ;
  b.set_fill((vec4)style.catch_obj(1)) ;
  b.set_stroke((vec4)style.catch_obj(2)) ;
  b.set_thickness((float)style.catch_obj(3)) ;
  b.set_pos(pos) ;
  b.set_nutrient_quality(nutrient_quality) ;

  if(b instanceof Agent_dynamic) {
    Agent_dynamic a_d = (Agent_dynamic) b ;
    a_d.set_digestion(digestion) ;
    a_d.set_starving(starving) ;
  }
}



/**
set colour bacterium
*/
boolean original_bacterium_aspect = true ;
vec4 fill_colour_bacterium, stroke_colour_bacterium ;
float thickness_bacterium ; 
public void set_aspect_bacterium(vec4 fill_colour, vec4 stroke_colour, float thickness) {
  original_bacterium_aspect = false ;
  if(fill_colour_bacterium == null) fill_colour_bacterium = vec4(fill_colour) ; else fill_colour_bacterium.set(fill_colour) ;
  if(stroke_colour_bacterium == null) stroke_colour_bacterium = vec4(stroke_colour) ; else stroke_colour_bacterium.set(stroke_colour) ;
  thickness_bacterium = thickness ;
}

/**
Bacterium update 0.1.1
*/
public void bacterium_update(ArrayList<Dead> list_dead, ArrayList<Agent> list,  Biomass biomass, boolean info) {
  update_die(list_dead, list) ;
  update_motion(list) ;
  update_statement(list) ;
  bacterium_update_feed(list_dead, list, biomass, info) ;
  if(LOG_ECOSYSTEM) update_log(list, FRAME_RATE_LOG) ;
}

/**
show bacterium specific method
*/
public void show_bacterium(Biomass biomass, Info_Object style, ArrayList<Agent>... all_list) {
  for(ArrayList list : all_list) {
    if(INFO_DISPLAY_AGENT) {
      info_agent(list) ;
      info_agent_track_line(list) ;
    } else {
      update_aspect(style, list) ;
    }
  }
}

/**
Bacterium update
*/
public void bacterium_update_feed(ArrayList<Dead> list_dead_body, ArrayList<Agent> list_b, Biomass biomass, boolean info) {
  for(Agent a : list_b) {
    if(a instanceof Bacterium) {
      Bacterium b = (Bacterium) a ;
      if(!b.satiate && list_dead_body.size() >= 0) {
        hunt_dead_agent(b, list_dead_body, info) ;
      }
      if(list_dead_body.size() >= 0 ) {
        eat_corpse(b, list_dead_body, biomass, info) ; 
      } else { 
        b.eating = false ;
      }
      b.hunger() ;
    }
  }
}


/**
local method
*/
public void eat_corpse(Bacterium b, ArrayList<Dead> list_target, Biomass biomass, boolean info) {
// first eat the agent who eat just before without look in the list
  if(b.eating) {
    int pointer = (int)b.ID_target.x ;
    int ID_target = (int)b.ID_target.y ;
    /* here we point directly in a specific point of the list, 
    if the pointer is superior of the list, 
    because if it's inferior a corpse can be eat by an other Agent */
    if(pointer < list_target.size() ) {
      Agent target = list_target.get((int)b.ID_target.x) ;
      /* if the entry point of the list return an agent 
      with a same ID than a ID_target corpse eat just before, 
      the Carnivore can continue the lunch */
      if (target instanceof Agent_static && target.get_ID() == ID_target) {
        Agent_static target_meat = (Agent_static) target ;
        b.eat(target_meat, info) ;
        biomass.humus_update(b.get_humus_production()) ;
        //biomass.humus += b.get_humus_production() ;
      } else {
        /* If the ID returned is different, a corpse was leave from the list, 
        and it's necessary to check in the full ist to find if any corpse have a seme ID */
        for(Agent target_in_list : list_target) {
          if (target_in_list instanceof Agent_static && target_in_list.get_ID() == ID_target ) {
            Agent_static target_meat = (Agent_static) target_in_list ;
            b.eat(target_meat, info) ; 
          } else b.eating = false ;
        }
      }
    }
  /* If the last research don't find the corpse, may be this one is return to dust ! */
  } else {
    for(Agent target : list_target) {
      if(target instanceof Agent_static) {
        Agent_static target_meat = (Agent_static) target ;
        b.eat(target_meat, info) ;
      }

      if(b.eating) {
        b.ID_target.set(list_target.indexOf(target),target.get_ID()) ;
        break ;
      }
    }
  }
}


public void hunt_dead_agent(Bacterium b, ArrayList<Dead> list_target, boolean info) {
  for(Agent target : list_target) {
    if(target instanceof Agent_static) {
      Agent_static target_dead = (Agent_static) target ;
      b.watch(target_dead, info) ;
      b.pick(target_dead) ;
      if(b.picking()) break ;
    }
  }
}
/**
BACTERIUM METHOD END

*/
/**

DYNAMIC METHOD END

*/








































/**
STATIC SUB METHOD 
METHOD FLORA 1.2.0
build 0.3.0
*/
// main method
public void build_flora(ArrayList<Agent> list_f, Info_dict carac, Info_Object style, int num) {
  for(int i = 0 ; i < num ; i++) {
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      add_flora(list_f, pos, carac, style) ;
    } else if (ENVIRONMENT == 3 ) {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_flora(list_f, pos, carac, style) ;
    }
  }
}

public void build_flora(ArrayList<Agent> list_f, Info_dict carac, Info_Object style, int num, vec... area) {
  println("num", num, "area length", area.length) ;
  for(int i = 0 ; i < num ; i++) {
    // it's not possible to give home to everybody, sorry
    if(i < area.length) {
      if(ENVIRONMENT == 2) {
        if(area[i] instanceof vec2) {
          vec2 spawn_pos = (vec2) area[i] ;
          add_flora(list_f, spawn_pos, carac, style) ;
        }
        if(area[i] instanceof vec3) {
          vec3 spawn_pos = (vec3) area[i] ;
          add_flora(list_f, vec2(spawn_pos.x, spawn_pos.y), carac, style) ;
        } else {
          System.err.println("Arg area in not an instance of vec2 or vec3, no agent can be add") ;
        }  
      } else if (ENVIRONMENT == 3) {
        if(area[i] instanceof vec2) {
          vec2 spawn_pos = (vec2) area[i] ;
          add_flora(list_f, vec3(spawn_pos.x, spawn_pos.y, 0), carac, style) ;
        }
        if(area[i] instanceof vec3) {
          vec3 spawn_pos = (vec3) area[i] ;
          add_flora(list_f, spawn_pos, carac, style) ;
        } else {
          System.err.println("Arg area in not an instance of vec2 or vec3, no agent can be add") ;
        } 
      }
    // it's not possible to give home to everybody, sorry
    } else {
      System.err.println("the population is above the home place") ;
    }
  }
}


// annexe methode
// add
public void add_flora(ArrayList<Agent> list_f, vec2 pos, Info_dict carac, Info_Object style) {
   vec3 final_pos =  vec3(pos.x,pos.y,0) ;
   add_flora(list_f, final_pos, carac, style) ;
}
public void add_flora(ArrayList<Agent> list_f, vec3 pos, Info_dict carac, Info_Object style) {
    // recover data
  String name = (String) carac.get("name")[0].catch_obj(0) ;
  vec3 size_template = (vec3) carac.get("size")[0].catch_obj(0) ;
  int life_expectancy = (int) carac.get("life_expectancy")[0].catch_obj(0) ;

  float s_x = random(ceil(size_template.x *.5f), ceil(size_template.x *3)) ;
  float s_y = random(ceil(size_template.y *.5f), ceil(size_template.y *3)) ;
  float s_z = random(ceil(size_template.z *.5f), ceil(size_template.z *3)) ;
  vec3 size = vec3(s_x, s_y, s_z) ;

  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;
  int speed_growth = (int) carac.get("speed_growth")[0].catch_obj(0) ;
  float need = (Float) carac.get("need")[0].catch_obj(0) ;

  Flora f = new Flora(pos, size, life_expectancy, name) ;
   list_f.add(f) ;
   // aspect
   f.set_costume((Costume)style.catch_obj(0));
   f.set_fill((vec4)style.catch_obj(1)) ;
   f.set_stroke((vec4)style.catch_obj(2)) ;
   f.set_thickness((float)style.catch_obj(3)) ;
   f.set_alpha((vec3)style.catch_obj(4)) ;
   // plant
   f.set_nutrient_quality(nutrient_quality) ;
   f.set_growth(speed_growth) ;
   f.set_need(need) ;
   //f.set_pos(pos) ;
}

/**
 set aspect flora
 */
boolean original_flora_aspect = true ;
vec4 fill_colour_flora, stroke_colour_flora ;
float thickness_flora ; 
public void set_aspect_flora(vec4 fill_colour, vec4 stroke_colour, float thickness) {
  original_flora_aspect = false ;
  if(fill_colour_flora == null) fill_colour_flora = vec4(fill_colour) ; else fill_colour_flora.set(fill_colour) ;
  if(stroke_colour_flora == null) stroke_colour_flora = vec4(stroke_colour) ; else stroke_colour_flora.set(stroke_colour) ;
  thickness_flora = thickness ;
}


/**
Flora update 0.0.3
*/
public void flora_update(ArrayList<Agent> list_f, Biomass b) {
  /**
  may be this part can be improve, not sure is necessary to read the list for each update ??????
  */
  flora_update_kill(list_f) ;
  flora_update_growth(list_f) ;
  flora_update_feed(list_f, b) ;
  flora_update_statement(list_f) ;
  flora_update_opacity(list_f) ;
}

public void flora_show(Info_Object style, ArrayList<Agent> list_f) {
  if(!INFO_DISPLAY_AGENT) {
    update_aspect(style, list_f) ;
    // flora_update_aspect(list_f) ;
  } else {
    info_agent(list_f) ;
  }
}
/**
Flora update()
*/

public void flora_update_kill(ArrayList<Agent> list_f) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      if(f.stamina < 0 ) {
        list_f.remove(f) ;
        break ;
      }
    }
  }
}

public void flora_update_feed(ArrayList<Agent> list_f, Biomass b) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      f.feeding(b) ;
    }
  }
}

public void flora_update_growth(ArrayList<Agent> list_f) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      f.growth() ;
    }
  }
}

public void flora_update_statement(ArrayList<Agent> list_f) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      f.statement() ;
    }
  }
}

public void flora_update_opacity(ArrayList<Agent> list_f) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      float ratio = PApplet.parseFloat(f.mass) / PApplet.parseFloat(f.mass_ref) ;
      float alpha = g.colorModeA *ratio ;
      if(alpha <= 0) alpha = .001f ;
      f.fill_style.set(f.fill_style.x, f.fill_style.y, f.fill_style.z, alpha) ;
      f.stroke_style.set(f.stroke_style.x, f.stroke_style.y, f.stroke_style.z, alpha) ;
    }
  }
}


/*
void flora_update_aspect(ArrayList<Agent> list_f) {
  for(Agent a : list_f) {
    if(a instanceof Flora) {
      Flora f = (Flora) a ;
      if(original_flora_aspect) {
        f.aspect(f.fill_style, f.stroke_style, 1) ; 
      } else {
        f.aspect(fill_colour_flora, stroke_colour_flora, thickness_flora) ;
      }
      f.costume() ; 
    }
  }
}
*/
/**
METHOD FLORA End

*/



































/**
METHOD DEAD 1.0.0

*/
/**
set colour dead
*/
boolean original_corpse_aspect = true ;
vec4 fill_colour_corpse, stroke_colour_corpse ;
float thickness_corpse ; 
public void set_aspect_corpse(vec4 fill_colour, vec4 stroke_colour, float thickness) {
  original_corpse_aspect = false ;
  if(fill_colour_corpse == null) fill_colour_corpse = vec4(fill_colour) ; else fill_colour_corpse.set(fill_colour) ;
  if(stroke_colour_corpse == null) stroke_colour_corpse = vec4(stroke_colour) ; else stroke_colour_corpse.set(stroke_colour) ;
  thickness_corpse = thickness ;
}

public void build_dead(ArrayList<Dead> list, Info_dict carac, Info_Object style, int num) {
  for(int i = 0 ; i < num ; i++) {
    if(ENVIRONMENT == 2 ) {
      vec2 pos = vec2().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()));
      add_dead(list, pos, carac, style) ;
    } else {
      vec3 pos = vec3().rand(vec2(LIMIT.a(),LIMIT.b()),vec2(LIMIT.c(),LIMIT.d()),vec2(LIMIT.e(),LIMIT.f()));
      add_dead(list, pos, carac, style) ;
    }
  }
}



public void add_dead(ArrayList<Dead> list, vec pos, Info_dict carac, Info_Object style) {
  int gender = (int)round(random(1));
  Dead dead = new Dead(carac, style, gender) ;
  set_dead(dead, pos, carac, style) ;
  list.add(dead) ;

}


public void set_dead(Agent d, vec pos, Info_dict carac, Info_Object style) {

  int nutrient_quality = (int) carac.get("nutrient_quality")[0].catch_obj(0) ;

  d.set_costume((Costume)style.catch_obj(0)) ;
  d.set_fill((vec4)style.catch_obj(1)) ;
  d.set_stroke((vec4)style.catch_obj(2)) ;
  d.set_thickness((float)style.catch_obj(3)) ;
  d.set_pos(pos) ;
  d.set_nutrient_quality(nutrient_quality) ;
   /*
  if(a instanceof Agent_static) {
    Agent_static a_s = (Agent_static) a ;
    a_s.set_pos(pos) ;
    a_s.set_nutrient_quality(nutrient_quality) ;
    a_s.set_fill(colour) ;
    a_s.set_stroke(colour) ;
  }
  */
}



/**
CORPSE || DEAD BODY update 0.1.0
*/
public void dead_update(ArrayList<Dead> list) {
  dead_remove(list) ;
  carrion_update(list) ;
  /*
  rework log for dead list
  */
  // if(LOG_ECOSYSTEM) update_log(list, FRAME_RATE_LOG) ;
}

public void show_dead(Info_Object style, ArrayList<Dead> list_dead) {
  if(INFO_DISPLAY_AGENT) {
    info_agent(list_dead) ;
  } else {
    // dead_aspect(list_dead) ;
    update_aspect(style, list_dead) ;
  }
}



/**
update dead body / corpse
*/
public void dead_remove(ArrayList<Dead> list) {
  for(Dead dead : list) {
    if(dead.get_mass() <= 0) {
      list.remove(dead) ;
      break ;
    }
  }
}



public void carrion_update(ArrayList<Dead> list) {
  for(Dead dead : list) {
    if(dead instanceof Agent_static) {
      Agent_static corpse = (Agent_static) dead ;
      corpse.carrion() ;
    }
  }
}

/**
DEAD METHOD END

*/




/**
* GENETIC 
*v 0.6.2
* 2016-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Life
*/



/**
GENOTYPE
v 0.1.0
*/
/*
methode to generate a new genome from the mother and father genome
*/
public Genome genotype(Genome mother, Genome father) {
  if(mother.num_chromosome() == father.num_chromosome() && mother.num_gene() == father.num_gene()) {
    // may be remove "1" for the gender chromosome ????
    String [] chromosome_name = new String[mother.num_chromosome() -1] ;
    for(int i = 0 ; i < chromosome_name.length ; i++) {
      chromosome_name[i] = mother.get_chromosome_name()[i] ;
    }
    String [] gene_name = new String[mother.num_gene() -1] ;
    Gene [] gene_data_mother = new Gene[mother.num_gene() -1] ;
    Gene [] gene_data_father = new Gene[mother.num_gene() -1] ;
    for(int i = 0 ; i < gene_name.length ; i++) {
      gene_name[i] = mother.get_genotype()[i].gene_name ;
      gene_data_mother[i] = mother.get_genotype()[i] ;
      gene_data_father[i] = father.get_genotype()[i] ;

    }
    return new Genome(chromosome_name, gene_name, gene_data_mother, gene_data_father) ;

  } else {
    return null ;
  }
}



/**
ARCHETYPE
v 0.1.0
*/
/*
method to generate a quick genome from a simple data
The method create two chromosome, one for the data value, one for the String data
int this method the first genome is used for the float data and the second for the String data
*/
public Genome archetype(float [] float_data) {
  String [] string_data = new String[0] ;
  String [] data_name = new String[0] ;
  int gender = MAX_INT ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(String [] string_data) {
  float [] float_data = new float[0] ;
  String [] data_name = new String[0] ;
  int gender = MAX_INT ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(float [] float_data, String [] data_name) {
  String [] string_data = new String[0] ;
  int gender = MAX_INT ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(String [] string_data, String [] data_name) {
  float [] float_data = new float[0] ;
  int gender = MAX_INT ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(float [] float_data, String [] string_data, String [] data_name) {
  int gender = MAX_INT ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(float [] float_data, int gender) {
  String [] string_data = new String[0] ;
  String [] data_name = new String[0] ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(String [] string_data, int gender) {
  float [] float_data = new float[0] ;
  String [] data_name = new String[0] ;
  return archetype(float_data, string_data, data_name, gender) ;
}

public Genome archetype(float [] float_data, String [] string_data, int gender) {
  String [] data_name = new String[0] ;
  return archetype(float_data, string_data, data_name, gender) ;
}

/*
Main method
*/
public Genome archetype(float [] float_data, String [] string_data, String [] data_name, int gender) {
  int num_chromosome = 2 ;
  if(float_data.length < 1 || string_data.length < 1) {
    num_chromosome = 1 ;
  }
  String [] chromosome_name = new String[num_chromosome] ;

  int num_info = float_data.length + string_data.length ;
  Gene [] gene_data_mother = new Gene[num_info] ;
  Gene [] gene_data_father = new Gene[num_info] ;
  String [] gene_name = new String[num_info] ;
  // init var
  for(int i = 0 ; i < gene_name.length ; i++) { 
    gene_name[i] = Integer.toString(i) ;
  }

  int num_naming = 0 ;
  if (gene_name.length <= data_name.length) {
    num_naming = gene_name.length ; 
  } else { 
    num_naming = data_name.length ;
  }
  // loop on the smalest list to don't have out bound
  for(int i = 0 ; i < num_naming ; i++) {
    gene_name [i] = data_name[i] ;
  }


  // make chromosome
  int pointer = 0 ;

  if(float_data.length > 0) {
    chromosome_name[0] = "Float" ;
    for(int i = 0 ; i < float_data.length ; i++) {
      int locus = i ;
      vec2 mother = vec2(float_data[i]) ;
      vec2 father = vec2(float_data[i]) ;
      vec2 mother_dominance = vec2().rand(1);
      vec2 father_dominance = vec2().rand(1);;
      gene_data_mother [i] = new Gene(chromosome_name[0], gene_name [pointer], locus, mother, mother_dominance) ;
      gene_data_father [i] = new Gene(chromosome_name[0], gene_name [pointer], locus, father, father_dominance) ;
      pointer++ ;
    }
  }
  if(string_data.length > 0) {
    int ID_chromosome = 1 ;
    if(float_data.length < 1) ID_chromosome = 0 ;
    chromosome_name[ID_chromosome] = "String" ;
    for(int i = 0 ; i < string_data.length ; i++) {
      int locus = i ;
      String mother_left = string_data[i] ;
      String mother_right = string_data[i] ;
      String father_left = string_data[i] ;
      String father_right = string_data[i] ;
      vec2 mother_dominance = vec2().rand(1);;
      vec2 father_dominance = vec2().rand(1);;
      gene_data_mother [pointer] = new Gene(chromosome_name[ID_chromosome], gene_name [pointer], locus, mother_left, mother_right, round(mother_dominance.x), round(mother_dominance.y))  ;
      gene_data_father [pointer] = new Gene(chromosome_name[ID_chromosome], gene_name [pointer], locus, father_left, father_right, round(father_dominance.x), round(father_dominance.y))  ;
      pointer++ ;
    }
  }
  

  // finalize
  if(gender == 0 || gender == 1) {
    return new Genome(chromosome_name, gene_name, gene_data_mother, gene_data_father, gender) ;
  } else {
    return new Genome(chromosome_name, gene_name, gene_data_mother, gene_data_father) ;
  }
}
















/**
HELIX 
v 0.2.0.0
*/
class Helix {
  Strand_DNA [] strand ;
  int num_strand ;
  int num_nucleotide ;
  int level ;
  vec2 radius ;
  vec3 final_pos ;
  DNA [] dna_seq ; 

  Helix (int num_strand, int num_nucleotide, int nucleotide_by_revolution) {
    // make a nucleotide chain if it's classic strand '1' or '2'
    if(num_strand == 2) {
      // this case is a real one case of ADN
      dna_seq = new DNA[1] ;
      dna_seq[0] = new DNA(num_nucleotide, true) ;
    } else {
      dna_seq = new DNA[num_strand] ;
      for(int i = 0 ; i < num_strand ; i++) {
        dna_seq[i] = new DNA(num_nucleotide, false) ;
      }
    }

    this.num_nucleotide = num_nucleotide ;
    this.num_strand = num_strand ;
    this.level = (int) num_nucleotide / nucleotide_by_revolution ;
    if(level < 1) level = 1 ;
    strand = new Strand_DNA [num_strand] ;
    float start_angle = 0 ;
    float angle = TAU / num_strand ;
    for(int i = 0 ; i < num_strand ; i++) {
      strand[i] = new Strand_DNA(num_nucleotide, nucleotide_by_revolution, start_angle) ;
      start_angle += angle ;
    }
  }






  /**
  setting
  */
  public void set_radius(int radius) {
    set_radius(radius, radius) ;
  }

  public void set_radius(int r_x, int r_y) {
    if(radius == null) {
      radius = vec2(r_x, r_y) ;
    } else {
      radius.set(r_x, r_y) ;
    }

    for(int i = 0 ; i < strand.length ; i++) {
      for(int k = 0 ; k < strand[i].size() ; k++) {
        strand[i].set_radius_x(k, radius.x) ;
        strand[i].set_radius_y(k, radius.y) ;
      }
    }
  }


  public void rotation(float angle) {
    float step = TAU / strand.length ;
    for(int i = 0 ; i < strand.length ; i++) {
      strand[i].set_pos(angle +(i*step)) ;
    }
  }

  public void set_height(int height_strand) {
    int size_h = height_strand / level ;
    for(int i = 0 ; i < strand.length ; i++) {
      for(int k = 0 ; k < strand[i].size() ; k++) {
        strand[i].set_height(k, size_h) ;
      }
    }
  }

  public void set_final_pos(vec3 pos) {
    if(this.final_pos == null) {
      this.final_pos = pos.copy() ;
    } else {
      this.final_pos.set(pos) ;
    }

    for(int i = 0 ; i < strand.length ; i++) {
      for(int k = 0 ; k < strand[i].size() ; k++) {
        strand[i].add(k, final_pos) ;
      }
    }
  }
  
  /**
  GET

   */

     // info
  public int size() {
    return strand.length ;
  }

  public int num() {
    return strand.length *strand[0].size() ;
  }

  public int length(int which_strand) {
    if(which_strand > num_strand) {
      return strand[which_strand].size() ;
    } else return 0 ;
  }

  public int length() {
    return strand[0].size() ;
  }

  public vec2 get_radius() {
    if(radius == null) radius = vec2(1) ;
    return radius ;
  }

  public DNA get_DNA(int which_strand) {
    if(which_strand < num_strand) {
      return dna_seq[which_strand] ;
    } else {
      return null ;
    }
  }







  public Strand_DNA [] get() {
    return strand ;
  }

  public Strand_DNA get(int which_strand) {
    if(which_strand < num_strand) {
      return strand[which_strand] ;
    } else {
      return null ;
    }
  }


  // get pos
  public vec3 get_final_pos() {
    return final_pos ;
  }
  
  // get array angle
  public float [] get_nuc_angle() {
    int count = 0 ;
    float [] angle = new float[num_nucleotide *num_strand] ;
    for(int i = 0 ; i < num_strand ; i++) {
      for(int k = 0 ; k < num_nucleotide ; k++) {
        angle [count] = strand[i].get_angle(k) ;
        count ++ ;
      }
    }
    return angle ;
  }

  public float [] get_nuc_angle(int which_strand) {
    if(which_strand < num_strand) {
      float [] angle = new float[strand[which_strand].size()] ;
      for(int i = 0 ; i < num_nucleotide ; i++) {
        angle[i] = strand[which_strand].get_angle(i) ;
      }
      return angle ;
    } else {
      float [] angle = new float[1] ;
      angle[0] = 0 ;
       System.err.println("target strand don't match with any strand") ;
      return angle ;
    }
  }



  // get array pos
  public vec3 [] get_nuc_pos() {
    int count = 0 ;
    vec3 [] pos = new vec3[num_nucleotide *num_strand] ;
    for(int i = 0 ; i < num_strand ; i++) {
      for(int k = 0 ; k < num_nucleotide ; k++) {
        pos[count] = vec3() ;
        pos[count].set(strand[i].get_pos(k)) ;
        pos[count].add(final_pos) ;
        // center the helix
        pos[count].add(0, -get_height() *.5f,0) ;
        count ++ ;
      }
    }
    return pos ;
  }

  public vec3 [] get_nuc_pos(int which_strand) {
    if(which_strand < num_strand) {
      vec3 [] pos = new vec3[strand[which_strand].size()] ;
      for(int i = 0 ; i < num_nucleotide ; i++) {
        pos[i] = vec3() ;
        pos[i].set(strand[which_strand].get_pos(i)) ;
        pos[i].add(final_pos) ;
        // center the helix
        pos[i].add(0, -get_height() *.5f,0) ;
      }
      return pos ;
    } else {
      return null ;
    }
  }


  public float get_height() {
    int last_nuc = strand[0].size() -1;
    return strand[0].get_pos(last_nuc).y ;
  }

  public float get_width() {
    return radius.x *2;
  }

  public float get_depth() {
    return radius.z *2;
  }




  /**
  private class Strand_DNA 0.2.0
  */
  private class Strand_DNA {
    private vec4 [] coord ;
    int num_nucleotide ; 
    int nucleotide_by_revolution ;

    float spacing ;
    float radius = 1 ;

    Strand_DNA(int num_nucleotide, int nucleotide_by_revolution, float start_angle) {
      this.nucleotide_by_revolution = nucleotide_by_revolution ;
      this.num_nucleotide = num_nucleotide ;
      coord = new vec4[num_nucleotide] ;

      spacing = 1.f / (float)nucleotide_by_revolution ;
      coord = nuc_coord(num_nucleotide, nucleotide_by_revolution, spacing, radius, start_angle) ;
    }


    // set
    public void set_pos(float new_angle) {
      if(coord != null) {
        vec4 [] temp_pos = new vec4[coord.length] ;
        temp_pos = nuc_coord(num_nucleotide, nucleotide_by_revolution, spacing, radius, new_angle) ;
        for(int i = 0 ; i < temp_pos.length ; i++) {
          if(coord[i] == null ) {
            coord[i] = vec4(temp_pos[i]) ;
          } else {
            coord[i].set(temp_pos[i]) ;
          }
        }
      }
    }

    public void set_height(int target, float ratio_height) {
      if(target < coord.length) {
        coord[target].mult(1,ratio_height,1,1) ;
      } 
    }

    public void set_radius_x(int target, float ratio_x) {
      if(target < coord.length) {
        coord[target].mult(ratio_x,1,1,1) ;
      } 
    }
    

    // here it's delicate because the "z" is used for the y radius,
    // because for the helix we are not in the classic represation of coor XYZ
    public void set_radius_y(int target, float ratio_z) {
      if(target < coord.length) {
        coord[target].mult(1,1,ratio_z,1) ;
      } 
    }

    

    // get
    public int size() {
      if(coord != null) {
        return coord.length ;
      } else return 0 ;
    }


    public vec3 get_pos(int target) {
      if(target < coord.length) {
        return vec3(coord[target].x, coord[target].y, coord[target].z) ;
      } else return null ;
    }


    public float get_angle(int target) {
      if(target < coord.length) {
        return coord[target].x;
      } else {
        System.err.println("target out of bounds") ;
        return 0 ;
      }
    }


    

    // add
    public void add(int target, vec3 v) {
      if(target < coord.length) {
        coord[target].add(v) ;
      } 
    }
    


    private vec4 [] nuc_coord(int num, int revolution, float spacing, float radius, float start_angle) {
      int level = num / revolution ;
      vec4 [] pos_angle = new vec4[num] ;
      float angle = TAU / revolution ;
      float z = 0 ;
      int count = 0 ;
      if(num > 0) {
        float angle_proj = start_angle ;
        for(int i = 0 ; i <= level ; i++) {
          for(int k = 0 ; k < revolution ; k ++) {
            float angle_dir = k *angle +start_angle ;
            angle_dir *= -1 ;
            angle_proj += angle ;
            vec2 pos_XY = projection(angle_proj, radius) ;

            z += spacing ;
            vec3 pos_XYZ = vec3(pos_XY.x, z, pos_XY.y) ;
            
            if(count < pos_angle.length) {
              pos_angle[count] = vec4(pos_XYZ.x, pos_XYZ.y, pos_XYZ.z, angle_dir) ; ;
              count ++ ;
            } else {
              break ;
            }
            if(count >= num) break ;
          }
        }
        return pos_angle ;
      } else return null ;  
    }
  }
  // end private class Strand_DNA
}




/**
method public nucleotide position
*/
/*
vec3 [] helix(int num, int revolution, float spacing, float radius, float start_angle) {
  return nuc_pos(num, revolution, spacing, radius, start_angle)
}
*/
























/**
GENOME 0.1.0

*/
class Genome {
  ArrayList <Chromosome> list_chromosome = new ArrayList<Chromosome>() ;
  ArrayList <Info> gene_map = new ArrayList<Info>() ;
  String chromosome_gender_name = "Gender" ;
  int num_gene = 0  ;
  /**
  CONSTRUCTOR
  */

  Genome (String [] chromosome_name, String[] gene_name, Gene [] gene_data_mother, Gene [] gene_data_father) {
    // build variable with all data from mother and father
    build_genome(chromosome_name, gene_name, gene_data_mother, gene_data_father) ;
    // choice the gender of creature DNA, if the random is under .5, the gender is female
    gender_chromosome(random(1)) ; 
    // here we add "1" for the gender chromosome
    num_gene = gene_name.length +1 ;
    // genemap
    write_gene_map() ;
  }

  Genome (String [] chromosome_name, String[] gene_name, Gene [] gene_data_mother, Gene [] gene_data_father, int gender) {
    // build variable with all data from mother and father
    build_genome(chromosome_name, gene_name, gene_data_mother, gene_data_father) ;
    // choice the gender of creature DNA, if the random is under .5, the gender is female
    if(gender < 1) gender = 0 ; else gender = 1 ;
    gender_chromosome(gender) ; 
    // here we add "1" for the gender chromosome
    num_gene = gene_name.length +1 ;
        // genemap
    write_gene_map() ;
  }



  /**
  build Chromosome
  */
  public void build_genome(String [] chromosome_name, String[] gene_name, Gene [] gene_data_mother, Gene [] gene_data_father) {
    //preparation
    Zygote [] zygote_data = new Zygote[gene_name.length] ;

    int [] num_gene_by_chromosome = new int[chromosome_name.length] ;
    for(int i = 0 ; i < gene_name.length ; i++) {
      for(int j = 0 ; j < chromosome_name.length ; j++) {
        if(gene_data_mother[i].chromosome_name.equals(chromosome_name[j])) {
          num_gene_by_chromosome[j]++ ;
        }
      }
    }

    int [] step_num_gene = new int[chromosome_name.length] ;
    for(int i = 0 ; i < step_num_gene.length ; i++) {
      for( int j = 0 ; j < i ; j++) {
        step_num_gene [i] += num_gene_by_chromosome[j] ;
      }
    }




    for(int i = 0 ; i < zygote_data.length ; i++ ) {
    // check if the allele mother and the allele father have same chromosome
      if(gene_data_mother[i].gene_name.equals(gene_data_father[i].gene_name)) {
        // number locus when there is no locus allocation.
        int locus = 0 ;
        if(gene_data_mother[i].locus >= 0 ) {
          locus = gene_data_mother[i].locus ; 
        } else {
          for(int j = 0 ; j < step_num_gene.length ; j++) {
            if(i < step_num_gene [j] && j > 0) {
              locus = i -step_num_gene [j]  ;
              break ;
            } else {
              locus = i ;
            }
          }
        }
        zygote_data[i] = new Zygote( gene_data_mother[i].chromosome_name, 
                                     gene_data_mother[i].gene_name,
                                     locus,  

                                     gene_data_mother[i].data_left_arm, 
                                     gene_data_mother[i].data_right_arm, 
                                     gene_data_mother[i].dominance_left_arm, 
                                     gene_data_mother[i].dominance_right_arm, 

                                     gene_data_father[i].data_left_arm, 
                                     gene_data_father[i].data_right_arm, 
                                     gene_data_father[i].dominance_left_arm, 
                                     gene_data_father[i].dominance_right_arm ) ;
      }
    }



    // how to choice which allele for which chromosome ?????
    int pointer = 0 ;
    for(int i = 0 ; i < chromosome_name.length ; i++) {
      String [] gene_name_by_chromosome = new String[num_gene_by_chromosome[i]] ;
      // create a raw Zygote without the name
      Zygote [] gene_data_by_chromosome = new Zygote[num_gene_by_chromosome[i]] ;
      int rank = 0 ;
      for(int j = pointer ; j < pointer + num_gene_by_chromosome[i] ; j++) {
        if(zygote_data[j].chromosome_name == chromosome_name[i]) {
          gene_name_by_chromosome[rank] =  gene_name[j] ;
          gene_data_by_chromosome[rank] =  new Zygote(  zygote_data[j].chromosome_name,
                                                        zygote_data[j].name, 
                                                        zygote_data[j].locus,

                                                        zygote_data[j].mother_data_left_arm, 
                                                        zygote_data[j].mother_data_right_arm, 
                                                        zygote_data[j].mother_dominance_left_arm, 
                                                        zygote_data[j].mother_dominance_right_arm, 

                                                        zygote_data[j].father_data_left_arm, 
                                                        zygote_data[j].father_data_right_arm, 
                                                        zygote_data[j].father_dominance_left_arm, 
                                                        zygote_data[j].father_dominance_right_arm) ;
          rank++ ;
        }
      }
      pointer += rank ;
      int rank_chromosome = i ;
      Chromosome c = new Chromosome(chromosome_name[i], rank_chromosome, gene_name_by_chromosome, gene_data_by_chromosome) ;
      list_chromosome.add(c) ;
    }
  }






  /**
  ADD GENE 
  WORK IN PROGRESS
  */
  public Chromosome add_gene_to_chromosome(String chromosome, String[] gene_name, Gene [] gene_data_mother, Gene [] gene_data_father) {
    Chromosome c = new Chromosome() ; ;
    return c ;

  }



  /**
  Set Chromosome after buid
  WORK IN PROGRESS
  */
  
  public void set_gender_chromosome(String[] gene_name, Gene [] gene_data_mother, Gene [] gene_data_father) {
    for(Chromosome c : list_chromosome ) {
      if(c.chromosome_name == "Gender") {
        add_gene_to_chromosome("Gender", gene_name, gene_data_mother, gene_data_father) ;
      }
    }
  } 
  








  /**
  NUM

  */
  /**
  get num
  */
  // get num of chromosome
  public int num_chromosome() {
    return list_chromosome.size() ;
  }

  public int num_gene() {
    int num = 0 ;
    for(int i = 0 ; i < list_chromosome.size() ; i++ ) {
      Chromosome c = list_chromosome.get(i) ;
      int num_allele = num_allele (c) ;
      num += num_allele ;
    }
    return num ;
  }

  /**
  READ

  */
  /**
  get name
  */
  public String [] get_chromosome_name() {
    String [] chromosome_name = new String[list_chromosome.size()] ;
    for(int i = 0 ; i < list_chromosome.size() ; i++ ) {
      Chromosome c = list_chromosome.get(i) ;
      chromosome_name [i] = c.chromosome_name ;
    }
    return chromosome_name ;
  }

  /**
  get genotype
  */
  public Gene [] get_genotype() {
    Gene [] gene = new Gene[num_gene()] ;
    int pointer = 0 ;
    for(int i = 0 ; i < list_chromosome.size() ; i++) {
      for(int j = 0 ; j < get_chromosome(i).length ; j++) {
        gene[pointer] = get_chromosome(i)[j] ;
        pointer++ ;
      }
    }
    return gene ;
  }

  /**
  get chromosome
  */

  public Gene [] get_chromosome(int which_chromosome) {
    // Chromosome c ;
    if(which_chromosome > list_chromosome.size()) {
      Chromosome c = list_chromosome.get(0) ;
      return get_chromosome(c) ;
    } else {
      Chromosome c = list_chromosome.get(which_chromosome) ;
      return get_chromosome(c) ;
    }

  }


  public Gene [] get_chromosome(Chromosome c) {
    if(c != null) {
      int num_allele = c.list_allele_left.size() ;
      int size_left = c.list_allele_left.size() ;
      int size_right = c.list_allele_right.size() ;
      // choice the arm
      if(size_left > size_right) num_allele = size_right ; 
      Gene [] gene = new Gene[num_allele] ;
      // attribution data
      for(int i = 0 ; i < num_allele ; i++ ) {
        Allele left = c.list_allele_left.get(i) ;
        Allele right = c.list_allele_right.get(i) ;
        gene [i] = new Gene(c.chromosome_name, left.name, left.locus, left.data, right.data, left.dominance, right.dominance)  ; 
      }
      return gene ;
    } else return null ;
  }




  /**
  get gene
  */
  public Gene get_gene(String target) {
    Gene gene = null ;
    boolean match = false  ;
    for(int i = 0 ; i < get_genotype().length ; i++) {
      if(get_genotype()[i].gene_name.equals(target)) {
        gene = get_genotype()[i] ;
        match = true ;
        break ;
      } else {
        match = false ;
        gene = get_genotype()[0] ;
      }
    }
    if(!match) println("Gene get_gene(String target) : your target don't match with any genes of the genotype, instead we use gene '0'") ;
    return gene ;
  }

  public Gene get_gene(int target) {
    // Gene gene = null ;
    boolean match = false  ;
    if(target >= num_gene() || target < 0) {
      match = false ;
      target = 0 ;
    } else {
      match = true ;
    }

    if(!match) println("Gene get_gene(int target) : your target don't match with any genes of the genotype, instead we use gene '0'") ;
    return get_genotype()[target] ;
  }

  /**
  get DNA
  */
  public char [] get_DNA(String chromosome_name, String gene_name, int arm) {
    char [] sequence_dna = new char[1] ;
    for(int i = 0 ; i < list_chromosome.size() ; i++ ) {
      Chromosome c = list_chromosome.get(i) ;
      if(c.chromosome_name.equals(chromosome_name)) {
        sequence_dna = new char[get_DNA(c, gene_name, arm).length] ;
        for(int j = 0 ; j < sequence_dna.length ; j++) {
          sequence_dna[j] = get_DNA(c, gene_name, arm)[j] ;
        }
        break ;
      }
    }
    return sequence_dna ;
  }


  public char [] get_DNA(String chromosome_name, int which_gene, int arm) {
    char [] sequence_dna = new char[1] ;
    for(int i = 0 ; i < list_chromosome.size() ; i++ ) {
      Chromosome c = list_chromosome.get(i) ;
      if(c.chromosome_name.equals(chromosome_name)) {
        sequence_dna = new char[get_DNA(c, which_gene, arm).length] ;
        for(int j = 0 ; j < sequence_dna.length ; j++) {
          sequence_dna[j] = get_DNA(c, which_gene, arm)[j] ;
        }
        break ;
      }
    }
    return sequence_dna ;
  }

  public char [] get_DNA(int which_chromosome, int which_gene, int arm) {
    char [] sequence_dna = new char[1] ;
    if(which_chromosome < list_chromosome.size()) {
      Chromosome c = list_chromosome.get(which_chromosome) ;
      sequence_dna = new char[get_DNA(c, which_gene, arm).length] ;
      for(int j = 0 ; j < sequence_dna.length ; j++) {
        sequence_dna[j] = get_DNA(c, which_gene, arm)[j] ;
      }
    }
    return sequence_dna ;
  }




  public char [] get_DNA(Chromosome c, int which_gene, int arm) {
    char [] sequence_dna = new char[1] ;

    if (c != null) {
      if( arm == 0 ) {
        sequence_dna = new char[loop_dna(which_gene, c.list_allele_left, sequence_dna).length] ;
        for(int i = 0 ; i < sequence_dna.length ; i++) {
          sequence_dna[i] = loop_dna(which_gene, c.list_allele_left, sequence_dna)[i] ;
        }
      } else if(arm == 1) {
        sequence_dna = new char[loop_dna(which_gene, c.list_allele_right, sequence_dna).length] ;
        for(int i = 0 ; i < sequence_dna.length ; i++) {
          sequence_dna[i] = loop_dna(which_gene, c.list_allele_right, sequence_dna)[i] ;
        }
      } 
    }
    return sequence_dna ;
  }
  


  public char [] get_DNA(Chromosome c, String gene_name, int arm) {
    char [] sequence_dna = new char[1] ;

    if (c != null) {
      if( arm == 0 ) {
        int num = c.list_allele_left.size() ;
        sequence_dna = new char[loop_dna(gene_name, num, c.list_allele_left, sequence_dna).length] ;
        for(int i = 0 ; i < sequence_dna.length ; i++) {
          sequence_dna[i] = loop_dna(gene_name, num, c.list_allele_left, sequence_dna)[i] ;
        }
      } else if(arm == 1) {
        int num = c.list_allele_right.size() ;
        sequence_dna = new char[loop_dna(gene_name, num, c.list_allele_right, sequence_dna).length] ;
        for(int i = 0 ; i < sequence_dna.length ; i++) {
          sequence_dna[i] = loop_dna(gene_name, num, c.list_allele_right, sequence_dna)[i] ;
        }
      } 
    }
    return sequence_dna ;
  }
  






  





  /**
  // get gene product
  */

  public Info get_gene_product(String target) {
    Info info = new Info_Object(target, "no gene for this name") ;

    int length  = get_gene_product().length ;
    int count  = 0 ;
    for(int i = 0 ; i < length ; i++) {
      if(get_gene_product()[i].get_name().contains(target)) {
        count ++ ;
        if(get_gene_product()[i].catch_obj(0) != null)  {
          info = new Info_Object(get_gene_product()[i].get_name(), get_gene_product()[i].catch_obj(0)) ;
        } else {
          info = new Info_Object(get_gene_product()[i].get_name(), "no data match with the request") ;
        }
      }
    }
    if(count > 1 ) info = new Info_Object("target", "Find " + count + " targets for your target") ;
    return info ;
  }

  public Info get_gene_product(String target_chromosome, String target_gene) {
    Info info = new Info_Object(target_gene, "the chromosome or gene don't exist") ;
    for(int i = 0 ; i < list_chromosome.size() ; i++) {
      Chromosome c = list_chromosome.get(i) ;
      if(c.chromosome_name.equals(target_chromosome)) {
        for(int j = 0 ; j < get_gene_product(i).length ; j++ ) {
          if(get_gene_product(i)[j].catch_obj(0) != null)  {
          info = new Info_Object(get_gene_product(i)[j].get_name(), get_gene_product(i)[j].catch_obj(0)) ;
        } else {
          info = new Info_Object(get_gene_product(i)[j].get_name(), "no data match with the request") ;
        }

        }
      }
    }
    return info ;
  }


  public Info get_gene_product(int which_chromosome, int locus) {
    Info info = new Info_Object("Chromosome: " + which_chromosome + " locus: " +locus, "don't exist") ;
    if(which_chromosome < list_chromosome.size() &&  locus < list_chromosome.get(which_chromosome).list_allele_left.size() ) {
      if(get_gene_product(which_chromosome)[locus].catch_obj(0) != null)  {
        info = new Info_Object(get_gene_product(which_chromosome)[locus].get_name(), get_gene_product(which_chromosome)[locus].catch_obj(0)) ;
      } else {
        info = new Info_Object(get_gene_product(which_chromosome)[locus].get_name(), "no data match with the request") ;
      }
    }
    return info ;
  }



  
  public Info [] get_gene_product() {
    Info [] info_gene = new Info_Object [num_gene] ;
    int pointer = 0 ;
    for(int i = 0 ; i < list_chromosome.size() ; i++ ) {
      Chromosome c = list_chromosome.get(i) ;
      int num_allele = num_allele (c) ;
      for(int j = 0 ; j < num_allele ; j++) {
        info_gene [ pointer +j] = get_gene_product(i)[j] ;
      }
      pointer += num_allele ;
    }
    return info_gene ;
  }


 

  public Info [] get_gene_product(int which_chromosome) {
    if(which_chromosome < list_chromosome.size()) {
      Chromosome c = list_chromosome.get(which_chromosome) ;
      int num_allele = num_allele(c) ;

      Info []allele_name = new Info_Object [num_allele] ;
      // attribution data
      for(int i = 0 ; i < num_allele ; i++ ) {
        Allele left = c.list_allele_left.get(i) ;
        Allele right = c.list_allele_right.get(i) ;
        
        // look for the dominance, recessive or codominace operation
        boolean number ;
        float gene_product_float = 0 ;
        String gene_product_string = "" ;
        float temp_left_dominance = Float.valueOf(left.dominance) ;
        float temp_right_dominance = Float.valueOf(right.dominance) ;
        // test if the data is String or float, 
        try {
          float temp_left_data = Float.valueOf(left.data) ;
          float temp_right_data = Float.valueOf(right.data) ;
          number = true ;
          gene_product_float = ((temp_left_data *temp_left_dominance) +(temp_right_data *temp_right_dominance)) / (temp_left_dominance +temp_right_dominance) ;
        } catch (NumberFormatException e) {
          number = false ;
          if(temp_left_dominance > temp_right_dominance) {
            gene_product_string = left.data ;
          } else if(temp_left_dominance < temp_right_dominance){ 
            gene_product_string = right.data ;
          } else {
            if(left.data == right.data ) {
              gene_product_string = left.data ;
            } else {
              gene_product_string = left.data + right.data ;
            }
          }
        }
        if(number) {
         allele_name [i] = new Info_Object(c.chromosome_name + " > " + left.name, gene_product_float)  ; 
        } else {
          allele_name [i] = new Info_Object(c.chromosome_name + " > " + left.name, gene_product_string)  ;
        }
      }
      return allele_name ;
    } else {
      Info [] i = new Info_Object [1] ;
      i[0] = new Info_Object("This chromosome is not found", which_chromosome) ;
      return i ;
    }
  }




  /**
  MUTATION

  */
  /**
  get to specific allele gene to do mutation of data.
  */
  // data mutation
  public void mutation_data(String target_gene, String mutation, boolean left, boolean right) {
    boolean match = false  ;
    int which_chromosome = 0 ;
    int locus = 0 ;
    // find the gene who match with the target
    for (Info i : gene_map) {
      if(i.catch_obj(0).equals(target_gene)) {
        which_chromosome = Integer.parseInt((String)i.catch_obj(1));
        locus = Integer.parseInt((String)i.catch_obj(2));
        match = true ;
        break ;
      } else {
        match = false ;
      }
    }
    // mutation
    if(!match) {
      println("Target gene don't match with any genes of the genotype, no mutation can be done") ;
    } else {
      if(left) {
        list_chromosome.get(which_chromosome).list_allele_left.get(locus).data = mutation ;
      }
      if(right) {
        list_chromosome.get(which_chromosome).list_allele_right.get(locus).data = mutation ;
      }
    }
  }
  
  
  public void mutation_data(int which_chromosome, int locus, String mutation, boolean left, boolean right) {
    boolean match_left = false  ;
    boolean match_right = false  ;
    int locus_left  = 0 ;
    int locus_right = 0 ;
    
    // left part
    // find the gene who match with the target
    if(left) {
      if(which_chromosome < list_chromosome.size()) {
        if(locus < list_chromosome.get(which_chromosome).list_allele_left.size()) {
          locus_left = locus ;
          match_left = true ;
        }
      } else {
        match_left = false ;
      }
  
      // mutation
      if(!match_left) {
        println("Target Allele - gene - left don't match with any genes of the genotype, no mutation can be done") ;
      } else {
        list_chromosome.get(which_chromosome).list_allele_left.get(locus_left).data = mutation ;
      }
    }
    // right
     if(right) {
      if(which_chromosome < list_chromosome.size()) {
        if(locus < list_chromosome.get(which_chromosome).list_allele_right.size()) {
          locus_right = locus ;
          match_right = true ;
        }
      } else {
        match_right = false ;
      }
  
      // mutation
      if(!match_right) {
        println("Target Allele - gene - right don't match with any genes of the genotype, no mutation can be done") ;
      } else {
        list_chromosome.get(which_chromosome).list_allele_right.get(locus_right).data = mutation ;
      }
    }
  }
  
  // dominance mutation
  public void mutation_dominance(String target_gene, float mutation, boolean left, boolean right) {
    boolean match = false  ;
    int which_chromosome = 0 ;
    int locus = 0 ;
    // find the gene who match with the target
    for (Info i : gene_map) {
      if(i.catch_obj(0).equals(target_gene)) {
        which_chromosome = Integer.parseInt((String)i.catch_obj(1));
        locus = Integer.parseInt((String)i.catch_obj(2));
        match = true ;
        break ;
      } else {
        match = false ;
      }
    }
    // mutation
    if(!match) {
      println("Target gene don't match with any genes of the genotype, no mutation can be done") ;
    } else {
      if(left) {
        list_chromosome.get(which_chromosome).list_allele_left.get(locus).dominance = mutation ;
      }
      if(right) {
        list_chromosome.get(which_chromosome).list_allele_right.get(locus).dominance = mutation ;
      }
    }
  }
  
    public void mutation_dominance(int which_chromosome, int locus, float mutation, boolean left, boolean right) {
    boolean match_left = false  ;
    boolean match_right = false  ;
    int locus_left  = 0 ;
    int locus_right = 0 ;
    
    // left part
    // find the gene who match with the target
    if(left) {
      if(which_chromosome < list_chromosome.size()) {
        if(locus < list_chromosome.get(which_chromosome).list_allele_left.size()) {
          locus_left = locus ;
          match_left = true ;
        }
      } else {
        match_left = false ;
      }
  
      // mutation
      if(!match_left) {
        println("Target Allele - gene - left don't match with any genes of the genotype, no mutation can be done") ;
      } else {
        list_chromosome.get(which_chromosome).list_allele_left.get(locus_left).dominance = mutation ;
      }
    }
    // right
     if(right) {
      if(which_chromosome < list_chromosome.size()) {
        if(locus < list_chromosome.get(which_chromosome).list_allele_right.size()) {
          locus_right = locus ;
          match_right = true ;
        }
      } else {
        match_right = false ;
      }
  
      // mutation
      if(!match_right) {
        println("Target Allele - gene - right don't match with any genes of the genotype, no mutation can be done") ;
      } else {
        list_chromosome.get(which_chromosome).list_allele_right.get(locus_right).dominance = mutation ;
      }
    }
  }

  

  

  /**
  LOCAL METHOD

  */


    /**
  write gene map info
  */
  public void write_gene_map() {
    gene_map.clear() ;
    for(int i = 0 ; i < get_genotype().length ; i++) {
      String chromosome_name_temp = get_genotype()[i].chromosome_name ;
      String chromosome_rank_temp = "-" ;
      for(int j = 0 ; j < get_chromosome_name().length ; j++) {
        if(get_chromosome_name()[j].equals(get_genotype()[i].chromosome_name)) chromosome_rank_temp = int_to_String(j) ;
      }
      String gene_name_temp = get_genotype()[i].gene_name ;
      String gene_locus_temp = int_to_String(get_genotype()[i].locus) ;
      Info temp = new Info_String(chromosome_name_temp, gene_name_temp, chromosome_rank_temp, gene_locus_temp) ;
      gene_map.add(temp) ;

    }
  }


  /**
  special chromosome for the gender ;
  */
  public void gender_chromosome(float gender) {
    String [] allele_name = new String [1] ;
    // no specific data
    Zygote [] allele_data = new Zygote[1] ;
    allele_data [0] = new Zygote() ;
    allele_name [0] = ("Unknow") ;
    int rank_chromosome = list_chromosome.size() ;
    // build
    Chromosome chromosome_gender = new Chromosome(chromosome_gender_name, rank_chromosome, allele_name, allele_data, gender) ;
    list_chromosome.add(chromosome_gender) ;
  }


  public int num_allele (Chromosome c) {
    int num = 0 ;
    num = c.list_allele_left.size() ;
    int size_left = c.list_allele_left.size() ;
    int size_right = c.list_allele_right.size() ;
    // choice the arm
    if(size_left > size_right) { 
      num = size_right ; 
    }
    return num ;
  }

  /**
  DNA writing
  */
  public char [] loop_dna(int which_gene, ArrayList<Allele> list_allele, char[] seq) {
    if(which_gene < list_allele.size()) {
      Allele a = list_allele.get(which_gene) ;
      seq = new char[allele_dna(a).length] ;
      for(int j = 0 ; j < seq.length ; j++) {
        seq[j] = allele_dna(a)[j] ;
      } 
    }
    return seq ;
  }



  public char [] loop_dna(String gene_name, int num, ArrayList<Allele> list_allele, char[] seq) {
    for(int i = 0 ; i < num ; i++ ) {
      Allele a = list_allele.get(i) ;
      if(a.name.equals(gene_name)) {
        seq = new char[allele_dna(a).length] ;
        for(int j = 0 ; j < seq.length ; j++) {
          seq[j] = allele_dna(a)[j] ;
        }
        break ;
      } 
    }
    return seq ;
  }
 
  //
  public char [] allele_dna(Allele a) {

    char [] info = new char[1] ;
    int length_locus = a.dna_locus.get_sequence().length ;
    int length_ancester = a.dna_ancester.get_sequence().length ;
    int length_name = a.dna_name.get_sequence().length ;
    int length_data = a.dna_data.get_sequence().length ;
    int length_dominance = a.dna_dominance.get_sequence().length ;

    int total_length = length_locus +length_ancester +length_name +length_data +length_dominance ;
    info = new char[total_length] ;

    int pointer = 0 ;
    for(int i = 0 ; i < a.dna_locus.get_sequence().length ; i++ ) {
      info[pointer] = a.dna_locus.get_sequence()[i] ;
      pointer++ ;
    }
    for(int i = 0 ; i < a.dna_ancester.get_sequence().length ; i++ ) {
      info[pointer] = a.dna_ancester.get_sequence()[i] ;
      pointer++ ;
    }
    for(int i = 0 ; i < a.dna_name.get_sequence().length ; i++ ) {
      info[pointer] = a.dna_name.get_sequence()[i] ;
      pointer++ ;
    }
    for(int i = 0 ; i < a.dna_data.get_sequence().length ; i++ ) {
      info[pointer] = a.dna_data.get_sequence()[i] ;
      pointer++ ;
    }
    for(int i = 0 ; i < a.dna_dominance.get_sequence().length ; i++ ) {
      info[pointer] = a.dna_dominance.get_sequence()[i] ;
      pointer++ ;
    }
    return info ;
  }
  /**
  END LOCAL METHOD
  */
}
/**


END GENOME


*/




  




































/**


CHROMOSOME


*/

class Chromosome {
  // int [] telomere ;
  String chromosome_name ;
  int rank ;

  ArrayList <Allele> list_allele_left = new ArrayList<Allele>() ;
  ArrayList <Allele> list_allele_right = new ArrayList<Allele>() ;
  
  Chromosome() {} ;
  // CONSTRUCTOR for symetric arms chromosome
  Chromosome(String chromosome_name, int rank, String [] gene_name, Zygote [] data) {
    this.chromosome_name = chromosome_name ;
    this.rank = rank ;
    arm_left(gene_name, rank, data) ;
    arm_right(gene_name, rank, data) ;
  }

  // CONSTRUCTOR for gender arms chromosome, no symetric chromosome
  Chromosome(String chromosome_name, int rank, String [] gene_name, Zygote [] data, float gender) {
    this.rank = rank ;
    this.chromosome_name = chromosome_name ;
    int locus = 0 ;
    if(gender < .5f ) {
      gene_name [0] = "XX" ;
      data[0] = new Zygote(chromosome_name, "XX", locus, "X","X",0,0, "X","X",0,0) ;
      arm_left(gene_name, rank, data) ;
      arm_right(gene_name, rank, data) ;
    } else {
      // here we give no choice to the random for the allele distribution.
      gene_name [0] = "XY" ;
      data[0] = new Zygote(chromosome_name, "XY", locus, "X","X",0,0, "X","X",0,0) ;
      arm_left(gene_name, rank, data) ;
      data[0] = new Zygote(chromosome_name, "XY", locus, "Y","Y",1,1, "Y","Y",1,1) ;
      arm_right(gene_name, rank, data) ;
    }
  }

  
  


  public void arm_left(String [] gene_name, int rank_chromosome, Zygote [] data) {
    build_allele(gene_name, rank_chromosome, data, list_allele_left) ;
  }
  
  public void arm_right(String [] gene_name, int rank_chromosome, Zygote [] data) {
    build_allele(gene_name, rank_chromosome, data, list_allele_right) ;
  }


  public void build_allele(String [] gene_name, int rank_chromosome, Zygote [] data, ArrayList<Allele> list_allele) {
    int ref_selected_gene = -1 ;
    for(int i = 0 ; i < gene_name.length ; i++) {
      try {
        // crossing-over
        String final_data = "" ;
        float final_dominance = 0 ;
        String allele_ancester = "" ;
        // choice the allele is replicate from mother or father and which arm, total 4 choices
        int which_allele_data = crossing_over(ref_selected_gene) ;
        ref_selected_gene = which_allele_data ;
        // replicate allele on the selected arm
        if(which_allele_data == 0) {
          allele_ancester = "mother" ;
          final_data = data[i].mother_data_left_arm ; 
          final_dominance = data[i].mother_dominance_left_arm ; 
        } else if (which_allele_data == 1) {
          allele_ancester = "mother" ;
          final_data = data[i].mother_data_right_arm ;
          final_dominance = data[i].mother_dominance_right_arm ; 
        } else if (which_allele_data == 2) {
          allele_ancester = "father" ;
          final_data = data[i].father_data_left_arm ;
          final_dominance = data[i].father_dominance_left_arm ; 
        } else {
          allele_ancester = "father" ;
          final_data = data[i].father_data_right_arm  ;
          final_dominance = data[i].father_dominance_right_arm ; 
        }
        // locus is the position of the allele in the chromosome arm,
        int locus = data[i].locus ;
        // build
        Allele allele = new Allele(rank_chromosome, locus, allele_ancester, gene_name[i], final_data, final_dominance) ;
        list_allele.add(allele) ;
      }
      catch(ArrayIndexOutOfBoundsException e) {
        e.printStackTrace();
      }
    }
  }





  public int crossing_over(int ref) {
    int setected_gene = floor(random(4)) ;
    if(setected_gene == 4) setected_gene = 3 ;
    if(setected_gene == ref) crossing_over(ref) ;
    return setected_gene ;
  }
}
/**

END CLASS GENOME

*/


















/**

Zygote 
is a container for the mother and father gene


*/
class Zygote {
  String chromosome_name ;
  String name ; 
  int locus ;
  String mother_data_left_arm, mother_data_right_arm ;
  float mother_dominance_left_arm, mother_dominance_right_arm ;
  String father_data_left_arm, father_data_right_arm ;
  float father_dominance_left_arm, father_dominance_right_arm ;

  Zygote() {}

  Zygote (String chromosome_name, String name, 
          int locus,

          String mother_data_left_arm, String mother_data_right_arm, 
          float mother_dominance_left_arm, float mother_dominance_right_arm, 

          String father_data_left_arm, String father_data_right_arm, 
          float father_dominance_left_arm, float father_dominance_right_arm) {

    this.chromosome_name = chromosome_name ;
    this.name = name ; 
    this.locus = locus ;
    this.mother_data_left_arm = mother_data_left_arm ;
    this.mother_data_right_arm = mother_data_right_arm ;
    this.mother_dominance_left_arm = mother_dominance_left_arm ;
    this.mother_dominance_right_arm = mother_dominance_right_arm ;
    this.father_data_left_arm = father_data_left_arm ;
    this.father_data_right_arm = father_data_right_arm ;
    this.father_dominance_left_arm = father_dominance_left_arm ;
    this.father_dominance_right_arm = father_dominance_right_arm ;
  }
}
/**

END CLASS ZYGOTE

*/


















/**

ALLELE 0.1.1

*/
class Allele {
  int type = 0 ;
  /*
  allele type
  0 = lethal ;
  1 = null ;
  2 = co-dominance ;
  */
  /**
  dominance and recessive is a complexe question, must be resolve in the future
  */
  int rank_chromosome ;
  int locus ;
  String ancester ;
  String name ;
  String data ;
  float dominance ;
  DNA dna_locus, dna_ancester, dna_name, dna_data, dna_dominance ;
  Allele(int rank_chromosome, int locus, String ancester, String name, String data, float dominance) {
    this.rank_chromosome = rank_chromosome ;
    this.locus = locus ;
    this.ancester = ancester ;
    this.name = name ;
    this.data = data ;
    this.dominance = dominance ;
    dna_locus = new DNA(int_to_String(locus), true) ;
    dna_ancester = new DNA(ancester, true) ;
    dna_name = new DNA(name, true) ;
    dna_data = new DNA(data, true) ;
    dna_dominance = new DNA(float_to_String_4(dominance), true) ;
  }
}


















/**

GENE 
This class is used when we need it, but it's the Allele the real information container.

*/
class Gene {
  String chromosome_name ;
  String gene_name ;
  int locus = -1 ;
  String data_left_arm, data_right_arm ;
  float dominance_left_arm, dominance_right_arm ;


  /**
  with locus
  */
  Gene(String chromosome_name, String gene_name, int locus, String data_left_arm, String data_right_arm, float dominance_left_arm, float dominance_right_arm) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.locus = locus ;
    this.data_left_arm = data_left_arm ;
    this.data_right_arm = data_right_arm ;
    this.dominance_left_arm = dominance_left_arm ;
    this.dominance_right_arm = dominance_right_arm ;
  }

  Gene(String chromosome_name, String gene_name, int locus, float data_left_arm, float data_right_arm, float dominance_left_arm, float dominance_right_arm) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.locus = locus ;
    this.data_left_arm = float_to_String_3(data_left_arm) ;
    this.data_right_arm = float_to_String_3(data_right_arm) ;
    this.dominance_left_arm = dominance_left_arm ;
    this.dominance_right_arm = dominance_right_arm ;
  }


  Gene(String chromosome_name, String gene_name, int locus, vec2 data, vec2 dominance) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.locus = locus ;
    this.data_left_arm = float_to_String_3(data.x) ;
    this.data_right_arm = float_to_String_3(data.y) ;
    this.dominance_left_arm = dominance.x ;
    this.dominance_right_arm = dominance.y ;
  }

  Gene(String chromosome_name, String gene_name, int locus, String data_left_arm, String data_right_arm, vec2 dominance) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.locus = locus ;
    this.data_left_arm = data_left_arm ;
    this.data_right_arm = data_right_arm ;
    this.dominance_left_arm = dominance.x ;
    this.dominance_right_arm = dominance.y ;
  }

    /**
  without locus
  */
  Gene(String chromosome_name, String gene_name, String data_left_arm, String data_right_arm, float dominance_left_arm, float dominance_right_arm) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.data_left_arm = data_left_arm ;
    this.data_right_arm = data_right_arm ;
    this.dominance_left_arm = dominance_left_arm ;
    this.dominance_right_arm = dominance_right_arm ;
  }

  Gene(String chromosome_name, String gene_name, float data_left_arm, float data_right_arm, float dominance_left_arm, float dominance_right_arm) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.data_left_arm = float_to_String_3(data_left_arm) ;
    this.data_right_arm = float_to_String_3(data_right_arm) ;
    this.dominance_left_arm = dominance_left_arm ;
    this.dominance_right_arm = dominance_right_arm ;
  }


  Gene(String chromosome_name, String gene_name, vec2 data, vec2 dominance) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.data_left_arm = float_to_String_3(data.x) ;
    this.data_right_arm = float_to_String_3(data.y) ;
    this.dominance_left_arm = dominance.x ;
    this.dominance_right_arm = dominance.y ;
  }

  Gene(String chromosome_name, String gene_name, String data_left_arm, String data_right_arm, vec2 dominance) {
    this.chromosome_name = chromosome_name ;
    this.gene_name = gene_name ;
    this.data_left_arm = data_left_arm ;
    this.data_right_arm = data_right_arm ;
    this.dominance_left_arm = dominance.x ;
    this.dominance_right_arm = dominance.y ;
  }



  public String get_chromosome_name() {
    return chromosome_name ;
  }

  public String get_gene_name() {
    return gene_name ;
  }

  public int get_locus() {
    return locus ;
  }


  public @Override String toString() {
    return "[ < Chromosome " + chromosome_name + " > < Gene " + gene_name + " > < Locus " + locus + " >< data: " + data_left_arm + " / " + data_right_arm + " > < dominance: " + dominance_left_arm + " / " +dominance_right_arm + " > ]";
  }
}
/**

END GENETIC

*/



















/**

DNA 0.1.2

*/

Table CODE_DNA_REF  ;
char [] nucleotide_char ;
public void load_nucleotide_table(String path) {
  CODE_DNA_REF = loadTable(path, "header") ;
  nucleotide_char = new char[CODE_DNA_REF.getRowCount()] ;
  for(int i = 0 ; i < nucleotide_char.length ; i++) {
    TableRow row = CODE_DNA_REF.getRow(i) ;
    String char_ref = row.getString("char") ;
    nucleotide_char[i] = char_ref.charAt(0) ;
  }
}



class DNA {
  ArrayList<Nucleotide> sequence_a  ;
  ArrayList<Nucleotide> sequence_b  ;
  // constructor
  DNA(String data, boolean pairing_dna) {
    sequence_a = new ArrayList<Nucleotide>() ;

    char [] array_char = data.toCharArray() ;
    for(int i = 0 ; i < array_char.length ; i++) {
      build_sequence(array_char[i]) ;
    }
    
    // pairing
    if(pairing_dna) {
      sequence_b = new ArrayList<Nucleotide>(pairing(sequence_a)) ;
    }
  }

  DNA(int size, boolean pairing_dna) {
    sequence_a = new ArrayList<Nucleotide>() ;
    int classic = 4 ;
    // with 4, it's classic ADN with GTAC
    for(int i = 0 ; i < size ; i++) {
      int nuc = floor(random(classic)) ;
      sequence_a.add(code(nuc)) ;
    }
    
    // pairing
    if(pairing_dna) {
      sequence_b = new ArrayList<Nucleotide>(pairing(sequence_a)) ;
    }
  }






  // methode
  Nucleotide nucleotide ;
  private void build_sequence(char c) {
    Nucleotide [] nucleotide  = new Nucleotide [4] ;
    for(int i = 0 ; i < nucleotide.length ; i++) {
      nucleotide [i] = translate(nucleotide, c)[i] ;
      sequence_a.add(nucleotide[i]) ;
    }
  }
  
  
  private char [] get_sequence() {
    char [] seq = new char[sequence_a.size()] ;
    for (int i = 0 ; i < sequence_a.size() ; i++) {
      Nucleotide n = (Nucleotide) sequence_a.get(i) ;
      seq[i] = n.nac ;
    }
    return seq ;
  }



  // mirror chain
  private ArrayList<Nucleotide> pairing(ArrayList<Nucleotide> strand) {
    ArrayList<Nucleotide> seq = new ArrayList<Nucleotide>() ;
    for(int i = 0 ; i < strand.size() ; i++) {
      Nucleotide nuc = strand.get(i) ;
      Nucleotide partner ;
      if(nuc.nac == 'c' || nuc.nac == 'C') partner = new Guanine() ;
      else if(nuc.nac == 'g' || nuc.nac == 'G') partner = new Cytosine() ;
      else if(nuc.nac == 't' || nuc.nac == 'T') partner = new Adenine() ;
      else if(nuc.nac == 'a'|| nuc.nac == 'A') partner = new Thymine() ;
      else partner = new Masked() ;
      seq.add(partner) ;
    }
    return seq ;
  }
}




/**
Translate char to Nucleotide
*/
private Nucleotide [] translate(Nucleotide [] n, char c) {
  for(int i = 0 ; i < nucleotide_char.length ; i++) {
    if(c == nucleotide_char[i]) {
      write_sequence(n, i) ;
      break ;
    } else {
      for(int j = 0 ; j < n.length ; j++) {
        n [j] = code('X') ;
      }
    }
  }
  return n ;
}

private void write_sequence(Nucleotide [] n, int row_id) {
  TableRow row = CODE_DNA_REF.getRow(row_id) ;
  String ref_sequence = row.getString("code") ;
  String [] sequence_a = ref_sequence.split("") ;
  for(int i = 0 ; i < sequence_a.length ; i++) {
    n[i] = code(sequence_a[i].charAt(0)) ;
  }
}


// Nucleotide from char
private Nucleotide code(char nac) {
  // nac : nucleic acid code from IUPAC
  if(nac == 'A' || nac == 'a') return new Adenine() ;
  else if(nac == 'C' || nac == 'c') return new Cytosine() ;
  else if(nac == 'G' || nac == 'g') return new Guanine() ;
  else if(nac == 'T' || nac == 't') return new Thymine() ;
  else return new Masked() ;
}

// Nucleotide from int
private Nucleotide code(int nac) {
  // nac : nucleic acid code from IUPAC
  if(nac == 0) return new Adenine() ;
  else if(nac == 1) return new Cytosine() ;
  else if(nac == 2) return new Guanine() ;
  else if(nac == 3) return new Thymine() ;
  else return new Masked() ;
}




/**
NUCLEOTIDE
*/
class Nucleotide {
  // nac : nucleic acid code from IUPAC
  char nac  ; 
}


class Guanine extends Nucleotide {
  Guanine () {
    this.nac = 'G' ;
  }
}

class Cytosine extends Nucleotide {
  Cytosine () {
    this.nac = 'C' ;
  }
}

class Adenine extends Nucleotide {
  Adenine () {
    this.nac = 'A' ;
  }
}

class Thymine extends Nucleotide {
  Thymine () {
    this.nac = 'T' ;
  }
}


class Masked extends Nucleotide {
  Masked() {
    this.nac = 'X' ;
  }
}








/**
* ECOSYSTEM UTIL 
* v 1.1.2
* 2015-2019
* Processing 3.5.3
* @author @stanlepunk
* @see https://github.com/StanLepunK/Life
* HOST and SYMBIOSIS
* WORLD
* BIOMASS
* picking, hunting, fooding
* REPRODUCTION
* GENETIC
* SHOW and COSTUME
* INFO
* GROWTH, LIFE and DIE
*/

/**
* HOST SYMBIOSIS MANAGEMENT 0.0.5
*/
int [] target_host ;
vec4 [] symbiosis_area ;
vec3 pos_host, radius_host, canvas_host, size_host ;

public vec4 [] get_symbiosis_area() {
  if(symbiosis_area != null) return symbiosis_area ; else return null ;
}

public int symbiosis_area_size() {
  if(symbiosis_area != null) return symbiosis_area.length ;
  else return -1 ;
}

public vec3 [] get_symbiosis_area_pos() {
  vec3 [] list = new vec3[symbiosis_area.length] ;
  for(int i = 0 ; i < list.length ; i++) {
    list[i] = vec3(symbiosis_area[i].x, symbiosis_area[i].y, symbiosis_area[i].z) ;
  }
  if(list != null) return list ; else return null ;
}

public int [] get_symbiosis_area_id() {
  int [] list = new int[symbiosis_area.length] ;
  for(int i = 0 ; i < list.length ; i++) {
      list[i] = PApplet.parseInt(symbiosis_area[i].w) ;
  }
  return list ;
}


public void init_symbiosis_area(int num) {
  symbiosis_area = new vec4[num];
}

public void init_host_target(int num) {
  target_host = new int[num] ;
}

public int [] get_host_address() {
  return target_host ;
}

public void set_host_address(int target, int value) {
  if(target < target_host.length) {
    target_host[target] = value ;
  }
}

/**
pos host
*/
public void pos_host(vec pos) {
  if(pos_host == null) {
    pos_host = vec3(pos.x,pos.y,pos.z) ;
  } else {
    pos_host.set(pos.x, pos.y, pos.z) ;
  }
}

public void pos_host(float x, float y, float z) {
  if(pos_host == null) {
    pos_host = vec3(x,y,z) ;
  } else {
    pos_host.set(x,y,z) ;
  }
}

public vec3 get_pos_host() {
  return pos_host ;
}

/**
radius host
*/
public void radius_host(vec radius) {
  if(radius_host == null) {
    radius_host = vec3(radius.x,radius.y,radius.z) ;
  } else {
    radius_host.set(radius.x, radius.y, radius.z) ;
  }
}

public void radius_host(float x, float y, float z) {
  if(radius_host == null) {
    radius_host = vec3(x,y,z) ;
  } else {
    radius_host.set(x,y,z) ;
  }
}

public vec3 get_radius_host() {
  return radius_host ;
}

/**
size host
*/
public void size_host(vec size) {
  if(size_host == null) {
    size_host = vec3(size.x,size.y,size.z) ;
  } else {
    size_host.set(size.x, size.y, size.z) ;
  }
}

public void size_host(float x, float y, float z) {
  if(size_host == null) {
    size_host = vec3(x,y,z) ;
  } else {
    size_host.set(x,y,z) ;
  }
}

public vec3 get_size_host() {
  return size_host ;
}


/**
canvas host
*/
public void canvas_host(vec canvas) {
  if(canvas_host == null) {
    canvas_host = vec3(canvas.x,canvas.y,canvas.z) ;
  } else {
    canvas_host.set(canvas.x, canvas.y, canvas.z) ;
  }
}

public void canvas_host(float x, float y, float z) {
  if(canvas_host == null) {
    canvas_host = vec3(x,y,z) ;
  } else {
    canvas_host.set(x,y,z) ;
  }
}

public vec3 get_canvas_host() {
  return canvas_host ;
}


/**
symbiosis area
*/
public void set_symbiosis_area(vec3 [] target_host_list) {
  for(int i = 0 ; i < symbiosis_area.length ; i++) {
    if(symbiosis_area[i] == null) symbiosis_area[i] = vec4() ;
    int where = (int)random(target_host_list.length) ;
    set_host_address(i, where) ;
    symbiosis_area[i].set(target_host_list[where].x, target_host_list[where].y, target_host_list[where].z, where) ;
  }
}



public void update_symbiosis_area(vec3 [] target_host_list) {
  if(symbiosis_area != null) {
    for(int i = 0 ; i < symbiosis_area.length ; i++) {
      int where = (int)symbiosis_area[i].w ;
      vec3 pos = target_host_list[where] ;
      symbiosis_area[i].x = pos.x ;
      symbiosis_area[i].y = pos.y ;
      symbiosis_area[i].z = pos.z ;
    }
  }  
}

/**
symbiosis 0.0.4
*/
public void symbiosis(ArrayList<Agent> symbiotic_agent_list, vec3 [] list_coord_host, int [] address) {
  if(list_coord_host.length > 0 && address.length > 0 && symbiotic_agent_list.size() > 0) {
    int max_loop = address.length ;
    if(max_loop > symbiotic_agent_list.size()) max_loop = symbiotic_agent_list.size() ;
    for(int i = 0 ; i < max_loop ; i++) {
      Agent a = symbiotic_agent_list.get(i) ;
      int where = floor(random(address.length)) ;
      a.set_home(list_coord_host[address[where]], address[where]) ;
      a.set_pos(a.get_home_pos()) ;
    }
  } 
}


public void sync_symbiosis(ArrayList<Agent> symbiotic_agent_list, vec3 pos) {
  for(Agent a : symbiotic_agent_list) {
    if(a.get_home_id() != -1) {
      if(symbiosis_area_size() > a.get_home_id()) {
        a.set_home_pos(get_symbiosis_area_pos()[a.get_home_id()]) ;
      } else {
        symbiotic_agent_list.remove(a) ;
        break ;
      }
      if(pos != null && !pos.equals(vec3(0))) {
        a.set_pos(a.get_home_pos().add(pos)) ;
      } else {
        a.set_pos(a.get_home_pos()) ;
      }
    } else {
      // System.err.println("ID home is equal to -1, need to init your symbiotic ecosystem before sync it") ;
    }
  }
}


public void sync_symbiosis(ArrayList<Agent> symbiotic_agent_list) {
  vec3 pos = vec3() ;
  sync_symbiosis(symbiotic_agent_list, pos) ;
}





















/**

WORLD 0.1.1

*/
boolean HORIZON_ALPHA = false ;
int HORIZON = 0 ;
int ENVIRONMENT = 2 ; // 2 is for 2D, 3 for 3D
vec3 ECO_BOX_SIZE = vec3(100,100,100) ;
vec3 ECO_BOX_POS = vec3() ;
vec6 LIMIT = vec6(0, ECO_BOX_SIZE.x, 0, ECO_BOX_SIZE.y, 0, ECO_BOX_SIZE.z) ;

boolean REBOUND ;
int SIZE_TEXT_INFO ;


public void set_renderer(String renderer) {
  if(renderer.equals(P3D)) {
    ENVIRONMENT = 3 ; 
  } else {
    ENVIRONMENT = 2 ;
  }
}


public void use_horizon(boolean horizon) {
  HORIZON_ALPHA = horizon ;
}

public void set_horizon(int value) {
   HORIZON = value ;
}

public void use_rebound(boolean rebound) {
  REBOUND = rebound ;
}

public vec3 get_box_pos() {
  return ECO_BOX_POS ;
}

public vec3 get_box_size() {
  return ECO_BOX_SIZE ;
}

public void build_box(vec3 pos, vec3 size) {
  set_pos_box(pos) ;
  set_size_box(size) ;
}

public void set_size_box(vec3 size) {
  ECO_BOX_SIZE.set(size) ;
}

public void set_pos_box(vec3 pos) {
  ECO_BOX_POS.set(pos) ;
}

public void set_limit_box(float left, float right, float top, float bottom, float front, float back) {
  LIMIT.set(left,right, top, bottom, front, back) ;
}
























/**

BIOMASS

*/
class Biomass {
  float humus, humus_max ;
  Biomass() {}

  public void humus_update(float var_humus) {
    humus +=var_humus ;
  }

  public void set_humus(float humus) {
    this.humus = this.humus_max = humus ;
  }
} 
























/**

AGENT DYNAMIC

*/

public void picking_update(ArrayList<Agent> list_picker, ArrayList<Agent> list_target) {
  for(Agent a : list_picker) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic picker = (Agent_dynamic) a ;
      if(!picker.satiate) {
        search_flora(picker, list_target) ;
      } 
      eat_flora(picker, list_target) ;
    }
  }
}

public void hunting_update(ArrayList<Agent> list_hunter, boolean info, ArrayList<Agent>... all_list) {
  for( ArrayList list_target : all_list) {
    for(Agent a : list_hunter) {
      if(a instanceof Agent_dynamic) {
        Agent_dynamic hunter = (Agent_dynamic) a ;
        if(!hunter.satiate && !hunter.eating) hunt(hunter, list_target) ;   
      }
    }
  }
}

public void eating_update(ArrayList<Agent> list_hunter, ArrayList<Dead> list_dead) {
  for(Agent a : list_hunter) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic hunter = (Agent_dynamic) a ;
      // eat
      if(list_dead.size() >= 0 ) {
        eat_meat(hunter, list_dead) ; 
      } else {
        hunter.eating = false ;
      }
    }
  }
}

/**

SEARCH

*/
/**
search flora
*/
public void search_flora(Agent_dynamic grazer, ArrayList<Agent> list_target) {

  if(grazer.tracking && grazer.max_time_track > grazer.time_track) {
    if(grazer.focus_target(list_target)) {
      int which_target = (int)grazer.ID_target.x ;
      int ID_target = (int)grazer.ID_target.y ;
      Agent target = list_target.get(which_target) ;
      grazer.track(grazer.target) ;
    } 
  } else {
    grazer.track_stop() ;
    int entry = floor(random(list_target.size())) ;
    for(int i = 0 ; i < list_target.size() ; i++) {
      int which = i + entry ;
      if(which >= list_target.size()) {
        which -= list_target.size() ;
      }
      Agent a = list_target.get(which) ;
      if(a instanceof Flora) {
        Flora target = (Flora) a ;
        grazer.watch(target, list_target) ;
        if(grazer.tracking) {
          break ;
        }
      }
    }
  }  
}






/**
hunt creature
*/
public void hunt(Agent_dynamic hunter, ArrayList<Agent> list_target) {
  // first watch the agent who watch just before without look in the list
  if(hunter.watching) find_target_hunter(hunter, list_target) ;

  if(hunter.tracking && hunter.max_time_track > hunter.time_track) {
    hunt_target(hunter, list_target) ; 
  } else {
    hunter.track_stop() ;
  }
}



// Local method : The hunt is launching !
public void hunt_target(Agent_dynamic hunter, ArrayList<Agent> list_target) {
   if (hunter.focus_target(list_target)) {
    hunt_and_kill_target(hunter, hunter.target) ;
   } else {
    hunter.track_stop() ;
  }
}
// super local method
public void hunt_and_kill_target(Agent_dynamic hunter, Agent target) {
  if(target instanceof Agent_dynamic) {
    Agent_dynamic target_d = (Agent_dynamic) target ;
    if(hunter.dist_to_target(target_d) < hunter.sense_range) {
      hunter.track(target_d) ; 
      hunter.kill(target_d) ;
    } else hunter.track_stop() ;
  }
}

/**
Find new target, Big Brother is hunting you !
*/
public void find_target_hunter(Agent_dynamic hunter, ArrayList<Agent> list_target) {
  // float [] dist_list = new float[0] ;
  ArrayList <vec3> closest_target = new ArrayList<vec3>() ;
  // find the closest target 
  for(Agent a : list_target) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic target_d = (Agent_dynamic) a ;
      if(hunter.dist_to_target(target_d) < hunter.sense_range) {
        float dist = hunter.dist_to_target(target_d) ;
        // catch distance to compare with the last one
        // plus catch index in the list and the ID target
        // and add in the nice target list

        vec3 new_target = vec3(dist, list_target.indexOf(target_d), target_d.get_ID()) ;
        closest_target.add(new_target) ;
        // compare the target to see which one is the closest.
        if(closest_target.size() > 1) if (closest_target.get(1).x <= closest_target.get(0).x ) closest_target.remove(0) ; else closest_target.remove(1) ;
      } 
    }
  }

  // Start the hunt party with the selected target
  if(closest_target.size() > 0 ) {
    Agent a = list_target.get((int)closest_target.get(0).y) ;
    if(a instanceof Agent_dynamic) {
      Agent_dynamic target_d = (Agent_dynamic) a ;
      hunter.track(target_d) ;
      hunter.kill(target_d) ;
      if(hunter.tracking) hunter.ID_target.set(list_target.indexOf(target_d),target_d.get_ID()) ;
    }
  }
}




/**

EAT

*/
/**
eating flora
*/
public void eat_flora(Agent_dynamic grazer, ArrayList<Agent> list_target) {
  if(grazer.eating) {
    Agent a ;
    if((int)grazer.ID_target.x < list_target.size()) {
      a = list_target.get((int)grazer.ID_target.x) ;
      if(a instanceof Flora) {
        Flora target = (Flora) a ;
        grazer.eat_veg(target) ;
      }
    }
  } else if (!grazer.eating) {
    for(Agent a : list_target) {
      if(a instanceof Flora) {
        Flora target = (Flora) a ;
        grazer.eat_veg(target) ;
        if(grazer.eating) {
          if((int)grazer.ID_target.x < list_target.size()) {
            grazer.ID_target.set(list_target.indexOf(a),target.ID) ;
            break ;
          }
        }
      }
    }
  }
}

/**
eat meat
*/
public void eat_meat(Agent_dynamic hunter, ArrayList<Dead> list_dead) {
  // first eat the agent who eat just before without look in the list
  if(hunter.eating) {
    int pointer = (int)hunter.ID_target.x ;
    int ID_target = (int)hunter.ID_target.y ;
    /* here we point directly in a specific point of the list, 
    if the pointer is superior of the list, 
    because if it's inferior a corpse can be eat by an other Agent */
    if(pointer < list_dead.size() ) {
      Dead target = list_dead.get((int)hunter.ID_target.x) ;
      /* if the entry point of the list return an agent 
      with a same ID than a ID_target corpse eat just before, 
      the Carnivore can continue the lunch */
      if (target instanceof Agent_static && target.get_ID() == ID_target ) {
        Agent_static agent_meat = (Agent_static) target ;
        hunter.eat_flesh(agent_meat) ; 
      }
      else {
        /* If the ID returned is different, a corpse was leave from the list, 
        and it's necessary to check in the full ist to find if any corpse have a seme ID */
        for(Dead target_in_list : list_dead) {
          if (target_in_list instanceof Agent_static && target_in_list.get_ID() == ID_target) {
            Agent_static agent_meat = (Agent_static) target_in_list ;
            hunter.eat_flesh(agent_meat) ; 
          } else {
            hunter.eating = false ;
          }
        }
      }
    }
  /* If the last research don't find the corpse, may be this one is return to dust ! */
  } else {
    for(Agent a : list_dead) {
      if(a instanceof Agent_static) {
        Agent_static target = (Agent_static) a ;
        hunter.eat_flesh(target) ;
        if(hunter.eating) {
          hunter.ID_target.set(list_dead.indexOf(target),target.get_ID()) ;
          break ;
        }
      }
    }
  }
}

/**


END FOOD


*/












































/**

REPRODUCTION AGENT DYNAMIC

*/
public boolean check_male_reproducer(Agent female, ArrayList<Agent> list_target) {
  boolean result = false ;
  if(list_target.size() > 0) {
    for (Agent male : list_target) {
      if(male instanceof Agent_dynamic && female instanceof Agent_dynamic) {
        Agent_dynamic m = (Agent_dynamic) male ;
        Agent_dynamic f = (Agent_dynamic) female ;
        if(dist(f.pos, m.pos) < f.reproduction_area) {
          result = true ;
          // must be create method copy but smell very complexe thing to do
          f.genome_father = m.genome ;
          break ; 
        } else result = false ;
      } else result = false ;
    }
  } else result = false ;
  return result ;
}


/**
Male Reproduction
*/
public void reproduction_male(ArrayList<Agent> list_f, ArrayList<Agent> list_m) {
  for (Agent f : list_f) {
    if(f instanceof Agent_dynamic) {
      Agent_dynamic f_a_d = (Agent_dynamic) f ;
      if(f_a_d.fertility && check_female_reproducer(f, list_m)) ;
    }
  }
}

public boolean check_female_reproducer(Agent female, ArrayList<Agent> list_target_male) {
  boolean result = false ;
  if(list_target_male.size() > 0) {
    for (Agent male : list_target_male) {
      if(male instanceof Agent_dynamic && female instanceof Agent_dynamic) {
        Agent_dynamic m = (Agent_dynamic) male ;
        Agent_dynamic f = (Agent_dynamic) female ;
        if(dist(female.get_pos(), male.get_pos()) < f.sex_appeal) {
          f.pos_target.set(male.get_pos()) ;
          m.tracking_partner = true ;
          // float ratio_acceleration_to_see_female = 1.3 ;
          // m.velocity = m.velocity_ref *ratio_acceleration_to_see_female ;
          m.dir.set(target_direction(f.pos, m.pos)) ;
          result = true ; 
        } else {
          result = false ;
          m.tracking_partner = false ;
        }
      } else {
        result = false ;
      }
    }
  } else result = false ;
  return result ;
}




/**
DELIVERY
*/
int num_by_pregnancy = 1 ;

public void delivery(Agent_dynamic deliver, Genome mother, Genome father, ArrayList<Agent> list_child, Info_dict carac, Info_Object style) {
  // check for heterozygote
  num_babies(deliver.multiple_pregnancy) ;
  Agent [] babies = new Agent [num_by_pregnancy] ;
  babies = babies(deliver, num_by_pregnancy, mother, father) ;
  for(int i = 0 ; i < num_by_pregnancy ; i++) {
    set_baby(deliver, babies[i], list_child, carac, style) ;
    if(PRINT_BORN_AGENT_DYNAMIC) print_born_agent_dynamic (babies[i]) ;
  }
  deliver.num_pregnancy ++ ;
  num_by_pregnancy = 1 ;
}

// local
public void set_baby(Agent_dynamic deliver, Agent baby, ArrayList<Agent> list_child, Info_dict carac, Info_Object style) {
  if(baby instanceof Agent_dynamic) {
    Agent_dynamic n = (Agent_dynamic) baby ;
    // clean the uterus of mother
    deliver.genome_father = null ;
    // set motion of the baby
    n.set_pos(deliver.pos) ;
    n.dir = vec3().rand(1);;
    // here we change velocity to don't have a same from parent, can be change that in the future
    float new_velocity = deliver.velocity +random(-1,1) ;
    if(new_velocity < .1f) new_velocity = .1f ;
    n.set_velocity(new_velocity) ;

    // all data from mother
    // Must add this part in the genome for the future,
    if(baby instanceof Carnivore) set_carnivore(n, deliver.pos, carac, style) ;
    if(baby instanceof Herbivore) set_herbivore(n, deliver.pos, carac, style) ;
    if(baby instanceof Omnivore) set_omnivore(n, deliver.pos, carac, style) ; 

    n.set_ID( (short) Math.round(random(Short.MAX_VALUE))) ;
    list_child.add(n) ;
  }
}


public Agent [] babies(Agent_dynamic deliver, int num, Genome mother, Genome father) {
  Agent [] b = new Agent [num] ;
  // re-init for the pregnancy
  String monster_message = "The mother deliver is a genetic monster, and the 'Nature of Code' kill it because is not a baby from an Authorized Class" ;

  for(int i = 0 ; i < b.length ; i++) {
    // check for homozygous
    if(b.length > 1 && i <  b.length -1 && random(3) < 1) {
      deliver.num_children += 2 ;
      deliver.num_homozygous += 2 ;
      if(deliver instanceof Herbivore ) b[i] = new Herbivore(mother, father, deliver.style) ;
      else if(deliver instanceof Omnivore ) b[i] = new Omnivore(mother, father, deliver.style) ;
      else if(deliver instanceof Carnivore ) b[i] = new Carnivore(mother, father, deliver.style) ;
      else println(monster_message) ;
      i++ ;
      if(deliver instanceof Herbivore ) b[i] = b[i -1] ;
      else if(deliver instanceof Omnivore ) b[i] = b[i -1] ;
      else if(deliver instanceof Carnivore ) b[i] = b[i -1] ;
      else println(monster_message) ;
    } else {
      deliver.num_children++ ;
      if(b.length > 1) deliver.num_heterozygous++ ;
      if(deliver instanceof Herbivore ) b[i] = new Herbivore(mother, father, deliver.style) ;
      else if(deliver instanceof Omnivore ) b[i] = new Omnivore(mother, father, deliver.style) ;
      else if(deliver instanceof Carnivore ) b[i] = new Carnivore(mother, father, deliver.style) ;
      else println(monster_message) ;
    }
  }
  return b ;
}



public void num_babies(float ratio_multi) {
  int max = 100 ;    
  float draw = random(max) ;
  // security
  int max_babies = 100 ;

  if(draw < ratio_multi && num_by_pregnancy < max_babies) {
    num_by_pregnancy++ ;
    num_babies(ratio_multi) ;
  }
}






/**
FAMILY
*/
public void manage_child(ArrayList<Agent> list_f, ArrayList<Agent> list_m, ArrayList<Agent> list_child) {
  if(list_child.size() > 0) {
    for (Agent child : list_child) {
      if(child instanceof Agent_dynamic) {
        Agent_dynamic c = (Agent_dynamic) child ;
        if(c.maturity <= 0 ) {
          if(c.gender == 0 ) {
            // we don't add 'c' because it's an 'Agent_dynamic' we need to a pure 'Agent'
            list_f.add(child) ;
            break ;
          }
          if(c.gender == 1 ) {
            // we don't add 'c' because it's an 'Agent_dynamic' we need to a pure 'Agent'
            list_m.add(child) ;
            break ;
          }
        }
      }
    }

    // remove child when this one to be added to the adult pool
    for (Agent child : list_child) {
      if(child instanceof Agent_dynamic) {
        Agent_dynamic c = (Agent_dynamic) child ;
        if(c.maturity <= 0 ) {
          list_child.remove(child) ;
          break ;
        }
      }
    }
  }
}

/**

END REPRODUCTION 
AGENT DYNAMIC

*/







































/**

SHOW / COSTUME

*/
public void set_costume_agent(int which_costume, ArrayList<Agent>... all_list) {
  for(ArrayList<Agent> list : all_list) {
    for(Agent a : list) {
      a.set_costume(which_costume) ; 
    }
  }
}


/**
Info_Object info
* boolean info = (boolean)info.catch_obj(0) ;
* boolean original = (boolean)info.catch_obj(1) ;
* int costume_ID = (int)info.catch_obj(2) ;
* vec4 fill = (vec4)info.catch_obj(3) ;
* vec4 stroke = (vec4)info.catch_obj(4) ; 
* float thickness = (float)info.catch_obj(5) ;
*/ 
public void show_agent_dynamic(Info_Object style, ArrayList<Agent>... all_list) {
  for(ArrayList list : all_list) {
    if(INFO_DISPLAY_AGENT) {
      info_agent(list) ;
      info_agent_track_line(list) ;
    } else {
      update_aspect(style, list) ;
    }
  }
}


/**
Aspect 1.0.3
*/
boolean use_style = true ;
public void use_style(boolean style) {
  use_style = style ;
}
/**
update aspect
*/
public void update_aspect(Info_Object style, ArrayList list) {
  int costume_ID = 0 ;
  vec4 fill_vec =  vec4(0, 0 , g.colorModeZ, g.colorModeA) ; 
  vec4 stroke_vec = vec4(g.colorModeX, g.colorModeY, g.colorModeZ, g.colorModeA) ; 
  float thickness = 1 ;
  // float alpha_behavior = (float)style.catch_obj(4) ;
  boolean fill_is = true ;
  boolean stroke_is = true ;

  if(style.catch_obj(0) != null) costume_ID = ((Costume)style.catch_obj(0)).get_type();
  if(style.catch_obj(1) != null) fill_vec = (vec4)style.catch_obj(1);
  if(style.catch_obj(2) != null) stroke_vec = (vec4)style.catch_obj(2); 
  if(style.catch_obj(3) != null) thickness = (float)style.catch_obj(3);
  // if(style.catch_obj(4) != null) alpha_behavior = (float)style.catch_obj(4) ;
  if(style.catch_obj(5) != null) fill_is = (boolean)style.catch_obj(5);
  if(style.catch_obj(6) != null) stroke_is = (boolean)style.catch_obj(6);




  for(Object o : list) {
    if(o instanceof Agent) {
      Agent a = (Agent) o ;
      boolean original_aspect = true ;
      vec4 fill_def ;
      vec4 stroke_def ;
      float thickness_def ;

      if(fill_vec != a.get_fill_style() || stroke_vec != a.get_stroke_style() || thickness != a.get_thickness()) {
        original_aspect = false ;
      }

      if(original_aspect) {
        fill_def = a.get_fill_style().copy() ;
        stroke_def = a.get_stroke_style().copy() ;
        thickness_def = a.get_thickness() ;
      } else {
        fill_def = fill_vec.copy() ;
        stroke_def = stroke_vec.copy() ;
        thickness_def = thickness ;
      }


      if(use_style) {
        if(a.get_melanin() != null) {
          vec4 map = map(a.get_melanin(), -1, 1, 0, 2);
          fill_def.mult(map) ;
          stroke_def.mult(map) ;
        }
        if(g.colorMode == 3) {
          if(fill_def.x > g.colorModeX) fill_def.x = fill_def.x - g.colorModeX ;
          if(stroke_def.x > g.colorModeX) stroke_def.x = stroke_def.x - g.colorModeX ;
        }
      }

      if(HORIZON_ALPHA) {
        if(fill_def != null) fill_def.set(fill_def.x, fill_def.y, fill_def.z, alpha(a)) ;
        if(stroke_def != null) stroke_def.set(stroke_def.x, stroke_def.y, stroke_def.z, alpha(a)) ;
      }

      // display

      if(!fill_is) {
        fill_def.alp(0);
      }
      if(!stroke_is) {
        thickness_def = 0 ;
      }
      a.aspect(fill_def, stroke_def, thickness_def) ;
      if(costume_ID != a.get_costume().get_type()) {
        a.set_costume(costume_ID) ; 
      } else {
        a.costume() ;
      }
    }
    /*
    if(o instanceof Dead) {
      Dead d = (Dead) o ;
      boolean original_aspect = true ;

      if(costume_ID != d.get_costume() || fill_vec != d.get_fill_style() || stroke_vec != d.get_stroke_style() || thickness != d.get_thickness()) {
        original_aspect = false ;
      }
      if(original_aspect) {
        if(HORIZON_ALPHA) {
          vec4 new_fill = vec4(d.get_fill_style().x, d.get_fill_style().y, d.get_fill_style().z, alpha(d)) ;
          vec4 new_stroke = vec4(d.get_stroke_style().x, d.get_stroke_style().y, d.get_stroke_style().z, alpha(d)) ;
          d.aspect(new_fill, new_stroke, thickness) ;
        } else {
          d.aspect(d.get_fill_style(), d.get_stroke_style(), d.get_thickness()) ;
        }
        d.costume() ;

      } else {
        if(HORIZON_ALPHA) {
          vec4 new_fill = vec4(fill_vec.x, fill_vec.y, fill_vec.z, alpha(d)) ;
          vec4 new_stroke = vec4(stroke_vec.x, stroke_vec.y, stroke_vec.z, alpha(d)) ;
          d.aspect(new_fill, new_stroke, thickness) ;
        } else {
          d.aspect(fill_vec, stroke_vec, thickness) ;
        }

        if(costume_ID != d.get_costume()) {
          d.costume(costume_ID) ; 
        } else {
          d.costume() ;
        }
      }
    } 
    */  
  }
}


public float alpha(Agent a) {
  vec3 temp_pos = a.get_pos() ;
  int horizon_back = PApplet.parseInt(HORIZON * a.get_alpha_back()) ;
  int horizon_front = PApplet.parseInt(HORIZON * a.get_alpha_front()) ;
  horizon_back += a.get_alpha_cursor() ;
  horizon_front += a.get_alpha_cursor() ;
  float alpha = map(temp_pos.z, -horizon_back, horizon_front, 0 ,1) ;
  if(alpha <= 0 ) alpha = 0 ;
  alpha = alpha * g.colorModeA ;
  return alpha ;
}
/**
END SHOW

*/


























/**
INFO – LOG – PRINT
v 0.2.0
*/
boolean INFO_DISPLAY_AGENT = false ;


int FRAME_RATE_LOG = 300 ;

boolean PRINT_DEATH_AGENT_DYNAMIC = true ;
boolean PRINT_BORN_AGENT_DYNAMIC = true ;
boolean PRINT_POPULATION = true ;


boolean LOG_ECOSYSTEM = false ;
boolean LOG_ALL_AGENTS = false ;

boolean LOG_HERBIVORE = false ;
boolean LOG_OMNIVORE = false ;
boolean LOG_CARNIVORE = false ;
boolean LOG_FLORA = false ;
boolean LOG_BACTERIUM = false ;
boolean LOG_DEAD = false ;


boolean log_is ;
int SEQUENCE_LOG = 0 ;
// int col_num = 10 ;
// log Eco agent
Table [] log_eco_agent ;
TableRow [] tableRow_eco_agent ;
// log Eco resume
Table log_eco_resume ;
TableRow [] tableRow_eco_resume ;

// log Agent
Table log_agents ;
TableRow [] tableRow_agents ;
int col_num_agents = 10 ;


boolean first_save = true  ;
String save_date = "" ;
public String save_date() {
  if (first_save) {
    save_date = year()+"_"+month()+"_"+day()+"_"+hour()+"_"+minute() ;
    SEQUENCE_LOG = 0 ;
    first_save = false ;
  }
  return save_date ;
}


/**
LOG 1.0.0

*/
/**
Log ecosystem 0.0.1
*/


/**
set log
*/

public void set_frameRate_log(int tempo) {
  FRAME_RATE_LOG = tempo ;
}


public void set_log_ecosystem(boolean b) { 
  LOG_ECOSYSTEM = b ;
}
public void set_log_agents(boolean b) { 
  LOG_ALL_AGENTS = b ;
}

public void set_log_herbivore(boolean b) { 
  LOG_HERBIVORE = b ;
}
public void set_log_omnivore(boolean b) { 
  LOG_OMNIVORE = b ;
}
public void set_log_carnivore(boolean b) { 
  LOG_CARNIVORE = b ;
}
public void set_log_bacterium(boolean b) { 
  LOG_BACTERIUM = b ;
}
public void set_log_flora(boolean b) { 
  LOG_FLORA = b ;
}
public void set_log_dead(boolean b) { 
  LOG_DEAD = b ;
}




// log
public boolean log_is() {
  return log_is ;
}


public void init_log() {
  if(log_agents != null) log_agents.clearRows() ;
  if(log_eco_resume != null) log_eco_resume.clearRows() ;
  if(log_eco_agent != null) {
    for(int i = 0 ; i <log_eco_agent.length ; i++) {
      if(log_eco_agent[i] != null) log_eco_agent[i].clearRows() ;
    }
  }
}



// build
public void build_log(int num_table_eco) {
  log_is = true ;
  int rank = 0 ;

  // build log eco agent
  log_eco_agent = new Table[num_table_eco] ;
  for(int i = 0 ; i < log_eco_agent.length ; i++) {
    log_eco_agent[i] = new Table() ;
  }
  String [] col_name_eco_agent = new String[9] ;
  col_name_eco_agent[rank++] = "Time" ;
  col_name_eco_agent[rank++] = "Agent" ;
  col_name_eco_agent[rank++] = "Life" ;
  col_name_eco_agent[rank++] = "Stamina" ;
  col_name_eco_agent[rank++] = "Size" ;
  col_name_eco_agent[rank++] = "Child" ;
  col_name_eco_agent[rank++] = "Female" ;
  col_name_eco_agent[rank++] = "Male" ;
  col_name_eco_agent[rank++] = "Population" ;
  for(int i = 0 ; i < log_eco_agent.length ; i++) {
    buildTable(log_eco_agent[i], col_name_eco_agent) ;
  }



  // build log Eco resume
  log_eco_resume = new Table() ;
  String [] col_name_eco_resume = new String[6] ;
  rank = 0 ;
  col_name_eco_resume[rank++] = "Time" ; 
  col_name_eco_resume[rank++] = "Frame rate" ; 
  col_name_eco_resume[rank++] = "Name" ;
  col_name_eco_resume[rank++] = "Units" ;
  col_name_eco_resume[rank++] = "Quantity" ; 
  col_name_eco_resume[rank++] = "Max" ; 
  buildTable(log_eco_resume, col_name_eco_resume) ;
  

  // build log agent global
  log_agents = new Table() ;
  String [] col_name_agents = new String[13] ;
  rank = 0 ;
  col_name_agents[rank++] = "Rank" ; 
  col_name_agents[rank++] = "Agent" ; 
  col_name_agents[rank++] = "Gen" ; 
  col_name_agents[rank++] = "Gender" ;
  col_name_agents[rank++] = "Pregnancy" ;  
  col_name_agents[rank++] = "Children" ; 
  col_name_agents[rank++] = "Heterozygous" ; 
  col_name_agents[rank++] = "Homozygous" ; 
  col_name_agents[rank++] = "Size" ;
  col_name_agents[rank++] = "Life" ;
  col_name_agents[rank++] = "Stamina" ;
  col_name_agents[rank++] = "Hunger" ;
  col_name_agents[rank++] = "Starving" ;
  buildTable(log_agents, col_name_agents) ;
}



public void log_eco_agent(int which, String name, ArrayList... pop_list) {
  add_log_eco_agent(log_eco_agent[which], name, pop_list) ;
}

public void log_eco_resume(float humus, float humus_max, ArrayList... pop_list) {
  add_log_eco_resume(log_eco_resume, humus, humus_max, pop_list) ;
}

public void log_agent_global(String name, ArrayList... pop_list) {
  add_log_agent_global(log_agents, name, pop_list) ;
}



public void log_save() {
  SEQUENCE_LOG++ ;

  // save
  for(int i = 0 ; i < log_eco_agent.length ; i++) {
    if(log_eco_agent[i].getRowCount() > 0) {
      TableRow row = log_eco_agent[i].getRow(0) ;
      String name_file = row.getString("Agent") ;
      saveTable(log_eco_agent[i], "log/Log_"+save_date()+"/ecosystem/eco_"+name_file+"_"+save_date()+".csv") ;
    }
  }
  saveTable(log_agents, "log/Log_"+save_date()+"/agent/agent_global/agent_global_"+SEQUENCE_LOG+".csv") ;
  log_agents.clearRows() ;

  saveTable(log_eco_resume, "log/Log_"+save_date()+"/ecosystem/resume/resume_"+SEQUENCE_LOG+".csv") ;
  log_eco_resume.clearRows() ;
}







// local
public void add_log_eco_resume(Table table, float humus, float humus_max, ArrayList... pop_list) {
  int num_group = 0 ;
  // humus
  TableRow new_row = table.addRow() ;
  new_row.setInt("Time", SEQUENCE_LOG) ;
  new_row.setInt("Frame rate", (int)frameRate) ;
  new_row.setString("Name", "Humus") ;
  new_row.setInt("Units", 1)  ;
  new_row.setFloat("Quantity", humus)  ;
  new_row.setFloat("Max", humus_max)  ;

  // agent
  for(ArrayList list : pop_list) {
    int units = 0 ;
    int max = 0 ;
    int quantity = 0 ;
    String name = "nobody" ;
    for(Object obj : list) {
      if(obj instanceof Agent) {
        Agent_model a = (Agent_model) obj ;
        units = list.size() ;
        max += a.stamina_ref ;
        quantity += a.stamina ;
      }
      if(obj instanceof Carnivore) name = "Carnivore" ;
      if(obj instanceof Herbivore) name = "Herbivore" ;
      if(obj instanceof Omnivore) name = "Omnivore" ;
      if(obj instanceof Bacterium) name = "Bacterium" ;
      if(obj instanceof Flora) name = "Flora" ;
      if(obj instanceof Dead) name = "Dead" ;
    }
    if(units > 0) {
      new_row = table.addRow() ;
      new_row.setInt("Time", SEQUENCE_LOG) ;
      new_row.setString("Name", name) ;
      new_row.setInt("Units", units)  ;
      new_row.setInt("Quantity", quantity)  ;
      new_row.setInt("Max", max)  ;
    }
  }
}



// agent global
public void add_log_agent_global(Table table, String name, ArrayList... pop_list) {
  int pop_total = 0 ;
  int rank = 0 ;
  for(int i = 0 ; i < pop_list.length ; i++) {
    pop_total += pop_list[i].size() ;
  }
  // size
  if(pop_total > 0 ) {
    for(ArrayList list : pop_list) {
      for(Object obj : list) {
        if(obj instanceof Agent_dynamic) {
          Agent_dynamic a = (Agent_dynamic) obj ;
          TableRow new_row = table.addRow() ;
          new_row.setInt("Rank", rank++) ;
          new_row.setString("Agent", a.name) ;
          new_row.setInt("Gen", a.generation) ;
          if(a.gender == 0 ) new_row.setString("Gender", "Female") ; else new_row.setString("Gender", "Male") ;
          new_row.setInt("Pregnancy", a.num_pregnancy) ;
          new_row.setInt("Children", a.num_children) ;
          new_row.setInt("Heterozygous", a.num_heterozygous) ;
          new_row.setInt("Homozygous", a.num_homozygous) ;
          new_row.setInt("Life", a.get_life()) ;
          new_row.setInt("Stamina", a.get_stamina()) ;
          new_row.setInt("Mass", a.get_mass()) ;
          new_row.setInt("Hunger", a.hunger) ;
          new_row.setString("Starving", String.valueOf(a.starving_bool)) ;
        }
      }
    }
  }
}
// log eco agent
public void add_log_eco_agent(Table table, String name, ArrayList... pop_list) {
  // pop
  int pop_total = 0 ;
  int stamina_total = 0 ;
  int life_total = 0 ;
  int mass_total = 0 ;
  // find data
  for(int i = 0 ; i < pop_list.length ; i++) {
    pop_total += pop_list[i].size() ;
  }
  // size
  if(pop_total > 0 ) {
    for(ArrayList list : pop_list) {
      for(Object obj : list) {
        if(obj instanceof Agent) {
          Agent a = (Agent) obj ;
          stamina_total += a.get_stamina() ;
          life_total += a.get_life() ;
          mass_total += a.get_mass() ;
        }
      }
    }
  }
  // write in table
  if(pop_list.length > 0 && pop_total > 0) {
    TableRow new_row = table.addRow() ;
    new_row.setString("Agent", name) ;
    new_row.setInt("Time", SEQUENCE_LOG) ;
    new_row.setInt("Stamina", stamina_total) ;
    if(life_total >= 0 ) new_row.setInt("Life", life_total) ;
    new_row.setInt("Mass", mass_total) ;
    // witout male or female
    if(pop_list.length == 1) {
      new_row.setInt("Population", pop_total) ;
    }
    // with male, female and child
    if(pop_list.length == 3) {
      new_row.setInt("Child", pop_list[0].size()) ;
      new_row.setInt("Female", pop_list[1].size()) ;
      new_row.setInt("Male", pop_list[2].size()) ;
      new_row.setInt("Population", pop_total) ;
    }      
  }
}











/**
print 0.0.2
*/
public void print_info_environment(Biomass biomass) {
  println("ENVIRONMENT") ;
  println("Humus", biomass.humus) ;
}


public void print_born_agent_dynamic(Agent a) {
  if(a instanceof Agent_dynamic) {
    Agent_dynamic baby = (Agent_dynamic) a ;
    println("BORN") ;
    println("name", baby.name, baby.ID) ;
    /*
    println("generation", baby.generation) ;
    println("life", baby.life) ;
    println("expectancy", baby.life_expectancy) ;
    println("size", baby.size) ;
    println("stamina", baby.stamina) ;
    println("satiate", baby.satiate) ;
    println("hunger", baby.hunger) ;
    */
  }
}


public void print_death_agent(Agent_dynamic dead) {
  println("DEATH") ;
  println("name", dead.name, dead.ID) ;
  //println("generation", dead.generation) ;
  //println("life", dead.life) ;
  //println("expectancy", dead.life_expectancy) ;
  println("size", dead.size) ;
  println("stamina", dead.stamina) ;
  println("satiate", dead.satiate) ;
  println("hunger", dead.hunger) ;
  // println("velocity", dead.velocity) ;
}





public void print_pop_agent_dynamic(String name, ArrayList... pop_list) {
  int pop_total = 0 ;
  for(int i = 0 ; i < pop_list.length ; i++) {
    pop_total += pop_list[i].size() ;
  }
  if(pop_list.length > 0 && pop_total > 0) {
      if(pop_list.length == 1) println(name, pop_list[0].size(), ">", pop_total) ;
      if(pop_list.length == 2) println(name, pop_list[0].size(), pop_list[1].size(), ">", pop_total) ;
      if(pop_list.length == 3) println(name, pop_list[0].size(), pop_list[1].size(),  pop_list[2].size(), ">", pop_total) ;
  }
}


/**
print by category
*/

public void print_info_herbivore(String title, ArrayList<Agent> list) {
 // println(title + " POPULATION ", list.size()) ;
  for(Agent a : list) {
    if(a instanceof Herbivore) {
      Herbivore h = (Herbivore) a ;
      //  println(title + " POPULATION ", list.size()) ;
     // h.info_print() ;
     // h.info_print_motion() ;
     // h.info_print_structure() ;
     // h.info_print_life() ;
     //h.info_print_feeding() ;
     // h.info_print_hunting_picking() ;
     // h.info_print_herbivore() ;

    }

  }
}

public void print_info_omnivore(String title, ArrayList<Agent> list) {
  println(title + " POPULATION ", list.size()) ;
  for(Agent a : list) {
    if(a instanceof Omnivore) {
      Omnivore o = (Omnivore) a ;
  //  println(title + " POPULATION ", list.size()) ;
        // o.info_print_agent_() ;
   // o.info_print_motion() ;
  // o.info_print_caracteristic() ;
   // o.info_print_life() ;
   // o.info_print_feeding() ;
   // o.info_print_hunting_picking() ;
   // o.info_print_herbivore() ;
    }
  }
}


public void print_info_carnivore(String title, ArrayList<Agent> list) {
  println(title + " population", list.size()) ;
  for(Agent a : list) {
    if(a instanceof Carnivore) {
      Carnivore c = (Carnivore) a ;
    // a_d.info_print() ;
    // a_d.info_print_motion() ;
      c.info_print_caracteristic() ;
      c.info_print_life() ;
      c.info_print_carnivore() ;
    }
  }
}



public void print_info_bacterium(String title, ArrayList<Agent> list) {
  println(title + " population ", list.size()) ;
  for(Agent a : list) {
    if(a instanceof Bacterium) {
      Bacterium b = (Bacterium) a ;
      // b.info_print() ;
      // b.info_print_motion() ;
      b.info_print_caracteristic() ;
      b.info_print_life() ;
      b.info_print_feeding() ;
      b.info_print_hunting_picking() ;
      b.info_print_life() ;
      b.info_print_bacterium() ;
    }
  }
}



/**
INFO misc
v 0.1.0
*/
/*
void info_agent(ArrayList<Agent> list) {
  for(Agent a : list) {
    a.info(a.get_fill_style(), SIZE_TEXT_INFO) ;
  }
}
*/

public void set_textSize_info(int size) {
  SIZE_TEXT_INFO = size ;
}


public void info_agent(ArrayList list) {
  for(Object o : list) {
    if(o instanceof Agent) {
      Agent a = (Agent) o ;
      a.info(a.get_fill_style(), SIZE_TEXT_INFO) ;
    } else if(o instanceof Dead) {
      Dead d = (Dead) o ;
      d.info(d.get_fill_style(), SIZE_TEXT_INFO) ;

    } 
  }
}

public void info_agent_track_line(ArrayList<Agent> list) {
  for(Agent a : list) {
    if(a instanceof Carnivore) {
      Carnivore c = (Carnivore) a ;
      track_line(c.pos, c.pos_target, c.colour_info(c.get_stroke_style())) ;
      c.pos_target.set(MAX_INT) ;
    } else if (a instanceof Herbivore) {
      Herbivore h = (Herbivore) a ;
      track_line(h.pos, h.pos_target, h.colour_info(h.get_stroke_style())) ;
      h.pos_target.set(MAX_INT) ;
    } else if (a instanceof Omnivore) {
      Omnivore o = (Omnivore) a ;
      track_line(o.pos, o.pos_target, o.colour_info(o.get_stroke_style())) ;
      o.pos_target.set(MAX_INT) ;
    } else if (a instanceof Bacterium) {
      Bacterium b = (Bacterium) a ;
      track_line(b.pos, b.pos_target, b.colour_info(b.get_stroke_style())) ;
      b.pos_target.set(MAX_INT) ;
    }
  }
}

public void track_line(vec3 pos, vec3 pos_target, vec4 colour) {
  if(!pos_target.equals(vec3(MAX_INT))) {
    stroke(colour) ;
    strokeWeight(1) ;
    line(pos, pos_target) ;
  }
}
/**
END
INFO – LOG – PRINT
*/



























/**

GROWTH
LIFE
DIE

*/
public void update_growth(ArrayList<Agent> list) {
  for (Agent a : list) {
    a.growth() ;
  }
}


public void update_die(ArrayList<Dead> list_dead, ArrayList<Agent> list) {
  // dead, possible to add to the dead list
  for(Agent a : list) {
    if(!a.get_alive()) {
      if(a instanceof Agent_dynamic) {
        Agent_dynamic a_d = (Agent_dynamic) a ;
        if(PRINT_DEATH_AGENT_DYNAMIC) {
          print_death_agent(a_d) ;
        }
        Dead dead = new Dead(a_d.pos, a_d.size, a_d.size_ref, a_d.nutrient_quality, a_d.name) ;
        list_dead.add(dead) ;
        list.remove(a) ;
        break ;
      }
    }
  }

  //disapear, retrun to the oblivion no return as possible !
  for(Agent a : list) {
    if(a.get_mass() < 0) {
      if(PRINT_DEATH_AGENT_DYNAMIC) {
        println("GO TO OBLIVION") ;
      }
      list.remove(a) ;
      break ;
    }
  }
}




  /**
Motion
*/
public void update_motion(ArrayList<Agent> list) {
  for(Agent a : list) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic a_d = (Agent_dynamic) a ;
      a_d.rebound(LIMIT, REBOUND) ;
      a_d.motion() ;
    }
  }
}


/**
Statement

*/
public void update_statement(ArrayList<Agent> list) {
  for(Agent a : list) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic a_d = (Agent_dynamic) a ;
      a_d.statement() ;
      a_d.hunger() ;
    }
  }
}


public void update_log(ArrayList<Agent> list, int tempo) {
  for(Agent a : list) {
    if(a instanceof Agent_dynamic) {
      Agent_dynamic a_d = (Agent_dynamic) a ;
      if(!a_d.log_is()) a_d.build_log() ;
      a_d.log(tempo) ;
    }
  }
}









/**
Area_ROPE 0.0.3.1
Romanesco Processing Environment 2016–2016
*/

/**
AREA
*/
final int ALPHA_SORT = 0 ;
final int RED_SORT = 1 ;
final int GREEN_SORT = 2 ;
final int BLUE_SORT = 3 ;
final int HUE_SORT = 4 ;
final int SATURATION_SORT = 5 ;
final int BRIGHTNESS_SORT = 6 ;

class Area {
  ArrayList<Bag> palette ;
  boolean mirror_img = false ;
  
  Area (PImage img, int step, int num_bag, int type_sort) {
    palette = new ArrayList<Bag>() ;
    create_bag(num_bag, type_sort) ;
    analyze(img, step, step, num_bag, type_sort) ;
    int [] pixel_rank = classify_components(img, type_sort, num_bag) ;
    int [] best_pixel = best_components(pixel_rank, num_bag) ;
  }

  // 
  protected int size() {
    return palette.size() ;
  }
  
  private Bag get(int target) {
    return palette.get(target) ;
  }
  
  // 
  private void mirror(boolean mirror_img) {
    this.mirror_img = mirror_img ;
  }
  
  // find the component
  private int[] best_components(int [] list, int num_bag) {
    int [] best_component = new int[num_bag] ;
    int [] best = new int[num_bag] ;
    boolean [] forbiden = new boolean[list.length] ;
    //int best = -1 ;
    for(int i = 0 ; i < best.length ; i++) {
      for(int k = 0 ; k < list.length ; k++) {
        if(!forbiden[k] && list[k] > best[i]) {
          best[i] = k ; 
        }
      }
      // forbiden zone, may be with HUE analyze it's possible to need something more sophisticated, for a wheel analyze.
      int start = best[i] - (num_bag *2) ;
      if(start <= 0) start = 0 ;
      int end = best[i] + (num_bag *2) ;
      if (end >= list.length) end = list.length ;
      for(int m = start ; m < end ; m++) {
        forbiden[m] = true ;
      }
    }
    return best ;
  }


  private int[] classify_components(PImage img, int type_sort, int num_bag) {
    int [] components ;   
    int num = 1 ; 
    img.loadPixels() ;

    // ahpha
    if(type_sort == ALPHA_SORT) {
      num = (int)g.colorModeA  +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ;
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)alpha(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ;

    // red
    } else if(type_sort == RED_SORT) {
      num = (int)g.colorModeX  +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)red(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ; 

    // green
    } else if(type_sort == GREEN_SORT) {
      num = (int)g.colorModeY  +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)green(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ;

    // blue  
    } else if(type_sort == BLUE_SORT) {
      num = (int)g.colorModeZ +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)blue(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ;

    // hue  
    } else if(type_sort == HUE_SORT) {
      num = (int)g.colorModeX  +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)hue(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ;

    // hue  
    } else if(type_sort == SATURATION_SORT) {
      num = (int)g.colorModeY  +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = (int)saturation(img.pixels[i]) ;
        components[value] ++ ;
      }
      return components ;

    // brightness  
    } else if(type_sort == BRIGHTNESS_SORT) {
      num = (int)g.colorModeZ +1 ;
      components = new int[minimum_components(num, num_bag)] ;
      for(int i = 0 ; i < components.length ; i++) {
        components[i] = 0 ; 
      }
      for(int i = 0 ; i < img.pixels.length ; i++) {
        int value = floor(brightness(img.pixels[i])) ;
        components[value] ++ ;
      }
      return components ; 
    } else return null ;
  }
  



  // minimum components
  private int minimum_components(int num, int num_bag) {
    int minimum_component = 11 ;
    if(num < minimum_component) num = minimum_component ;
    else if(num < num_bag) num = num_bag ;
    return num ;
  }
  




  // area img
  private void analyze(PImage img, int step_x, int step_y, int num_bag, int type_sort) {
    float [] colour_pointer = new float[num_bag] ;
    float range = range_size(num_bag, type_sort) ;

    for(int x = 0 ;  x < img.width ; x = x + step_x) {
      for(int y = 0 ; y < img.height ; y = y + step_y) {
        manage_bag(img, x, y, type_sort, range) ;
      }
    }
  }
  


  // manage bag
  private void manage_bag(PImage img, int x, int y, int type_sort, float range) {
    int which_pix = 0 ;
    // pixel position
    if(!mirror_img) {
      which_pix =  y*img.width +x; 
    } else {
      // Reversing x to mirror the image
     which_pix = (img.width -x -1) + y*img.width; 
    }
    
    int c = img.get(x,y) ;

    if(match_bag(c, range, type_sort)) {
      add_colour_in_bag(x, y, c, range, type_sort) ;
    } 
  }


  // create bag
  private void create_bag(int num, int type_sort) {
    float range =  range_size(num, type_sort) ;
    float colour_ID = range *.5f ;
    for(int i = 0 ; i < num ; i++) {
      Bag bag = new Bag(colour_ID) ;
      colour_ID += range ;
      palette.add(bag) ;
    }
  }



  //add color in a specific bag
  private void add_colour_in_bag(int x, int y, int c, float range, int type_sort) {
    if(palette.size() > 0) {
      for(Bag bag : palette) {
        float min = bag.colour_ID - (range *.5f) ;
        float max = bag.colour_ID + (range *.5f) ;

        if(type_sort == ALPHA_SORT) {
          if(alpha_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == RED_SORT) {
          if(red_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == GREEN_SORT) {
          if(green_range(min, max, c)) { 
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == BLUE_SORT) { 
          if(blue_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == HUE_SORT) {
          if(hue_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == SATURATION_SORT) {
          if(saturation_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } else if(type_sort == BRIGHTNESS_SORT) {
          if(brightness_range(min, max, c)) {
            bag.add(x,y,c) ;
          } 
        } 
      }
    } 
  }
  
  // check bag if the new pixel match with any bag existing
  private boolean match_bag(int colour, float range, int type_sort) {
    boolean result = false ;
    if(palette.size() > 0) {
      for(Bag bag : palette) {
        
        float min = bag.colour_ID - (range *.5f) ;
        float max = bag.colour_ID + (range *.5f) ;

        if(type_sort == ALPHA_SORT) {
          result = alpha_range(min, max, colour) ;
        } else if(type_sort == RED_SORT) {
          result = red_range(min, max, colour) ;
        } else if(type_sort == GREEN_SORT) {
          result = green_range(min, max, colour) ;
        } else if(type_sort == BLUE_SORT) { 
          result = blue_range(min, max, colour) ;
        } else if(type_sort == HUE_SORT) {
          result = hue_range(min, max, colour) ;
        } else if(type_sort == SATURATION_SORT) {
          result = saturation_range(min, max, colour) ;
        } else if(type_sort == BRIGHTNESS_SORT) {
          result = brightness_range(min, max, colour) ;
        } else result = brightness_range(min, max, colour) ;
        if(result) break ;
      }
    } else {
      result = false ;
    }
    return result ;
  }

  private float select_component(int c, int type_sort) {
    if(type_sort == ALPHA_SORT) return alpha(c) ;
    else if(type_sort == RED_SORT) return red(c) ;
    else if(type_sort == GREEN_SORT) return green(c) ;
    else if(type_sort == BLUE_SORT) return blue(c) ;
    else if(type_sort == HUE_SORT) return hue(c) ;
    else if(type_sort == SATURATION_SORT) return saturation(c) ;
    else if(type_sort == BRIGHTNESS_SORT) return brightness(c) ;
    else return brightness(c) ;
  }

  private float range_size(int num, int type_sort) {
    if(type_sort == ALPHA_SORT) return g.colorModeA / num ;
    else if(type_sort == RED_SORT) return g.colorModeX / num  ;
    else if(type_sort == GREEN_SORT) return g.colorModeY / num ;
    else if(type_sort == BLUE_SORT) return g.colorModeY / num ;
    else if(type_sort == HUE_SORT) return g.colorModeZ / num ;
    else if(type_sort == SATURATION_SORT) return g.colorModeY / num ;
    else if(type_sort == BRIGHTNESS_SORT) return g.colorModeZ / num ;
    else return g.colorModeZ / num ;
  }


  // internal class
  private class Bag {
    ArrayList<vec3> bag ;
    float colour_ID ;

    private Bag(float colour_ID) {
      this.colour_ID = colour_ID ;
      bag = new ArrayList<vec3>()  ;
    }


    private void add(int x, int y, int c) {
      bag.add(vec3(x,y,c)) ;
    }
    
    public int size() {
      return bag.size() ;
    }
    
    
    public vec3 get(int target) {
      vec3 v = bag.get(target) ;
      return v ;
    }
    
    public vec2 get_pos(int target) {
      vec3 v = bag.get(target) ;
      return vec2(v.x,v.y) ;
    }
    
    public int get_colour(int target) {
      vec3 v = bag.get(target) ;
      return (int)v.z ;
    }
  }
}




/**
* Vehicle
* refactoring by Stan le Punk
* @see @stanlepunk
* @see https://github.com/StanLepunK/Force_Field
* 2017-2019
* v 1.4.1
*
* Run on Processing 3.5.3
* Rope library 0.4.0
*
* work based on the code traduction of Daniel Shiffman from Reynolds Study algorithm
* @see http://natureofcode.com
* @see http://natureofcode.com/book/chapter-6-autonomous-agents/
* About Craig Reynolds 
* @see http://www.red3d.com/cwr/
*/

public class Vehicle implements rope.core.R_Constants {
  // The usual stuff
  private vec2 starting_direction;
  private vec2 position;
  private vec2 velocity;
  private vec2 acceleration;
  private float radius = 1.f;
  private float max_force;    // Maximum steering force
  private float ref_max_force;    // Maximum steering force

  private float max_speed;    // Maximum speed
  private float ref_max_speed;  // Maximum speed

  private boolean manage_border_is = false;

  private Force_field ff ;

  public Vehicle(vec2 position, float max_speed, float max_force) {
    this.position = position.copy();
    this.ref_max_speed = this.max_speed = max_speed;
    this.ref_max_force = this.max_force = max_force;
    acceleration = vec2();
    velocity = vec2();
  }
  /**
  set
  */
  public void set_radius(float radius) {
    this.radius = radius;
  }

  public void set_position(vec2 position) {
    if(this.position == null) {
      this.position = vec2(position);
    } else {
      this.position.set(position);
    }
  }

  public void set_speed(float speed) {
    this.ref_max_speed = this.max_speed = speed;
  }

  public void mult_speed(float mult) {
    this.max_speed *=mult;
  }

  public void add_speed(float add) {
    this.max_speed +=add;
  }
  
  /**
  get
  */
  public vec2 get_position() {
    vec2 temp_pos = position.copy() ;
    return temp_pos.add(vec2(ff.canvas_pos));
  }

  public vec2 get_absolute_position() {
    return position ;
  }
  
  public float get_direction() {
    return velocity.angle() ;
  }
  


  /**
  update
  */
  // Method to update position
  public void update(Force_field ff) {
    this.ff = ff ;
    // Update velocity
    velocity.add(acceleration);
    // Limit speed
    velocity.limit(max_speed);
    position.add(velocity);
    // Reset accelertion to 0 each cycle
    acceleration.mult(0);
  }

  /**
  manage border
  */
  public void manage_border(boolean manage_border_is) {
    this.manage_border_is = manage_border_is;
  }


  /**
  SWAP
  v 0.2.1
  */
  public void swap() {
    float res = ff.resolution ;
    float offset_cell_vehicle = radius *2 + (res *.5f) ;

    if(ff.type != GRAVITY) {
      swap_border(offset_cell_vehicle,manage_border_is);
    }

    if(ff.type == GRAVITY || ff.type == MAGNETIC) {
      swap_spot(offset_cell_vehicle);
    }   
  }

  /*
  * swap border v 0.0.4
  * before borders
  */
  private void swap_border(float offset_cell_vehicle, boolean from_border_is) {
    go_side(offset_cell_vehicle, from_border_is);
  }

  /*
  * swap_spot v 0.2.0
  */
  private void swap_spot(float offset_cell_vehicle) {
    for(int index = 0 ; index < ff.get_spot_num() ; index++) {
      vec2 pos_vehicle = get_position().copy();
      vec2 pos_spot = vec2(ff.get_spot_pos(index).x,ff.get_spot_pos(index).y);
      vec2 diam = ff.get_spot_size(index);
      int tesla = ff.get_spot_tesla(index);
      
      // GRAVITY case
      if(ff.type == GRAVITY) {
        // GET IN TO THE HOLE
        if(!ff.reverse_is) {
          // go in the hole
          if(inside(pos_spot, diam, pos_vehicle, ELLIPSE)) {
            go_side(offset_cell_vehicle,false);
          }
        // GET OUT OF THE HOLE
        } else {          
          // go out of the hole
          if(!out_of_canvas(offset_cell_vehicle, pos_vehicle)) {
            go_spot();
          }
        }
      }

      // MAGNETIC case
      if(ff.type == MAGNETIC) {
       if(inside(pos_spot, diam, pos_vehicle, ELLIPSE) && tesla > 0) {
          go_spot();
        } 
      }    
    } 
  }


  public boolean out_of_canvas(float offset_cell_vehicle, vec2 pos_vehicle) {
    return inside(vec2(-offset_cell_vehicle), vec2(ff.get_canvas()), pos_vehicle, RECT);
  }
  /**
  go
  v 0.2.1
  */
  /*
  * manage vehicle when this one must swap to an other place
  */
  private void go_spot() {
    ArrayList<Spot> list = ff.get_list();
    // select an emitter to spurt out vehicles                                                                
    int spot_emitter = floor(random(list.size()));
    Spot spot = list.get(spot_emitter);
    if(spot.get_size() != null && spot.get_pos() != null) {
      position.set(vec2(0));
      position.add(vec2(spot.get_pos()));
    } else {
      /*
      * recursive in case the spot not initialized, may be it's little dangerous if no spot has be init !
      */
      go_spot();
    }
  }
  

  private void go_side(float offset_cell_vehicle, boolean from_border_is) {
    float offset = offset_cell_vehicle ;
    // go to opposite
    if(from_border_is) {      
      if (position.x < -offset) {
        position.x = ff.get_canvas().x -offset;
      }
      if (position.x > ff.get_canvas().x -offset) {
        position.x = -offset;
      }
      // y pos
      if (position.y < -offset) {
        position.y = ff.get_canvas().y -offset ;
      }
      if (position.y > ff.get_canvas().y -offset) {
        position.y = -offset;
      }
    // go to a random position
    }
    
    boolean swap_is = false ;
    if(from_border_is == false) {
      if (position.x < -offset) swap_is = true;
      else if (position.x > ff.get_canvas().x -offset) swap_is = true;
      else if (position.y < -offset) swap_is = true ;
      else if (position.y > ff.get_canvas().y -offset) swap_is = true;
    }

    if(swap_is || ff.type == GRAVITY ) {
      int which_canvas_side = floor(random(4));
      if(which_canvas_side == 0) {
        position.x = random(ff.canvas.x) -offset;
        position.y = -offset; 
      } else if(which_canvas_side == 1) {
        position.x = random(ff.canvas.x) -offset;
        position.y = ff.canvas.y -offset;
      } else if(which_canvas_side == 2) {
        position.x = -offset;
        position.y = random(ff.canvas.y) -offset;
      } else if(which_canvas_side == 3) {
        position.x = ff.canvas.x -offset;
        position.y = random(ff.canvas.y) -offset;
      }
    }    
  }



  
  /**
  follow
  v 0.1.0
  */
  // Implementing Reynolds' flow field following algorithm
  public void follow() {
    vec2 temp_pos = get_absolute_position().copy();
    vec2 desired  = ff.dir_in_grid(temp_pos);
    vec2 steer = vec2();
    vec2 velocity_total = velocity.copy();

    if(desired != null) {
      starting_direction = null;
      desired.mult(max_speed);
      // Steering is desired minus velocity
      steer = sub(desired, velocity_total);
    // case where the direction returned is null for the emitter spot case  
    } else {
      if(starting_direction == null) {
        float theta = random(-PI,PI);
        starting_direction = vec2(cos(theta),sin(theta));
      }
      steer = sub(starting_direction, velocity_total);
    }

    steer.limit(max_force);  // Limit to maximum steering force
    apply_force(steer);
    reset_param();
  }


  private void reset_param() {
    this.max_speed = this.ref_max_speed;
    this.max_force = this.ref_max_force;
  }

  private void apply_force(vec2 steer) {
    // We could add mass here if we want A = F / M
    acceleration.add(steer);
  }
}
/**
Force Field
2017-2019
* @see @stanlepunk
* @see https://github.com/StanLepunK/Force_Field
* v 1.12.1
* Processing 3.5.3
* Rope library 0.4.0
*/

/**
Force Field
work based on the code traduction of Daniel Shiffman from Reynolds Study algorithm
and Jos Stam work for the Navier-Stokes adaptation
about Daniel Shiffmann
http://natureofcode.com
http://natureofcode.com/book/chapter-6-autonomous-agents/
About Craig Reynolds 
http://www.red3d.com/cwr/
About Jos Stam work
http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf 
*/

/**
CONSTANTE used by the class Force_field
int FLUID, CHAOS, PERLIN, GRAVITY, MAGNETIC, IMAGE
*/

/**
At this moment the force field is available only in 2D mode
*/

public class Force_field implements rope.core.R_Constants {
  // FIELD
  private vec4[][] field;
  private vec4[][] field_save;
  private int type = STATIC; // or STATIC, FLUID, MAGNETIC, CHAOS
  private int super_type = STATIC; // or STATIC, DYNAMIC
  private int pattern = PERLIN; // CHAOS, PERLIN, BLANK, IMAGE
  private float sum_activities;

  // CANVAS
  private ivec2 canvas, canvas_pos;
  private int cols, rows; // Columns and Rows
  private int resolution; // How large is each "cell" of the flow field
  
  // TEXTURE
  private PImage src;
  private PImage texture_velocity;
  private PImage texture_direction;
  
  // SPOT
  private int spot_area_level = 1 ;
  private ArrayList<vec> spot_fluid_pos_ref;
  private ArrayList<Boolean> reset_ref_spot_pos_list_is;
  private ArrayList<Spot> spot_list;
  private ArrayList<Spot> spot_mag_north_list;
  private ArrayList<Spot> spot_mag_south_list;
  private ArrayList<Spot> spot_mag_neutral_list;
  
  // EQUATION
  vec2 center_equation_dir, center_equation_len;

  // GRAVITY
  private float mass_field = 1.f;
  
  // FLUID
  private Navier_Stokes_2D ns_2D;
  private Navier_Stokes_3D ns_3D;
  private int NX, NY, NZ;
  private float frequence = .01f;
  private float viscosity = .0001f;
  private float diffusion = .01f;
  private float limit_vel = 100.f;

  // IMAGE
  private ivec4 sort;
  
  // MISC
  private boolean border_is = false;
  private boolean reverse_is;
  private boolean is;



  




  /**
  CONSTRUCTOR
  v 0.1.1
  */
  // MINIMUM
  public Force_field(int resolution, int type, int pattern) {
    set_resolution(resolution);
    this.type = type ;
    init_super_type(this.type);  
    this.pattern = pattern;
    this.is = true ;
    ivec2 canvas_pos = ivec2();
    ivec2 canvas = ivec2(width,height);
    set_canvas(ivec2(this.resolution/2 +canvas_pos.x, this.resolution/2 +canvas_pos.y), ivec2(canvas.x,canvas.y));

    cols = NX = canvas.x/this.resolution;
    rows = NY = canvas.y/this.resolution +1;

    init_field();
    init_spot();
    init_texture(cols,rows);
    border_is = true ;

    if(type == FLUID) {
      printErr("FLUID have square or cube canvas, the HEIGHT be used for the canvas side");
      int iteration = 20 ;
      border_is = false;
      ns_2D = new Navier_Stokes_2D(ivec2(NX,NY), iteration);
    } 
    set_field();
  }

  // CLASSIC
  public Force_field(int resolution, ivec2 canvas_pos, ivec2 canvas, int type, int pattern) {
    set_resolution(resolution);
    this.type = type ;
    init_super_type(this.type);  
    this.pattern = pattern;
    this.is = true ;

    set_canvas(ivec2(this.resolution/2 +canvas_pos.x, this.resolution/2 +canvas_pos.y), ivec2(canvas.x,canvas.y));

    cols = NX = canvas.x/this.resolution;
    rows = NY = canvas.y/this.resolution +1;

    init_field();
    init_spot();
    init_texture(cols,rows);
    border_is = true ;

    if(type == FLUID) {
      printErr("FLUID have square or cube canvas, the HEIGHT be used for the canvas side");
      int iteration = 20 ;
      border_is = false;
      ns_2D = new Navier_Stokes_2D(ivec2(NX,NY), iteration);
    } 
    set_field();
  }

  //PImage
  public Force_field(int resolution, ivec2 canvas_pos, PImage src, int... component_sorting) {
    set_resolution(resolution);
    this.type = STATIC;
    init_super_type(this.type);
    this.pattern = IMAGE;
    this.is = true;
    sorting_channel(component_sorting);
    
    if(this.src == null) {
      this.src = createImage(src.width,src.height,ARGB);
      src.loadPixels();
      this.src.pixels = src.pixels;
      this.src.updatePixels(); 
    } else {
      this.src.resize(src.width,src.height);
      src.loadPixels();
      this.src.pixels = src.pixels;
      this.src.updatePixels(); 
    }
    // Determine the number of columns and rows based on sketch's width and height
    set_canvas(ivec2(resolution/2 +canvas_pos.x, resolution/2 +canvas_pos.y), ivec2(this.src.width,this.src.height));
    cols = canvas.x/resolution;
    rows = canvas.y/resolution;
    init_field();

    init_texture(cols,rows);

    border_is = true ;
    set_field();
  }



  /**
  initialisation
  v 0.2.0
  */
  private void init_super_type(int type) {
    if(type != STATIC) {
      this.super_type = DYNAMIC;
    } else {
      this.super_type = STATIC;
    }
  }

  private void init_texture(int w, int h) {
    texture_velocity = createImage(w,h,RGB);
    texture_direction = createImage(w,h,RGB);
  }

  private void init_field() {
    sum_activities = 0;
    field = new vec4[cols][rows];
    field_save = new vec4[cols][rows];
  }

  private void init_spot() {
    spot_list = new ArrayList<Spot>();
    reset_ref_spot_pos_list_is = new ArrayList<Boolean>();

    if(this.type == MAGNETIC) {
      spot_mag_north_list = new ArrayList<Spot>();
      spot_mag_south_list = new ArrayList<Spot>();
      spot_mag_neutral_list = new ArrayList<Spot>();
    }
  }

  public void add_spot(int num) {
    if(spot_list != null) {
      for(int i = 0 ; i < num ; i++) {
        add_spot();
      }
    } else {
      printErr("method add_spot() class Force_field: ArrayList<> spot_list is null");
    }  
  }

  public void add_spot() {
    Spot spot = new Spot();
    // set default area detection for gravity and magnetic mode
    int radius_spot_detection = ceil( sqrt(cols*rows) / abs(spot_area_level) ) +1;
    spot.detection(radius_spot_detection);
    spot_list.add(spot);
    boolean bool = false ;
    reset_ref_spot_pos_list_is.add(bool);
  }



  /**
  set resolution
  v 0.0.1
  */
  private void set_resolution(int resolution) {
    if(resolution <= 0) {
      printErr("Contructor Force_field: resolution =", resolution, "instead the value 20 is used");
      this.resolution = 20 ;
    } else {
      this.resolution = resolution;
    }
  }
  /**
  set field
  v 0.1.1
  */
  private void set_field() {
    set_field(this.pattern) ;
  }

  private void set_field(int pattern) {
    // Reseed noise so we get a new flow field every time
    sum_activities = 0 ;
    if(pattern == IMAGE && src != null) {
      set_field_img_2D();
    } else {
      if(pattern == PERLIN) {
        noiseSeed((int)random(10000));
        set_field_perlin();
      } else if(pattern == CHAOS) {
        set_field_chaos();
      } else if(pattern == EQUATION) {
        set_field_equation();
      } else if(pattern == BLANK) {
        set_field_blank();
      } else {
        set_field_blank();
      }
    }    
  }






  private void eq_swap(vec2 dir) {
    float x = dir.x;
    float y = dir.y;
    if(eq.x == 2) dir.x = y;
    if(eq.y == 1) dir.y = x;
  }

  private float eq_len_vector(float x, float y, float dx, float dy, float div) {
    float fx = 0;
    float fy = 0;
    fx = x -dx;
    fy = y -fy;
    return sqrt((fx*fx)+(fy*fy))/div;
  }

  // specific op_ration
  private vec2 eq_pow(ivec4 pow, vec2 v) {
    vec2 r = vec2(v);
    if(pow.x > 1) {
      if(pow.x%2 == 0) {
        r.x = pow(v.x,pow.x);
      } else {
        r.x = -1 * pow(v.x,pow.x) ;
      }  
    }
    if(pow.y > 1) {
      if(pow.y%2 == 0) {
        r.y = pow(v.y,pow.y);
      } else {
        r.y = -1 * pow(v.y,pow.y) ;
      }
    }
    return r;
  }

  private vec2 eq_mult(vec4 mult, vec2 v) {
    vec2 r = vec2(v);
    if(mult.x != 1) {
      r.x = v.x *mult.x;
    }
    if(mult.y != 1) {
      r.y = v.y *mult.y;
    }
    return r;
  }

  private vec2 eq_root(ivec4 root, vec2 v) {
    vec2 r = vec2(v);
    if(root.x == 2) {
      r.x = sqrt(r.x);
    } else if(root.x == 3) {
      r.x = sqrt(sqrt(r.x));
    } else if(root.x == 4) {
      r.x = sqrt(sqrt(sqrt(r.x)));
    }

    if(root.y == 2) {
      r.y = sqrt(r.y);
    } else if(root.y == 3) {
      r.y = sqrt(sqrt(r.y));
    } else if(root.y == 4) {
      r.y = sqrt(sqrt(sqrt(r.y)));
    }  
    return r;
  }

  // compute op-eration
  private void eq_op(vec2 dir) {
    for(int rank = 0 ; rank < eq.get_op() ; rank++) {
      if(eq.pow != null) {
        for(ivec4 pv : eq.pow) {
          if(pv.w == rank) {
            dir.set(eq_pow(pv,dir));
            break;
          }
        }
      }
      if(eq.mult != null) {
        for(vec4 mv : eq.mult) {
          if(mv.w == rank) {
            dir.set(eq_mult(mv,dir));
            break;
          }
        }
      }
      if(eq.root != null) {
        for(ivec4 rv : eq.root) {
          if(rv.w == rank) {
            dir.set(eq_root(rv,dir));
            break;
          }
        }
      }
    }
  }



  private void set_field_equation() { 
    if(eq != null ) {
      if(eq.get_center_dir_2D() != null) center_equation_dir = eq.get_center_dir_2D().copy();
      if(eq.get_center_len_2D() != null) center_equation_len = eq.get_center_len_2D().copy();
    }   

    if(center_equation_dir == null) center_equation_dir = vec2(0);
    if(center_equation_len == null) center_equation_len = vec2(0);
    set_field_equation(center_equation_dir, center_equation_len);
  }

  private void set_field_equation(vec2 c_dir,vec2 c_len) {
    int dir_offset_x = PApplet.parseInt(cols *(c_dir.x - .5f));
    int dir_offset_y = PApplet.parseInt(rows *(c_dir.y - .5f));

    float len_offset_x = cols *c_len.x;
    float len_offset_y = rows *c_len.y;

    for (int x = dir_offset_x ; x < cols +dir_offset_x ; x++) {
      for (int y = dir_offset_y ; y < rows +dir_offset_y ; y++) {
        vec2 d = vec2(x,y);
        // dir
        if(eq != null) {
          eq_swap(d);
          eq_op(d);
          // d.set(y,x);
        }

        float tx = map(d.x, 0, cols, -HALF_PI,HALF_PI);
        float ty = map(d.y, 0, rows, 0,PI);
             
        // len
        vec2 l = vec2(x,y);
        if(eq != null ) {
          // l.set(eq_root(eq.root,l));
        }
        float div = cols+rows;
        float len = eq_len_vector(l.x,l.y,len_offset_x,len_offset_y,div);
        // if(len > 1) println(len,frameCount,"before");
        if(eq != null ) {
          if(eq.reverse_len) len = 1.3f -len;
          if(len < 0) len = 0;
        }
        // if(len > 1) println(len,frameCount,"after");

        // Polar to cartesian coordinate
        float xx = cos(tx) ;
        float yy = sin(ty) ;
        float zz = 0 ;
        float ww = len ;

        int cx = x -dir_offset_x;
        int cy = y -dir_offset_y;
        field[cx][cy] = vec4(xx,yy,zz,ww); 
        field_save[cx][cy] = vec4(xx,yy,zz,ww);
        sum_activities += field[cx][cy].sum() ;     
      }
    }
  }


  private void set_field_blank() {
    for (int x = 0 ; x < cols ; x++) {
      for (int y = 0 ; y < rows ; y++) {
        field[x][y] = vec4(0); 
        field_save[x][y] = vec4(0);   
      }
    }
    sum_activities += 0 ;
  }
  
  private void set_field_chaos() {
    for (int x = 0 ; x < cols ; x++) {
      for (int y = 0 ; y < rows ; y++) {
        float theta = random(TWO_PI);
        float dist = random(1);
        // Polar to cartesian coordinate
        float xx = cos(theta) ;
        float yy = sin(theta) ;
        float zz = 0 ;
        float ww = dist ;
        field[x][y] = vec4(xx,yy,zz,ww); 
        field_save[x][y] = vec4(xx,yy,zz,ww);
        sum_activities += field[x][y].sum() ;     
      }
    }
  }

  private void set_field_perlin() {
    float xoff = 0 ;
    for (int x = 0 ; x < cols ; x++) {
      float yoff = 0;
      for (int y = 0 ; y < rows ; y++) {
        float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
        float dist = noise(xoff,yoff);
        // Polar to cartesian coordinate
        float xx = cos(theta) ;
        float yy = sin(theta) ;
        float zz = 0 ;
        float ww = dist ;
        field[x][y] = vec4(xx,yy,zz,ww); 
        field_save[x][y] = vec4(xx,yy,zz,ww);
        sum_activities += field[x][y].sum() ;     
        yoff += .1f;
      }
      xoff += .1f;
    }
  }

  private void set_field_img_2D() {
    src.loadPixels();
    for(int x = 0 ; x < cols ; x++) {
      for(int y = 0 ; y < rows ; y++) {
        int pix = src.get(x *resolution, y *resolution);

        float theta_x = map_pix(sort.x,pix,0,TAU);
        float theta_y = map_pix(sort.y,pix,0,TAU);
        float vel = map_pix(sort.w,pix,0,1);

        // Polar to cartesian coordinate
        float xx = cos(theta_x) ;
        float yy = sin(theta_y) ;
        float zz = 0 ;
        float ww = vel ;
        field[x][y] = vec4(xx,yy,zz,ww); 
        field_save[x][y] = vec4(xx,yy,zz,ww);     

        sum_activities += field[x][y].sum() ;
      }
    }
  }






  private float map_pix(int component_color, int pix, float min, float max) {
    float f = 0;
    if(component_color == RED) {
      f = red(pix);
      return map(f,0, g.colorModeX,min,max);
    } else if(component_color == GREEN) {
      f = green(pix);
      return map(f,0, g.colorModeY,min,max);
    } else if(component_color == BLUE) {
      f = blue(pix);
      return map(f,0, g.colorModeZ,min,max);
    } else if(component_color == HUE) {
      f = hue(pix);
      return map(f,0, g.colorModeX,min,max);
    } else if(component_color == SATURATION) {
      f = saturation(pix);
      return map(f,0, g.colorModeY,min,max);
    } else if(component_color == BRIGHTNESS) {
      f = brightness(pix);
      return map(f,0, g.colorModeZ,min,max);
    } else {
      f = alpha(pix);
      return map(f,0, g.colorModeA,min,max);
    }
  }




  /**
  work directly on the field
  This method is close to reset, but this one load a previous saved field.
  */
  public void refresh() {
    save();
  }

  public void save() {
    if(field != null && field_save != null) {
      for (int x = 0 ; x < cols ; x++) {
        for (int y = 0 ; y < rows ; y++) {
          field[x][y].set(field_save[x][y]);
        }
      }
    }
  }


  /**
  velocity
  */
  /*
  * map velocity
  */
  public void map_velocity(float start1, float stop1, float start2, float stop2) {
    if(field != null && field_save != null) {
      for (int x = 0 ; x < cols ; x++) {
        for (int y = 0 ; y < rows ; y++) {
          map_velocity(x,y,start1,stop1,start2,stop2);
        }
      }
    }
  }

  public void map_velocity(int x, int y, float start1, float stop1, float start2, float stop2) {
    map_velocity(ivec2(x,y), start1, stop1, start2, stop2);
  }
  public void map_velocity(int x, int y, int z, float start1, float stop1, float start2, float stop2) {
    map_velocity(ivec3(x,y,z), start1, stop1, start2, stop2);
  }

  public void map_velocity(ivec coord, float start1, float stop1, float start2, float stop2) {
    if(field != null && field_save != null && coord.x < cols && coord.y < rows) {
      field[coord.x][coord.y].w = map(field[coord.x][coord.y].w,start1,stop1,start2,stop2);
    } else {
      if(coord.x >= cols || coord.y >= rows || coord.x < 0 || coord.y < 0) {
        printErr("method map_velocity() in class Force_field is not possible because your target x or y is not in field dimension");
      } else {
        printErr("method map_velocity() in class Force_field is not possible the field is null");
      }
    }
  }
  /*
  * mult velocity
  */
  public void mult_velocity(float mult) {
    if(field != null && field_save != null) {
      for (int x = 0 ; x < cols ; x++) {
        for (int y = 0 ; y < rows ; y++) {
          mult_velocity(x,y,mult);
        }
      }
    }
  }

  public void mult_velocity(int x, int y, float mult) {
    mult_velocity(ivec2(x,y), mult);
  }
  public void mult_velocity(int x, int y, int z, float mult) {
    mult_velocity(ivec3(x,y,z), mult);
  }

  public void mult_velocity(ivec coord, float mult) {
    if(field != null && field_save != null && coord.x < cols && coord.y < rows) {
      // field[coord.x][coord.y].set(field_original[coord.x][coord.y]);
      field[coord.x][coord.y].w *= mult;
    } else {
      if(coord.x >= cols || coord.y >= rows || coord.x < 0 || coord.y < 0) {
        printErr("method mult_velocity() in class Force_field is not possible because your target x or y is not in field dimension");
      } else {
        printErr("method mult_velocity() in class Force_field is not possible the field is null");
      }
    }
  }





  /**
  public set border
  v 0.0.6
  */
  public void set_border_is(boolean state) {
    border_is = state ;
  }


  /**
  public set spot
  v 0.2.1
  */
  public void set_spot(float pos_x, float pos_y, float size_x, float size_y) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
      set_spot(pos_x,pos_y,size_x,size_y,i);
    }
  }

  public void set_spot(vec pos, vec2 size) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
      set_spot(pos,size,i);
    }
  }

  public void set_spot(float pos_x, float pos_y, float size_x, float size_y, int which_one) {
    set_spot(vec2(pos_x,pos_y), vec2(size_x,size_y),which_one);
  }

  public void set_spot(vec pos, vec2 size, int which_one) {
    set_spot_pos(pos,which_one);
    set_spot_diam(size.x,size.y,which_one);
  }

  /**
  spot detection
  */
  public void set_spot_detection(int spot_area_level) {
    if(spot_area_level <= 0) {
      this.spot_area_level = 1 ;
      printErr("method set_spot_area() class Force_field param level =" + spot_area_level + " level must be upper, instead the value 1 is used");
    } else {
      this.spot_area_level = spot_area_level ;
    }
    int radius_spot_detection = ceil( sqrt(cols*rows) / abs(this.spot_area_level) ) +1;
    for(Spot s : spot_list) {
      s.detection(radius_spot_detection);
    }
  }

  /**
  spot position
  */
  public void set_spot_pos(float x, float y) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
      set_spot_pos(x,y,i);
    } 
  }

  public void set_spot_pos(vec pos) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
      set_spot_pos(pos, i);  
    }
  }

  public void set_spot_pos(float x, float y, int which_one) {
    set_spot_pos(vec3(x,y,0),which_one);  
  }

  // main method set pos
  public void set_spot_pos(vec pos, int which_one) {
    /**
    emergency fix, not enought but stop the bleeding
    */
    if(canvas.x < canvas.y) {
      if(pos.y > canvas.x -resolution) {
        if(pos.x < 0) {
          pos.x = 0 ;
          pos.y = 0 ;
        }
        if(pos.x > canvas.x -resolution) {
          pos.x = canvas.x -resolution;
          pos.y = canvas.x -resolution;
        }
      }
    }

    // vec2 spot_pos = pos.copy();
    vec2 temp_pos = vec2(pos.x,pos.y);
    // vec2 spot_raw_pos = pos.copy();

    temp_pos.sub(vec2(canvas_pos));
    if(which_one < spot_list.size()) {
      Spot spot = spot_list.get(which_one);
   //   spot.set_raw_pos(spot_raw_pos);
      vec3 final_spot = vec3(temp_pos.x,temp_pos.y,pos.z);
      spot.set_pos(final_spot);
    } else {
      System.err.println("void set_spot_pos(): No Spot match with your target, you must add new spot in the list before set it");
    }
  }

  /*
  * spot size
  */
  public void set_spot_diam(float x, float y) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
      set_spot_diam(x,y,i);  
    }
  }

  public void set_spot_diam(vec2 size) {
    for(int i = 0 ; i <spot_list.size() ; i++) {
      set_spot_diam(size.x,size.y,i);
    }
  }

  public void set_spot_diam(float x, float y, int which_one) {
    set_spot_diam(vec2(x,y),which_one);  
  }
  /*
  * main method set size
  */
  public void set_spot_diam(vec2 size, int which_one) {
    vec2 final_size = size.copy();
    if(which_one < spot_list.size()) {
      Spot spot = spot_list.get(which_one);
      spot.set_size(final_size);
    } else {
      System.err.println("void set_spot_diam(): No Spot match with your target, you must add new spot in the list before set it");
    }  
  }

  /*
  * spot mass
  */
  public void set_spot_mass(int mass) {
    for(int i = 0 ; i < spot_list.size() ; i++) {
       set_spot_mass(mass,i);
    }  
  }

  public void set_spot_mass(int mass, int which_one) {
    if(which_one < spot_list.size()) {
      Spot spot = spot_list.get(which_one);
      spot.set_mass(mass);
    } else {
      System.err.println("void set_spot_mass():No Spot match with your target, you must add new spot in the list before set it");
    }  
  }

  /*
  * spot tesla
  */
  public void set_spot_tesla(int tesla) {
    for(int i = 0 ; i <spot_list.size() ; i++) {
      set_spot_tesla(tesla,i);
    }
  }

  public void set_spot_tesla(int tesla, int which_one) {
    if(which_one < spot_list.size()) {
      Spot spot = spot_list.get(which_one);
      spot.set_tesla(tesla);
    } else {
      System.err.println("void set_spot_tesla(): No Spot match with your target, you must add new spot in the list before set it");
    }
  }


  /*
  * get
  */
  public int get_spot_area_level() {
    return spot_area_level ;
  }

  public int get_spot_num() {
    if(spot_list != null) return spot_list.size();
    else return -1;
  }

  public int get_spot_south_num() {
    if(spot_mag_south_list != null) return spot_mag_south_list.size();
    else return -1;
  }

  public int get_spot_north_num() {
    if(spot_mag_north_list != null) return spot_mag_north_list.size();
    else return -1;
  }

  public vec3 [] get_spot_pos() {
    vec3 [] pos = new vec3[spot_list.size()] ;
    for(int i = 0 ; i < spot_list.size() ; i++) {
      Spot s = spot_list.get(i);

      pos[i] = vec3(s.get_pos()).copy();
      pos[i].add(canvas_pos.x,canvas_pos.y,0);
    }
    return pos;  
  }

  public vec3 get_spot_pos(int which_one) {
    if(spot_list != null && spot_list.size() > which_one) {
      Spot spot = spot_list.get(which_one);
      return vec3(spot.get_pos()).add(canvas_pos.x,canvas_pos.y,0);
    } else return null ;
  }


  /**
  * get spot size
  */
  public vec2 [] get_spot_size() {
    vec2 [] size = new vec2[spot_list.size()] ;
    for(int i = 0 ; i < spot_list.size() ; i++) {
      Spot s = spot_list.get(i) ;
      size[i] = vec2(s.get_size()).copy() ;
    }
    return size;
  }

  public vec2 get_spot_size(int which_one) {
    if(spot_list != null && spot_list.size() > which_one) {
      Spot spot = spot_list.get(which_one);
      return vec2(spot.get_size());
    } else return null ;
  }

  public int [] get_spot_tesla() {
    int [] tesla = new int[spot_list.size()] ;
    for(int i = 0 ; i < spot_list.size() ; i++) {
      Spot s = spot_list.get(i) ;
      tesla[i] = s.get_tesla() ;
    }
    return tesla;
  }

  public int get_spot_tesla(int which_one) {
    if(spot_list != null && spot_list.size() > which_one) {
      Spot spot = spot_list.get(which_one);
      return spot.get_tesla();
    } else {
      System.err.println("No Spot match with your target, try another one! charge '0' is used");
      return 0 ;
    }
  }

  public float [] get_spot_mass() {
    float [] mass = new float[spot_list.size()] ;
    for(int i = 0 ; i < spot_list.size() ; i++) {
      Spot s = spot_list.get(i) ;
      mass[i] = s.get_mass() ;
    }
    return mass;
  }

  public float get_spot_mass(int which_one) {
    if(spot_list != null && spot_list.size() > which_one) {
      Spot spot = spot_list.get(which_one);
      return spot.get_mass();
    } else {
      System.err.println("No Spot match with your target, try another one! mass '1' is used");
      return 1 ;
    }
  }
  
  /**
  * return arraylist spot$
  * @return ArrayList
  */
  public ArrayList<Spot> get_list() {
    if(spot_list != null) return spot_list ; else return null;
  }

  public ArrayList<Spot> get_list_south() {
    if(spot_mag_south_list != null) return spot_mag_south_list; else return null;
  }

  public ArrayList<Spot> get_list_north() {
    if(spot_mag_north_list != null) return spot_mag_north_list; else return null;
  }

  public ArrayList<Spot> get_list_neutral() {
     if(spot_mag_neutral_list != null) return spot_mag_neutral_list; else return null;
  }




















  



  /**
  CANVAS
  v 0.0.3
  */
  /**
  *set canvas
  */
  public void set_canvas(ivec2 pos, ivec2 size) {
    set_canvas_pos(pos);
    set_canvas_size(size);
  }

  public void set_canvas_pos(ivec2 canvas_pos) {
    if(this.canvas_pos != null) {
      this.canvas_pos.set(canvas_pos);
    } else {
      this.canvas_pos = ivec2(canvas_pos);
    }
  }

  public void set_canvas_size(ivec2 canvas) {
    if(this.canvas != null) {
      this.canvas.set(canvas);
    } else {
      this.canvas = ivec2(canvas);
    }
  }

  /*
  * get canvas
  */
  public ivec2 get_canvas() {
    return canvas;
  }

  public ivec2 get_canvas_pos() {
    if(canvas_pos == null) return ivec2(); else return canvas_pos;
  }

  public int get_resolution() {
    return resolution;
  }



















  /**
  * set specific arg for specificic field
  */

  /**
  * fluid field
  */
  public void set_frequence(float frequence) {
    this.frequence = frequence ;
  } 
  public void set_viscosity(float viscosity) {
    this.viscosity = viscosity ;
  }
  public void set_diffusion(float diffusion) {
    this.diffusion = diffusion ;
  }


  /**
  set mass field
  */
  public void set_mass_field(float mass_field) {
    this.mass_field = mass_field ;
  }


  /*
  misc
  */
  public void reverse_flow(boolean reverse_is) {
    this.reverse_is = reverse_is ;
  }









































  /**
  reset
  v 0.2.0
  */
  public void clear_spot() {
    if(reset_ref_spot_pos_list_is != null) reset_ref_spot_pos_list_is.clear();
    if(spot_list != null) spot_list.clear();
    if(spot_mag_north_list != null) spot_mag_north_list.clear();
    if(spot_mag_south_list != null) spot_mag_south_list.clear();
    if(spot_mag_neutral_list != null) spot_mag_neutral_list.clear();
  }

  public void ref_spot(int which_one) {
    reset_ref_spot_pos_list_is.set(which_one,true);
  }

  public void ref_spot() {
    reset_ref_spot_pos_list_is.set(0,true);
  }

  /**
  * reset force field and the Navier_strokr stable fuild if this one is active
  */
  public void reset() {
    reset_force_field();
  }

  private void reset_force_field() {
    sum_activities = 0;
    for (int x = 0; x < cols ; x++) {
      for (int y = 0; y < rows ; y++) {
        field[x][y] = vec4(0);
        if(type == FLUID) {
          ns_2D.set_dx(x,y,0);
          ns_2D.set_dy(x,y,0);
        }
      }
    }
  }

  public void reset_spot_area() {
    reset_force_field_spot_area();
  }
  
  private void reset_force_field_spot_area() {
    // reset part where the spot area is active
    if(spot_list != null && spot_list.size() > 0) {
      for(Spot s : spot_list) {
        if(s.get_pos() != null && s.get_detection() != null && s.get_detection().size() > 0) {
          for(ivec2 coord : s.get_detection()) {
            vec2 pos_cell = mult(coord, resolution);
            pos_cell.add(s.get_pos());
            vec2 d = vec2(s.get_pos().x,s.get_pos().y);
            d.div(resolution);
            int x = coord.x +(int)d.x;
            int y = coord.y +(int)d.y;
            if(x >= 0 && y >= 0 && x < field.length && y < field[0].length) {
              field[x][y].set(0);
            }  
          }
        }
      }
    } 
  }

  /**
  refresh
  v 0.0.2
  */
  public void refresh_sorting_channel(int... sorting_channel) {
    sorting_channel(sorting_channel);
    set_field_img_2D();
  }
  









  /**
  activity
  v 0.0.5
  */
  /**
  * activity, return true if the Force field is not equal to 0
  * @return boolean
  * @param float threshold is tolerance to start if there is an activity who can interest the rest of the world !
  */
  public boolean activity_is(float threshold) {
    if(sum_activities < threshold && sum_activities > -threshold) {
      return false ; 
    } else {
      return true ;
    }
  }
  /**
  * activity, return true if the field is sum field is different than previous.
  * @return boolean
  * 
  */
  float ref_activities = 0 ;
  public boolean activity_is() {
    boolean spot_activity_is = false ;
    if(spot_list != null && spot_list.size() > 0) {
      for(Spot s : spot_list) {
        if(s.get_pos() != null) {
          spot_activity_is = s.activity_is();
          if(spot_activity_is) {
            break ;
          }      
        }
      }
    }

    if(ref_activities != sum_activities || ref_activities == 0 || spot_activity_is) {
      ref_activities = sum_activities;
      sum_activities = 0;
      return true;
    } else if(ref_activities == sum_activities) {
      return false;
    } else {
      return false;
    }
  }

  /**
  * get_activity(), return true if the Force field is not equal to 0
  * @return float
  */
  public float get_activity() {
    return sum_activities;
  }













  /**
  update
  v 0.1.0.2
  */
  public void update() { 
    if(type == FLUID) {
      update_spot_fluid();
      ns_2D.update(frequence, viscosity, diffusion) ;
      update_fluid_field(ns_2D);
    } else if(type == GRAVITY) {
      update_grav_mag_field();
    } else if(type == MAGNETIC) {
      count_spot_mag();
      update_grav_mag_field();
    } else if(super_type == STATIC) {
      // println("STATIC field convert to texture", frameCount);
      convert_field_to_texture();
    }
  }
  


  // update stable fluid field
  private void update_fluid_field(Navier_Stokes n) {
    if(n instanceof Navier_Stokes_2D) {
      Navier_Stokes_2D ns = (Navier_Stokes_2D)n ;
      for(int x = 0 ; x < ns.get_NX() ; x++) {
        for(int y = 0 ; y < ns.get_NY() ; y++) {
          float dx = ns.get_dx(x,y);
          float dy = ns.get_dy(x,y);
          // dz and dw serve to nothing in this case
          float dz = 0 ;
          float dw = 0 ;
          field[x][y] = vec4(dx,dy,dz,dw);
          field_to_texture(x,y,dx,dy);
          sum_activities += field[x][y].sum() ;
        }
      }
    }
  }
  

  // update gravity and magnetic field
  private void update_grav_mag_field() {
    compute_with_area_detection();
    // old style, very slow
    //compute_without_area()
  }
  

  private void compute_with_area_detection() {
    for(Spot s : spot_list) {
      if(s.get_pos() != null && s.get_detection() != null && s.get_detection().size() > 0) {
        s.reverse_emitter(reverse_is);
        for(ivec2 coord : s.get_detection()) {
          vec2 pos_cell = mult(coord, resolution);
          pos_cell.add(s.get_pos());
          float theta = theta_2D(pos_cell,vec2(s.get_pos().x,s.get_pos().y));
          vec2 vector = vec2(cos(theta),sin(theta));  
          
          float force = 0;
          /**
          not sure the secuty max_force work, there is a problem
          with the center of spot [0][0] the force is to hight so when the vector is add, it's very too much :(
          and a big red line is create in MAGNETIC type
          */
          float max_force = .999f;
          if(type == GRAVITY) {
            force = spot_gravity_force(s,pos_cell);
          } else if(type == MAGNETIC) {
            force = spot_magnetic_force(s,pos_cell);
          }
          if(force >= max_force) {
            force = max_force ;
          }
          vector.mult(force);
          
          vec2 d = vec2(s.get_pos().x,s.get_pos().y);
          d.div(resolution);

          int x = coord.x +(int)d.x;
          int y = coord.y +(int)d.y;
    
          if(x >= 0 && y >= 0 && x < field.length && y < field[0].length) {
            if(force >= max_force) {
              field[x][y].set(vector.x,vector.y,0,0);
            } else {
              field[x][y].add(vector.x,vector.y,0,0);
            }
          }        
        }       
      }
    }

    // update texture field
    for (int x = 0; x < cols ; x++) {
      for (int y = 0; y < rows ; y++) {
        sum_activities += field[x][y].sum();
        field_to_texture(x,y,field[x][y].x,field[x][y].y);
      }
    }
  }

  @Deprecated
  private void compute_without_area_detection() {
    // very very slow, because there is 3 loop, two for coordonate and one for the spot list
    // so when the spot list is big... the frameRate decrease fast
    for (int x = 0; x < cols ; x++) {
      for (int y = 0; y < rows ; y++) {
        vec2 flow = flow(vec2(x,y), spot_list);
        field[x][y] = vec4(flow.x,flow.y,0,0);
        field_to_texture(x,y,field[x][y].x,field[x][y].y);
        sum_activities += field[x][y].sum() ;
      }
    }
  }

  @Deprecated
  private vec2 flow(vec2 coord, ArrayList<Spot> list) {
    vec2 pos_cell = mult(coord, resolution);
    vec2 field_dir = vec2();
    float force = 0;
    // each case of field, must now the spot influencer to get it the data force
    for(Spot s : list) {
      s.reverse_emitter(reverse_is);
      float theta = theta_2D(pos_cell,vec2(s.get_pos()));
      vec2 temp_field = vec2(cos(theta),sin(theta));   
      if(type == GRAVITY) {
        force = spot_gravity_force(s,pos_cell);
      } else if(type == MAGNETIC) {
        force = spot_magnetic_force(s,pos_cell);
      }
      temp_field.mult(force);
      field_dir.add(temp_field);
    }
    return field_dir ;
  }
  
  /**
  magnetic force
  v 0.0.2
  */
  /**
  * spot_magnetic_force
  * @return float magnetic force
  */
  private float spot_magnetic_force(Spot s, vec2 pos_cell) {
    vec2 spot_pos = vec2(s.get_pos());
    float dist = dist(spot_pos, pos_cell);
    int tesla_charge = s.get_tesla();
    return intensity(dist, tesla_charge);
  }
  
  /*
  * intensity
  * very simple formula, not real one :(
  */
  private float intensity(float dist, int tesla) {
    float l = sqrt((get_canvas().x *get_canvas().x) + (get_canvas().y * get_canvas().y));
    float d = constrain(dist, 1, 2 *l) ;
    float speed = .05f;
    float distance = 1 /d *speed;
    return distance *tesla *l *.02f;
  }

  /**
  gravity force
  v 0.0.1
  */
  /** 
  * spot_gravity_force
  * @return float gravity force
  */
  private float spot_gravity_force(Spot s, vec2 pos_cell) {
    vec2 spot_pos = vec2(s.get_pos());
    float m_2 = s.get_mass() ;
    float m_1 = mass_field ;
    float dist = dist(spot_pos, pos_cell);
    double gravity = 1.f / (g_force(dist, m_1, m_2) *1000000000L);
    return (float)gravity;
  }

  /**
  CONVERT TO TEX VELOCITY & TEXTURE
  local method to convert vector to texture
  */
  private void convert_field_to_texture() {
    for (int x = 0; x < cols ; x++) {
      for (int y = 0; y < rows ; y++) {
        // here we convert the vector field vec4 to vec2 to have a real vector
        /*
        vec2 flow = vec2(field[x][y].x,field[x][y].y).mult(field[x][y].w);
        field_to_texture(x,y,flow.x,flow.y);
        */
        vec2 flow_dir = vec2(field[x][y].x,field[x][y].y);
        field_to_tex_dir(x,y,flow_dir.x,flow_dir.y);
        //vec2 flow_vel = vec2(field[x][y].x,field[x][y].y));
        field_to_tex_vel(x,y,field[x][y].w);
        sum_activities += field[x][y].sum() ;
      }
    }
  }

  private void field_to_tex_dir(int x, int y, float vx, float vy) {
    float dir_rad = atan2(vx,vy) ;
    float direction = map(dir_rad, -PI, PI, 0, g.colorModeX);
    int colour_dir = color(direction);
    texture_direction.set(x,y,colour_dir);
  }

  private void field_to_tex_vel(int x, int y, float vel) {
    vel = map(vel,0,1,0,g.colorModeX);
    int colour_vel = color(vel);
    texture_velocity.set(x,y,colour_vel);
  }
  
  private void field_to_texture(int x, int y, float vx, float vy) {
    // direction
    float dir_rad = atan2(vx,vy) ;
    float direction = map(dir_rad, -PI, PI, 0, g.colorModeX);
    int colour_dir = color(direction);
    texture_direction.set(x,y,colour_dir);

    // velocity
    float velocity = (float)Math.sqrt(vx*vx + vy*vy);
    velocity = map(velocity, 0, 1, 0,g.colorModeX);
    int colour_vel = color(velocity);
    texture_velocity.set(x,y,colour_vel);
  }







  /**
  update spot
  v 0.2.3
  */
  // spot mag
  private void count_spot_mag() {
    int total_sub_list = spot_mag_north_list.size() + spot_mag_south_list.size() + spot_mag_neutral_list.size() ;
    if(total_sub_list < spot_list.size()) {
      for(Spot s : spot_list) {
        if(s.get_tesla() > 0 && total_sub_list < spot_list.size()) {
          spot_mag_north_list.add(s) ;
          total_sub_list++ ;
        }
        if(s.get_tesla() < 0 && total_sub_list < spot_list.size()) {
          spot_mag_south_list.add(s) ;
          total_sub_list++ ;
        }
      }
    }  
  }



 // spot fluid
  private void update_spot_fluid() {
    int which_one = 0 ;
    for(Spot s : spot_list) {
      update_spot_fluid(ns_2D, s.get_pos(), which_one);
      update_spot_fluid_ref(ns_2D, s.get_pos(), which_one);
      which_one++;
    }
  }

  private void update_spot_fluid_ref(Navier_Stokes n, vec pos_ref, int which_one) {
    // init
    if(spot_fluid_pos_ref == null) {
      spot_fluid_pos_ref = new ArrayList<vec>();
    }
    // rebuilt ref list if necessary, in case the spot num change
    if(spot_fluid_pos_ref.size() != spot_list.size()) {
      spot_fluid_pos_ref.clear();
      for(Spot s : spot_list) {
        vec pos = vec2(s.get_pos());
        spot_fluid_pos_ref.add(pos);
      }
    }

    if(n instanceof Navier_Stokes_2D) {
      spot_fluid_pos_ref.set(which_one, vec2(pos_ref));
    } else if(n instanceof Navier_Stokes_3D) {
      spot_fluid_pos_ref.set(which_one, vec3(pos_ref));
    }   
  }

  private vec get_spot_fluid_ref(int which_one) {
    if(spot_fluid_pos_ref != null) {
      return spot_fluid_pos_ref.get(which_one);
    } else return null;
  }

  private void update_spot_fluid(Navier_Stokes n, vec spot_pos, int which_one) {
    if(n instanceof Navier_Stokes_2D) {
      Navier_Stokes_2D ns = (Navier_Stokes_2D)n;
      vec2 c = vec2(canvas);
      vec2 c_pos = vec2(canvas_pos);
      vec2 target = vec2(spot_pos);
      update_spot_fluid_2D(ns, target, c, c_pos, which_one);
    } else if(n instanceof Navier_Stokes_3D) {
      Navier_Stokes_3D ns = (Navier_Stokes_3D)n;
      vec3 target = vec3(spot_pos);
      vec3 c = vec3(canvas);
      vec3 c_pos = vec3(canvas_pos);
      update_spot_fluid_3D(ns, target, c, c_pos, which_one);     
    }
  }
  
  private void update_spot_fluid_2D(Navier_Stokes_2D ns, vec2 target, vec2 canvas, vec2 canvas_pos, int which_one) {
    vec2 pos_ref_2D = vec2();
    if(spot_fluid_pos_ref != null || reset_ref_spot_pos_list_is.get(which_one)) {
      pos_ref_2D = vec2(get_spot_fluid_ref(which_one));
      reset_ref_spot_pos_list_is.set(which_one,false);
    } 
    
    vec2 vel = sub(target, pos_ref_2D);

    vec2 cell = canvas.div(ns.get_NX(),ns.get_NY());
    ivec2 target_cell = ivec2(floor(div(target,cell)));

    vel.x = (abs(vel.x) > limit_vel)? 
    Math.signum(vel.x) *limit_vel : 
    vel.x;
    vel.y = (abs(vel.y) > limit_vel)? 
    Math.signum(vel.y) *limit_vel : 
    vel.y;
    ns.apply_force(target_cell.x, target_cell.y, vel.x, vel.y);
  }
  
  private void update_spot_fluid_3D(Navier_Stokes_3D ns, vec3 target, vec3 canvas, vec3 canvas_pos, int which_one) {
    vec3 pos_ref_3D = vec3();
    /*
    if(pos_ref_3D == null || reset_ref_spot_pos_list_is.get(which_one)) {
      pos_fluid_spot_ref(target);
      reset_ref_spot_pos_list_is.set(which_one,false);
    } 
    */

    vec3 cell = canvas.div(ns.get_N());
    vec3 vel = sub(target, pos_ref_3D);
    ivec3 target_cell = ivec3(floor(div(target,cell)));

    vel.x = (abs(vel.x) > limit_vel)? 
    Math.signum(vel.x) *limit_vel : 
    vel.x;
    vel.y = (abs(vel.y) > limit_vel)? 
    Math.signum(vel.y) *limit_vel : 
    vel.y;
    vel.z = (abs(vel.z) > limit_vel)? 
    Math.signum(vel.z) *limit_vel : 
    vel.z;

    ns.apply_force(target_cell.x, target_cell.y, target_cell.z, vel.x, vel.y, vel.z);

    pos_ref_3D.set(target);
  }





























  /**
  get velocity and direction texture
  get texture can be used externaly
  */
  public PImage get_tex_velocity() {
    return texture_velocity;
  }

  public PImage get_tex_direction() {
    return texture_direction;
  }



  /**
  * get fluid info
  */
  public float get_frequence() {
    return frequence ;
  } 
  public float get_viscosity() {
    return viscosity ;
  }
  public float get_diffusion() {
    return diffusion ;
  }


  /**
  get mass field
  */
  public float get_mass_field() {
    return mass_field ;
  }








  /**
  get grid
  v 0.1.0
  */
  public vec4 [][] get_field() {
    if(field != null) return field ;
    else return null;
  }
  public int get_NX() {
    return NX;
  }

  public int get_NY() {
    return NY;
  }

  public int get_NZ() {
    return NZ;
  }

  public int get_cols() {
    return cols;
  }
  public int get_rows() {
    return rows ;
  }






  /**
  get type and pattern 
  */
  /**
  * return type force field is used
  * @return int
  */
  public int get_type() {
    return type;
  }

  /**
  * return patttern force field is used
  * @return int
  */
  public int get_pattern() {
    return pattern;
  }
  /**
  * return super type force field is used
  * @return int
  */
  public int get_super_type() {
    return super_type;
  }


  /**
  is 
  */
    /**
  * return is the force field are build or not
  * @return boolean
  */
  public boolean is() {
    return is;
  }


  /**
  get border
  */
  /**
  * return true if the border is active, false if it's not
  * @return boolean
  */
  public boolean border_is() {
    return border_is ;
  }




  


  

  /**
  direction from grid
  v 0.1.0
  */

  /**
  dir_in_grid
  v 0.2.1
  */
  /**
  * it's most important method, this one give the direction of the vehicle in according force field.
  * @return vec2
  Here must improve the algorithm, when there is a spot in the cell, because in this case the precision direction need be very exact.
  */
  public vec2 dir_in_grid(vec2 vehicle_pos) {
    vec2 dir = vec2(0) ;
    int max_col = cols-1;
    int max_row = rows-1;

    int x = PApplet.parseInt(constrain(vehicle_pos.x /resolution, 0, max_col));
    int y = PApplet.parseInt(constrain(vehicle_pos.y /resolution, 0, max_row));

    if(field != null) {
      if(Double.isNaN(field[x][y].x) || Double.isNaN(field[x][y].y)) {
        dir = vec2(1).copy() ;
      } else {
        // Need to check the position vehicle, in the case this one is in the last cell, where the spot is. 
        // If the the spot and the vehicle are in the same cell, it's necessary to return a direction very focus on spot.
        dir = dir_check_rank(x,y,vehicle_pos); 
      }
    }
    // reverse 
    // the type MAGNETIC is not include because the way depend of the tesla
    if(type != MAGNETIC && dir != null && reverse_is) {
      dir.mult(-1);
    }
    return dir ;
  }

  public vec2 dir_check_rank(int x, int y,vec2 pos_v) {
    vec2 dir = vec2() ;
    if((type == MAGNETIC || type == GRAVITY)) {
      int rank = match_spot(pos_v);
      if(rank != -1) {
        Spot s = spot_list.get(rank);
        if(s.emitter_is()) {
          dir = null ;
        } else {
          vec2 pos_cell = mult(vec2(x,y),resolution);
          float theta = 0;
          pos_v.sub(resolution *.5f);
          theta = theta_2D(pos_v,vec2(s.get_pos()));

          float force = 1 ;
          if(type == MAGNETIC) { 
            force = spot_magnetic_force(s,pos_cell); 
          }
          if(type == GRAVITY) { 
            force = spot_gravity_force(s,pos_cell); 
          }

          vec2 temp_field = vec2(cos(theta),sin(theta));
          temp_field.mult(force);
          dir.set(0);
          dir.add(temp_field);
        } 
      } else {
        dir = vec2(field[x][y].x,field[x][y].y);
      }     
    } else {
      dir = vec2(field[x][y].x,field[x][y].y);
    }
    return dir;
  }

  private int match_spot(vec2 vehicle_pos) {
    int spot_match = -1;
    if(spot_list != null) {
      for(int i = 0 ; i < spot_list.size() ; i++) {
        // check if the vehicle is in the range of the spot
        Spot s = spot_list.get(i);
        if(s.get_pos() != null && s.get_size() != null) {
          vec2 spot_pos = vec2(s.get_pos().x,s.get_pos().y);
          vec2 spot_size = vec2(s.get_size().x, s.get_size().y);
          if(compare(vehicle_pos,spot_pos, spot_size.mult(2))) {
            spot_match = i ;
            break;
          } 
        }
      }
    }
    return spot_match ;
  }



 

  











  private Spot get_spot(vec2 vehicle_pos) {
    Spot spot = new Spot();
    if(spot_list != null) {
      for(Spot s : spot_list) {
        // check if the vehicle is in the range of the spot
        if(compare(vehicle_pos, (vec2)s.get_pos(), vec2(s.get_size().x, s.get_size().y).mult(2) ) ) {
          spot = s ;
          break;
        } 
      }
      return spot ;
    } else return spot;
  }


  /**
  field warp
  v 0.3.1
  Warp position
  */
  
  public vec2 field_warp(vec2 uv, float scale) {

    int cell_x = (int) Math.floor(uv.x*NX);
    int cell_y = (int) Math.floor(uv.y*NY);

    float cell_u = (uv.x *NX -(cell_x)) *(1.f/NX);
    float cell_v = (uv.y *NY -(cell_y)) *(1.f/NY);

    // security ArrayIndexOutOfBoundsException
    // CX
    int cx = cell_x;
    int cx_sub = cell_x-1;
    int cx_add = cell_x+1;
    if(cx >= get_cols()) cx -= get_cols();
    if(cx_sub < 0) cx_sub = get_cols()+cx_sub;
    if(cx_add >= get_cols()) cx_add -= get_cols();
    
    // CY
    int cy = cell_y;
    int cy_sub = cell_y-1;
    int cy_add = cell_y+1;
    if(cy >= get_rows()) cy -= get_rows();
    if(cy_sub < 0) cy_sub = get_rows()+cy_sub;
    if(cy_add >= get_rows()) cy_add -= get_rows();

    // compute
    vec2 result = vec2();

    result.x = (cell_u > .5f)? 
    lerp(field[cx][cy].x, field[cx_add][cy].x, cell_u-.5f) : 
    lerp(field[cx_sub][cy].x, field[cx][cy].x, .5f-cell_u);

    result.y = (cell_v > .5f)? 
    lerp(field[cx][cy].y, field[cx][cy_add].y, cell_u) : 
    lerp(field[cx][cy].y, field[cx][cy_sub].y, .5f-cell_v);

    result.mult(-scale).add(uv);

    return result;
  }
  

















  /**
  end Navier-stokes method
  */





  /**
  util v 0.0.3.1
  library private methods
  */
  /**
  * compute angle to vectorial direction
  */
  private float theta_2D(vec2 current_coord, vec2 target) {
    vec2 current_cell_pos = current_coord.copy() ;
    current_cell_pos.add(resolution *.5f);
    vec2 dir = look_at(current_cell_pos, target);
    // why multiply by '-1' it's a mistery
    return -1 *dir.angle();
  }




  /**
  * Sorting channel
  * Here the sorting component must use the int Constants ROPE: r.RED, r.GREEN, r.BLUE, r.ALPHA, r.HUE, r.SATURATION, r.BRIGHTNESS
  */
  private void sorting_channel(int... sorting) {
    if(sorting.length == 1) {
      this.sort = ivec4(sorting[0],sorting[0],sorting[0],sorting[0]);
    } else if(sorting.length == 2) {
      this.sort = ivec4(sorting[0],sorting[0],sorting[0],sorting[1]);
    } else if(sorting.length == 3) {
      this.sort = ivec4(sorting[0],sorting[1],-1,sorting[2]);
    } else if(sorting.length == 4){
      this.sort = ivec4(sorting[0],sorting[1],sorting[2],sorting[3]);
    } else if(sorting.length > 4){
      this.sort = ivec4(sorting[0],sorting[1],sorting[2],sorting[3]);
      printErr("void sorting_channel(): Too much channel to sort, the first 4 is used");
    } else {
      this.sort = ivec4(1) ;
      printErr("void sorting_channel(): No channel available to sort, the value 1 is used for all component");
    }
  }
}

/**
END class Force_field
*/















/**
* Force EQUATION
* 2018-2019
* v 0.1.0
* Processing 3.5.3
* Rope library 0.4.0
* Equation work with field array 2D
*/
public class Equation implements rope.core.R_Constants {
  // ArrayList<Integer> rank ;
  vec3 center_eq_dir, center_eq_len;
  ArrayList<ivec4> pow;
  ArrayList<ivec4> root;
  ArrayList<vec4> mult;
  boolean reverse_len;
  int num_op = 0 ;
  int x = 1;
  int y = 2;
  int z = 3;

  Equation() {
  }

  private void rank() {
    num_op++;
  }

  private int get_op() {
    return num_op;
  }

  public void swap_xyz(String st_x, String st_y, String st_z) {
    if(st_x.equals("x")) x = 1 ;
    else if(st_x.equals("y")) x = 2 ;
    else if(st_x.equals("z")) x = 3 ;
    else x = 1 ;

    if(st_y.equals("x")) y = 1 ;
    else if(st_y.equals("y")) y = 2 ;
    else if(st_y.equals("z")) y = 3 ;
    else y = 2 ;

    if(st_z.equals("x")) z = 1 ;
    else if(st_z.equals("y")) z = 2 ;
    else if(st_z.equals("z")) z = 3 ;
    else z = 3 ;
  }

  public void swap_xy(String x, String y) {
    swap_xyz(x,y,"z");
  }

  // operation
  public void mult(float mx, float my, float mz) {
    if(mult == null) mult = new ArrayList<vec4>();
    int rank = get_op() ;
    mult.add(vec4(mx,my,mz,rank));
    rank();
  }

  public void pow(int px, int py, int pz) {
    if(pow == null) pow = new ArrayList<ivec4>();
    int rank = get_op();
    if(px < 1) px = 1;
    if(py < 1) py = 1;
    if(pz < 1) pz = 1;
    pow.add(ivec4(px,py,pz,rank));
    rank();
  }

  public void root(int rx, int ry, int rz) {
    if(root == null) root = new ArrayList<ivec4>();
    int rank = get_op();
    int min = 1;
    int max = 4;
    if(rx < min) rx = min;
    if(rx > max) rx = max;

    if(ry < min) ry = min;
    if(ry > max) ry = max;

    if(rz < min) rz = min;
    if(rz > max) rz = max;
    root.add(ivec4(rx,ry,rz,rank));
    rank();
  }

  // Center dir
  private void eq_center_dir(float x, float y, float z) {
    center_eq_dir = vec3(x,y,z);
  }

  public vec2 get_center_dir_2D() {
    if(center_eq_dir != null) return vec2(center_eq_dir.x,center_eq_dir.y);
    else return null ;
  }

  public vec3 get_center_dir_3D() {
    if(center_eq_dir != null) return vec3(center_eq_dir.x,center_eq_dir.y,center_eq_dir.z);
    else return null;
  }

  // Center len
  private void eq_center_len(float x, float y, float z) {
    center_eq_len = vec3(x,y,z);
  }

  public vec2 get_center_len_2D() {
    if(center_eq_len != null) return vec2(center_eq_len.x,center_eq_len.y);
    else return null;
  }

  public vec3 get_center_len_3D() {
    if(center_eq_len != null) return vec3(center_eq_len.x,center_eq_dir.y,center_eq_len.z);
    else return null;
  }
}


/**
EQ method
v 0.0.1
*/
Equation eq;
public void init_eq() {
  eq = new Equation();
  // if(eq == null) eq = new Equation();
}
/**
misc
*/
// choice a center to compute the vector direction
public void eq_center_dir(float x, float y) {
  eq.eq_center_dir(x, y, 0);
}

public void eq_center_dir(float x, float y, float z) {
  eq.eq_center_dir(x, y, z);
}

// choice a center to compute the length vector
public void eq_center_len(float x, float y) {
  eq.eq_center_len(x, y, 0);
}

public void eq_center_len(float x, float y, float z) {
  eq.eq_center_len(x, y, z);
}

// reverse len
public void eq_reverse_len(boolean state){
  eq.reverse_len = state;
}

public void eq_swap_xyz(String x, String y, String z) {
  eq.swap_xyz(x,y,z);
}

public void eq_swap_xy(String x, String y) {
  eq_swap_xyz(x,y,"z");
}


/**
eq operation
*/
// pow
public void eq_pow(int px, int py) {
  eq_pow(px, py, 1);
}

public void eq_pow(int px, int py, int pz) {
  eq.pow(px,py,pz);
}

//root squareroot, cuberoot and timeroot for 4th dimension
public void eq_root(int rx, int ry){
  eq_root(rx,ry,1);
}
public void eq_root(int rx, int ry, int rz) {
  eq.root(rx,ry,rz);
}

//root squareroot, cuberoot and timeroot for 4th dimension
public void eq_mult(float mx, float my){
  eq_mult(mx,my,1);
}
public void eq_mult(float mx, float my, float mz) {
  eq.mult(mx,my,mz);
}
/**
SPOT
* @see http://stanlepunk.xyz
* @see https://github.com/StanLepunK/Force_Field
v 0.3.0
*/
public class Spot {
  private vec previous_pos;
  private vec pos; 
  // private Vec raw_pos;
  private vec size;
  private boolean reverse_charge_is;
  private boolean emitter_is;

  ArrayList<ivec2> area_detection;

  private int tesla = 0;
  private int mass = 0;
  
  // constructor
  public Spot() {

  }



  // set
  public void set_pos(vec pos) {
    if(pos instanceof vec2) {
      if(this.pos == null) {
        this.previous_pos = vec2();
      } else {
        this.previous_pos = vec2(this.pos.x, this.pos.y);
      }
      this.pos = vec2((vec2)pos);
    } else if(pos instanceof vec3) {
      if(this.pos == null) {
        this.previous_pos = vec3();
      } else {
        this.previous_pos = vec3(this.pos.x, this.pos.y,this.pos.z);
      }
      this.pos = vec3((vec3)pos);
    }
  }

  public void set_size(vec size) {
    if(size instanceof vec2) {
      this.size = vec2((vec2)size);
    } else if(size instanceof vec3) {
      this.size = vec3((vec3)size);
    }
  }

  public void reverse_charge(boolean reverse_is) {
    this.reverse_charge_is = reverse_is ;
  }

  public void set_tesla(int tesla) {
    this.tesla = tesla ;
  }

  public void set_mass(int mass) {
    this.mass = abs(mass) ;
  } 

  // get
  public int get_mass() {
    return mass;
  }

  public int get_tesla() {
    if(!reverse_charge_is) {
      return tesla; 
    } else {
      return -tesla;
    }
  }

  public vec get_pos() {
    return pos;
  }

  public vec get_size() {
    return size;
  }

  // misc
  public boolean emitter_is() {
    if(get_tesla() < 0 || emitter_is) {
      return true; 
    } else {
      return false;
    }
  }

  public void reverse_emitter(boolean state) {
    this.emitter_is = state ;
  }
  

  // area_detection
  private void detection(int radius) {
    if(area_detection == null) {
      area_detection = new ArrayList<ivec2>(); 
      add(radius);
    } else {
      area_detection.clear();
      add(radius);
    }   
  }

  private void add(int radius) {
    for(int x = -radius ; x <= radius ; x++) {
      for(int y = -radius ; y <= radius ; y++) {
        if(inside(vec2(0), vec2(radius), vec2(x,y), ELLIPSE)) {
          ivec2 in = ivec2(x,y);
          area_detection.add(in);
        }  
      }
    }
  }

  public ArrayList<ivec2> get_detection() {
    return area_detection;
  }


  public boolean activity_is() {
    if(pos.x != previous_pos.x || pos.y != previous_pos.y || pos.z != previous_pos.z) {
      return true; 
    } else {
      return false;
    }
  }
}
/**
* NAVIER-STOKES by Stan le Punk
* 2017-2019
* v 0.4.0
* @see http://stanlepunk.xyz
Java implementation of the Navier-Stokes-Solver based on the Jos Tam's work :
* @see http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf
* @see https://github.com/StanLepunK/Navier_Stokes_Jos_Stam_imp
*
* Processing implementation for Processing 3.5.2
*/
abstract class Navier_Stokes {
  int N = -1;
  ivec NXYZ;
  int iter;
  boolean three_Dimension_is;
  float[] u,v;
  float[] u_prev,v_prev;

  float[] s,t,p;
  float[] s_prev,t_prev,p_prev;

  int num_cell;

  float[] dst;
  float[] dst_prev;

  
  // implented with N
  Navier_Stokes(int N, boolean three_Dimension_is) {
    build(N, 20, three_Dimension_is);
  }

  Navier_Stokes(int N, int iter, boolean three_Dimension_is) {
    build(N, iter, three_Dimension_is);
  }

  // implemented with NXYZ
  Navier_Stokes(ivec NXYZ, boolean three_Dimension_is) {
    build(NXYZ, 20, three_Dimension_is);
  }

  Navier_Stokes(ivec NXYZ, int iter, boolean three_Dimension_is) {
    build(NXYZ, iter, three_Dimension_is);
  }





  //build
    private void build(int N, int iter, boolean three_Dimension_is) {
    this.N = N ;
    this.NXYZ = ivec3(N);
    this.iter = iter ;
    this.three_Dimension_is = three_Dimension_is ;

    if(!three_Dimension_is) {
      num_cell = (N +2) *(N +2);
      u = new float[num_cell];
      v = new float[num_cell];
      u_prev = new float[num_cell];
      v_prev = new float[num_cell];
    } else {
      num_cell = (N +2) *(N +2) *(N +2);
      s = new float[num_cell];
      t = new float[num_cell];
      p = new float[num_cell];
      s_prev = new float[num_cell];
      t_prev = new float[num_cell];
      p_prev = new float[num_cell];
    }
    
    dst = new float[num_cell];
    dst_prev = new float[num_cell];
  }


  private void build(ivec NXYZ, int iter, boolean three_Dimension_is) {
    this.NXYZ = ivec3(NXYZ.x,NXYZ.y,NXYZ.z);
    this.iter = iter ;
    this.three_Dimension_is = three_Dimension_is ;

    if(!three_Dimension_is) {
      num_cell = (NXYZ.x +2) *(NXYZ.y +2);
      u = new float[num_cell];
      v = new float[num_cell];
      u_prev = new float[num_cell];
      v_prev = new float[num_cell];
    } else {
      num_cell = (NXYZ.x +2) *(NXYZ.y +2) *(NXYZ.z +2);
      s = new float[num_cell];
      t = new float[num_cell];
      p = new float[num_cell];
      s_prev = new float[num_cell];
      t_prev = new float[num_cell];
      p_prev = new float[num_cell];
    }
    
    dst = new float[num_cell];
    dst_prev = new float[num_cell];
  }
   


  protected void add_source(float[] x, float[] s, float dt) {
    for (int i = 0; i < num_cell; i++) {
      x[i] += dt * s[i];
    }
  }

  public int get_N() {
    if(N == -1) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return N;
  }

  public ivec3 get_NXYZ() {
    if(NXYZ == null) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return ivec3(NXYZ.x,NXYZ.y,NXYZ.z);
  }

  public ivec2 get_NXY() {
    if(NXYZ == null) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return ivec2(NXYZ.x,NXYZ.y);
  }

  public int get_NX() {
    if(NXYZ == null) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return NXYZ.x;
  }

  public int get_NY() {
    if(NXYZ == null) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return NXYZ.y;
  }

  public int get_NZ() {
    if(NXYZ == null) {
      printErr("Navier Stokes is implemented with NX,NY and NZ");
    }
    return NXYZ.z;
  }
}
























/**
Navier_Stokes_2D
2017-2017
v 0.1.0.1
*/

public class Navier_Stokes_2D extends Navier_Stokes {
  /**
  constructor
  */
  public Navier_Stokes_2D(int N) {
    super(N, 20, false);
  }
  public Navier_Stokes_2D(int N, int iter) {
    super(N, iter, false);
  }


  public Navier_Stokes_2D(ivec2 NXY) {
    super(NXY, 20, false);
  }
  public Navier_Stokes_2D(ivec2 NXY, int iter) {
    super(NXY, iter, false);
  }





  /**
  public method
  */
/**
get
*/
  public float get_dx(int x, int y) {
    return u[IX(x+1, y+1)];
  }

  public float get_dy(int x, int y) {
    return v[IX(x+1, y+1)];
  }

/**
set
*/
  public void set_dx(int x, int y, float value) {
    u[IX(x+1, y+1)] = 0;
  }

  public void set_dy(int x, int y, float value) {
    v[IX(x+1, y+1)] = 0;
  }

  /** 
  apply force
  v 0.0.3
  */
  public void apply_force(int cell_x, int cell_y, float vx, float vy) {
    cell_x += 1;
    cell_y += 1;
    int which_one = IX(cell_x, cell_y);

    if(which_one >= 0) {
      if(which_one < u.length) {
        float dx = u[which_one];
        u[which_one] = (vx != 0) ? 
        lerp(vx,dx,.85f) : 
        dx;
      }

      if(which_one < v.length) {
        float dy = v[which_one];
        v[which_one] = (vy != 0) ? 
        lerp(vy,dy,.85f) : 
        dy;
      }
    } 
  }


  /**
  update
  */
  public void update(float dt, float visc, float diff) {
    vel_step(u, v, u_prev, v_prev, visc, dt, iter, NXYZ.x, NXYZ.y);
    dens_step(dst, dst_prev, u, v, diff, dt, iter, NXYZ.x, NXYZ.y);
  }






  /**
  NAVIER STROKE
  real work
  from here to the end we dont use the type iVec
  */
  private void vel_step(float[] u, float[] v, float[] u0, float[] v0, float visc, float dt, int iter, int NX, int NY) {
    // step 0
    add_source(u,u0,dt);
    add_source(v,v0,dt);
    // step 1
    SWAP(u0, u);
    diffuse(1, u, u0, visc, dt, iter, NX, NY);
    SWAP(v0, v);
    diffuse(2, v, v0, visc, dt, iter, NX, NY);

    project(u, v, u0, v0, iter, NX, NY);

    // step 2
    SWAP(u0, u);
    SWAP(v0, v);
    advect(1, u, u0, u0, v0, dt, NX, NY);
    advect(2, v, v0, u0, v0, dt, NX, NY);
    project(u, v, u0, v0, iter, NX, NY);
  }


  private void dens_step(float[] x, float[] x0, float[] u, float[] v, float diff, float dt, int iter, int NX, int NY) {
    add_source(x, x0, dt);
    SWAP(x0, x);
    diffuse(0, x, x0, diff, dt, iter, NX, NY);
    SWAP(x0, x);
    advect(0, x, x0, u, v, dt, NX, NY);
  }


  



  /**

  NAVIER STROKE start from HERE
  main method
  */

  /**
  diffusion
  */
  private void diffuse(int b, float[] x, float[] x0, float diff, float dt, int iter, int NX, int NY) {
    float a = dt *diff *NX*NY;
    float c = 1 +4 *a ;
    lin_solve(b, x, x0, a, c, iter, NX, NY);
  }



  /**
  advect
  */
  private void advect(int b, float[] d, float[] d0, float[] u, float[] v, float dt, int NX, int NY) {
    int i, j;
    int  i0, j0;
    int i1, j1;
    float x, y ;
    float s0, t0;
    float s1, t1;
    // float dt0 = dt *N;
    float dtx = dt *(NX -2);
    float dty = dt *(NY -2);
/*
        float dtx = dt *(N -2);
    float dty = dt *(N -2);
    float dtz = dt *(N -2);
    */

    for (i = 1; i <= NX; i++) {
      for (j = 1; j <= NY; j++) {
        x = i - dtx * u[IX(i,j)];
        y = j - dty * v[IX(i,j)];
        /*
        x = i - dt0 * u[IX(i,j)];
        y = j - dt0 * v[IX(i,j)];
        */
        //
        if (x < 0.5f) x = 0.5f;
        if (x > NX +.5f) x = NX +.5f;
        if (y < .5f) y = .5f;
        if (y > NY +.5f) y = NY +.5f;

        i0 = (int) x;
        i1 = i0 +1;
        j0 = (int) y;
        j1 = j0 +1;

        s1 = x -i0;
        s0 = 1 -s1;
        t1 = y -j0;
        t0 = 1 -t1;
        
        float arg_0 = t0 *d0[IX(i0, j0)] +t1 *d0[IX(i0, j1)];
        float arg_1 = t0 *d0[IX(i1, j0)] +t1 *d0[IX(i1, j1)];

        d[IX(i, j)] = s0 *(arg_0) +s1 *(arg_1);
      }
    }
    set_bnd(b, d, NX, NY);
  }
  /**
  boundary
  v 0.0.2
  */
  private void set_bnd(int b, float[] x, int NX, int NY) {
    for (int i = 1; i <= NX ; i++) {
      if(i <= NY) {
        x[IX(0, i)] = b == 1 ? -x[IX(1, i)] : x[IX(1, i)];
        x[IX(NX + 1, i)] = b == 1 ? -x[IX(NX, i)] : x[IX(NX, i)];
      }


      x[IX(i, 0)] = b == 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
      x[IX(i, NY + 1)] = b == 2 ? -x[IX(i, NY)] : x[IX(i, NY)];
    }

    x[IX(0, 0)] = 0.5f * (x[IX(1, 0)] + x[IX(0, 1)]);
    x[IX(0, NY +1)] = 0.5f * (x[IX(1, NY +1)] + x[IX(0, NY)]);

    x[IX(NX +1, 0)] = 0.5f * (x[IX(NX, 0)] +x[IX(NX +1, 1)]);
    x[IX(NX +1, NY +1)] = 0.5f * (x[IX(NX, NY +1)] + x[IX(NX +1, NY)]);
  }


  

  /**
  project
  v 0.0.2
  */
  private void project(float[] u, float[] v, float[] u0, float[] v0, int iter, int NX, int NY) {
    float hx = 1.f / NX;
    float hy = 1.f / NY;
    
    for (int i = 1; i <= NX; i++) {
      for (int j = 1; j <= NY; j++) {
        float step_1 = u[IX(i+1,j)] -u[IX(i-1,j)] 
                      +v[IX(i,j+1)] -v[IX(i,j-1)];
        v0[IX(i, j)] = -.5f *hx *step_1;
        u0[IX(i, j)] = 0;
      }
    }
    set_bnd(0, v0, NX, NY);
    set_bnd(0, u0, NX, NY);

    lin_solve(0, u0, v0, 1, 4, iter, NX, NY) ;

    for (int i = 1; i <= NX; i++) {
      for (int j = 1; j <= NY; j++) {
        u[IX(i,j)] -= .5f *(u0[IX(i+1,j)] -u0[IX(i-1,j)]) /hx;
        v[IX(i,j)] -= .5f *(u0[IX(i,j+1)] -u0[IX(i,j-1)]) /hy;
      }
    }
    set_bnd(1, u, NX, NY);
    set_bnd(2, v, NX, NY);
  }






  /**
  util
  v 0.0.2
  */
  private void lin_solve(int b, float[] x, float[] x0, float a, float c, int iter, int NX, int NY) {
    for (int inc = 0; inc < iter; inc++) {
      for (int i = 1; i <= NX; i++) {
        for (int j = 1; j <= NY; j++) {
          float step_1 = x[IX(i-1,j)] +x[IX(i+1,j)] 
                        +x[IX(i,j-1)] +x[IX(i,j+1)];
          float step_2 = a *step_1 +x0[IX(i,j)];
          x[IX(i, j)] = step_2 /c;
        }
      }
      set_bnd(b, x, NX, NY);
    }
  }

  // method used to be 'static' since this class is not a top level type
  private int IX(int x, int y) {
    return x +(NXYZ.x+2) *y;
    // return x +(NXYZ.x+2) *y +(NXYZ.y+2);
  }

  // same applies to the swap operation ^^ 
  private void SWAP(float[] x0, float[] x) {
    float[] tmp = new float[num_cell];
    arraycopy(x0, 0, tmp, 0, num_cell);
    arraycopy(x, 0, x0, 0, num_cell);
    arraycopy(tmp, 0, x, 0, num_cell);
  }
}























/**
Navier_Stokes_3D 
2017-2017
v 0.1.1
by Stan le Punk
http://stanlepunk.xyz

Refactoring C code from Mike Ash
https://www.mikeash.com/pyblog/fluid-simulation-for-dummies.html
*/

public class Navier_Stokes_3D extends Navier_Stokes {
  /**
  constructor
  */
  public Navier_Stokes_3D(int N) {
    super(N, 20, true);
  }
  public Navier_Stokes_3D(int N, int iter) {
    super(N, iter, true);
  }

  public Navier_Stokes_3D(ivec3 NXYZ) {
    super(NXYZ, 20, false);
  }
  public Navier_Stokes_3D(ivec3 NXYZ, int iter) {
    super(NXYZ, iter, false);
  }







  /**
  public method
  */
  /**
  get
  */
  public float get_dx(int x, int y, int z) {
    return s[IX(x+1, y+1, z+1)];
  }

  public float get_dy(int x, int y, int z) {
    return t[IX(x+1, y+1, z+1)];
  }

  public float get_dz(int x, int y, int z) {
    return p[IX(x+1, y+1, z+1)];
  }


  /**
  set
  */
  public void set_dx(int x, int y, int z, float value) {
    s[IX(x+1, y+1, z+1)] = value;
  }

  public void set_dy(int x, int y, int z, float value) {
    t[IX(x+1, y+1, z+1)] = value;
  }

  public void set_dz(int x, int y, int z, float value) {
    p[IX(x+1, y+1, z+1)] = value;
  }






/** 
apply force
v 0.0.2
*/
  public void apply_force(int cell_x, int cell_y, int cell_z, float vx, float vy, float vz) {
    cell_x += 1;
    cell_y += 1;
    cell_z += 1;
    int which_one = IX(cell_x, cell_y, cell_z) ;
    if(which_one >= 0) {
      if(which_one < s.length) {
        float dx = s[which_one];
        s[which_one] = (vx != 0) ? 
        lerp(vx, dx, 0.85f) : 
        dx;
      }

      if(which_one < t.length) {
        float dy = t[which_one];
        t[which_one] = (vy != 0) ? 
        lerp(vy,dy, .85f) : 
        dy;
      }

      if(which_one < p.length) {
        float dz = p[which_one];
        p[which_one] = (vz != 0) ? 
        lerp(vz, dz, .85f) : 
        dz;
      }
    }      
  }







/**
update
*/
  public void update(float dt, float visc, float diff) {
    vel_step(s, t, p, s_prev, t_prev, p_prev, visc, dt);
    dens_step(dst, dst_prev, s, t, p, diff, dt);
  }
  
  private void vel_step(float[] s, float[] t, float[] p, float[] s0, float[] t0, float[] p0, float visc, float dt) {
    // step 0
    add_source(s, s0, dt); // x
    add_source(t, t0, dt); // y
    add_source(p, p0, dt); // z
    // step 1
    SWAP(s0, s); // s
    diffuse(1, s, s0, visc, dt, iter, N); // s
    SWAP(t0, t); // t
    diffuse(2, t, t0, visc, dt, iter, N); // t
    SWAP(p0, p); // p
    diffuse(3, p, p0, visc, dt, iter, N); // p

    project(s, t, p, s0, t0, iter, N);

    // step 2
    SWAP(s0, s); // x
    SWAP(t0, t); // y
    SWAP(p0, p); // z
    advect(1, s, s0, s0, t0, p0, dt, N); // x
    advect(2, t, t0, s0, t0, p0, dt, N); // y
    advect(3, p, p0, s0, t0, p0, dt, N); // z
    project(s, t, p, s0, t0, iter, N);
  }


  private void dens_step(float[] x, float[] x0, float[] s, float[] t, float[] p, float diff, float dt) {
    add_source(x, x0, dt);
    SWAP(x0, x);
    diffuse(0, x, x0, diff, dt, iter, N);
    SWAP(x0, x);
    advect(0, x, x0, s, t, p, dt, N);
  }




  /**
  main method
  */

  /**
  diffusion
  */
  private void diffuse(int b, float[] x, float[] x0, float diff, float dt, int iter, int N) {
    float a = dt * diff * (N - 2) * (N - 2);
    lin_solve(b, x, x0, a, 1 + 6 * a, iter, N);
  }





  /**
  advect
  */
  private void advect(int b, float[] d, float[] d0, float[] vel_x, float[] vel_y, float[] vel_z, float dt, int N) {
    float i0, i1, j0, j1, k0, k1;
    
    float dtx = dt *(N -2);
    float dty = dt *(N -2);
    float dtz = dt *(N -2);
    
    float s0, s1, t0, t1, u0, u1;
    float tmp1, tmp2, tmp3, x, y, z;

    for(int k = 1 ; k < N -1 ; k++) {
      for(int j = 1 ; j < N -1; j++) { 
        for(int i = 1 ; i < N -1; i++) {
          tmp1 = dtx *vel_x[IX(i,j,k)];
          tmp2 = dty *vel_y[IX(i,j,k)];
          tmp3 = dtz *vel_z[IX(i,j,k)];
          x = i -tmp1; 
          y = j -tmp2;
          z = k -tmp3;
          
          if(x < .5f) x = .5f; 
          if(x > N +.5f) x = N +.5f;
          i0 = floor(x); 
          i1 = i0 + 1.f;

          if(y < .5f) y = .5f; 
          if(y > N +.5f) y = N +.5f; 
          j0 = floor(y);
          j1 = j0 + 1.f; 

          if(z < .5f) z = .5f;
          if(z > N +.5f) z = N +.5f;
          k0 = floor(z);
          k1 = k0 + 1.f;
          
          s1 = x -i0; 
          s0 = 1.f -s1; 
          t1 = y -j0; 
          t0 = 1.f -t1;
          u1 = z -k0;
          u0 = 1.f -u1;
          
          int i0i = (int)i0;
          int i1i = (int)i1;
          int j0i = (int)j0;
          int j1i = (int)j1;
          int k0i = (int)k0;
          int k1i = (int)k1;
          
          d[IX(i, j, k)] = s0 *(t0 *(u0 *d0[IX(i0i, j0i, k0i)] 
                                    +u1 *d0[IX(i0i, j0i, k1i)]) 
                              +(t1 *(u0 *d0[IX(i0i, j1i, k0i)] 
                                    +u1 *d0[IX(i0i, j1i, k1i)]))) 
                          +s1 *(t0 *(u0 *d0[IX(i1i, j0i, k0i)] 
                                    +u1 *d0[IX(i1i, j0i, k1i)]) 
                              +(t1 *(u0 *d0[IX(i1i, j1i, k0i)] 
                                    +u1 *d0[IX(i1i, j1i, k1i)])));
        }
      }
    }
    set_bnd(b, d, N);
  }
  /**
  boundary
  */
  private void set_bnd(int flag, float[] x, int N) {

    for(int j = 1 ; j < N -1 ; j++) {
        for(int i = 1 ; i < N -1; i++) {
            x[IX(i,j,0)] = flag == 3 ? 
            -x[IX(i,j,1)] : 
            x[IX(i,j,1)];
            x[IX(i,j,N-1)] = flag == 3 ? 
            -x[IX(i,j,N-2)] : 
            x[IX(i,j,N-2)];
        }
    }
    for(int k = 1; k < N -1 ; k++) {
        for(int i = 1 ; i < N -1 ; i++) {
            x[IX(i,0 ,k)] = flag == 2 ?
             -x[IX(i,1,k)] : 
             x[IX(i,1,k)];
            x[IX(i,N-1,k)] = flag == 2 ? 
            -x[IX(i,N-2,k)] : 
            x[IX(i,N-2,k)];
        }
    }
    for(int k = 1; k < N -1; k++) {
        for(int j = 1; j < N -1; j++) {
            x[IX(0,j,k)] = flag == 1 ? 
            -x[IX(1,j,k)] : 
            x[IX(1,j,k)];
            x[IX(N-1,j,k)] = flag == 1 ? 
            -x[IX(N-2,j,k)] : 
            x[IX(N-2,j,k)];
        }
    }
    float ratio = .33f;
    x[IX(0,0,0)]       = ratio *(x[IX(1,0,0)] +x[IX(0,1,0)] +x[IX(0,0,1)]);
    x[IX(0,N-1,0)]     = ratio *(x[IX(1,N-1,0)] +x[IX(0,N-2,0)] +x[IX(0,N-1,1)]);

    x[IX(0,0,N-1)]     = ratio *(x[IX(1,0,N-1)] +x[IX(0,1,N-1)] +x[IX(0,0,N)]);
    x[IX(0,N-1,N-1)]   = ratio *(x[IX(1,N-1,N-1)] +x[IX(0,N-2,N-1)] +x[IX(0,N-1,N-2)]);

    x[IX(N-1,0,0)]     = ratio *(x[IX(N-2,0,0)] +x[IX(N-1,1,0)] +x[IX(N-1,0,1)]);
    x[IX(N-1,N-1,0)]   = ratio *(x[IX(N-2,N-1,0)] +x[IX(N-1,N-2,0)] +x[IX(N-1,N-1,1)]);
    
    x[IX(N-1,0,N-1)]   = ratio *(x[IX(N-2,0,N-1)] +x[IX(N-1,1,N-1)] +x[IX(N-1,0,N-2)]);
    x[IX(N-1,N-1,N-1)] = ratio *(x[IX(N-2,N-1,N-1)] +x[IX(N-1,N-2, N-1)] +x[IX(N-1,N-1,N-2)]);
  }



  

  /**
  project
  */
  private void project(float[] vel_x, float[] vel_y, float[] vel_z, float[] p, float[] div,  int iter, int N) {
    for (int k = 1 ; k < N-1 ; k++) {
      for (int j = 1 ; j < N-1 ; j++) {
        for (int i = 1 ; i < N-1 ; i++) {
          div[IX(i,j,k)] = -.5f *(vel_x[IX(i+1,j,k)] 
                                 -vel_x[IX(i-1,j,k)] 
                                 +vel_y[IX(i,j+1,k)] 
                                 -vel_y[IX(i,j-1,k)] 
                                 +vel_z[IX(i,j,k+1)] 
                                 -vel_z[IX(i,j,k-1)] ) /N;
          p[IX(i, j, k)] = 0;
        }
      }
    }
    set_bnd(0, div, N); 
    set_bnd(0, p, N);
    lin_solve(0, p, div, 1, 6, iter, N);
    for (int k = 1 ; k < N -1 ; k++) {
      for (int j = 1 ; j < N -1 ; j++) {
        for (int i = 1 ; i < N -1 ; i++) {
          vel_x[IX(i,j,k)] -=.5f *(p[IX(i+1,j,k)] -p[IX(i-1,j,k)]) *N;
          vel_y[IX(i,j,k)] -=.5f *(p[IX(i,j+1,k)] -p[IX(i,j-1,k)]) *N;
          vel_z[IX(i,j,k)] -=.5f *(p[IX(i,j,k+1)] -p[IX(i,j,k-1)]) *N;
        }
      }
    }
    set_bnd(1, vel_x, N);
    set_bnd(2, vel_y, N);
    set_bnd(3, vel_z, N);
  }

  /**
  util
  */
  private void lin_solve(int b, float[] x, float[] x0, float a, float c, int iter, int N) {
    float c_recip = 1.f /c;
    for (int k = 0 ; k < iter ; k++) {
      for (int m = 1 ; m < N -1 ; m++) {
        for (int j = 1 ; j < N -1 ; j++) {
          for (int i = 1 ; i < N -1 ; i++) {
            x[IX(i,j,m)] = (x0[IX(i,j,m)] +a *(x[IX(i+1,j,m)] 
                                              +x[IX(i-1,j,m)] 
                                              +x[IX(i,j+1,m)] 
                                              +x[IX(i,j-1,m)] 
                                              +x[IX(i,j,m+1)] 
                                              +x[IX(i,j,m-1)])) *c_recip;
          }
        }
      }
      set_bnd(b, x, N);
    }
  }

  // method used to be 'static' since this class is not a top level type
  private int IX(int x, int y, int z) {
    // my solution
    return x +(N+2) *y +(N+2) *(N+2) *z;
    // solution from 
    // return x +y *N +z * N *N;
  }

        // same applies to the swap operation ^^ 
  private void SWAP(float[] x0, float[] x) {
    float[] tmp = new float[num_cell];
    arraycopy(x0, 0, tmp, 0, num_cell);
    arraycopy(x, 0, x0, 0, num_cell);
    arraycopy(tmp, 0, x, 0, num_cell);
  }
}





































/**
* Force field warp texture
* @author @stanlepunk
* @see https://github.com/StanLepunK/Force_Field
* 2017-2019
v 0.9.2
*/

class Warp_Force {
  private PImage buffer_img;
  private PGraphics pg;
  private boolean shader_warp_filter = false ;
  private int shader_warp_mode = 0 ;

  private ROPImage_Manager img_manager ;

  private boolean reset_img ;

  private PShader rope_warp_shader, rope_warp_blur;
  

  public Warp_Force() {
    build("shader/");
  }


  private void build(String path) {
    img_manager = new ROPImage_Manager();
    shader(path);
  }
  

  private void shader(String main_folder_path) {
    String path = main_folder_path+"fx_post/warp_tex_a.glsl";
    rope_warp_shader = loadShader(path);
    path = main_folder_path+"fx_post/blur_gaussian.glsl";
    rope_warp_blur = loadShader(path); 
  }


  /**
  * Use this method in Processing setup
  * load PImage from path
  *
  * @webref warp:method
  * @param path array String of path
  * @return void
  * @brief load PImage from path to the image manager
  */
  public void load(String... path) {
    img_manager.load(path);
  }



  
  /**
  * add PImage directly
  *
  * @webref warp:method
  * @param pg is PImage to add at the manager
  * @param name is PImage name to add info at your image
  * @return none
  * @brief add PImage direclt
  */
  public void add(PImage pg) {
    add(pg,"my name is nobody");
  }

  public void add(PImage pg, String name) {
    img_manager.add(pg,name);
  }



  /**
  * set PImage directly
  *
  * @webref warp:method
  * @param pg is PImage to add at the manager
  * @param name is PImage name to add info at your image
  * @return none
  * @brief add PImage direclt
  */

  /*
  public void set(PImage img, String name) {
    img_manager.set(img,name);
  }
  */
  
  






  /**
  * select PImage in the manager list to use with warp
  *
  * @webref warp:method
  * @param index point PImage in the array list manager
  * @param name point PImage in the array list manager
  * @return none
  * @brief add PImage direclt
  */
  public void select(int index) {
    img_manager.select(index);
  }

  public void select(String name) {
    img_manager.select(img_manager.get_rank(name)) ;
  }


  /**
  get
  */
  public String get_name(int target) {
    return img_manager.get_name(target) ;
  }

  public String get_name() {
    return img_manager.get_name() ;
  }

  public int get_width() {
    if(img_manager.get() != null) {
      return img_manager.get().width;
    } else return 0 ;
  }

  public int get_height() {
    if(img_manager.get() != null) {
      return img_manager.get().height;
    } else return 0 ;
  }
  
  public PImage get_image() {
    return img_manager.get();
  }


  

  public int library_size() {
    if(img_manager != null) {
      return img_manager.size();
    } else return -1;
  }

  public ROPImage_Manager library() {
    return img_manager ;
  }

  public void image_library_clear() {
    img_manager.clear();
  }




  public void shader_init() {
    rendering_shader_is(true);
    shader_mode(0); // default mode, regular rendering
    shader_filter(false); // no effect echo shadering
  }

  public void shader_filter(boolean filter_is) {
    shader_warp_filter = filter_is ;
  }

  // int mode = 0; // default mode is rendering
  // mode = 500 ; // velocity mode
  // mode = 501 ; // direction mode
  public void shader_mode(int which_mode) {
    shader_warp_mode = which_mode;
  }







  /**
  *  refresh PImage selected after warp effect
  *
  * @webref warp:method
  * @param ratio is Vec component of refresh / the max Vec is 4
  * @param value is the array component / the max element is 4
  * refresh component is must have a normal value 0 > 1
  * @return none
  * @brief refresh the PImage to the begin
  */
  public void refresh(vec ratio) {
    refresh_image_is(true);

    if(ratio instanceof vec2) {
      vec2 r = (vec2) ratio ;
      refresh_image(r.x,r.x,r.x);
    } else if (ratio instanceof vec3) {
      vec3 r = (vec3) ratio ;
      refresh_image(r.x,r.y,r.z);
    } else {
      printErr("method refresh() from class Warp : ratio is not an instance of vec2, vec3 or vec4, instead the value max '.5' is used");
      refresh_image(.5f,.5f,.5f);
    } 
  }

  public void refresh(float... value) {
    vec3 v = array_to_rgb_vec3(value);
    refresh_image_is(true);
    refresh_image(v.x,v.y,v.z);
  }

  private vec3 array_to_rgb_vec3(float... f) {
    vec3 v = vec3(1);
    if(f.length == 1) {
      v.set(f[0],f[0],f[0]);
    } else if(f.length == 2) {
      v.set(f[0],f[0],f[0]);
    } else if(f.length == 3) {
      v.set(f[0],f[1],f[2]);
    } else if(f.length > 3) {
      v.set(f[0],f[1],f[2]);
    }
    return v;
  }







  /**
  misc
  */
  public void reset() {
    reset_img = true ;
  }

  public void image_library_fit(PGraphics pg, boolean full_fit) {
    for(int i = 0 ; i < img_manager.size() ;i++) {
      image_resize(img_manager.get(i),pg, full_fit);
    }
  }

  public void image_library_crop(PGraphics pg) {
    for(int i = 0 ; i < img_manager.size() ;i++) {
      PImage temp = image_copy_window(img_manager.get(i), CENTER).copy();
      img_manager.get(i).resize(temp.width,temp.height);
      temp.loadPixels();
      img_manager.get(i).pixels = temp.pixels;
      img_manager.get(i).updatePixels();
    }
  }






  /**
  SHOW
  */
  /*
  Main and Public method to show result
  */
  public void show(Force_field force_field, float intensity) {
    if(reset_img) {
      draw(img_manager.get());
    }
    reset_img = false;

    if(pg == null && img_manager.get() != null) { 
      set(img_manager.get());
    } else if(img_manager.get() != null) {  
      update(force_field,img_manager.get(),intensity);
    }
  }


  /*
  Follower method
  */
  private void set(PImage target) {
    if(get_renderer(getGraphics()).equals(P3D) || get_renderer(getGraphics()).equals(P2D)) {
      buffer_img = createImage(target.width, target.height, ARGB);
      pg = createGraphics(target.width, target.height, get_renderer(getGraphics()));
      pg.beginDraw();
      pg.image(target,0,0);
      pg.endDraw();
    }
  }
  

  private void update(Force_field force_field, PImage target, float intensity) {
    PImage inc = target.copy(); 
    rendering(pg, buffer_img, inc, force_field, intensity);   

    buffer_img.pixels = buffering(pg).pixels;
    buffer_img.updatePixels();
  }




  private PImage buffering(PImage target) {
    PImage temp = createImage(target.width,target.height, ARGB);
    target.loadPixels();
    temp.pixels = target.pixels;
    temp.updatePixels();
    return temp;
  }

  private void draw(PImage target) {
    if(target != null) set(target);
    buffer_img.pixels = buffering(pg).pixels;
    buffer_img.updatePixels();
  }
  























  /**
  rendering
  */
  private boolean rendering_warp_GPU = false ;
  private void rendering_shader_is(boolean rendering_warp_GPU) { 
    this.rendering_warp_GPU = rendering_warp_GPU ;
  }

  /**
  refresh background image
  */
  private boolean refresh_image_is ;
  private void refresh_image_is(boolean refresh_image_is) {
    this.refresh_image_is = refresh_image_is;
  }
  /**
  refresh component is must have a normal value 0 > 1
  */
  private vec3 warp_img_refresh ;
  private void refresh_image(float x, float y, float z) {
    if(this.warp_img_refresh == null) {
      warp_img_refresh = vec3(x,y,z);
    } else {
      warp_img_refresh.set(x,y,z);
    }
  }












  /**
  * warp image Master method
  * v 0.4.0
  * EFFECT PART MUST BE IMPROVE TO BE INTERESTING
  */
  // refresh effect
  private boolean refresh_mix_is; // default effect
  public void refresh_mix(boolean refresh_mix_is) {
    this.refresh_mix_is = refresh_mix_is;
  }

  public void refresh_multiply(boolean refresh_multiply_is) {
    refresh_multiply(refresh_multiply_is, .5f, 1);
  }

  private boolean refresh_multiply_is ;
  private vec3 refresh_multiply_value ;
  public void refresh_multiply(boolean refresh_multiply_is, float... value) {
    vec3 v = array_to_rgb_vec3(value);
    if(refresh_multiply_value == null) {
      refresh_multiply_value = vec3(v.x,v.y,v.z);
    } else {
      refresh_multiply_value.set(v.x,v.y,v.z);
    }
    this.refresh_multiply_is = refresh_multiply_is;
  }

  public void refresh_overlay(boolean refresh_overlay_is) {
    refresh_overlay(refresh_overlay_is, .5f, 1);
  }

  private boolean refresh_overlay_is ;
  private vec3 refresh_overlay_value ;
  public void refresh_overlay(boolean refresh_overlay_is, float... value) {
    vec3 v = array_to_rgb_vec3(value);
    if(refresh_overlay_value == null) {
      refresh_overlay_value = vec3(v.x,v.y,v.z);
    } else {
      refresh_overlay_value.set(v.x,v.y,v.z);
    }
    this.refresh_overlay_is = refresh_overlay_is;
  }




  // normal effect
  private boolean effect_multiply_is ;
  private vec3 effect_multiply_value ;
  public void effect_multiply(boolean effect_multiply_is, float... value) {
    vec3 v = array_to_rgb_vec3(value);
    if(effect_multiply_value == null) {
      effect_multiply_value = vec3(v.x,v.y,v.z);
    } else {
      effect_multiply_value.set(v.x,v.y,v.z);
    }
    this.effect_multiply_is = effect_multiply_is;
  }

  private boolean effect_overlay_is ;
  private vec3 effect_overlay_value ;
  public void effect_overlay(boolean effect_overlay_is, float... value) {
    vec3 v = array_to_rgb_vec3(value);
    if(effect_overlay_value == null) {
      effect_overlay_value = vec3(v.x,v.y,v.z);
    } else {
      effect_overlay_value.set(v.x,v.y,v.z);
    }
    this.effect_overlay_is = effect_overlay_is;
  }








  /*
  rendering
  */
  private void rendering(PGraphics result, PImage buffer, PImage inc, Force_field ff, float intensity) {    
    if (rendering_warp_GPU) {
      rendering_graphic_processor(result,buffer,inc,ff,intensity);  
    } else {
      rendering_computer_processor(result,buffer,inc,ff,intensity);
    }
  }







  /**
  WARP GPU
  Graphic Processor Unit version of fluid image / GLSL
  v 0.0.4
  */
  private void rendering_graphic_processor(PGraphics result, PImage buffer, PImage inc, Force_field ff, float intensity) {
    refresh_rendering_gpu(result,buffer,inc,ff,intensity);
    finalize_rendering_gpu(result,buffer,inc,ff,intensity);  
  }



  private void refresh_rendering_gpu(PGraphics result, PImage buffer, PImage inc, Force_field ff, float intensity) {
    if(refresh_image_is) {
      refresh_mix(true);
      refresh_multiply(false); // add value is possible refresh_multiply(boolean b, float... val)
      refresh_overlay(false); // add value is possible refresh_overlay(boolean b, float... val)

      result.beginDraw();
      if(refresh_mix_is) {
        int mix_mode_mix = 17;
        result = fx_mix(buffer,inc,false,mix_mode_mix,warp_img_refresh,vec3(1));
      }
      if(refresh_multiply_is) {  
        int mix_mode_multiply = 1;
        result = fx_mix(buffer,inc,false,mix_mode_multiply,vec3(1),refresh_multiply_value);
      }
      if(refresh_overlay_is) {
         int mix_mode_overlay = 4;
         result = fx_mix(buffer,inc,false,mix_mode_overlay,vec3(1),refresh_overlay_value);
      }
      if(result.pixels == null) {
        result.loadPixels();
      }
      result.endDraw();
    }
    image(result);
  }


  private void finalize_rendering_gpu(PGraphics result, PImage buffer, PImage inc, Force_field ff, float intensity) {
    result.beginDraw(); 
    warp_image_graphic_processor(result,inc,ff,intensity);

    if(effect_multiply_is) {
      int mix_mode_multiply = 1;
      println("multiply",refresh_multiply_value);
      result = fx_mix(buffer,inc,false,mix_mode_multiply,vec3(1),refresh_multiply_value);
    }
    if(effect_overlay_is) {
      println("overlay",refresh_overlay_value);
      int mix_mode_overlay = 4;
      result = fx_mix(buffer,inc,false,mix_mode_overlay,vec3(1),refresh_overlay_value);
    }
    result.endDraw();
  }




  // main method
  private void warp_image_graphic_processor(PGraphics result, PImage tex, Force_field ff, float intensity) {
    float grid_w = ff.get_tex_velocity().width;
    float grid_h = ff.get_tex_velocity().height;
    PImage tex_dir_blur = ff.get_tex_direction().copy();
    smooth_texture(PApplet.parseInt(grid_w), PApplet.parseInt(grid_h), tex_dir_blur);
   
    rope_warp_shader.set("mode",shader_warp_mode);
    rope_warp_shader.set("strength",intensity);

    rope_warp_shader.set("texture_source",tex);
    rope_warp_shader.set("texture_velocity",ff.get_tex_velocity());
    rope_warp_shader.set("texture_direction",pass2);
    
    // shader filter
    if(shader_warp_filter) { 
      try {
        // rope_warp_shader.set("flip_source",true,false);
        result.filter(rope_warp_shader);
      } catch(java.lang.RuntimeException e) { 
        printErrTempo(60,"class Warp void warp_image_graphic_processor: Too many calls to pushMatrix()",frameCount);
      }
    } else {  
      result.shader(rope_warp_shader);
      result.image(tex,0,0); // don't update the image
    }
  }


  /**
  Smooth texture
  method to blur the texture, before passing this one to the main picture must be warp.
  This step remove the stair effect.
  */
  private PGraphics pass1, pass2;

  private void smooth_texture(int w, int h, PImage tex) {
      // blur direction texture
    if(pass1 == null) pass1 = createGraphics(w,h,P2D);
    if(pass2 == null) pass2 = createGraphics(w,h,P2D);
    rope_warp_blur.set("radius",7);
    rope_warp_blur.set("sigma",3f); 
    // Applying the blur shader along the vertical direction   
    rope_warp_blur.set("horizontal_pass",true);
    pass1.beginDraw();            
    pass1.shader(rope_warp_blur);
    pass1.image(tex,0,0); 
    pass1.endDraw();

   
    // Applying the blur shader along the horizontal direction        
    rope_warp_blur.set("horizontal_pass",false);
    pass2.beginDraw();            
    pass2.shader(rope_warp_blur);  
    pass2.image(pass1,0,0);
    pass2.endDraw(); 
  }



















  /**
  WARP CPU
  Computer Processor Unit 
  v 0.2.0
  * based on by Felix Woitzel code
  * but the code don't work perfectly, on the top and right direction
  */

  private void rendering_computer_processor(PGraphics result, PImage buffer, PImage inc, Force_field ff, float intensity) {
    result.beginDraw();
    if(refresh_image_is) {
      int mix_mode_mix = 17;
      result = fx_mix(buffer,inc,false,mix_mode_mix,warp_img_refresh,vec3(1));
      // mix(result,buffer,inc,warp_img_refresh);
    }
    warp_image_computer_processor(result,buffer,inc,ff,intensity);
    result.endDraw();
    image(result);  
  }

  private void warp_image_computer_processor(PGraphics result, PImage tex, PImage inc, Force_field ff, float intensity) {

    result.loadPixels();
    int [] c_array = result.pixels ;

    ivec2 canvas = ivec2(ff.get_canvas());
    ivec2 img_canvas = ivec2(result.width, result.height);
    
    vec2 ratio_canvas = vec2(1).div(canvas);

    int start_x = 0 ;
    int start_y = 0 ;
    int end_x = img_canvas.x;
    int end_y = img_canvas.y;  

    // this part must be send to shader GLSL  
    for (int x = start_x ; x < end_x ; x++) {
      for (int y = start_y ; y < end_y ; y++) {
        vec2 uv = ratio_canvas.copy().mult(x,y);
        vec2 warp = ff.field_warp(uv,intensity);
        if(warp != null) {
          warp.mult(canvas);
          int c = apply_warp(warp,c_array,result,inc);
          result.set(x,y,c);

        } else {
          printErr("error in fluid_image() caught vec2 warp is null for " + uv);
          int c = color(r.BLACK);
          result.set(x,y,c);
        }
      }
    }
  }

  /**
  * problem the pixel have a tendances to go on the the right :(
  */
  public int apply_warp(vec2 warp, int [] pix, PImage src, PImage img_fluid) {
    // security out bound
    if (warp.x < 0) warp.x = 0;
    if (warp.y < 0 ) warp.y = 0;
    if (warp.x > src.width) warp.x = src.width -1;
    if (warp.y > src.height) warp.y = src.height -1;
    

    int x = floor(warp.x);
    int y = floor(warp.y);

    /**
    * interesting bug
    * float u = warp.x +x;
    * float v = warp.y +y; 
    */

    float u = warp.x -x;
    float v = warp.y -y;
    
    int indexTopLeft = x +y *img_fluid.width;
    int indexTopRight = x +1 +y *img_fluid.width;
    int indexBottomLeft = x +(y+1) *img_fluid.width;  
    int indexBottomRight = x +1 +(y+1) *img_fluid.width;
   
    
    /**
    * Keep for the future
    */
    /*
    if(indexTopLeft >= pix.length) indexTopLeft -= pix.length;
    if(indexTopRight >= pix.length) indexTopRight -= pix.length;
    if(indexBottomLeft >= pix.length) indexBottomLeft -= pix.length;
    if(indexBottomRight >= pix.length) indexBottomRight -= pix.length;
    */
    
    // border true
    if(indexTopLeft >= pix.length) indexTopLeft = pix.length -1;
    if(indexTopRight >= pix.length) indexTopRight = pix.length -1;
    if(indexBottomLeft >= pix.length) indexBottomLeft = pix.length -1;
    if(indexBottomRight >= pix.length) indexBottomRight = pix.length -1;

    if(indexTopLeft < 0) indexTopLeft = 0;
    if(indexTopRight < 0) indexTopRight = 0;
    if(indexBottomLeft < 0) indexBottomLeft = 0;
    if(indexBottomRight < 0) indexBottomRight = 0;


    try {
      int top_left = pix[indexTopLeft];
      int top_right = pix[indexTopRight];
      int bottom_left = pix[indexBottomLeft];
      int bottom_right = pix[indexBottomRight];

      int from = lerpColor(top_left,top_right,u);
      int to = lerpColor(bottom_left,bottom_right,u);
      float ratio = v;

      int c = lerpColor(from,to,ratio);

      return c;
    } catch (Exception e) {
      printErr("error in apply_warp() caught trying to get color for pixel position " + x + ", " + y);
      return r.BLACK;
    }
  }

}







/**
* class Mask_mapping
* v 0.3.1
* 2018-2019
* Processing 3.5.3
* Rope library 0.4.0

use " M " maj to able or enable mask
$

*/
public class Masking implements rope.core.R_Constants {
  PGraphics pg;
  private ivec3 [] coord;
  private ivec3 [] coord_block_1, coord_block_2, coord_block_3, coord_block_4;
  private boolean init;
  private boolean block_is;
  private int c = BLACK;
  private int range = 10;
  

  // CONSTRUCTOR
  public Masking(ivec2 [] list) {
    coord = new ivec3[list.length];
    for(int i = 0 ; i < coord.length ;i++) {
      coord[i] = ivec3(list[i].x,list[i].y,0);
    }
    init = true;
  }


  public Masking(ivec2 [] list, ivec2 [] list_block_1, ivec2 [] list_block_2, ivec2 [] list_block_3, ivec2 [] list_block_4) {
    if(list.length != 8) {
      printErr("class Mask_mapping need exactly 8 points to create a block, no more no less, there is",list.length,"in the list, no mask can be create");
    } else {
      block_is = true ;
      coord = new ivec3[list.length];
      for(int i = 0 ; i < coord.length ;i++) {
        coord[i] = ivec3(list[i].x,list[i].y,0);
      }
      // block 1
      if(list_block_1 != null && list_block_1.length > 0) {
        coord_block_1 = new ivec3[list_block_1.length];
        for(int i = 0 ; i < coord_block_1.length ;i++) {
          coord_block_1[i] = ivec3(list_block_1[i].x,list_block_1[i].y,0);
        }
      }
      // block 2
      if(list_block_2 != null && list_block_2.length > 0) {
        coord_block_2 = new ivec3[list_block_2.length];
        for(int i = 0 ; i < coord_block_2.length ;i++) {
          coord_block_2[i] = ivec3(list_block_2[i].x,list_block_2[i].y,0);
        }
      }
      // block 3
      if(list_block_3 != null && list_block_3.length > 0) {
        coord_block_3 = new ivec3[list_block_3.length];
        for(int i = 0 ; i < coord_block_3.length ;i++) {
          coord_block_3[i] = ivec3(list_block_3[i].x,list_block_3[i].y,0);
        }
      }
      // block 4
      if(list_block_4 != null && list_block_3.length > 0) {
        coord_block_4 = new ivec3[list_block_4.length];
        for(int i = 0 ; i < coord_block_4.length ;i++) {
          coord_block_4[i] = ivec3(list_block_3[i].x,list_block_4[i].y,0);
        }
      }
    }
    init = true;
  }





  // METHOD
  public ivec2 [] get_coord() {
    return ivec3_coord_to_ivec2_coord(coord) ;
  }

  public ivec2 [] get_coord_block_1() {
    return ivec3_coord_to_ivec2_coord(coord_block_1) ;
  }

  public ivec2 [] get_coord_block_2() {
    return ivec3_coord_to_ivec2_coord(coord_block_2) ;
  }

  public ivec2 [] get_coord_block_3() {
    return ivec3_coord_to_ivec2_coord(coord_block_3) ;
  }

  public ivec2 [] get_coord_block_4() {
    return ivec3_coord_to_ivec2_coord(coord_block_4) ;
  }

  private ivec2 [] ivec3_coord_to_ivec2_coord(ivec3 [] target) {
    if(target != null) {
      ivec2 [] list = new ivec2[target.length];
      for(int i = 0 ; i < list.length ; i++) {
        list[i] = ivec2(target[i].x,target[i].y);
      }
      return list;
    } else return null;
  }

  public void reset() {
    pg = createGraphics(width,height);
  }


  public PGraphics get_mask() {
    return pg;
  }

  

  public void set_fill(int c) {
    this.c = c;
  }



  public void draw(boolean modify_is) {
    if(pg == null) {
      pg = createGraphics(width,height);
    }

    if(pg != null && init) {
      pg.beginDraw();
      if(modify_is) {
        if(pg != null) {      
          pg.fill(RED);
          pg.noStroke();
        }
      } else {
        if(pg != null) {
          pg.fill(c);
          pg.noStroke();    
        }
      }
      pg.endDraw();

      if(block_is) {
        if(pg != null) draw_shape(pg, coord, coord_block_1, coord_block_2, coord_block_3, coord_block_4);
        if(modify_is) {
          show_point(pg,coord);
          move_point(coord);

          if(coord_block_1 != null) {
            show_point(pg,coord_block_1);
            move_point(coord_block_1);
          }
          if(coord_block_2 != null) {
            show_point(pg,coord_block_2);
            move_point(coord_block_2);
          }
          if(coord_block_3 != null) {
            show_point(pg,coord_block_3);
            move_point(coord_block_3);
          }
          if(coord_block_4 != null) {
            show_point(pg,coord_block_4);
            move_point(coord_block_4);
          }
        }
      } else {
        if(pg != null) draw_shape(pg,coord);
        if(modify_is) {
          show_point(pg,coord);
          move_point(coord);
        }
      }
      
    } else {
      println(pg,init);
      printErr("class Masking.draw(): Must be iniatilized with an array list ivec2 [] coord)");
    }
  }

  private void show_point(PGraphics pg,ivec3 [] list) {
    for(ivec3 iv : list) {
      pg.beginDraw();
      pg.stroke(WHITE);
      pg.strokeWeight(range);
      pg.point(iv.x,iv.y);
      pg.endDraw();
    }
  }

  private boolean drag_is = false ;
  private void move_point(ivec3 [] list) {
    if(!drag_is) {
      for(ivec3 iv : list) {
        ivec2 drag = ivec2(mouseX,mouseY);
        ivec2 area = ivec2(range);
        if(inside(drag,area,ivec2(iv.x,iv.y)) && iv.z == 0) {
          if(mousePressed) {
            iv.set(iv.x,iv.y,1);
            drag_is = true ;
          } else {
            // border magnetism
            if(iv.x < 0 + range) iv.x = 0 ;
            if(iv.x > width -range) iv.x = width;
            if(iv.y < 0 + range) iv.y = 0 ;
            if(iv.y > height -range) iv.y = height;
          }
        }
      }
    }
    
    for(ivec3 iv : list) {
      if(iv.z == 1) iv.set(mouseX,mouseY,1);
    }

    if(!mousePressed) {
      drag_is = false;
      for(ivec3 iv : list) {
        iv.set(iv.x,iv.y,0);
      }
    }
  }

  private void draw_shape(PGraphics pg, ivec3 [] list) {
    pg.beginDraw();
    //
    pg.beginShape();
    for(int i = 0 ; i < list.length ; i++) {
      pg.vertex(list[i].x,list[i].y);
    }
    pg.endShape(CLOSE);
    //
    pg.endDraw();
  }

  private void draw_shape(PGraphics pg, ivec3 [] list, ivec3 [] list_b_1, ivec3 [] list_b_2, ivec3 [] list_b_3, ivec3 [] list_b_4) {
    pg.beginDraw();
    // block 1
    pg.beginShape();
    pg.vertex(list[0].x,list[0].y);
    pg.vertex(list[1].x,list[1].y);
    pg.vertex(list[5].x,list[5].y);
    if(list_b_1 != null) {
      for(int i = 0 ; i < list_b_1.length ; i++) {
        pg.vertex(list_b_1[i].x,list_b_1[i].y);
      }
    }
    pg.vertex(list[4].x,list[4].y);
    pg.endShape(CLOSE);

    // block 2
    pg.beginShape();
    pg.vertex(list[1].x,list[1].y);
    pg.vertex(list[2].x,list[2].y);
    pg.vertex(list[6].x,list[6].y);
    if(list_b_2 != null) {
      for(int i = 0 ; i < list_b_2.length ; i++) {
        pg.vertex(list_b_2[i].x,list_b_2[i].y);
      }
    }
    pg.vertex(list[5].x,list[5].y);
    pg.endShape(CLOSE);

    // block 3
    pg.beginShape();
    pg.vertex(list[2].x,list[2].y);
    pg.vertex(list[3].x,list[3].y);
    pg.vertex(list[7].x,list[7].y);
    if(list_b_3 != null) {
      for(int i = 0 ; i < list_b_3.length ; i++) {
        pg.vertex(list_b_3[i].x,list_b_3[i].y);
      }
    }
    pg.vertex(list[6].x,list[6].y);
    pg.endShape(CLOSE);

    // block 4
    pg.beginShape();
    pg.vertex(list[3].x,list[3].y);
    pg.vertex(list[0].x,list[0].y);
    pg.vertex(list[4].x,list[4].y);
    if(list_b_4 != null) {
      for(int i = 0 ; i < list_b_4.length ; i++) {
        pg.vertex(list_b_4[i].x,list_b_4[i].y);
      }
    }
    pg.vertex(list[7].x,list[7].y);
    pg.endShape(CLOSE);
    //
    pg.endDraw();
  }
}







/**
* CLASS PIX 
* v 0.10.2
* 2016-2018
* Processing 3.5.3
* Rope library 0.4.0
* @author @stanlepunk
* @see https://github.com/StanLepunK/Pixel
*/


abstract class Pix implements rope.core.R_Constants {
  PApplet p5;

  Pix(PApplet p5) {
    this.p5 = p5;
  }
  // P3D mode
  vec3 pos, new_pos;
  vec3 size;
  
  // in cartesian mode
  vec3 dir = null ;

  vec3 grid_position ;
  int ID, rank ;
  Costume costume; // 0 is for point
  float ratio_costume_size = Float.MAX_VALUE;
  float costume_angle = 0 ;
  vec4 colour, new_colour  ;
  
  // use for the motion
  float field = 1.0f ;


  public void init_mother_arg() {
    pos = vec3(width/2, height/2,0) ;
    if(new_pos == null) {
      new_pos = pos.copy();
    } else {
      new_pos.set(pos);
    }
    if(size == null) {
      size = vec3(1) ;
    } else {
      size.set(1);
    }
    if(grid_position == null) {
      grid_position = pos.copy();
    } else {
      grid_position.set(pos);
    }
    // give a WHITE color to the pixel
    if(colour == null) {
      if(g.colorMode == 3 ) {
        colour = vec4(0, 0, g.colorModeZ, g.colorModeA) ; 
      } else {
        colour = vec4(g.colorModeX, g.colorModeY, g.colorModeZ, g.colorModeA) ;
      }
    } else {
      if(g.colorMode == 3 ) {
        colour.set(0, 0, g.colorModeZ, g.colorModeA) ; 
      } else {
        colour.set(g.colorModeX, g.colorModeY, g.colorModeZ, g.colorModeA) ;
      }
    }
   
    if(new_colour == null) {
      new_colour = colour.copy() ;
    } else {
      new_colour.set(colour) ;
    }

    int ID = 0 ;
    int rank = -1 ;
  }
  
  
  // RETURN color in vec4
  // test the color mode to return the good data for each component
  public vec4 int_color_to_vec4_color(int c) {
    vec4 color_temp = vec4() ;
    if(g.colorMode == 3 ) color_temp = vec4(hue(c),saturation(c),brightness(c),alpha(c)) ;
    else color_temp = vec4(red(c),green(c),blue(c),alpha(c)) ;
    return vec4(color_temp) ;
  }






  /** 
  SETTING
  */
  // ID
  public void set_ID(int ID) {  
    this.ID = ID ; 
  }

  public void costume_angle(float costume_angle) {
    if(costume.get_type() == POINT_ROPE) {
      printErrTempo(180, "class Pix method costume_angle() cannot be used with costume_ID POINT_ROPE");
    }
    this.costume_angle = costume_angle ;
  }


  // set costume
  public void costume(int type) {
    if(costume == null) {
      costume = new Costume(p5,type);
    } else {
      this.costume.set_type(type);
    }
  }

  public void costume(Costume costume) {
    this.costume = costume;
  }

  public void costume_ratio_size(float ratio_costume_size) {
    this.ratio_costume_size = ratio_costume_size;
  }
  



  // size
  public void size(float x) {
    size(x,x,1) ;
  }
  public void size(float x, float y) {
    size(x,y,1) ;
  }

  public void size(vec size) {
    if(size.z == 0) {
      size(size.x, size.y, 1);
    } else {
      size(size.x,size.y,size.z);
    }
  }

  public void size(ivec size) {
    if(size.z == 0) {
      size(size.x, size.y, 1);
    } else {
      size(size.x,size.y,size.z);
    }
  }

  public void size(float x, float y, float z) {
    if(size == null) {
      size = vec3(x,y,z) ;
    } else {
      size.set(x,y,z);
    }
  }

 
  // normal direction
  @Deprecated
  public void direction(vec3 d) {
    dir(d.x,d.y,d.z);
  }
  @Deprecated
  public void direction(float x, float y, float z) {
    dir(x,y,z);
  }
  
  @Deprecated
  public void direction_x(float x) {
    dir.x = x ;
  }
  
  @Deprecated
  public void direction_y(float y) {
    dir.y = y ;
  }

  @Deprecated
  public void direction_z(float z) {
    dir.z = z ;
  }
  

  public void dir_x(float x) {
    if(this.dir != null) {
      dir.x = x ;
    } else {
      this.dir = vec3(x,0,0);
    }
  }
  
  public void dir_y(float y) {
    if(this.dir != null) {
      dir.y = y ;
    } else {
      this.dir = vec3(0,y,0);
    }
  }

  public void dir_z(float z) {
    if(this.dir != null) {
      dir.z = z;
    } else {
      this.dir = vec3(0,0,z);
    }
  }

  public void dir(vec d) {
    if(d != null) {
      dir(d.x,d.y,d.z);
    } else {
      printErr("class Pix method dir() cannot set vector because the arg vector pass is null");
    }

    
  }

  public void dir(float x, float y, float z) {
    if(this.dir == null) {
      this.dir = vec3(x,y,z);
    } else {
      this.dir.set(x,y,z);
    }
  }



  // position
  @Deprecated
  public void position(vec pos) {
    this.pos.set(pos);
  }
  
  @Deprecated
  public void position(int x, int y){
    this.pos.set(x,y,0);
  }
  
  @Deprecated
  public void position(int x, int y, int z){
    this.pos.set(x,y,z);
  }
  
  public void pos(ivec pos) {
    if(pos != null) {
      pos(pos.x,pos.y,pos.z);
    } else {
      printErrTempo(60,"class Pix method pos() cannot set vector because the vector arg pass is null");
    }
  }

  public void pos(vec pos) {
    if(pos != null) {
      pos(pos.x,pos.y,pos.z);
    } else {
      printErrTempo(60,"class Pix method pos() cannot set vector because the vector arg pass is null");
    }
  }

  public void pos(float x, float y){
    pos(x,y,0);
  }
  
  public void pos(float x, float y, float z){
    this.pos.set(x,y,z);
  }















  /**
  ASPECT
  v 0.2.0
  */
  /**
  improve methode to check if the stroke must be Stroke or noStroke()
  */
  public void aspect() {
    float thickness = 1 ;
    if(costume == null) costume = new Costume(p5);
    costume.aspect(colour,colour,thickness);
  }

  public void aspect(boolean new_colour_choice) {
    float thickness = 1 ;
    vec4 color_choice = vec4();
    if(new_colour_choice) {
      color_choice.set(new_colour); 
    } else {
      color_choice.set(colour);
    }
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_choice,color_choice,thickness) ;
  }

  public void aspect(boolean new_colour_choice, float thickness) {
    vec4 color_choice = vec4() ;
    if(new_colour_choice) {
      color_choice.set(new_colour) ; 
    } else {
      color_choice.set(colour);
    }
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_choice,color_choice,thickness);
  }

  public void aspect(float thickness) {
    if(costume == null) costume = new Costume(p5);
    costume.aspect(colour,colour,thickness);
  }

  public void aspect(int c) {
    float thickness = 1 ;
    vec4 color_pix = int_color_to_vec4_color(c).copy();
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_pix, color_pix, thickness);
  }

  public void aspect(vec4 color_pix) {
    float thickness = 1 ;
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_pix, color_pix, thickness) ;
  }

  public void aspect(vec4 color_pix, float thickness) {
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_pix, color_pix, thickness) ;
  }
  
  public void aspect(vec4 color_fill, vec4 color_stroke, float thickness) {
    if(costume == null) costume = new Costume(p5);
    costume.aspect(color_fill,color_stroke,thickness);
  }
  




  //with effect
  /**
  Methode must be refactoring, very weird
  */
  /*
  void aspect(int diam, PVector effectColor) {
    strokeWeight(diam) ;
    stroke(new_colour.r, effectColor.x *new_colour.g, effectColor.y *new_colour.b, effectColor.z *new_colour.a) ;
  }
  */  
  
  
  
  
  /**
  CHANGE COLOR
  */
  //direct change HSB
  public void set_hue(int new_hue, int target_color, boolean use_new_colour) {
    set_hue(new_hue, target_color, target_color +1, use_new_colour) ;
  }
  public void set_saturation(int new_sat, int target_color, boolean use_new_colour) {
    set_saturation(new_sat, target_color, target_color +1, use_new_colour) ;
  }
  public void set_brightness(int new_bright, int target_color, boolean use_new_colour) {
    set_brightness(new_bright, target_color, target_color +1, use_new_colour) ;
  }
  //direct change RGB
  public void set_red(int new_red, int target_color, boolean use_new_colour) {
    set_red(new_red, target_color, target_color +1, use_new_colour) ;
  }
  public void set_green(int new_green, int target_color, boolean use_new_colour) {
    set_green(new_green, target_color, target_color +1, use_new_colour) ;
  }
  public void set_blue(int new_blue, int target_color, boolean use_new_colour) {
    set_blue(new_blue, target_color, target_color +1, use_new_colour) ;
  }
  //direct change ALPHA
  public void set_alpha(int new_alpha, int target_color, boolean use_new_colour) {
    set_alpha(new_alpha, target_color, target_color +1, use_new_colour) ;
  }
  
  // change with range
  // HSB change
  public void set_hue(int new_hue, int start, int end, boolean use_new_colour) {
    float hue_temp ; ;
    if(!use_new_colour) hue_temp = set_color_component_from_specific_component("hue", colour.hue(), new_hue, start, end) ; 
    else hue_temp = set_color_component_from_specific_component("hue", new_colour.hue(), new_hue, start, end) ;
    new_colour = vec4(hue_temp, new_colour.y, new_colour.z, new_colour.w)  ;
  }
  public void set_saturation(int new_saturation, int start, int end, boolean use_new_colour) {
    float saturation_temp ;
    if(!use_new_colour) saturation_temp = set_color_component_from_specific_component("saturation", colour.sat(), new_saturation, start, end) ;
    else saturation_temp = set_color_component_from_specific_component("saturation", new_colour.sat(), new_saturation, start, end) ;
    new_colour = vec4(new_colour.x, saturation_temp, new_colour.z, new_colour.w)  ;
  }
  public void set_brightness(int new_brightness, int start, int end, boolean use_new_colour) {
    float brightness_temp ;
    if(!use_new_colour) brightness_temp = set_color_component_from_specific_component("brightness", colour.bri(), new_brightness, start, end) ;
    else brightness_temp = set_color_component_from_specific_component("brightness", new_colour.bri(), new_brightness, start, end) ;
    new_colour = vec4(new_colour.x, new_colour.y, brightness_temp, new_colour.w)  ;
  }
  // RGB change
  public void set_red(int new_red, int start, int end, boolean use_new_colour) {
    float red_temp ;
    if(!use_new_colour) red_temp = set_color_component_from_specific_component("red", colour.red(), new_red, start, end) ;
    else red_temp = set_color_component_from_specific_component("red", new_colour.red(), new_red, start, end) ;
    new_colour = vec4(red_temp, new_colour.y, new_colour.z, new_colour.w)  ;
  }
  public void set_green(int new_green, int start, int end, boolean use_new_colour) {
    float green_temp ;
    if(!use_new_colour) green_temp = set_color_component_from_specific_component("green", colour.gre(), new_green, start, end) ;
    else green_temp = set_color_component_from_specific_component("green", new_colour.gre(), new_green, start, end) ;
    new_colour = vec4(new_colour.x, green_temp, new_colour.z, new_colour.w)  ;
  }
  public void set_blue(int new_blue, int start, int end, boolean use_new_colour) {
    float blue_temp ;
    if(!use_new_colour) blue_temp = set_color_component_from_specific_component("blue", colour.blu(), new_blue, start, end) ;
    else blue_temp = set_color_component_from_specific_component("blue", new_colour.blu(), new_blue, start, end) ;
    new_colour = vec4(new_colour.x, new_colour.y, blue_temp, new_colour.w)  ;
  }

  // ALPHA change
  public void set_alpha(int new_alpha, int start, int end, boolean use_new_colour) {
    float alpha_temp ;
    if(!use_new_colour) alpha_temp = set_color_component_from_specific_component("alpha", colour.alp(), new_alpha, start, end) ;
    else alpha_temp = set_color_component_from_specific_component("alpha", new_colour.alp(), new_alpha, start, end) ;
    new_colour = vec4(new_colour.x, new_colour.y, new_colour.z, alpha_temp)  ;
  }



  // INTERNAL method to change color
  public float set_color_component_from_specific_component (String which_component, float original_component, int new_component, int start_range, int end_range) {
    if (start_range < end_range ) {
      if(original_component >= start_range && original_component <= end_range) original_component = new_component ; 
    } else if (start_range > end_range) {
      if( (original_component >= start_range && original_component <= roof(which_component)) || original_component <= end_range) { 
        original_component = new_component ;
      }
    }        
    return original_component ;
  }
  
  //
  public float roof(String which_component) {
    float roof = 1 ;
    switch(which_component) {
      case "HUE" : roof = g.colorModeX ; break ; 
      case "SATURATION" : roof = g.colorModeY ; break ; 
      case "BRIGHTNESS" : roof = g.colorModeZ ; break ; 
      case "RED" : roof = g.colorModeX ; break ; 
      case "GREEN" : roof = g.colorModeY ; break ; 
      case "BLUE" :  roof = g.colorModeZ ; break ;
      case "ALPHA" :  roof = g.colorModeA ; break ; 

      case "hue" :  roof = g.colorModeX ; break ; 
      case "saturation" :  roof = g.colorModeY ; break ; 
      case "brightness" :  roof = g.colorModeZ ; break ;  
      case "red" :  roof = g.colorModeX ; break ; 
      case "green" :  roof = g.colorModeY ; break ; 
      case "blue" :  roof = g.colorModeZ ; break ;
      case "alpha" :  roof = g.colorModeA ; break ; 

      case "Hue" :  roof = g.colorModeX ; break ;  
      case "Saturation" :  roof = g.colorModeY ; break ;  
      case "Brightness" :  roof = g.colorModeZ ; break ; 
      case "Red" :  roof = g.colorModeX ; break ; 
      case "Green" :  roof = g.colorModeY ; break ; 
      case "Blue" :  roof = g.colorModeZ ; break ; 
      case "Alpha" :  roof = g.colorModeA ; break ;
    }
    return roof ;
  }
}

















/**
CLOUD
v 0.3.4
*/
class Cloud extends Pix {
  int num ;
  int time_count = Integer.MIN_VALUE;
  float tempo_ref = .001f ;
  float tempo = .001f ;
  String behavior = "RADIUS";
  vec3 [] coord;
  int type = r.CARTESIAN ;
  int distribution;
  String renderer_dimension;
  float radius = 1;
  vec3 orientation;

  float angle_growth;
  float dist_growth ;

  boolean polar_is;
  float dist;
  int spiral_rounds;

  vec2 range;


  public Cloud(PApplet p5,int num, String renderer_dimension) {
    super(p5);
    init_mother_arg();
    this.num = num ;
    coord = new vec3[num];
    choice_renderer_dimension(renderer_dimension);
  }

  protected void init() {
    if(renderer_dimension == P2D) {
      cartesian_pos_2D(dist) ; 
    } else {
      if(polar_is) {
        polar_pos_3D(); 
      } else {
        cartesian_pos_3D(); 
      }
    }
  }

  /**
  SET
  */
  public void set_distribution(int distribution) {
    this.distribution = distribution;
  }
  

  
  float angle_step ;
  protected void set_angle_step(float angle_step) {
    if(distribution == ORDER && !polar_is) {
      this.angle_step = angle_step;
    } else {
      printErrTempo(180, "class Cloud, method angle_step() must be used in Cartesian rendering and with ORDER distribution");
    }
  }







  protected void set_growth(float angle_growth) {
    if(this.type == r.CARTESIAN && this.distribution == r.ORDER && this.renderer_dimension.equals(P2D)) {
      this.angle_growth = angle_growth ;
    } else {
      printErrTempo(180, "class CLOUD method growth() work only int type == r.CARTESIAN & int distribution = r.ORDER & String renderer_dimension P2D");
    }
  }


  protected void cartesian_pos_2D(float dist) {
    float angle = TAU / num ;
    if(angle_step != 0) {
      angle = angle_step / num ;
    }

    if(angle_growth != 0) {
      dist_growth += angle_growth;
      angle += dist_growth;
    }

    float tetha ;
    for(int i = 0 ; i < num ; i++ ) {
      if(distribution == r.ORDER) {
        tetha = dist +(angle *i);
        coord[i] = vec3(cos(tetha),sin(tetha), 0 ) ; 
      } else {
        tetha = dist + random(-PI, PI) ;
        coord[i] = vec3(cos(tetha),sin(tetha), 0 ) ;
      }
    }
  }

  protected void cartesian_pos_3D() {
    if(distribution == ORDER) {
      // step and root maybe must be define somewhere ????
      float step = PI * (3 - sqrt(5.f)) ; 
      float root = PI ;
      if(angle_step != 0) {
        step = angle_step * (3 - sqrt(5.f)) ;
        root = angle_step;
      }
      coord = list_cartesian_fibonacci_sphere(num, step, root);
    } else {
      for(int i = 0 ; i < coord.length ; i++ ) {
        float tetha  = random(-PI, PI) ;
        float phi  = random(-TAU, TAU) ;
        coord[i] = vec3(cos(tetha) *cos(phi),
                        cos(tetha) *sin(phi), 
                        sin(tetha) ) ; 
      }
    }
  }


  protected void polar_pos_3D() {
    float step = TAU ;
    if(distribution == ORDER) {
      for (int i = 0; i < coord.length ; i++) {      
        coord[i] = vec3() ;
        coord[i].x = distribution_polar_fibonacci_sphere(i, num, step).x ;
        coord[i].y = distribution_polar_fibonacci_sphere(i, num, step).y ;
        coord[i].z = 0  ;
      }
    } else {
      for (int i = 0; i < coord.length ; i++) {
        int which = floor(random(num)) ;
        coord[i] = vec3() ;
        coord[i].x = distribution_polar_fibonacci_sphere(which, num, step).x ;
        coord[i].y = distribution_polar_fibonacci_sphere(which, num, step).y ;
        coord[i].z = 0  ;
      }
    }
  }






  
  protected void rotation(float rotation, boolean static_rot) {
    if(!polar_is && this.renderer_dimension == P2D) {
      if(static_rot) {
        dist = rotation ; 
      } else {
        dist += rotation;
      }
    } else {
      printErrTempo(180, "Class Pix method rotation() is available only in P2D rendering and for sub Class Cloud_2D, for Cloud_3D use rotation_x(), rotation_y() or rotation_z()");
    }
  }








  protected void choice_renderer_dimension(String dimension) {
    if(dimension == P3D) {
      this.renderer_dimension = P3D ;
    } else {
      this.renderer_dimension = P2D ;
    }
  }


  protected void give_points_to_costume_2D() {
    for(int i  = 0 ; i < coord.length ;i++) {
      if(ratio_costume_size != Float.MAX_VALUE) {
        set_ratio_costume_size(ratio_costume_size);
      }
      costume.draw(coord[i],size,vec3(0,0,costume_angle));
    }
  }

  public void set_radius(float radius) {
    this.radius = radius;
  }

  public void set_tempo(int n) {
    this.tempo = tempo_ref *n ;
  }

  public void set_time_count(int count) {
    time_count = count;
  }

  public vec3 [] list() {
    return coord;   
  }



  public void set_behavior(String behavior) {
    this.behavior = behavior ;
  }
  
  public void spiral(int spiral_rounds) {
    this.spiral_rounds = spiral_rounds;
    if(type != r.CARTESIAN) {
      printErrTempo(180, "class Cloud method spiral() is available only for type r.CARTESIAN, not for type r.POLAR");
    }
  }


  /**
  void range();
  Use with the bahavior, it's ratio mult for the radius
  */
  public void range(vec2 range) {
    range(range.x,range.y);
  }
  public void range(float min, float max) {
    if(range == null) {
      range = vec2(min, max);
    } else {
      range.set(min,max);
    }
  }

  // distribution surface polar
  protected void distribution_surface_polar() {
    if(behavior != "RADIUS") {
      radius = abs(distribution_behavior(range,radius)) ;
    }
  }

 // distribution surface cartesian
 protected void distribution_surface_cartesian() {
    float radius_temp = radius;
    
    if(spiral_rounds > 0) {
      int round = 0 ;
      if(range == null) {
        range = vec2(0,1);
      }
      float height_step = ((range.y -range.x) /coord.length) /spiral_rounds;
      float floor = (range.y -range.x) / spiral_rounds;
      for (int i = 0 ; i < coord.length ; i++) {       
        float range_in = range.x + (height_step *i) + (floor *round) ;
        
        if(behavior != "RADIUS") {
          vec2 temp_range = range.copy();
          temp_range.set(range_in,range.y);
          radius_temp = distribution_behavior(temp_range,radius);
        } else {
          radius_temp = radius;
          radius_temp *= range_in ;
        }
        coord[i].mult(radius_temp) ;
        coord[i].add(pos) ;
        round ++ ;
        if(round >= spiral_rounds) round = 0 ;
      }   
    } else {
      for (int i = 0 ; i < coord.length ; i++) {
        if(behavior != "RADIUS") {
          radius_temp = distribution_behavior(range,radius);
        }
        coord[i].mult(radius_temp) ;
        coord[i].add(pos) ;
      }
    }
  }
  
  /**
  distribution behavior
  */
  // internal method
  private float distribution_behavior(vec2 range, float radius) {
    float normal_distribution = 1 ;
    
    // rules
    float root_1 = 0 ;
    float root_2 = 0 ;
    float root_3 = 0 ;
    float root_4 = 0 ;
     if(behavior.contains(RANDOM)) {
      root_1 = random(1) ;
      if(behavior.contains("2") || behavior.contains("3") || behavior.contains("4")|| behavior.contains("SPECIAL")) {
        root_2 = random(1) ;
        root_3 = random(1) ;
        root_4 = random(1) ;
      }
    }

    float t = 0 ;
    if(behavior.contains(SIN) || behavior.contains(COS)) {
      if(time_count == Integer.MIN_VALUE) {
        t = frameCount *tempo; 
      } else t = time_count *tempo;   
    }

    float factor_1_2 = 1.2f;
    float factor_0_5 = .5f;
    float factor_12_0 = 12.f;
    float factor_10_0 = 10.f;
    
    // distribution
    if(behavior == RANDOM) normal_distribution = root_1;
    else if(behavior == RANDOM_ROOT) normal_distribution = sqrt(root_1);
    else if(behavior == RANDOM_QUARTER) normal_distribution = 1 -(.25f *root_1);
    
    else if(behavior == RANDOM_2) normal_distribution = root_1 *root_2;

    else if(behavior == RANDOM_3) normal_distribution = root_1 *root_2 *root_3;

    else if(behavior == RANDOM_4) normal_distribution = root_1 *root_2 *root_3 *root_4;
    else if(behavior == RANDOM_X_A) normal_distribution = .25f *(root_1 +root_2 +root_3 +root_4);
    else if(behavior == RANDOM_X_B) {
      float temp = root_1 -root_2 +root_3 -root_4;
      if(temp < 0) temp += 4 ;
      normal_distribution = .25f *temp;
    }

    else if(behavior == SIN) normal_distribution = sin(t);
    else if(behavior == COS) normal_distribution = cos(t);
    else if(behavior == "SIN_TAN") normal_distribution = sin(tan(t)*factor_0_5);
    else if(behavior == "SIN_TAN_COS") normal_distribution = sin(tan(cos(t) *factor_1_2));
    else if(behavior == "SIN_POW_SIN") normal_distribution = sin(pow(8.f,sin(t)));
    else if(behavior == "POW_SIN_PI") normal_distribution = pow(sin((t) *PI), factor_12_0);
    else if(behavior == "SIN_TAN_POW_SIN") normal_distribution = sin(tan(t) *pow(sin(t),factor_10_0));

    // result
    if(range != null) {
      //return radius *(map(normal_distribution,-1,1,range.x,range.y)); // classic

      float max = map(normal_distribution, -1, 1,-range.y,range.y);
      return radius *(map(max,-1,1,range.x,1));

      // return radius *(map(normal_distribution,-range.x,range.x,range.x,range.y)); // interesting
    } else  {
      return radius *normal_distribution;
    }
  }

  /**
  GET
  */
  public float get_growth() {
    return dist_growth;
  }


  public void growth_size(float dist) {
    dist_growth = dist ;
  }

  public float get_rotation() {
    return dist ;
  }

  public int length() {
    return num;
  }
}















/**
CLOUD 2D
*/
class Cloud_2D extends Cloud {
 
  public Cloud_2D(PApplet p5,int num) {
    super(p5,num,P3D);
    // choice_renderer_dimension(renderer_dimension);
    this.distribution = ORDER;
    orientation = vec3(0,PI/2,0); 
    init() ;
  }

  public Cloud_2D(PApplet p5,int num, int distribution) {
    super(p5,num,P2D);
    this.distribution = distribution ;
    init();
  }

  public Cloud_2D(PApplet p5,int num, int distribution, float angle_step) {
    super(p5,num,P2D);
    this.distribution = distribution ;
    set_angle_step(angle_step);
    init();
  }


  
  public void update() {
    cartesian_pos_2D(dist);
    distribution_surface_cartesian();
  }
  


  public void show() {
    give_points_to_costume_2D();
  }
}











/**
CLOUD 3D
*/
class Cloud_3D extends Cloud {

  boolean rotation_x, rotation_y, rotation_z;
  float dist_x, dist_y, dist_z;

  boolean rotation_fx_x, rotation_fx_y, rotation_fx_z;
  float dist_fx_x, dist_fx_y, dist_fx_z;
 
  public Cloud_3D(PApplet p5, int num) {
    super(p5,num,P3D);
    // choice_renderer_dimension(renderer_dimension);
    this.distribution = ORDER;
    this.orientation = vec3(0,PI/2,0); 
    init() ;
  }

  /*
  Use this constructor if you want build a cartesian sphere with a real coord in the 3D space, you must ask a "POINT" costume
  */

  public Cloud_3D(PApplet p5, int num, String renderer_dimension) {
    super(p5, num, renderer_dimension);
    this.distribution = ORDER;
    this.orientation = vec3(0,PI/2,0); 
    init();
  }


  public Cloud_3D(PApplet p5, int num, String renderer_dimension, int distribution) {
    super(p5, num, renderer_dimension);
    this.distribution = distribution ;
    this.orientation = vec3(0,PI/2,0); 
    init();
  }

  public Cloud_3D(PApplet p5, int num, String renderer_dimension, int distribution, int type) {
    super(p5,num, renderer_dimension);
    this.type = type ;
    if(renderer_dimension == P2D && type == r.POLAR) {
      printErr("class Cloud_3D cannot work good with 2D String renderer_dimension and type int r.POLAR");
    }

    this.distribution = distribution ;
    this.orientation = vec3(0,PI/2,0);
    if(this.type == r.POLAR) {
      polar(true);
    } else {
      polar(false);
    }
    init() ;
  }

  public Cloud_3D(PApplet p5, int num, String renderer_dimension, float step_angle) {
    super(p5,num, renderer_dimension);
    polar(false);
    this.distribution = r.ORDER ;
    this.orientation = vec3(0,PI/2,0);
    set_angle_step(step_angle);
    /*
    if(type == r.POLAR) {
      polar(true);
    } else {
      polar(false);
    }
    */
    init() ;
  }



  // change orientation
  public void orientation(vec3 orientation) {
    orientation(orientation.x, orientation.y, orientation.z);
  }

  public void orientation_x(float orientation_x) {
    orientation(orientation.x, 0,0);
  }

  public void orientation_y(float orientation_y) {
    orientation(0, orientation.y,0);
  }

  public void orientation_z(float orientation_z) {
    orientation(0,0,orientation.z);
  }

  public void orientation(float x, float y, float z) {
     if(!polar_is) {
      printErrTempo(180, "void orientation() class Cloud work only with type r.POLAR");
    }
    this.orientation = vec3(x,y,z) ;
  }


  // rotation
  public void rotation_x(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_x() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_x = true ;
      if(static_rot) dist_x = rot ; else dist_x += rot ;
    }
  }

  public void rotation_y(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_y() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_y = true ;
      if(static_rot) dist_y = rot ; else dist_y += rot ;
    }
  }

  public void rotation_z(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_z() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_z = true ;
      if(static_rot) dist_z = rot ; else dist_z += rot ;
    }
  }

  // rotation FX
  public void rotation_fx_x(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_fx_x() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_fx_x = true ;
      if(static_rot) dist_fx_x = rot ; else dist_fx_x += rot ;
    }
  }
  


  public void rotation_fx_y(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_fx_y() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_fx_y = true ;
      if(static_rot) dist_fx_y = rot ; else dist_fx_y += rot ;
    }
  }

  public void rotation_fx_z(float rot, boolean static_rot) {
    if(!polar_is) {
      printErrTempo(180, "class Cloud_3D method rotation_fx_z() is not available for cartesian_2D distribution, only in polar distribution");
    } else {
      rotation_fx_z = true ;
      if(static_rot) dist_fx_z = rot ; else dist_fx_z += rot ;
    }
  }


  public void ring(float rot, boolean static_rot) {
    rotation_fx_y(rot, static_rot);
  }

  public void helmet(float rot, boolean static_rot) {
    rotation_fx_z(rot, static_rot);
  }





  /**
  * distribution_surface
  */

  public void polar(boolean polar_is) {
    this.polar_is = polar_is;
  }

  public void update() {
    if(polar_is) {
      distribution_surface_polar() ; 
    } else {
      cartesian_pos_3D();
      distribution_surface_cartesian() ;
    }
  }
  


  /**
  * Show
  */
  public void show() {
    if (renderer_P3D() && renderer_dimension == P3D && polar_is) {
      give_points_to_costume_3D(); 
    } else {
      give_points_to_costume_2D();
    }
  }

  protected void give_points_to_costume_3D() {
    if(!polar_is) {
      for(int i  = 0 ; i < coord.length ;i++) {
        // method from mother class need pass info arg
        if(ratio_costume_size != Float.MAX_VALUE) {
          set_ratio_costume_size(ratio_costume_size);
        }
        costume.draw(coord[i],size,vec3(0,0,costume_angle));
      }
    } else {
      // method from here don't need to pass info about arg
      costume_3D_polar(dist) ;
    }
  }
  
  // internal
  protected void costume_3D_polar(float dist) {
   start_matrix() ;
   translate(pos) ;
    for(int i = 0 ; i < num ;i++) {
      start_matrix() ;
      /**
      super effect
      float rot = (map(mouseX,0,width,-PI,PI)) ;
      dir_pol[i].y += rot ;
      */
      if(rotation_x) rotateX(dist_x); 
      if(rotation_y) rotateY(dist_y); 
      if(rotation_z) rotateZ(dist_z); 
      // vec2 coord_temp = vec2(coord[i].x,coord[i].y).add(dist);
      vec2 coord_temp = vec2(coord[i].x,coord[i].y);
      rotateYZ(coord_temp) ;
      
      if(rotation_fx_x) rotateX(dist_fx_x); // interesting
      if(rotation_fx_y) rotateY(dist_fx_y); // interesting
      if(rotation_fx_z) rotateZ(dist_fx_z); // interesting

      vec3 pos_primitive = vec3(radius,0,0) ;
      translate(pos_primitive) ;

      start_matrix();
      rotateXYZ(orientation) ;
      vec3 pos_local_primitive = vec3();

      if(ratio_costume_size != Float.MAX_VALUE) {
        set_ratio_costume_size(ratio_costume_size);
      }
      costume.draw(pos_local_primitive, size,vec3(0,0,costume_angle));
      stop_matrix() ;
      stop_matrix() ;
    }
    stop_matrix() ;
  }
}



















/**
Class pixel Basic
v 0.0.3
*/
class Pixel extends Pix  {
  // CONSTRUCTOR
  
  // PIXEL 2D
  public Pixel(PApplet p5, vec2 pos_2D) {
    super(p5);
    init_mother_arg() ;
    this.pos = new vec3(pos_2D.x,pos_2D.y, 0)  ;
  }

  public Pixel(PApplet p5, vec2 pos_2D, vec2 size_2D) {
    super(p5);
    init_mother_arg() ;
    this.pos = new vec3(pos_2D.x,pos_2D.y, 0)  ;
    this.size = new vec3(size_2D.x,size_2D.y,0) ; ;
  }
  
  // Constructor plus color components
  public Pixel(PApplet p5, vec2 pos_2D, vec4 color_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = new vec3(pos_2D.x,pos_2D.y, 0)  ;
    colour = vec4(color_vec) ;
    new_colour = vec4(colour) ;
    
  }

  public Pixel(PApplet p5, vec2 pos_2D, vec2 size_2D, vec4 color_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = new vec3(pos_2D.x,pos_2D.y, 0)  ;
    this.size = new vec3(size_2D.x,size_2D.y,0) ;
    colour = vec4(color_vec) ;
    new_colour = vec4(colour) ;
  }


 

  //PIXEL 3D
  public Pixel(PApplet p5, vec3 pos_3D) {
    super(p5);
    init_mother_arg() ;
    this.pos = pos_3D  ;
  }

  public Pixel(PApplet p5, vec3 pos_3D, vec3 size_3D) {
    super(p5);
    init_mother_arg() ;
    this.pos = pos_3D ;
    this.size = size_3D ;
  }
  // constructor plus color component
  public Pixel(PApplet p5, vec3 pos_3D,  vec4 color_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = pos_3D ;
    colour = color_vec.copy() ;
    new_colour = colour.copy() ;
  }
  
  public Pixel(PApplet p5, vec3 pos_3D, vec3 size_3D, vec4 color_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = pos_3D ;
    this.size = size_3D ;
    colour = color_vec.copy() ;
    new_colour = colour.copy() ;
  }


  
  //RANK PIXEL CONSTRUCTOR
  public Pixel(PApplet p5, int rank) {
    super(p5);
    init_mother_arg() ;
    this.rank = rank ;
  }
  
  public Pixel(PApplet p5, int rank, vec2 grid_position_2D) {
    super(p5);
    init_mother_arg() ;
    this.rank = rank ;
    this.grid_position = new vec3(grid_position_2D.x,grid_position_2D.y,0) ;
  }
  public Pixel(PApplet p5, int rank, vec3 grid_position) {
    super(p5);
    init_mother_arg() ;
    this.rank = rank ;
    this.grid_position = grid_position ;
  }
  
  // METHOD

  // set summit
  private void set_summits(int summits) {
    if(summits == 1) this.costume.set_type(POINT_ROPE);
    else if(summits == 2) this.costume.set_type(LINE_ROPE);
    else if(summits == 3) this.costume.set_type(TRIANGLE_ROPE);
    else if(summits == 4) this.costume.set_type(SQUARE_ROPE);
    else if(summits == 5) this.costume.set_type(PENTAGON_ROPE);
    else if(summits == 6) this.costume.set_type(HEXAGON_ROPE);
    else if(summits == 7) this.costume.set_type(HEPTAGON_ROPE);
    else if(summits == 8) this.costume.set_type(OCTOGON_ROPE);
    else if(summits == 9) this.costume.set_type(NONAGON_ROPE);
    else if(summits == 10) this.costume.set_type(DECAGON_ROPE);
    else if(summits == 11) this.costume.set_type(HENDECAGON_ROPE);
    else if(summits == 12) this.costume.set_type(DODECAGON_ROPE);
    else if(summits > 12) this.costume.set_type(ELLIPSE_ROPE);
  }



  // show
  public void show() {
    if(ratio_costume_size != Float.MAX_VALUE) {
      set_ratio_costume_size(ratio_costume_size);
    }
    if (renderer_P3D()) {
      this.costume.draw(pos,size,dir);
    } else {
      this.costume.draw(pos,size,vec3(0,0,costume_angle));
    }
  }
}




























/**
PIXEL MOTION 0.0.2
*/
class Pixel_motion extends Pix  {
    /**
    Not sure I must keep the arg field and life
  */
  float field = 1.0f ;
  float life = 1.0f ;

  // CONSTRUCTOR 2D
  Pixel_motion(PApplet p5, vec2 pos_2D, float field, int colour_int) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos_2D) ;
    this.field = field ;
    colour = int_color_to_vec4_color(colour_int) ;
    new_colour = vec4(colour) ;
  }

  Pixel_motion(PApplet p5, vec2 pos_2D, float field, vec4 colour_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos_2D) ;
    this.field = field ;
    colour = vec4(colour_vec) ;
    new_colour = vec4(colour) ;
  }

  Pixel_motion(PApplet p5, vec2 pos_2D, float field) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos_2D) ;
    this.field = field ;
  }
  
  // CONSTRUCTOR 3D
  Pixel_motion(PApplet p5, vec3 pos, float field, int colour_int) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos) ;
    this.field = field ;
    colour = int_color_to_vec4_color(colour_int) ;
    new_colour = vec4(colour) ;
  }

  Pixel_motion(PApplet p5, vec3 pos, float field, vec4 colour_vec) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos) ;
    this.field = field ;
    colour = vec4(colour_vec) ;
    new_colour = vec4(colour) ;
  }

  Pixel_motion(PApplet p5, vec3 pos, float field) {
    super(p5);
    init_mother_arg() ;
    this.pos = vec3(pos) ;
    this.field = field ;
  }


  


  /**
  Motion ink
  */
  public void motion_ink_2D() {
    int size_field = 1 ;
    float speed_dry = 0 ;
    motion_ink_2D(size_field, speed_dry) ;
  }

  public void motion_ink_2D(float speed_dry) {
    int size_field = 1 ;
    motion_ink_2D(size_field, speed_dry) ;
  }

  public void motion_ink_2D(int size_field) {
    float speed_dry = 0 ;
    motion_ink_2D(size_field, speed_dry) ;
  }


  // with external var
  public void motion_ink_2D(int size_field, float speed_dry) {
    if (field > 0 ) { 
      if(speed_dry != 0 ) field -= abs(speed_dry) ;
      float rad;
      float angle;
      rad = random(-1,1) *field *size_field;
      angle = random(-1,1) *TAU;
      pos.x += rad * cos(angle);
      pos.y += rad * sin(angle);
    }
  }



  // 3D
  public void motion_ink_3D() {
    int size_field = 1 ;
    float speed_dry = 0 ;
    motion_ink_3D(size_field, speed_dry) ;
  }

  public void motion_ink_3D(float speed_dry) {
    int size_field = 1 ;
    motion_ink_3D(size_field, speed_dry) ;
  }

  public void motion_ink_3D(int size_field) {
    float speed_dry = 0 ;
    motion_ink_3D(size_field, speed_dry) ;
  }

  // with external var
  public void motion_ink_3D(int size_field, float speed_dry) {
    if (field > 0 ) { 
      if(speed_dry != 0 ) field -= abs(speed_dry) ;
      float rad;
      float angle;
      rad = random(-1,1) *field *size_field;
      angle = random(-1,1) *TAU;
      pos.x += rad * cos(angle);
      pos.y += rad * sin(angle);
      pos.z += rad * cos(angle);
    }
  }




  


  
  
  
  /**
  This part must be refactoring, is really a confusing way to code
  For example why we use PImage ????
  Why do we use 'wind', can't we use 'motion' instead ????
  
  //UPDATE POSITION with the wind
  void update_position_2D(PVector effectPosition, PImage pic) {
    vec2 dir_2D = norm_dir("DEG",effectPosition.x) ;
    
    velocity_2D = vec2 (  1.0 *dir_2D.x *effectPosition.y  + random(-effectPosition.z) ,
                      1.0 *dir_2D.y *effectPosition.y  + random(-effectPosition.z))   ;
    pos_2D.add(wind_2D) ;
    //keep the pixel in the scene
    if (pos_2D.x< 0)          pos_2D.x= pic.width;
    if (pos_2D.x> pic.width)  pos_2D.x=0;
    if (pos_2D.y< 0)          pos_2D.y= pic.height;
    if (pos_2D.y> pic.height) pos_2D.y=0;
  }
  
  
  
  //return position with display size
  vec2 position_2D(PVector effectPosition, PImage pic) {
    vec2 dir_2D = norm_dir("DEG",effectPosition.x) ;

    new_pos_2D = pos_2D.copy() ;
    
    direction_2D = vec2 (  1.0 *dir_2D.x *effectPosition.y  + random(-effectPosition.z, effectPosition.z) ,
                      1.0 *dir_2D.y *effectPosition.y  + random(-effectPosition.z, effectPosition.z))   ;
                  
    new_pos_2D.add(wind_2D) ;
    //keep the pixel in the scene
    if (new_pos_2D.x< 0)          new_pos_2D.x= pic.width;
    if (new_pos_2D.x> pic.width)  new_pos_2D.x=0;
    if (new_pos_2D.y< 0)          new_pos_2D.y= pic.height;
    if (new_pos_2D.y> pic.height) new_pos_2D.y=0;
    
    return new_pos_2D ;
  }
  */
  /**
  End of method who must be refactoring
  */
}
/**
SOUNDA Rope
* for SOUNDA > SOUND-Analyze
* v 1.5.2
* Copyleft (c) 2017-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Sound_rope
* Processing 3.5.3
* Rope Library 0.4.0
* Class Sounda use Minim library
* more information about this library
* @author Damien Quartz
* @see https://github.com/ddf/Minim
*/



/**
Class Sounda
v 0.2.1
*/
public class Sounda implements rope.core.R_Constants {
  boolean info = false;
  private int analyze_length;
  Section section[];
  // library stuff
  
  
  Minim minim;
  AudioInput input;
  AudioBuffer source_buffer;
  FFT fft;
  String warning_input = ("there is no sound input available, check if any source is connected");
  

  public Sounda() {}

  public Sounda(int analyze_length) {
    this.analyze_length = analyze_length;
    minim = new Minim(this);
    input = minim.getLineIn(Minim.STEREO, analyze_length);
  }

  public void info(boolean info) {
    this.info = info;
    if(transient_detection != null) {
      transient_detection.info(this.info);
    }
  }






  /**
  stop minim
  */
  public void stop() {
    input.close() ;
    minim.stop() ;
  }

  /**
  MISC
  v 0.2.0
  */
  public float get_right() {
    float sum = 0 ;
    for(int i = 0 ; i < buffer_size() ; i++) {
      sum += get_right(i);
    }
    return sum / buffer_size();
  }

  public float get_left() {
    float sum = 0 ;
    for(int i = 0 ; i < buffer_size() ; i++) {
      sum += get_left(i);
    }
    return sum / buffer_size();
  }

  public float get_mix() {
    float sum = 0 ;
    for(int i = 0 ; i < buffer_size() ; i++) {
      sum += get_mix(i);
    }
    return sum / buffer_size();
  }


  public float get_right(int target_sample) {
    if(input != null) {
      if(target_sample < buffer_size()) {
         return input.right.get(target_sample);
      } else {
        printErrTempo(60, "method get_right("+target_sample+"): no target match in buffer, instead target 0 is use");
        return input.right.get(0);
      }
    } else {
      return 0;
    }
  }

  public float get_left(int target_sample) {
    if(input != null) {
      if(target_sample < buffer_size()) {
        return input.left.get(target_sample);
      } else {
        printErrTempo(60, "method get_left("+target_sample+"): no target match in buffer, instead target 0 is use");
        return input.left.get(0);
      }
    } else {
      return 0;
    }  
  }

  public float get_mix(int target_sample) {
    if(input != null) {
      if(target_sample < buffer_size()) {
        return input.mix.get(target_sample);
      } else {
        printErrTempo(60, "method get_mix("+target_sample+"): no target match in buffer, instead target 0 is use");
        return input.mix.get(0);
      }
    } else {
      return 0;
    }
  }

  public int buffer_size() {
    return analyze_length;
  }


  /**
  time track
  v 1.1.1
  */
  int time_track_elapse ;
  float no_sound_since ;
  float threshold_spectrum_sensibility = .6f;
  int time_to_reset_time_track = 20;

  public void set_time_track(float threshold, int time_to_reset) {
    threshold_spectrum_sensibility = threshold;
    time_to_reset_time_track = time_to_reset;
  }



  public float get_time_track() {
    float result = 0;
    if(get_spectrum_sum() < threshold_spectrum_sensibility) {
      no_sound_since += .1f;
    } else {
      no_sound_since = 0;
    }

    if(no_sound_since > time_to_reset_time_track) {
      time_track_elapse = 0;
      result = 0 ;
    } else {
      time_track_elapse += millis()%10 ;
      result = time_track_elapse *.01f ;
    }

    result = round(result *10.0f) /10.0f ;
    return result;
  }



  public boolean sound_is() {
    if(get_time_track() > .2f ) return true ; else return false;
  }




  /**
  set buffer
  */
  public void audio_buffer(int canal) {
    if(input != null) {
      switch(canal) {
        case RIGHT :
          source_buffer = input.right ;
          break ;
        case LEFT :
          source_buffer = input.left ;
          break ;
        case MIX :
          source_buffer = input.mix ;
          break ;
        default :
          source_buffer = input.mix ;
      }
    } 
  }





  /**
  SPECTRUM
  v 0.0.4
  */
  float[] spectrum;
  int spectrum_bands = 0 ;
  float scale_spectrum = .1f ;
  public void set_spectrum(int num, float scale) {
    if(num > analyze_length) {
      spectrum_bands = analyze_length ;
    } else {
      spectrum_bands = num ;
    }

    spectrum = new float [spectrum_bands];
    if(input != null) {
      fft = new FFT(input.bufferSize(), input.sampleRate());
      fft.linAverages(spectrum_size());
    } else {
      printErr("void set_spectrum(): "+warning_input);
    }


    scale_spectrum = scale;
  }

  public void update_spectrum(boolean update_is) {
    if(input != null && update_is) {
      if(source_buffer == null) {
        println("void spectrum(): there is no AudioBuffer selected, by default AudioBuffer input.mix is used");
        source_buffer = input.mix;
      }
      fft.forward(source_buffer);
      for(int i = 0 ; i < spectrum_size();i++) {
        fft.scaleBand(i,scale_spectrum);
      }
    }   
  }

  public float [] get_spectrum() {
    float [] f = new float[spectrum_size()];
    for(int i = 0 ; i < spectrum_size() ; i++) {
      f[i] = fft.getBand(i);
    }
    return f;
  }


  public float get_spectrum(int band_target){
    if(input != null && band_target < spectrum_size()) {
      return fft.getBand(band_target);
    } else return Float.NaN;
  }

  public int spectrum_size() {
    return spectrum_bands;
  }


  public float get_spectrum_sum() {
    float result = 0 ;
    for (int i = 0 ; i < spectrum_size() ; i++) {
      result += get_spectrum(i);
    }
    return result ;
  }

  public float get_spectrum_average() {
    return get_spectrum_sum() / spectrum_size();
  }


  public float get_spectrum_beat_sum(int beat_target) {
    float result = 0 ;
    for (int i = get_section_in(beat_target) ; i < get_section_out(beat_target) ; i++) {
      result += get_spectrum(i);
    }
    return result ;
  }


  public float get_spectrum_beat_average(int beat_target) {
    return get_spectrum_beat_sum(beat_target) / spectrum_size();
  }





  /**
  SECTION
  */
  // int num_section ;
  public void set_section(Section... section) {
    this.section = section;
  }

  public void set_section(ivec2[] in_out) {
    int len = buffer_size();
    set_section(len, in_out);
  }

  public void set_section(int len, ivec2[] in_out) {
    int num_section = in_out.length;
    section = new Section[num_section];
    // check the max value of section
    for(int i = 0 ; i < num_section ; i++) {
      if(in_out[i].y > len) {
        in_out[i].y = len;
        in_out[i].x = len -1;
        println("'OUT' of beat is upper of spectrum, the value beat 'y' max analyze is cap to the spectrum, and 'x' to spectrum minus '1") ;
      }
      if(in_out[i].x > len) {
        in_out[i].y = len;
        in_out[i].x = len -1;
        println("'IN' of beat is upper of spectrum, the value beat 'y' max analyze is cap to the spectrum, and 'x' to spectrum minus '1") ;
      }
    }
    for(int i = 0 ; i < num_section ; i++) {
      section[i] = new Section(len,in_out[i].x,in_out[i].y);
    }
  }

  // get beat section
  public int get_section(int band_target) {
    int which_section = -1;
    for(int i = 0 ; i < section.length ;i++) {
      if(band_target > section[i].in && band_target < section[i].out) {
        which_section = i ;
        break;
      }
    }
    if(which_section == -1) {
      println("method get_section(): No section match with the target",band_target,"the method return -1");
    }
    return which_section ;
  }

  public int get_section_in(int section_target) {
    if(section_target < section.length) {
      return section[section_target].in ;
    } else {
      printErr("method get_section_in(): target",section_target,"not found, method return -1");
      return -1;
    }
  }

  public int get_section_out(int section_target) {
    if(section_target < section.length) {
      return section[section_target].out;
    } else {
      printErr("method get_section_out(): target",section_target,"not found, method return -1");
      return -1;
    }
  }

  public int section_size() {
    if(section != null && section.length > 0) {
      return section.length ;
    } else {
      printErr("method section_size(): no array beat found method return -1");
      return -1;
    }
  }

  






  /**
  TRANSIENT DETECTION
  v 0.1.0
  */
  Transient transient_detection;
  public void init_transient(vec2... threshold) {
    if(transient_detection == null) transient_detection = new Transient();
    audio_buffer(MIX);
    buffering();
    transient_detection.set_section(section);
    transient_detection.set_transient_detection(section,threshold);
  }

  public void set_transient(int index, vec2 threshold) {
    transient_detection.set_transient_detection(section,index,threshold);
  }

  // set param transient
  public void set_transient_low_pass(float... low_pass) {
    if(transient_detection != null) {
       if(low_pass.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >=low_pass.length) index = 0;
          transient_detection.set_low_pass(section[i],low_pass[index]);
          index++;
        }
      }
     
    } else {
      printErr("method set_transient_low_pass(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  public void set_transient_smooth_slow(float... smooth_slow) {
    if(transient_detection != null) {
       if(smooth_slow.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >= smooth_slow.length) index = 0;
          transient_detection.set_smooth_slow(section[i],smooth_slow[index]);
        }
      }
    } else {
      printErr("method set_transient_smooth_slow(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  public void set_transient_smooth_fast(float... smooth_fast) {
    if(transient_detection != null) {
       if(smooth_fast.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >= smooth_fast.length) index = 0;
          transient_detection.set_smooth_fast(section[i],smooth_fast[index]);
        }
      }
    } else {
      printErr("method set_transient_smooth_fast(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  public void set_transient_ratio_log(float... ratio_log) {
    if(transient_detection != null) {
      if(ratio_log.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >= ratio_log.length) index = 0;
          transient_detection.set_ratio_log(section[i],ratio_log[index]);
        }
      }
    } else {
      printErr("method set_transient_ratio_transient(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  public void set_transient_threshold_low(float... threshold_low) {
    if(transient_detection != null) {
      if(threshold_low.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >= threshold_low.length) index = 0;
          transient_detection.set_threshold_low(section[i],threshold_low[index]);
        }
      }
    } else {
      printErr("method set_transient_threshold_low(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  public void set_transient_threshold_high(float... threshold_high) {
    if(transient_detection != null) {
      if(threshold_high.length <= section.length) {
        int index = 0;
        for(int i = 0 ; i < section.length ; i++) {
          if(index >= threshold_high.length) index = 0;
          transient_detection.set_threshold_high(section[i],threshold_high[index]);
        }
      }
    } else {
      printErr("method set_transient_threshold_high(): method init_transient() need in to write in first before the other setting methods");
    }
  }

  // get param transient
  public float[] get_transient_low_pass() {
    return transient_detection.get_low_pass();
  }

  public float[] get_transient_smooth_slow() {
    return transient_detection.get_smooth_slow();
  }

  public float[] get_transient_smooth_fast() {
    return transient_detection.get_smooth_fast();
  }

  public float[] get_transient_threshold_low() {
    return transient_detection.get_threshold_low();
  }

  public float[] get_transient_threshold_high() {
    return transient_detection.get_threshold_high();
  }

  public float[] get_transient_ratio_log() {
    return transient_detection.get_ratio_log();
  }

  public boolean transient_is() {
    boolean transient_is = false ;
    buffering();
    for(int i = 0 ; i < transient_detection.section_size() ; i++) {
      if(transient_detection.detection_is(section,i)) {
        transient_is = true;
        break;
      }
    }
    return transient_is;
  }

  public boolean transient_is(int section_target) {
    boolean result = false ;
    buffering();
    if(source_buffer != null) {
      result = transient_detection.detection_is(section,section_target);
    } 
    return result;
  }

  /**
  pass buffer audio to transient class
  */
  private void buffering() {
    if(source_buffer != null) {
      float [] temp = new float[source_buffer.size()];
      for(int i = 0 ; i < temp.length ; i++) {
        temp[i] = source_buffer.get(i);
      }
      transient_detection.buffer(temp);
    }
  }

  public vec2 get_transient_threshold(int section_target, int band_target) {
    return transient_detection.get_transient_threshold(section_target, band_target);
  }

  public vec2 get_transient_threshold(int section_target) {
    if(transient_detection != null) {
      return transient_detection.get_transient_threshold(section_target);
    } else {
      return null;
    }
  }
  







  /**
  BEAT
  v 0.1.2
  */
  /**

  BEAT METHOD work with the band, the band is from Spectrum.
  
  */
  boolean beat_advance_is ;
  boolean [][] beat_band_is ;
 
  // setting
  public void set_beat(float... threshold) {
    ivec2 [] in_out = new ivec2[threshold.length];
    int part = spectrum_size() / in_out.length;
    for(int i = 0 ; i < in_out.length ; i++) {
      in_out[i] = ivec2(i*part,(i+1)*part);
    }
    set_section(in_out);
    int [] id_beat_section = new int [threshold.length];
    for(int i = 0 ; i < id_beat_section.length ; i++) {
      id_beat_section[i]=i;
    }
    set_beat(id_beat_section, threshold);
  }


  public void set_beat(int[] target_beat_section, float... threshold) {
    if(section != null && spectrum !=null) {
      beat_advance_is = true ;
      beat_band_is = new boolean [target_beat_section.length][spectrum_size()];
      // init var
      for(int i = 0 ; i < beat_band_is.length ; i++) {
        if(target_beat_section[i] < section_size()) {
          int target_section = target_beat_section[i];
          section[target_section].set_threshold_beat(threshold[i]);

        } else {
          printErr("method set_beat(): int target_beat_section",target_beat_section[i],"is out of the num os section available");
        }
        for(int k = 0 ; k < beat_band_is[0].length ; k++) {
          beat_band_is[i][k] = false;
        }
      }
      // declare which band must be analyze when there is a beat detection
      for(int i = 0 ; i < section.length ; i++ ) {
        int step = buffer_size() / spectrum_size();
        int in = floor(section[i].in / step);
        int out = floor(section[i].out / step);
        for(int k = in ; k < out ; k++) {
          beat_band_is[i][k] = true ;
        }
      }
    } else {
      if(section == null) {
        printErr("method set_beat(): there is no section initialized, use method set_section(), before set_beat() advance mode");
      }
      if(spectrum == null) {
        printErr("method set_beat(): spectrum is not initialized, use method set_spectrum(), before set_beat()");
      }     
    }
  }

  // boolean beat is
  public boolean beat_is() {
    boolean beat_is = false ;
    for(int i = 0 ; i < section_size() ; i++) {
      for(int k = 0 ; k < spectrum_bands ; k++ ) {
        if(beat_band_is(i,k)) {
          beat_is = true ;
          break ;
        }
      }
    }
    return beat_is;
  }

  public boolean beat_is(int beat_target) {
    boolean beat_is = false ;
    if(beat_target < section.length) {
      int step = buffer_size() / spectrum_size();
      int in = floor(section[beat_target].in / step);
      int out = floor(section[beat_target].out / step);
      for(int band_target = in ; band_target < out ; band_target++) {
        if(beat_band_is(beat_target,band_target)) {
          beat_is = true;
          break ;
        }
      }
    } else {
      printErrTempo(60,"method beat_is(",beat_target,") is out of the range, by default method return false",frameCount);
    }
    return beat_is;
  }



  // beat band is
  public boolean beat_band_is(int beat_target, int band_target) {
    if(get_spectrum(band_target) > get_beat_threshold(beat_target,band_target)) {
      return true ;
    } else {
      return false ;
    }
  }

  public Section get_beat(int beat_target) {
    return section[beat_target];
  }


  // get bet threshold
  public float get_beat_threshold(int section_target, int band_target) {
    float threshold = Float.MAX_VALUE ;
    // check if the target is on the beat range analyze
    if(beat_advance_is && beat_band_is[section_target][band_target]) {
      threshold = section[section_target].get_threshold_beat();
    }
    return threshold;
  }


  public float get_beat_threshold(int section_target) {
    return section[section_target].get_threshold_beat();
  }











  /**
  TEMPO
  v 0.4.1
  */
  /**
  master method
  */
  String [] tempo_name = {"silenzio","largo","larghetto","adagio","andante","moderato","allegro","presto","prestissimo"};
  Tempo [] tempo;

  public void set_tempo() {
    set_tempo(null);
  }

  public void set_tempo(float... threshold) {
    if(threshold != null) {
      // printErrTempo(60,"method set_tempo() is not availble at this time try in an other life");
      if(section_size() > 0 && threshold.length <= section_size()) {
        tempo = new Tempo[section_size()];
        for(int i = 0 ; i < section_size() ; i++) {
          tempo[i] = new Tempo(get_beat(i));
          // tempo[i] = new Tempo(get_transient(i));
          tempo[i].set_threshold(threshold[i]);
        }
      } else {
        printErrTempo(60,"method set_tempo(boolean true) must be used after set_section() method");
      }
    } else {
      tempo = new Tempo[1];
      tempo[0] = new Tempo(analyze_length);
    }
  }


  public int get_tempo() {
    if(tempo.length > 1) {
      int sum = 0 ;
      for(int i = 0 ; i < tempo.length ; i++) {
        sum += tempo[i].get_tempo();
      }
      return sum / tempo.length;
    } else {
      return tempo[0].get_tempo();
    }
  }

  public float get_tempo_threshold(int target_tempo) {
    return tempo[target_tempo].get_threshold();
  }

  public int get_tempo(int target_tempo) {
    if(tempo.length > 1 && target_tempo < tempo.length) {
      return tempo[target_tempo].get_tempo();
    } else {
      printErrTempo(60,"method get_tempo(int target_tempo): target_tempo",target_tempo," is out of tempo num, instead the method use the global tempo");
      return tempo[0].get_tempo();
    }
  }

  public String get_tempo_name() {
    return get_tempo_name(0);
  }

  public String get_tempo_name(int target_tempo) {
    if(tempo[target_tempo].get_tempo() <= 0) return tempo_name[target_tempo];
    else if(tempo[target_tempo].get_tempo() > 0 && tempo[target_tempo].get_tempo() <= 60) return tempo_name[1];
    else if(tempo[target_tempo].get_tempo() > 60 && tempo[target_tempo].get_tempo() <= 66) return tempo_name[2];
    else if(tempo[target_tempo].get_tempo() > 66 && tempo[target_tempo].get_tempo() <= 76) return tempo_name[3];
    else if(tempo[target_tempo].get_tempo() > 76 && tempo[target_tempo].get_tempo() <= 108) return tempo_name[4];
    else if(tempo[target_tempo].get_tempo() > 108 && tempo[target_tempo].get_tempo() <= 120) return tempo_name[5];
    else if(tempo[target_tempo].get_tempo() > 120 && tempo[target_tempo].get_tempo() <= 160) return tempo_name[6];
    else if(tempo[target_tempo].get_tempo() > 160 && tempo[target_tempo].get_tempo() <= 200) return tempo_name[7];
    else return tempo_name[7];
  }

  public void update_tempo(boolean update_tempo_is) {
    if(update_tempo_is) {
      for(int i = 0 ; i < tempo.length ; i++) {
        tempo[i].update();
      }
    }   
  }






  /**
  Private class
  */
  /**
  class Section
  v 0.4.1
  */
  protected class Section {
    // transient param
    
    float low_pass = 100;
    float smooth_slow = 50 ;
    float smooth_fast = 500;
    float ratio_log = 200;
    float threshold_low = .1f;
    float threshold_high = .5f;

    // beat param
    float threshold_beat = 1;
    int in ;
    int out ;
    int [] leg;
    int length;

    public Section(int length) {
      this.length = length;
      leg = new int[length];
      this.in = 0;
      this.out = leg.length;
    }

    public Section(int length, int in, int out) {
      this.length = length;
      set_in_out(in,out);
      leg = new int[this.out-this.in];
    }


    public Section(int length, int in, int out, vec2 threshold_transient) {
      this.length = length;
      set_in_out(in,out);
      leg = new int[this.out-this.in];
      this.threshold_low = threshold_transient.x;
      this.threshold_high = threshold_transient.y;
      //this.threshold_transient = threshold_transient.copy();
    }

    public Section(int length, int in, int out, float threshold_beat) {
      this.length = length;
      set_in_out(in,out);
      leg = new int[this.out-this.in];
      this.threshold_beat = threshold_beat;
    }

    private void set_in_out(int in, int out) {
      if(out <= in ) {
        out = in +1;
      }
      this.in = in;
      this.out = out;
    }
     

    /*
    public boolean beat_is() {
      boolean beat_is = false ;
      int max = out ;
      if(out >= length) {
        max = length -1;
      }

      for(int i = in ; i <= max ; i++) {
        if(get_spectrum(i) > threshold_beat) {
          beat_is = true ;
          break ;
        }
      }
      return beat_is ;
    }
    */

    // set 
    public void set_threshold_transient(vec2 threshold_transient) {
      this.threshold_low = threshold_transient.x;
      this.threshold_high = threshold_transient.y;
    }

    public void set_threshold_beat(float threshold_beat) {
      this.threshold_beat = threshold_beat;
    }

    public void set_in(int in) {
      leg = new int[out -in +1];
      this.in = in;
    }

    public void set_out(int out) {
      leg = new int[out -in +1];
      this.out = out;
    }

    // get
    public vec2 get_threshold_transient() {
      return vec2(threshold_low,threshold_high);
    }

    public float get_threshold_beat() {
      return threshold_beat;
    }

    public int get_in() {
      return in ;
    }

    public int get_out() {
      return out ;
    }
  }
  




  /**
  class Tempo
  v 0.0.1
  */
  class Tempo {
    private int tempo;
    private int progress;
    private int time_tempo_count;
    private int sec_tempo_count;
    private float threshold;
    private int in, out;

    public Tempo (int len) {
      this.in = 0 ;
      this.out = len;
      set_threshold(4.5f);
    }

    public Tempo (Section s) {
      this.in = s.get_in();
      this.out =  s.get_out();
      set_threshold(4.5f);
    }


    private void update() {
      if(second() != sec_tempo_count) {
        time_tempo_count++;
        sec_tempo_count = second();
      }
      compute_tempo();
    }

    private int time_elapse = 0;
    private boolean new_tempo_count = true;
    private void compute_tempo() {
      if(sound_is()) {
        int time = 4;
        if(time_tempo_count%time == 0 && new_tempo_count) {
          new_tempo_count = false;
          time_elapse = 0;
          tempo = progress;
          if(tempo < 40) tempo = 40;
          progress = 0;
        }

        if(time_tempo_count%time != 0) new_tempo_count = true;

        time_elapse++;
        count_tempo();
      } else {
        progress = 0 ;
        tempo = 0 ;
      }
    }

    private void count_tempo() {
      for(int target_band = in ; target_band < out ; target_band++) {
        if(get_spectrum(target_band) > threshold) {
          progress++;
          break;
        }
      }
    }

    public void set_threshold(float threshold) {
      this.threshold = threshold;
    }

    public float get_threshold() {
      return threshold;
    }


    public int get_tempo() {
      return tempo;
    }
  }






  /**
  color spectrum
  v 0.1.0
  */
  /*
  int [] color_spectrum(int component, int sort) {
    vec2 range = vec2(-1) ;
    return color_spectrum(component, sort, range);
  }


  int [] color_spectrum(int component, int sort, vec2... range) {
    boolean reverse_alpha = true;
    // set range
    boolean range_is = false ;
    vec2 range_x = null;
    vec2 range_y = null;
    vec2 range_z = null;
    vec2 range_a = null;
    if(range.length == 1 && range[0].equals(-1)) {
      range_is = false ;
    } else {
      range_is = true ;
      if(range.length == 1) {
        range_x = range[0];
        range_y = range[0];
        range_z = range[0];
        range_a = range[0];
      } else if(range.length == 2) {
        range_x = range[0];
        range_y = range[0];
        range_z = range[0];
        range_a = range[1];
      } else if(range.length == 3) {
        range_x = range[0];
        range_y = range[1];
        range_z = range[2];
      } else if(range.length == 4) {
        range_x = range[0];
        range_y = range[1];
        range_z = range[2];
        range_a = range[3];
      }
    }

    // spectrum part
    int x = 0;
    int y = 0;
    int z = 0;
    int a = 0;

    float norm_x = 1.;
    float norm_y = 1.;
    float norm_z = 1.;
    float norm_a = 1.;

    int [] line = new int[floor(spectrum_size()/component)];
    int c = 0;
    int where = 0;
    int offset_0 = 0;
    int offset_1 = 0;
    int offset_2 = 0;
    int offset_3 = 0;

    for(int i = 0 ; i < line.length ; i++) {
      iVec5 sort_colour = sort_colour(i, line.length, component, sort);
      where = sort_colour.a;
      offset_0 = sort_colour.b;
      offset_1 = sort_colour.c;
      offset_2 = sort_colour.d;
      offset_3 = sort_colour.e;

      switch(component) {
        case 1:
        norm_x = get_spectrum(where);
        if(norm_x > 1) norm_x = 1;

        if(range_is) {
          norm_x = map(norm_x, 0,1, range_x.x, range_x.y) ;
        }

        x = int(norm_x *g.colorModeX);
        c = color(x);
        break ;
        //
        case 2:
        norm_x = get_spectrum(where);
        if(norm_x > 1) norm_x = 1;

        if(!reverse_alpha) {
          norm_a = get_spectrum(where +offset_1);
          if(norm_a > 1) norm_a = 1 ;
        } else {
          norm_a = 1 -get_spectrum(where +offset_1);
          if(norm_a < 0) norm_a = 0;
        }

        if(range_is) {
          norm_x = map(norm_x, 0,1, range_x.x, range_x.y) ;
          norm_a = map(norm_a, 0,1, range_a.x, range_a.y) ;
        }

        x = int(norm_x *g.colorModeX);
        y = int(norm_x *g.colorModeY);
        z = int(norm_x *g.colorModeZ);
        a = int(norm_a *g.colorModeA);
        c = color(x,y,z,a);
        break ;
        //
        case 3:
        norm_x = get_spectrum(where);
        norm_y = get_spectrum(where +offset_1);
        norm_z = get_spectrum(where +offset_2);

        if(norm_x > 1) norm_x = 1;
        if(norm_y > 1) norm_y = 1;
        if(norm_z > 1) norm_z = 1;

        if(range_is) {
          norm_x = map(norm_x, 0,1, range_x.x, range_x.y) ;
          norm_y = map(norm_y, 0,1, range_y.x, range_y.y) ;
          norm_z = map(norm_z, 0,1, range_z.x, range_z.y) ;
        }

        x = int(norm_x *g.colorModeX);
        y = int(norm_y *g.colorModeY);
        z = int(norm_z *g.colorModeZ);
        c = color(x,y,z);
        break ;
        //
        case 4:
        norm_x = get_spectrum(where);
        norm_y = get_spectrum(where +offset_1);
        norm_z = get_spectrum(where +offset_2);

        if(norm_x > 1) norm_x = 1;
        if(norm_y > 1) norm_y = 1;
        if(norm_z > 1) norm_z = 1;

        if(!reverse_alpha) {
          norm_a = get_spectrum(where +offset_3);
          if(norm_a > 1) norm_a = 1 ;
        } else {
          norm_a = 1 -get_spectrum(where +offset_3);
          if(norm_a < 0) norm_a = 0;
        }

        if(range_is) {
          norm_x = map(norm_x, 0,1, range_x.x, range_x.y) ;
          norm_y = map(norm_y, 0,1, range_y.x, range_y.y) ;
          norm_z = map(norm_z, 0,1, range_z.x, range_z.y) ;
          norm_a = map(norm_a, 0,1, range_a.x, range_a.y) ;
        }

        x = int(norm_x *g.colorModeX);
        y = int(norm_y *g.colorModeY);
        z = int(norm_z *g.colorModeZ);
        a = int(norm_a *g.colorModeA);
        c = color(x,y,z,a);
        break ;
        //
        default:
        norm_x = get_spectrum(where);

        if(norm_x > 1) norm_x = 1;

        if(range_is) {
          norm_x = map(norm_x, 0,1, range_x.x, range_x.y) ;
        }
        x = int(norm_x *g.colorModeX);
        c = color(x);
        break ;
      }
      line[i] = c ;
    }
    return line ;
  }

  // constant sorting
  int SORT_HASH = 0;
  int SORT_BLOCK_RGBA = 1;
  int SORT_BLOCK_ARGB = 1;


  iVec5 sort_colour(int i, int line_length, int component, int sort) {
    // iVec5 result = iVec5();
    int w = 0;
    int r = 0;
    int g = 0;
    int b = 0;
    int a = 0;
    if(sort == SORT_HASH) {
      // pixel position
      w = i *component;
      // pixel component
      r = 0;
      g = 1;
      b = 2;
      a = 3;
    } else if(sort == SORT_BLOCK_RGBA) {
      // pixel position
      w = i;
      // pixel component
      r = 0;
      g = line_length;
      b = line_length *2;
      a = line_length *3;
    } else if(sort == SORT_BLOCK_ARGB) {
      // pixel position
      w = i;
      // pixel component
      a = 0;
      r = line_length;
      g = line_length *2;
      b = line_length *3;
    }
    return iVec5(w,r,g,b,a);
  }
  */
}














/**
TRANSIENT DETECTION
2018-2018
v 0.1.1
--
main transient method
on idea of Jean-Baptiste Vallon Hoarau

equation :
x = is your value entry value from buffer > buffer[n]
y = is your value array aftre the thread > value[n]

step 1 
--
low_pass filter :
value [] lp ; 
loop on buffer where n is a current value
entry is the first buffer val
value ref = first buffer value > buffer[entry];
value s = abs(a)+1 > make a value always positive upper to 1
ref = ref + (buffer[n] - ref) / s
lp[n] = ref
y = lp[n]

step 2
--
pow
loop on buffer where n is a current value
pow[n] = y^2
y = pow[n]

step 3 
--
smooth fast
value [] smooth_fast ; 
loop on buffer where n is a current value
ref = pow[0];
s_fast = abs(smooth_fast) +1; > keep value positive upper to 1
ref = ref + (y - ref) / s_fast;
lp_fast[n] = ref;

step 4 and 5
--
smooth slow

value [] smooth_slow ; 
loop on buffer where n is a current value
ref = pow[0];
s_slow = abs(smooth_slow)+1; > keep value positive upper to 1
float current_value = pow[n];
ref = ref + (current_value - ref) / s_slow;
smooth_fast[n] = ref;

diff between value fast and slow or reverse
diff[n] = smooth_fast[n] - smooth_slow[n]
y = diff[n]

step 6
--
log value
loop on buffer where n is a current value
scale > need to have value signifiant
log_value[n] = log(1+(scale*y));
y = log_value[n]

step 7
--
Hysteresie with threshold low and high
loop on buffer where n is a current value
boolean state
if (y > threshold_high and  state false) 
    y = 1 ;
    test = true ;
else if (y < threshold_low and state true)
    y = 0;
    state = false;

if the answer is true in the couple : BINGO it's a transient
*/
class Transient extends Sounda {
  float [] buffer;

  Transient() {
    super();
  }

  public void buffer(float [] buffer) {
    this.buffer = buffer; 
  }




  // setting
  public void set_transient_detection(Section [] section, vec2... threshold) {
    int [] id_transient_section = new int [threshold.length];
    for(int i = 0 ; i < id_transient_section.length ; i++) {
      id_transient_section[i]=i;
    }
    set_transient_detection(section,id_transient_section,threshold);
  }

  public void set_transient_detection(Section [] section, int index, vec2 threshold) {
    if(index < section_size()) {
      section[index].set_threshold_transient(threshold);
    } else {
      printErrTempo(60,"class Transient – method set_transient(int"+index+" vec2 "+threshold+") is out of the range");
    }
  }


  private boolean transient_advance_is ;
  private boolean [][] transient_leg_is ;
  private void set_transient_detection(Section [] section, int[] target_transient_section, vec2... threshold) {
    if(buffer != null && section != null) {
      transient_advance_is = true;
      transient_leg_is = new boolean [target_transient_section.length][buffer.length];
      // init var
      for(int i = 0 ; i < transient_leg_is.length ; i++) {
        if(target_transient_section[i] < section_size()) {
          int target_section = target_transient_section[i];
          section[target_section].set_threshold_transient(threshold[i]);
        } else {
          printErr("method set_beat(): int target_beat_section",target_transient_section[i],"is out of the num os section available");
        }
        for(int k = 0 ; k < transient_leg_is[0].length ; k++) {
          transient_leg_is[i][k] = false;
        }
      }
      // declare which band must be analyze when there is a beat detection
      for(int i = 0 ; i < section.length ; i++ ) {
        for(int k = section[i].in ; k < section[i].out ; k++) {
          transient_leg_is[i][k] = true ;
        }
      }
    } else {
      if(buffer != null) {
        printErr("method set_transient(): there is no section initialized, use method set_section(), before set_transient() advance mode");
      } else {
        printErr("void void set_transient_detection(): "+warning_input);
      }
    }
  }


  

  // set param transient
  public void set_low_pass(Section section, float low_pass) {
    section.low_pass = low_pass;
  }

  public void set_smooth(Section section, float slow, float fast) {
    section.smooth_slow = slow;
    section.smooth_fast = fast;
  }

  public void set_smooth_slow(Section section, float slow) {
    section.smooth_slow = slow;
  }

  public void set_smooth_fast(Section section, float fast) {
    section.smooth_fast = fast;
  }


  public void set_ratio_log(Section section, float ratio_log) {
    section.ratio_log = ratio_log;
  }

  public void set_threshold(Section section, float low, float high) {
    section.threshold_low = low;
    section.threshold_high = high; 
  }

  public void set_threshold_low(Section section, float low) {
    section.threshold_low = low;
  }


  public void set_threshold_high(Section section, float high) {
    section.threshold_high = high; 
  }




  

  // boolean transient is
  // method use when you work without the class SOUNDA
  public boolean detection_is() {
    boolean transient_is = false;
    for(int i = 0 ; i < section_size() ; i++) {
      if(detection_is(section,i)) {
        transient_is = true;
        break;
      }
    }
    return transient_is;
  }


  public boolean detection_is(Section [] section, int section_index) {
 
    boolean transient_event_is = false;   
    
    int in = floor(section[section_index].in);
    int out = floor(section[section_index].out);
    int num_leg = out - in ;
    if(section_index < section.length && num_leg > 0) {
      // set the value must be analyze
      float [] pow_value = new float[num_leg];
      float [] value_fast = new float[num_leg];
      float [] value_slow = new float[num_leg];
      float [] diff_value = new float[num_leg];
      float [] log_value = new float[num_leg];
      boolean [] transient_is = new boolean[num_leg];
      float [] raw_value = new float[num_leg];

      for(int index = in ; index < out ; index++) {
        int index_value = index - in ;
        if(index < buffer.length) {
          raw_value[index_value] = buffer[index];
        } else {
          raw_value[index_value] = 0;
        }
      }

      low_pass(section[section_index].low_pass,in,out);
      // here pass the first filtering value from first low pass
      for(int i = 0 ; i  < pow_value.length ; i++) {
        pow_value[i] = low_pass_value[i];
        pow_value[i] = pow(pow_value[i],2);
      }
      // new low pass fast
      float ref_fast = pow_value[0];
      float smoothing_fast = abs(section[section_index].smooth_fast)+1;
      for(int i = 0 ; i  < value_fast.length ; i++) {
        float current_value = pow_value[i];
        ref_fast += (current_value - ref_fast) / smoothing_fast;
        value_fast[i] = ref_fast;
      }

      // new low pass slow
      float ref_slow = pow_value[0];
      float smoothing_slow = abs(section[section_index].smooth_slow)+1;
      // pass second thread value: first low pass and pow treatment
      for(int i = 0 ; i  < value_slow.length ; i++) {
        float current_value = pow_value[i];
        ref_slow += (current_value - ref_slow) / smoothing_slow;
        value_slow[i] = ref_slow;
      }

      // difference between quick and fast low pass
      for(int i = 0 ; i < diff_value.length ; i++) {
        //diff_value[i] = low_pass_value_slow[i] - low_pass_value_fast[i];
        diff_value[i] = value_fast[i] - value_slow[i];
      }

      // log 
      for(int i = 0 ; i  < log_value.length ; i++) {
        log_value[i] = log(1+(section[section_index].ratio_log*diff_value[i]));
      }
      
      // transiente detection and hysteresie
      for(int i = 0 ; i < log_value.length ; i++) {
        transient_is[i] = false;
        float value = log_value[i];
        if(value > section[section_index].threshold_high && !transient_is[i]) {
          value = 1;
          transient_is[i] = true;
        } else if(value < section[section_index].threshold_low && transient_is[i]) {
          value = 0;
          transient_is[i] = false;
        }
      }
     
      
      for(int i = 0 ; i < transient_is.length ; i++) {
        if(transient_is[i]) {
          transient_event_is = true;
          break ;
        }
      }

      // display just for devellopement
      if(info) {
        show_visual(in, transient_is, raw_value, low_pass_value, pow_value, value_fast, value_slow, diff_value, log_value);
      }

      // end display dev   
    } else {
      printErrTempo(60,"method transient_is(section",section_index,") is out of the range, by default method return false",frameCount);
    }
    return transient_event_is;
  }


  private void show_visual(int in, boolean [] transient_is, float [] raw_value, float [] low_pass_value, float [] pow_value, float [] low_pass_value_fast, float [] low_pass_value_slow, float [] diff_value, float [] log_value) {
    float factor =height/6;
    int num = 8;
    int step = height / num;
    int [] pos_y = new int[num] ;
    for(int i = 0 ; i < num ; i++) {
      pos_y[i] = step *(i +1); 
    }
    float ratio_display = 1 ;
    if(buffer.length > 0) {
      ratio_display = (float)width / buffer.length;
    }
    for(int i = 0 ; i < transient_is.length ;i++) {
    // no filter
      int x = i +in;
      x *= ratio_display;
      int y = PApplet.parseInt(raw_value[i] *factor) +pos_y[0];
      set(x, y,r.YELLOW);
      // low pass filter
      y = PApplet.parseInt(low_pass_value[i] *factor) +pos_y[1];
      set(x, y,r.YELLOW);
      // transient work
      // show pow value
      y = PApplet.parseInt(pow_value[i] *factor) +pos_y[2];
      set(x, y,r.YELLOW);

      // show low pass quick
      y = PApplet.parseInt(low_pass_value_fast[i] *factor) + pos_y[3];
      set(x, y,r.YELLOW);

      // show low pass slow
      y = PApplet.parseInt(low_pass_value_slow[i] *factor) + pos_y[4];
      set(x, y,r.YELLOW);

      // diff between fast and slow
      y = PApplet.parseInt(diff_value[i] *factor) +pos_y[5];
      set(x, y,r.YELLOW);

       // log value + 1
      y = PApplet.parseInt(log_value[i] *factor) +pos_y[6];
      set(x, y,r.YELLOW);
    }
  }

  float [] low_pass_value;
  private void low_pass(float smooth, int in, int out) {
    float smoothing;
    int length = out -in ;
    low_pass_value = new float[length];
  
    // float ref = buffer[0];
    float ref = buffer[in];
    smoothing = abs(smooth)+1;
    // println("smooth", smoothing);
    for(int index = in ; index < out ; index++) {
      float current_value = buffer[index];
      int index_low_pass = index - in ;
      ref += (current_value - ref) / smoothing; 
      low_pass_value[index_low_pass] = ref;
    }
  }


  public void print_transient_param(Section [] section) {
    printTempo(60,"__");
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"smooth slow pass:",section[i].low_pass,frameCount);
    }
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"smooth slow:",section[i].smooth_slow,frameCount);
    }
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"smooth fast:",section[i].smooth_fast,frameCount);
    }
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"threshold low:",section[i].threshold_low,frameCount);
    }
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"threshold high:",section[i].threshold_high,frameCount);
    }
    for(int i = 0 ; i < section.length ; i++) {
      printTempo(60,"ratio transient:",section[i].ratio_log,frameCount);
    }
  }
  


  // get param transient
  public float[] get_low_pass() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].low_pass;
    }
    return value;
  }

  public float[] get_smooth_slow() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].smooth_slow;
    }
    return value;
  }

  public float[] get_smooth_fast() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].smooth_fast;
    }
    return value;
  }

  public float[] get_ratio_log() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].ratio_log;
    }
    return value;
  }

  public float[] get_threshold_low() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].threshold_low;
    }
    return value;
  }

  public float[] get_threshold_high() {
    float [] value = new float[section.length];
    for(int i = 0 ; i < section.length ;i++) {
      value[i] = section[i].threshold_high;
    }
    return value;
  }


  // get bet threshold
  public vec2 get_transient_threshold(Section [] section, int section_target, int band_target) {
    vec2 threshold = vec2(Float.MAX_VALUE) ;
    // check if the target is on the beat range analyze
    if(transient_advance_is && transient_leg_is[section_target][band_target]) {
      threshold = section[section_target].get_threshold_transient().copy();
    }
    return threshold;
  }


  public vec2 get_transient_threshold(Section [] section, int section_target) {
    return section[section_target].get_threshold_transient();
  }
}



/**
* BACKGROUND FX
* Rope background shader fx collection
* 2019-2019
* v 0.1.7
* all filter bellow has been tested.
* @see http://stanlepunk.xyz
* @see https://github.com/StanLepunK/Shader
*/



/**
* Template fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_template(FX fx) {
	return fx_bg_template(fx.get_canvas(),fx.on_g(),vec3(fx.get_colour()));
}


// test setting
public PGraphics fx_bg_template() {
  vec3 colour = abs(vec3().sin_wave(frameCount,.01f,.02f,.03f));
	return fx_bg_template(null,true,colour);
}


// main
PShader fx_bg_template;
PGraphics pg_template_fx_bg;
public PGraphics fx_bg_template(ivec2 canvas, boolean on_g, vec3 colour) {
	
	if(!on_g && (pg_template_fx_bg == null
								|| (canvas.x != pg_template_fx_bg.width 
								&& canvas.y != pg_template_fx_bg.height))) {
		pg_template_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_template == null) {
		String path = get_fx_bg_path()+"template_fx_bg.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_template = loadShader(path);
			println("load shader: template_fx_bg.glsl");
		} 
	} else {
		set_shader_resolution(fx_bg_template,canvas,on_g);

		// render
		fx_bg_template.set("rgb",colour.x,colour.y,colour.z); // value from 0 to 1

		if(on_g) {
			filter(fx_bg_template);
		} else {
			pg_template_fx_bg.shader(fx_bg_template);
		}
	}


	if(on_g) {
		return null;
	} else {
		return pg_template_fx_bg; 
	}
}









/**
* Cellular fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.3
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_cellular(FX fx) {
	return fx_bg_cellular(fx.get_canvas(),fx.on_g(),fx.get_colour(),fx.get_num(),vec2(fx.get_speed()),fx.get_quality());
}




// main
PShader fx_bg_cellular;
PGraphics pg_cellular_fx_bg;
public PGraphics fx_bg_cellular(ivec2 canvas, boolean on_g, vec4 colour, int num, vec2 speed, float quality) {
	if(!on_g && (pg_cellular_fx_bg == null
								|| (canvas.x != pg_cellular_fx_bg.width 
								&& canvas.y != pg_cellular_fx_bg.height))) {
		pg_cellular_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_cellular == null) {
		String path = get_fx_bg_path()+"cellular.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_cellular = loadShader(path);
			println("load shader: cellular.glsl");
		}	
	} else {
		set_shader_resolution(fx_bg_cellular,canvas,on_g);

		fx_bg_cellular.set("time",frameCount *.1f); 


    // external paramter
		fx_bg_cellular.set("rgba",colour.x,colour.y,colour.z,colour.w); // value from 0 to 1
		fx_bg_cellular.set("num",num); // value from 0 to 1
		fx_bg_cellular.set("speed",speed.x,speed.y); // value from 0 to 1
		fx_bg_cellular.set("quality",quality); // value from 0 to 1

		if(on_g) {
			filter(fx_bg_cellular);
		} else {
			pg_cellular_fx_bg.shader(fx_bg_cellular);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_cellular_fx_bg; 
	}
}








/**
* Heart fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_heart(FX fx) {
	return fx_bg_heart(fx.get_canvas(),fx.on_g(),vec3(fx.get_colour()),fx.get_num(),fx.get_speed().x,fx.get_quality(),fx.get_strength().x);
}




// main
PShader fx_bg_heart;
PGraphics pg_heart_fx_bg;
public PGraphics fx_bg_heart(ivec2 canvas, boolean on_g, vec3 colour, int num, float speed, float quality, float strength) {
	if(!on_g && (pg_heart_fx_bg == null
								|| (canvas.x != pg_heart_fx_bg.width 
								&& canvas.y != pg_heart_fx_bg.height))) {
		pg_heart_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_heart == null) {
		String path = get_fx_bg_path()+"heart.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_heart = loadShader(path);
			println("load shader: heart.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_heart,canvas,on_g);

		fx_bg_heart.set("time",frameCount *.1f); 


    // external paramter
		fx_bg_heart.set("rgb",colour.x,colour.y,colour.z); // value from 0 to 1
		fx_bg_heart.set("num",num); // value from 0 to 1
		fx_bg_heart.set("speed",speed); // value from 0 to 1
		fx_bg_heart.set("quality",quality); // value from 0 to 1

		fx_bg_heart.set("strength",strength); // value from 1 to ++
		if(on_g) {
			filter(fx_bg_heart);
		} else {
			pg_heart_fx_bg.shader(fx_bg_heart);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_heart_fx_bg; 
	}
}








/**
* Necklace fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_necklace(FX fx) {
	return fx_bg_necklace(fx.get_canvas(),fx.on_g(),vec2(fx.get_pos()),vec2(fx.get_size()),fx.get_colour().x,fx.get_num(),fx.get_speed().x);
}




// main
PShader fx_bg_necklace;
PGraphics pg_necklace_fx_bg;
public PGraphics fx_bg_necklace(ivec2 canvas, boolean on_g, vec2 pos, vec2 size, float alpha, int num, float speed) {
	if(!on_g && (pg_necklace_fx_bg == null
								|| (canvas.x != pg_necklace_fx_bg.width 
								&& canvas.y != pg_necklace_fx_bg.height))) {
		pg_necklace_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_necklace == null) {
		String path = get_fx_bg_path()+"necklace.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_necklace = loadShader(path);
			println("load shader: necklace.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_necklace,canvas,on_g);


		fx_bg_necklace.set("time",frameCount); 
    // external paramter
    fx_bg_necklace.set("position",pos.x,pos.y); // value from 0 to 1
    fx_bg_necklace.set("size",size.x,size.y); // value from 0 to 1
		fx_bg_necklace.set("alpha",alpha); // value from 0 to 1
		fx_bg_necklace.set("num",num); // value from 1 to ++
		fx_bg_necklace.set("speed",speed); // value from 0 to 1

		if(on_g) {
			filter(fx_bg_necklace);
		} else {
			pg_necklace_fx_bg.shader(fx_bg_necklace);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_necklace_fx_bg; 
	}
}







/**
* Neon fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_neon(FX fx) {
	return fx_bg_neon(fx.get_canvas(),fx.on_g(),vec2(fx.get_pos()),fx.get_speed().x);
}




// main
PShader fx_bg_neon;
PGraphics pg_neon_fx_bg;
public PGraphics fx_bg_neon(ivec2 canvas, boolean on_g, vec2 pos, float speed) {
	if(!on_g && (pg_neon_fx_bg == null
								|| (canvas.x != pg_neon_fx_bg.width 
								&& canvas.y != pg_neon_fx_bg.height))) {
		pg_neon_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_neon == null) {
		String path = get_fx_bg_path()+"neon.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_neon = loadShader(path);
			println("load shader: neon.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_neon,canvas,on_g);


		fx_bg_neon.set("time",frameCount *speed); 
    // external paramter
    fx_bg_neon.set("position",pos.x,pos.y); // value from 0 to 1

		if(on_g) {
			filter(fx_bg_neon);
		} else {
			pg_neon_fx_bg.shader(fx_bg_neon);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_neon_fx_bg; 
	}
}












/**
* PSY fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_psy(FX fx) {
	return fx_bg_psy(fx.get_canvas(),fx.on_g(),fx.get_num(),fx.get_speed().x);
}



// main
PShader fx_bg_psy;
PGraphics pg_psy_fx_bg;
public PGraphics fx_bg_psy(ivec2 canvas, boolean on_g, int num, float speed) {
	if(!on_g && (pg_psy_fx_bg == null
								|| (canvas.x != pg_psy_fx_bg.width 
								&& canvas.y != pg_psy_fx_bg.height))) {
		pg_psy_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_psy == null) {
		String path = get_fx_bg_path()+"psy.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_psy = loadShader(path);
			println("load shader: psy.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_psy,canvas,on_g);


		fx_bg_psy.set("time",frameCount *speed); // speed value must be low from 0.0001 to 0.05 and it's very fast
    // external paramter
    fx_bg_psy.set("num",num); // 2 or 3

		if(on_g) {
			filter(fx_bg_psy);
		} else {
			pg_psy_fx_bg.shader(fx_bg_psy);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_psy_fx_bg; 
	}
}






/**
* SNOW fx backgournd by Stan le punk
* this template can be used for texture or direct filtering
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_snow(FX fx) {
	return fx_bg_snow(fx.get_canvas(),fx.on_g(),vec2(fx.get_pos()),vec3(fx.get_colour()),fx.get_speed().x,fx.get_quality());
}



// main
PShader fx_bg_snow;
PGraphics pg_snow_fx_bg;
public PGraphics fx_bg_snow(ivec2 canvas, boolean on_g, vec2 pos, vec3 colour, float speed, float quality) {
	if(!on_g && (pg_snow_fx_bg == null
								|| (canvas.x != pg_snow_fx_bg.width 
								&& canvas.y != pg_snow_fx_bg.height))) {
		pg_snow_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_snow == null) {
		String path = get_fx_bg_path()+"snow.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_snow = loadShader(path);
			println("load shader: snow.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_snow,canvas,on_g);

    fx_bg_snow.set("rgb",colour.x,colour.y,colour.z); // speed value must be low from 0.0001 to 0.05 and it's very fast
		fx_bg_snow.set("time",frameCount *speed); // speed value must be low from 0.0001 to 0.05 and it's very fast

		fx_bg_snow.set("position",pos.x,pos.y); // speed value must be low from 0.0001 to 0.05 and it's very fast

		fx_bg_snow.set("quality",quality); // speed value must be low from 0.0001 to 0.05 and it's very fast
    // external paramter


		if(on_g) {
			filter(fx_bg_snow);
		} else {
			pg_snow_fx_bg.shader(fx_bg_snow);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_snow_fx_bg; 
	}
}















/**
* VORONOI HEX
* refactoring
* oroginal shader see glsl file for the link
* v 0.0.1
* 2019-2019
*/
// setting by class FX
public PGraphics fx_bg_voronoi_hex(FX fx) {
	return fx_bg_voronoi_hex(fx.get_canvas(),fx.on_g(),fx.get_size().x,vec3(fx.get_colour()),fx.get_speed().x,fx.get_speed().y,fx.get_strength().x,fx.get_threshold().x,fx.get_mode());
}


// main
PShader fx_bg_voronoi_hex;
PGraphics pg_voronoi_hex_fx_bg;
public PGraphics fx_bg_voronoi_hex(ivec2 canvas, boolean on_g, float size, vec3 colour, float speed_mutation,float speed_colour, float strength, float threshold, int mode) {
	if(!on_g && (pg_voronoi_hex_fx_bg == null
								|| (canvas.x != pg_voronoi_hex_fx_bg.width 
								&& canvas.y != pg_voronoi_hex_fx_bg.height))) {
		pg_voronoi_hex_fx_bg = createGraphics(canvas.x,canvas.y,get_renderer());
	}
  // setting
	if(fx_bg_voronoi_hex == null) {
		String path = get_fx_bg_path()+"voronoi_hex.glsl";
		if(fx_bg_rope_path_exists) {
			fx_bg_voronoi_hex = loadShader(path);
			println("load shader: voronoi_hex.glsl");
		}
	} else {
		set_shader_resolution(fx_bg_voronoi_hex,canvas,on_g);
		// processing parameter
		fx_bg_voronoi_hex.set("time",PApplet.parseFloat(frameCount)); 
    
    // external parameter
    fx_bg_voronoi_hex.set("rgb",colour.x,colour.y,colour.z); // from 0 to 1
    fx_bg_voronoi_hex.set("size",size); // from 1 to 10++
    fx_bg_voronoi_hex.set("speed_mutation",speed_mutation); // from 0 to 1
    fx_bg_voronoi_hex.set("speed_colour",speed_colour); // from 0 to 1
		fx_bg_voronoi_hex.set("strength",strength); // from -0.05 to 0.05
		fx_bg_voronoi_hex.set("threshold",threshold); // from 0.1 to 0.3
		fx_bg_voronoi_hex.set("mode",mode); // from 0 to 1

		if(on_g) {
			filter(fx_bg_voronoi_hex);
		} else {
			pg_voronoi_hex_fx_bg.shader(fx_bg_voronoi_hex);
		}
	}

	if(on_g) {
		return null;
	} else {
		return pg_voronoi_hex_fx_bg; 
	}
}







/**
 * CLASS FX 
 * v 0.4.2
 * @author @stanlepunk
 * @see https://github.com/StanLepunK/Shader
 * 2019-2019
 * class used to create easy setting for shader fx
*/
public class FX {
	// processing parameter
	private int id;
	private int type;
	private String name;
	private ivec2 canvas;
	private String [] name_slider;
	private String [] name_button;
	private String author;
	private String pack;
	private String version;
	private int revision;
	private boolean on_g = true;


	// glsl parameter
	private int mode; // 0
	private int num; // 1 
	private float quality; // 2
	private float time; // 3

	private vec2 scale; // 10
	private vec2 resolution; // 11

	private vec3 strength; // 20
	private vec3 angle; // 21
	private vec3 threshold; // 22
	private vec3 pos; // 23
	private vec3 size; // 24
	private vec3 offset; // 25
	private vec3 speed; // 26

	private vec4 level_source; // 30
	private vec4 level_layer; // 31
	private vec4 colour; // 32
	private vec4 cardinal; // 33 > north, east, south, west > top, right, bottom, left

  private float hue; // 200
	private float saturation; // 201
	private float brightness; // 202

	private float red; // 300
	private float green; // 301
	private float blue; // 302

	private float alpha; // 400

	// modular
	private vec3 [] matrix; // 40 > 42
	private vec2 [] pair; // 50 > 42
	private bvec4 [] event; // 10O-102



  // CONSTRUCTOR
  public FX () {}

  // set
  public void set_on_g(boolean is) {
  	on_g = is;
  }

  public void set_canvas(int x, int y) {
  	if(this.canvas == null) {
  		this.canvas = ivec2(x,y);
  	} else {
  		this.canvas.set(x,y);
  	}
  }

  public void set_type(int type) {
  	this.type = type;
  }

  public void set_id(int id) {
  	this.id = id;
  }

  public void set_name(String name) {
  	this.name = name;
  }

  public void set_name_slider(String... name) {
  	name_slider = new String[name.length];
  	for(int i = 0 ; i < name_slider.length ; i++) {
  		this.name_slider[i] = name[i];
  	}
  }

  public void set_name_button(String... name) {
  	name_button = new String[name.length];
  	for(int i = 0 ; i < name_button.length ; i++) {
  		this.name_button[i] = name[i];
  	}
  }

  public void set_author(String author) {
  	this.author = author;
  }

  public void set_pack(String pack) {
  	this.pack = pack;
  }

  public void set_version(String version) {
  	this.version = version;
  }

  public void set_revision(int revision) {
  	this.revision = revision;
  }

  public void set(int which, Object... arg) {
  	if(which == 0) {
  		set_mode((int)arg[0]);
  	} else if(which == 1) {
  		set_num((int)arg[0]);
  	} else if(which == 2) {
  		set_quality((float)arg[0]);
  	} else if(which == 3) {
  		set_time((float)arg[0]);
  	}

  		else if(which == 10) {
  		set_scale(to_float_array(arg));
  	} else if(which == 11) {
  		set_resolution(to_float_array(arg));
  	}

  		else if(which == 20) {
  		set_strength(to_float_array(arg));
  	} else if(which == 21) {
  		set_angle(to_float_array(arg));
  	} else if(which == 22) {
  		set_threshold(to_float_array(arg));
  	} else if(which == 23) {
  		set_pos(to_float_array(arg));
  	} else if(which == 24) {
  		set_size(to_float_array(arg));
  	} else if(which == 25) {
  		set_offset(to_float_array(arg));
  	} else if(which == 26) {
  		set_speed(to_float_array(arg));
  	}

  		else if(which == 30) {
  		set_level_source(to_float_array(arg));
  	} else if(which == 31) {
  		set_level_layer(to_float_array(arg));
  	} else if(which == 32) {
  		set_colour(to_float_array(arg));
  	} else if(which == 33) {
  		set_cardinal(to_float_array(arg));
  	}

  		else if(which == 40) {
  		if(matrix == null || matrix.length < 1) matrix = new vec3[1];
  		set_matrix(0,to_float_array(arg));
  	} else if(which == 41) {
  		if(matrix == null || matrix.length < 2) matrix = new vec3[2];
  		set_matrix(1,to_float_array(arg));
  	} else if(which == 42) {
  		if(matrix == null || matrix.length < 3) matrix = new vec3[3];
  		set_matrix(2,to_float_array(arg));
  	}	

  	else if(which == 50) {
  		if(pair == null || pair.length < 1) pair = new vec2[1];
  		set_pair(0,to_float_array(arg));
  	} else if(which == 51) {
  		if(pair == null || pair.length < 2) pair = new vec2[2];
  		set_pair(1,to_float_array(arg));
  	} else if(which == 52) {
  		if(pair == null || pair.length < 3) pair = new vec2[3];
  		set_pair(2,to_float_array(arg));
  	}	

  		else if(which == 100) {
  		if(event == null || event.length < 1) event = new bvec4[1];
  		set_event(0,to_boolean_array(arg));
  	} else if(which == 101) {
  		if(event == null || event.length < 2) event = new bvec4[2];
  		set_event(1,to_boolean_array(arg));
  	} else if(which == 102) {
  		if(event == null || event.length < 3) event = new bvec4[3];
  		set_event(2,to_boolean_array(arg));
  	}
  }

  private float[] to_float_array(Object... arg) {
  	float [] f = new float[arg.length];
  	for(int i = 0 ; i < arg.length ; i++) {
  		if(arg[i] instanceof Float) {
  			f[i] = (float)arg[i];
  		} else {
  			printErr("class FX method to_float_array(): arg",arg,"cannot be cast to float");
  			f[i] = 0;
  		}
  	}
  	return f;
  }


  private boolean[] to_boolean_array(Object... arg) {
  	boolean [] b = new boolean[arg.length];
  	for(int i = 0 ; i < arg.length ; i++) {
  		if(arg[i] instanceof Boolean) {
  			b[i] = (boolean)arg[i];
  		} else {
  			printErr("class FX method to_boolean_array(): arg",arg,"cannot be cast to boolean");
  			b[i] = false;
  		}
  	}
  	return b;
  }


  private void set_mode(int mode) {
		this.mode = mode;
	}

	private void set_num(int num) {
		this.num = num;
	}

	private void set_quality(float quality) {
		this.quality = quality;
	}

	private void set_time(float time) {
		this.time = time;
	}

	private void set_scale(float... arg) {
		if(this.scale == null) {
			this.scale = vec2(build_float_2(arg));
		} else {
			this.scale.set(build_float_2(arg));
		}
	}

	private void set_resolution(float... arg) {
		if(this.resolution == null) {
			this.resolution = vec2(build_float_2(arg));
		} else {
			this.resolution.set(build_float_2(arg));
		}
	}

	private void set_strength(float... arg) {
		if(this.strength == null) {
			this.strength = vec3(build_float_3(arg));
		} else {
			this.strength.set(build_float_3(arg));
		}
	}

	private void set_angle(float... arg) {
		if(this.angle == null) {
			this.angle = vec3(build_float_3(arg));
		} else {
			this.angle.set(build_float_3(arg));
		}
	}

	private void set_threshold(float... arg) {
		if(this.threshold == null) {
			this.threshold = vec3(build_float_3(arg));
		} else {
			this.threshold.set(build_float_3(arg));
		}
	}

	private void set_pos(float... arg) {
		if(this.pos == null) {
			this.pos = vec3(build_float_3(arg));
		} else {
			this.pos.set(build_float_3(arg));
		}
	}

	private void set_size(float... arg) {
		if(this.size == null) {
			this.size = vec3(build_float_3(arg));
		} else {
			this.size.set(build_float_3(arg));
		}
	}

	private void set_offset(float... arg) {
		if(this.offset == null) {
			this.offset = vec3(build_float_3(arg));
		} else {
			this.offset.set(build_float_3(arg));
		}
	}

	private void set_speed(float... arg) {
		if(this.speed == null) {
			this.speed = vec3(build_float_3(arg));
		} else {
			this.speed.set(build_float_3(arg));
		}
	}

	private void set_level_source(float... arg) {
		if(this.level_source == null) {
			this.level_source = vec4(build_float_4(arg));
		} else {
			this.level_source.set(build_float_4(arg));
		}
	}

	private void set_level_layer(float... arg) {
		if(this.level_layer == null) {
			this.level_layer = vec4(build_float_4(arg));
		} else {
			this.level_layer.set(build_float_4(arg));
		}
	}

	private void set_colour(float... arg) {
		if(this.colour == null) {
			this.colour = vec4(build_float_4(arg));
		} else {
			this.colour.set(build_float_4(arg));
		}
	}

	private void set_cardinal(float... arg) {
		if(this.cardinal == null) {
			this.cardinal = vec4(build_float_4(arg));
		} else {
			this.cardinal.set(build_float_4(arg));
		}
	}

	private void set_hue(float hue) {
		this.hue = hue;
	}

	private void set_saturation(float saturation) {
		this.saturation = saturation;
	}

	private void set_brightness(float brightness) {
		this.brightness = brightness;
	}

	private void set_red(float red) {
		this.red = red;
	}

	private void set_green(float green) {
		this.green = green;
	}

	private void set_blue(float blue) {
		this.blue = blue;
	}

	private void set_alpha(float alpha) {
		this.alpha = alpha;
	}

	private void set_matrix(int which, float... arg) {
		if(this.matrix[which] == null) {
			this.matrix[which] = vec3(build_float_3(arg));
		} else {
			this.matrix[which].set(build_float_3(arg));
		}
	}

	private void set_pair(int which, float... arg) {
		if(this.pair[which] == null) {
			this.pair[which] = vec2(build_float_2(arg));
		} else {
			this.pair[which].set(build_float_2(arg));
		}
	}

	private void set_event(int which, boolean... arg) {
		if(this.event[which] == null) {
			this.event[which] = bvec4(build_boolean_4(arg));
		} else {
			this.event[which].set(build_boolean_4(arg));
		}
	}



	// get
	public boolean on_g() {
		return on_g;
	}

	public String get_name() {
		return name;
	}

	public ivec2 get_canvas() {
		return this.canvas;
	}

	public String [] get_name_slider() {
  	return name_slider;
  }

  public String [] get_name_button() {
  	return name_button;
  }

	public int get_id() {
		return id;
	}

	public String get_author() {
  	 return author;
  }

  public String get_pack() {
  	return pack;
  }

  public String get_version() {
  	return version;
  }

  public  int get_revision() {
  	return revision;
  }

	public int get_type() {
		return type;
	}

	public int get_mode() {
		return mode;
	}

	public int get_num() {
		return num;
	}

	public float get_quality() {
		return quality;
	}

	public float get_time() {
		return time;
	}

	public vec2 get_scale() {
		if(scale == null) {
			scale = vec2(1);
			printErr("class FX method get_scale(): arg",null,"instead set arg and return",scale);
		} 
		return scale;	
	}

	public vec2 get_resolution() {
		if(resolution == null) {
			resolution = vec2(width,height);
			printErr("class FX method get_resolution(): arg",null,"instead set arg and return",resolution);
		} 
		return resolution;
	}

	public vec3 get_strength() {
		if(strength == null) {
			strength = vec3(0);
			printErr("class FX method get_strength(): arg",null,"instead set arg and return",strength);
		}
		return strength;
	}

	public vec3 get_angle() {
		if(angle == null) {
			angle = vec3(0);
			printErr("class FX method get_angle(): arg",null,"instead set arg and return",angle);
		}
		return angle;
	}

	public vec3 get_threshold() {
		if(threshold == null) {
			threshold = vec3(0);
			printErr("class FX method get_threshold(): arg",null,"instead set arg and return",threshold);
		}
		return threshold;
	}

	public vec3 get_pos() {
		if(pos == null) {
			pos = vec3(width/2,height/2,0);
			printErr("class FX method get_pos(): arg",null,"instead set arg and return",pos);
		}
		return pos;
	}

	public vec3 get_size() {
		if(size == null) {
			size = vec3(5);
			printErr("class FX method get_size(): arg",null,"instead set arg and return",size);
		}
		return size;
	}

	public vec3 get_offset() {
		if(offset == null) {
			offset = vec3(0);
			printErr("class FX method get_offset(): arg",null,"instead set arg and return",offset);
		}
		return offset;
	}

	public vec3 get_speed() {
		if(speed == null) {
			speed = vec3(0);
			printErr("class FX method get_offset(): arg",null,"instead set arg and return",speed);
		}
		return speed;
	}

	public vec4 get_level_source() {
		if(level_source == null) {
			level_source = vec4(1);
			printErr("class FX method get_level_source(): arg",null,"instead set arg and return",level_source);
		}
		return level_source;
	}

	public vec4 get_level_layer() {
		if(level_layer == null) {
			level_layer = vec4(1);
			printErr("class FX method get_level_layer(): arg",null,"instead set arg and return",level_layer);
		}
		return level_layer;
	}

	public vec4 get_colour() {
		if(colour == null) {
			colour = vec4(1);
			printErr("class FX method get_colour(): arg",null,"instead set arg and return",colour);
		}
		return colour;
	}

	public vec4 get_cardinal() {
		if(cardinal == null) {
			cardinal = vec4(1);
			printErr("class FX method get_cardinal(): arg",null,"instead set arg and return",cardinal);
		}
		return cardinal;
	}

	public float get_hue() {
		return hue;
	}

	public float get_saturation() {
		return saturation;
	}

	public float get_brightness() {
		return brightness;
	}

	public float get_red() {
		return red;
	}

	public float get_green() {
		return green;
	}

	public float get_blue() {
		return blue;
	}

	public float get_alpha() {
		return alpha;
	}   

  // matrix
	public vec3 get_matrix(int which) {
		if(matrix != null  && which < matrix.length && which >= 0) {
			if(matrix[which] == null) {
				matrix[which] = vec3(0);
				printErr("class FX method get_matrix(): arg",null,"instead set arg and return",matrix[which]);
			}
			return matrix[which];
		} else return null;
	}

	public vec3 [] get_matrix() {
		if(matrix != null) {
			return matrix;
		} else return null;
	}
  
  // pair
	public vec2 get_pair(int which) {
		if(pair != null && which < pair.length && which >= 0) {
			if(pair[which] == null) {
				pair[which] = vec2(0);
				printErr("class FX method get_pair(): arg",null,"instead set arg and return",pair[which]);
			}
			return pair[which];
		} else return null;
	}

	public vec2 [] get_pair() {
		if(pair != null) {
			return pair;
		} else return null;
	}
  
  // event
  public bvec4 get_event(int which) {
		if(event != null && which < event.length  && which >= 0) {
			return event[which];
		} else {
			printErr("class FX method get_event(",which,") is out of the list available");
			return null;
		}
	}

	public bvec4 [] get_event() {
		if(event != null) {
			return event;
		} else return null;
	}

	// util
	private bvec4 build_boolean_4(boolean... arg) {
		if(arg.length == 1 ) {
			return bvec4(arg[0],false,false,false);
		} else if(arg.length == 2) {
			return bvec4(arg[0],arg[1],false,false);
		} else if(arg.length == 3) {
			return bvec4(arg[0],arg[1],arg[2],false);
		} else if(arg.length == 4) {
			return bvec4(arg[0],arg[1],arg[2],arg[3]);
		} else {
			return bvec4(false);
		}
	}


	private vec4 build_float_4(float... arg) {
		if(arg.length == 1 ) {
			return vec4(arg[0],arg[0],arg[0],g.colorModeA);
		} else if(arg.length == 2) {
			return vec4(arg[0],arg[0],arg[0],arg[1]);
		} else if(arg.length == 3) {
			return vec4(arg[0],arg[1],arg[2],g.colorModeA);
		} else if(arg.length == 4) {
			return vec4(arg[0],arg[1],arg[2],arg[3]);
		} else {
			return vec4(g.colorModeX,g.colorModeY,g.colorModeZ,g.colorModeA);
		}
	}

	private vec3 build_float_3(float... arg) {
		if(arg.length == 1 ) {
			return vec3(arg[0],arg[0],arg[0]);
		} else if(arg.length == 2) {
			return vec3(arg[0],arg[1],0);
		} else if(arg.length == 3) {
			return vec3(arg[0],arg[1],arg[2]);
		} else {
			return vec3(0);
		}
	}

	private vec2 build_float_2(float... arg) {
		if(arg.length == 1 ) {
			return vec2(arg[0],arg[0]);
		} else if(arg.length == 2) {
			return vec2(arg[0],arg[1]);
		} else {
			return vec2(0);
		}
	}
}
/**
* POST FX shader collection
*
* 2019-2019
* v 0.2.0
* all filter bellow has been tested.
* @author @stanlepunk
* @see https://github.com/StanLepunK/Shader
*/








/**
* Template by Stan le punk
* this template can be used for texture or direct filtering
v 0.1.3
2018-2019
*/
// setting by class FX
public PGraphics fx_template(PImage source, FX fx) {
	return fx_template(source,fx.on_g(),null);
}




// main
PShader fx_template;
PGraphics result_template;
public PGraphics fx_template(PImage source, boolean on_g, vec4 level_source) {
	if(!on_g && (result_template == null 
								|| (source.width != result_template.width 
								&& source.height != result_template.height))) {
		result_template = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_template == null) {
		String path = get_fx_post_path()+"template_fx_post.glsl";
		if(fx_post_rope_path_exists) {
			fx_template = loadShader(path);
			println("load shader: template_fx_post.glsl");
		}
		println("load shader:",path);
	} else {
		if(on_g) set_shader_flip(fx_template,source);
		fx_template.set("texture_source",source);
		fx_template.set("resolution",(float)source.width,(float)source.height);

  
    // fx_template.set("color_mode",3); // mode 0 RGB / mode 3 HSB

    // fx_template.set("hue",cx); // value from 0 to 1
		fx_template.set("level_source",level_source.x,level_source.y,level_source.w,level_source.z); // value from 0 to 1
		// fx_template.set("level_source",1,1,1,1.); // value from 0 to 1

    // rendering
		render_shader(fx_template,result_template,source,on_g);

	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_template; 
	}
}







































/**
* Blur circular
* v 0.1.4
* 2018-2019
*/
// use fx setting
public PGraphics fx_blur_circular(PImage source, FX fx) {
	return fx_blur_circular(source,fx.on_g(),fx.get_strength(),fx.get_num());

}

// test setting
public PGraphics fx_blur_circular(PImage source, boolean on_g) {
	float strength = map(mouseX,0,width,0,100);
	int num = 36; // samples: 16 is default / max 256 but in this cas you need a very very robust graphics engine
	return fx_blur_circular(source,on_g,vec3(strength),num);
}


// main 
PShader fx_blur_circular;
PGraphics result_blur_circular;
public PGraphics fx_blur_circular(PImage source, boolean on_g, vec3 strength, int num) {
	if(!on_g && (result_blur_circular == null || (source.width != result_blur_circular.width && source.height != result_blur_circular.height))) {
		result_blur_circular = createGraphics(source.width,source.height,get_renderer());
	}
	
	if(fx_blur_circular == null) {
		String path = get_fx_post_path()+"blur_circular.glsl";
		if(fx_post_rope_path_exists) {
			fx_blur_circular = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_blur_circular,source);
		fx_blur_circular.set("texture_source",source);
		fx_blur_circular.set("resolution_source",source.width,source.height);
		fx_blur_circular.set("resolution",source.width,source.height);
    
    // external variable
		if(strength != null) fx_blur_circular.set("strength",strength.x);
		fx_blur_circular.set("num",num); 

		render_shader(fx_blur_circular,result_blur_circular,source,on_g);
	}
	// end
	reset_reverse_g(false);
	if(on_g) {
		return null;	
	} else {
		return result_blur_circular; 
	}
}








/**
* gaussian blur
* v 0.2.3
* 2018-2019
*/
// setting by class FX
public PGraphics fx_blur_gaussian(PImage source, FX fx) {
	ivec2 res = ivec2();
	boolean second_pass = true;
	return fx_blur_gaussian(source,fx.on_g(),second_pass,res,fx.get_strength().x());
}


// test setting
public PGraphics fx_blur_gaussian(PImage source, boolean on_g) {
	ivec2 res = ivec2();
	boolean second_pass = true;
	float size = 5; // blur
	return fx_blur_gaussian(source,on_g,second_pass,res,size);
}

// main
PShader fx_blur_gaussian;
PGraphics result_blur_gaussian;
public PGraphics fx_blur_gaussian(PImage source, boolean on_g, boolean second_pass, ivec2 resolution, float strength) {
	if(!on_g && (result_blur_gaussian == null || (source.width != result_blur_gaussian.width && source.height != result_blur_gaussian.height))) {
		result_blur_gaussian = createGraphics(source.width,source.height,get_renderer());
	}
  
  if(result_blur_gaussian == null) {
  	// security, because that's return problem consol with too much waring message for PImage source
  	if(resolution != null && !all(equal(ivec2(-1),resolution))) {
  		result_blur_gaussian = fx_image(source,false,null,null,null,null,SCREEN);
  	}
  } else {
  	if(resolution != null && !all(equal(ivec2(result_blur_gaussian),resolution))) {
  		result_blur_gaussian = fx_image(source,false,null,null,null,null,SCREEN);
  	}
  }


	PGraphics pg;
  PGraphics pg_2;

	if(resolution == null) {
  	pg = createGraphics(result_blur_gaussian.width,result_blur_gaussian.height,get_renderer());
  	pg_2 = createGraphics(result_blur_gaussian.width,result_blur_gaussian.height,get_renderer());
  } else {
  	int min_res = 10;
  	if(any(lessThanEqual(resolution,ivec2(min_res)))) {
  		resolution.set(result_blur_gaussian.width,result_blur_gaussian.height);
  	}
  	pg = createGraphics(resolution.x,resolution.y,get_renderer());
  	pg_2 = createGraphics(resolution.x,resolution.y,get_renderer());
  }

	
	if(fx_blur_gaussian == null) {
		String path = get_fx_post_path()+"blur_gaussian.glsl";
		if(fx_post_rope_path_exists) {
			fx_blur_gaussian = loadShader(path);
			println("load shader:",path);
		}
	} else {
		// flip part, for the case it's a texture, PImage or PGraphics
		fx_blur_gaussian.set("texture_source",source);
		if(on_g) {
			fx_blur_gaussian.set("flip_source",true,false);
			if(graphics_is(source).equals("PGraphics") && !reverse_g_source_is()) {
				fx_blur_gaussian.set("flip_source",false,false);
				reverse_g_source(true);
			} 
		}


		if(resolution != null) {
			fx_blur_gaussian.set("resolution",resolution.x,resolution.y);
			fx_blur_gaussian.set("resolution_source",resolution.x,resolution.y);
		}


		// external parameter
		if(strength <= 0.001f) strength = 0.001f;
		fx_blur_gaussian.set("size",strength); // from 1 to nowhere
		fx_blur_gaussian.set("sigma",.5f); // better between 0 and 1
		fx_blur_gaussian.set("horizontal_pass",true);
	  


	  // rendering 
	  if(!on_g) {
	  	pg.beginDraw();            
	    pg.shader(fx_blur_gaussian);
	    pg.image(result_blur_gaussian,0,0); 
	    pg.endDraw();

	    // Applying the blur shader along the horizontal direction   
	    if(second_pass) {
	    	fx_blur_gaussian.set("texture_source",pg);
	    	fx_blur_gaussian.set("horizontal_pass",false); 	
	    	pg_2.beginDraw();            
	    	pg_2.shader(fx_blur_gaussian);  
	    	pg_2.image(pg,0,0);
	    	pg_2.endDraw(); 	
	    }
	  } else if(on_g) {
	  	g.filter(fx_blur_gaussian);
	  	// Applying the blur shader along the horizontal direction   
	  	if(second_pass) {
	  		fx_blur_gaussian.set("texture_source",g);
	    	fx_blur_gaussian.set("horizontal_pass",false);
	    	g.filter(fx_blur_gaussian);
	  	}
	  }  
	}
	
  // end
  reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		if(second_pass) {
			return pg_2; 
		} else {
			return pg;
		}
		
	}
}

















/**
* Blur radial
v 0.2.4
2018-2019
*/
// setting by class FX
public PGraphics fx_blur_radial(PImage source, FX fx) {
	float str = 0;
	if(fx.get_strength() != null) {
		str = fx.get_strength().x();
	}

	float scl = 0;
	if(fx.get_scale() != null) {
		scl = fx.get_scale().x();
	}
	return fx_blur_radial(source,fx.on_g(),vec2(fx.get_pos()),str,scl);
}





// main
PShader fx_blur_radial;
PGraphics result_blur_radial;
public PGraphics fx_blur_radial(PImage source, boolean on_g, vec2 pos, float strength, float scale) {
	if(!on_g && (result_blur_radial == null 
								|| (source.width != result_blur_radial.width 
								&& source.height != result_blur_radial.height))) {
		result_blur_radial = createGraphics(source.width,source.height,get_renderer());
	}
	
	if(fx_blur_radial == null) {
		String path = get_fx_post_path()+"blur_radial.glsl";
		if(fx_post_rope_path_exists) {
			fx_blur_radial = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_blur_radial,source);
		fx_blur_radial.set("texture_source",source);

    // external parameter
		fx_blur_radial.set("scale",scale); // from 0 to beyond but good around .9;
		fx_blur_radial.set("strength",strength);
		if(pos != null) fx_blur_radial.set("position",pos.x,pos.y);
		
		render_shader(fx_blur_radial,result_blur_radial,source,on_g);
	}
	
	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_blur_radial; 
	}
}












/**
* Colour change A by Stan le punk
v 0.2.2
2018-2019
*/

// setting by class FX
public PGraphics fx_colour_change_a(PImage source, FX fx) {
	return fx_colour_change_a(source,fx.on_g(),fx.get_num(),fx.get_matrix());
}

// test
public PGraphics fx_colour_change_a(PImage source, boolean on_g) {
	vec3 col_0 = vec3().sin_wave(frameCount,.001f,.02f,.005f).mult(10);
  vec3 col_1 = vec3().cos_wave(frameCount,.001f,.02f,.005f).mult(10);
  vec3 col_2 = vec3().sin_wave(frameCount,.01f,.002f,.002f).mult(10);
		// 	vec3 col_0 = vec3(-1,0,1);
		// vec3 col_1 = vec3(1,0,-1);
		// vec3 col_2 = vec3(-1,0,1);	
	int num = (int)map(mouseX,0,width,1,32);
	return fx_colour_change_a(source,false,num,col_0);
}


// main
PShader fx_colour_change_a;
PGraphics result_colour_change_a;
public PGraphics fx_colour_change_a(PImage source, boolean on_g, int num, vec3... mat) {
	if(!on_g && (result_colour_change_a == null 
								|| (source.width != result_colour_change_a.width 
								&& source.height != result_colour_change_a.height))) {
		result_colour_change_a = createGraphics(source.width,source.height,get_renderer());
	}
	
	if(fx_colour_change_a == null) {
		String path = get_fx_post_path()+"colour_change_A.glsl";
		if(fx_post_rope_path_exists) {
			fx_colour_change_a = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_colour_change_a,source);
		fx_colour_change_a.set("texture_source",source);

		// external param
		if(mat != null && mat.length == 1) {
			if(mat[0] != null) fx_colour_change_a.set("mat_col_0",mat[0].x,mat[0].y,mat[0].z);
		} else if(mat != null && mat.length == 2) {
			if(mat[0] != null) fx_colour_change_a.set("mat_col_0",mat[0].x,mat[0].y,mat[0].z);
			if(mat[1] != null) fx_colour_change_a.set("mat_col_1",mat[1].x,mat[1].y,mat[1].z);
		} else if(mat != null && mat.length > 2) {
			if(mat[0] != null) fx_colour_change_a.set("mat_col_0",mat[0].x,mat[0].y,mat[0].z);
			if(mat[1] != null) fx_colour_change_a.set("mat_col_1",mat[1].x,mat[1].y,mat[1].z);
			if(mat[2] != null) fx_colour_change_a.set("mat_col_2",mat[2].x,mat[2].y,mat[2].z);
		}

		fx_colour_change_a.set("num",num);

		render_shader(fx_colour_change_a,result_colour_change_a,source,on_g);

	}
	
	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;	
	} else {
		return result_colour_change_a; 
	}
}













/**
* colour change B
* v 0.0.4
* 2018-2019
*/

// setting by class FX
public PGraphics fx_colour_change_b(PImage source, FX fx) {
	float angle = 0;
	if(fx.get_angle() != null) {
		angle = fx.get_angle().x;
	}

	float strength = 0;
	if(fx.get_strength() != null) {
		strength = fx.get_strength().x;
	}
	return fx_colour_change_b(source,fx.on_g(),angle,strength);
}

// test
public PGraphics fx_colour_change_b(PImage source, boolean on_g) {
	float angle = map(mouseX,0,width,0,TAU);
	float strength = map(mouseY,0,height,1,10);
	return fx_colour_change_b(source,on_g,angle,strength);
}

PShader fx_colour_change_b;
PGraphics pg_colour_change_b;
public PGraphics fx_colour_change_b(PImage source, boolean on_g, float angle, float strength) {
	if(!on_g && (pg_colour_change_b == null 
								|| (source.width != pg_colour_change_b.width 
								&& source.height != pg_colour_change_b.height))) {
		pg_colour_change_b = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_colour_change_b == null) {
		String path = get_fx_post_path()+"colour_change_B.glsl";
		if(fx_post_rope_path_exists) {
			fx_colour_change_b = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_colour_change_b,source);
		fx_colour_change_b.set("texture_source",source);
		fx_colour_change_b.set("resolution_source",source.width,source.height);
		
		// external parameter
    fx_colour_change_b.set("angle",angle); 
    fx_colour_change_b.set("strength",1.f);

    // rendering
		render_shader(fx_colour_change_b,pg_colour_change_b,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_colour_change_b; 
	}
}























/**
* Datamosh inpired by an algorithm of Alexandre Rivaux 
* @see https://github.com/alexr4/datamoshing-GLSL
* v 0.0.2
*2019-2019
*/
// setting by class FX
public PGraphics fx_datamosh(PImage source, FX fx) {
	return fx_datamosh(source,fx.on_g(),fx.get_threshold().x(),fx.get_strength().x(),fx.get_pair(0),fx.get_pair(1),fx.get_pair(2));
}

// main
PShader fx_datamosh;
PShader fx_flip_datamosh;
PGraphics pg_datamosh;
public PGraphics fx_datamosh(PImage source, boolean on_g, float threshold, float strength, vec2 offset_red, vec2 offset_green, vec2 offset_blue) {
	if(!on_g && (pg_datamosh == null 
								|| (source.width != pg_datamosh.width 
								&& source.height != pg_datamosh.height))) {
		pg_datamosh = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_datamosh == null) {
		// main glsl
		String path = get_fx_post_path()+"datamosh.glsl";
		if(fx_post_rope_path_exists) {
			fx_datamosh = loadShader(path);
			println("load shader: datamosh.glsl");
		}
		println("load shader:",path);
		// flip glsl
		path = get_fx_post_path()+"flip.glsl";
		if(fx_post_rope_path_exists) {
			fx_flip_datamosh = loadShader(path);
			println("load shader: flip.glsl");
		}
		println("load shader:",path);
	} else {
		if(on_g) set_shader_flip(fx_datamosh,source);

		fx_datamosh.set("resolution",(float)source.width,(float)source.height);
		fx_datamosh.set("resolution_source",(float)source.width,(float)source.height);

    fx_datamosh.set("texture",source);
    
    fx_datamosh.set("strength",strength); // value from -infinite to infinite 
		fx_datamosh.set("threshold",threshold); // value from 0 to 1

		if(offset_red != null) {
			fx_datamosh.set("offset_red",offset_red.x(),offset_red.y());
		}

		if(offset_green != null) {
			fx_datamosh.set("offset_green",offset_green.x(),offset_green.y());
		}
		
		if(offset_blue != null) {
			fx_datamosh.set("offset_blue",offset_blue.x(),offset_blue.y());
		} 

		if(pg_datamosh == null) {
			pg_datamosh = createGraphics(source.width,source.height,get_renderer());
		} else {
			fx_datamosh.set("texture_layer",pg_datamosh);
		}
		if(pg_datamosh.width > 0 && pg_datamosh.height > 0) {
			pg_datamosh.beginDraw();
			pg_datamosh.shader(fx_datamosh);
			pg_datamosh.image(source,0,0);
			pg_datamosh.endDraw();
		}
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		background(pg_datamosh,CENTER);
		fx_flip_datamosh.set("texture_source",g);
		fx_flip_datamosh.set("resolution_source",width,height);
		fx_flip_datamosh.set("flip_source",1,1);
		filter(fx_flip_datamosh);
		return null;
	} else {
		return pg_datamosh; 
	}
}



























/**
* Dither bayer 8
* v 0.2.0
* 2018-2019
*/
// setting by class FX
public PGraphics fx_dither_bayer_8(PImage source, FX fx) {
	return fx_dither_bayer_8(source,fx.on_g(),vec3(fx.get_level_source()),fx.get_mode());	
}

// main
PShader fx_dither_bayer_8;
PGraphics pg_dither_bayer_8;
public PGraphics fx_dither_bayer_8(PImage source, boolean on_g, vec3 level, int mode) {
	if(!on_g && (pg_dither_bayer_8 == null 
								|| (source.width != pg_dither_bayer_8.width 
								&& source.height != pg_dither_bayer_8.height))) {
		pg_dither_bayer_8 = createGraphics(source.width,source.height,get_renderer());
	}

	
	if(fx_dither_bayer_8 == null) {
		String path = get_fx_post_path()+"dither_bayer_8.glsl";
		if(fx_post_rope_path_exists) {
			fx_dither_bayer_8 = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_dither_bayer_8,source);
		fx_dither_bayer_8.set("texture_source",source);
		fx_dither_bayer_8.set("resolution_source",source.width,source.height);


		// external parameter
    fx_dither_bayer_8.set("level_source",level.x,level.y,level.z);
    fx_dither_bayer_8.set("mode",mode); // mode 0 : gray / 1 is rgb

    // rendering
		render_shader(fx_dither_bayer_8,pg_dither_bayer_8,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_dither_bayer_8; 
	}
}












/**
* Flip
* v 0.0.1
*2019-2019
*/
// setting by class FX
public PGraphics fx_flip(PImage source, FX fx) {
	return fx_flip(source,fx.on_g(),fx.get_event(0).xy());
}

// main
PShader fx_flip;
PGraphics pg_flip;
public PGraphics fx_flip(PImage source, boolean on_g, bvec2 flip) {
	if(!on_g && (pg_flip == null 
								|| (source.width != pg_flip.width 
								&& source.height != pg_flip.height))) {
		pg_flip = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_flip == null) {
		// main glsl
		String path = get_fx_post_path()+"flip.glsl";
		if(fx_post_rope_path_exists) {
			fx_flip = loadShader(path);
			println("load shader: flip.glsl");
		}
		println("load shader:",path);
	} else {

		ivec2 iflip = ivec2(0);
		if(flip.x) iflip.x(1);
		if(flip.y) iflip.y(1);
		if(on_g) {
			iflip.y = 1-iflip.y;
		}

		fx_flip.set("resolution",(float)source.width,(float)source.height);
		fx_flip.set("resolution_source",(float)source.width,(float)source.height);
    fx_flip.set("texture_source",source);
		fx_flip.set("flip_source",iflip.x(),iflip.y()); // value: 0 or 1

    // rendering
		render_shader(fx_flip,pg_flip,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_flip; 
	}
}















/**
* Grain 
v 0.1.4
2018-2019
*/

// setting by class FX
public PGraphics fx_grain(PImage source, FX fx) {
	float offset = 0;
	if(fx.get_offset() != null) {
		offset = fx.get_offset().x;
	}

	float scl = 0;
	if(fx.get_scale() != null) {
		scl = fx.get_scale().x;
	}
	return fx_grain(source,fx.on_g(),offset,fx.get_mode());
}

// main
PShader fx_grain;
PGraphics result_grain;
public PGraphics fx_grain(PImage source, boolean on_g, float offset, int mode) {
	if(!on_g && (result_grain == null 
								|| (source.width != result_grain.width 
								&& source.height != result_grain.height))) {
		result_grain = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_grain == null) {
		String path = get_fx_post_path()+"grain.glsl";
		if(fx_post_rope_path_exists) {
			fx_grain = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_grain,source);
		fx_grain.set("texture_source",source);
		fx_grain.set("resolution_source",source.width,source.height);
		fx_grain.set("resolution",source.width,source.height);

		// external param
    fx_grain.set("offset",offset); // that define the offset
		fx_grain.set("mode",mode); // mode 0 is for black and white, and mode 1 for RVB

		render_shader(fx_grain,result_grain,source,on_g);

	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;	
	} else {
		return result_grain; 
	}
}


















/**
* Grain scatter
v 0.1.4
2018-2019
*/
// setting by class FX
public PGraphics fx_grain_scatter(PImage source, FX fx) {
		float str = 0;
	if(fx.get_strength() != null) {
		str = fx.get_strength().x;
	}
	return fx_grain_scatter(source,fx.on_g(),str);
}


// main
PShader fx_grain_scatter;
PGraphics result_grain_scatter;
public PGraphics fx_grain_scatter(PImage source, boolean on_g,float strength) {
	if(!on_g && (result_grain_scatter == null 
								|| (source.width != result_grain_scatter.width 
								&& source.height != result_grain_scatter.height))) {
		result_grain_scatter = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_grain_scatter == null) {
		String path = get_fx_post_path()+"grain_scatter.glsl";
		if(fx_post_rope_path_exists) {
			fx_grain_scatter = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_grain_scatter,source);
		fx_grain_scatter.set("texture_source",source);
		fx_grain_scatter.set("resolution_source",source.width,source.height);
		fx_grain_scatter.set("resolution",source.width,source.height);

		// external param
		fx_grain_scatter.set("strength",strength);

		// rendering
		render_shader(fx_grain_scatter,result_grain_scatter,source,on_g);

	}
	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_grain_scatter; 
	}
}



















/**
* halftone dot
* v 0.0.5
* 2018-2019
*/
// setting by class FX
public PGraphics fx_halftone_dot(PImage source, FX fx) {
	vec2 pos = vec2(source.width/2,source.height/2);
	if(fx.get_pos() != null) {
		pos = vec2(fx.get_pos().x(),fx.get_pos().y());
	}

	float threshold = .95f;
	if(fx.get_threshold() != null) {
		threshold = fx.get_threshold().x();
	}

	float angle = 0;
	if(fx.get_angle() != null) {
		angle = fx.get_angle().x();
	}

	float pixel_size = 5;
	if(fx.get_angle() != null) {
		pixel_size = fx.get_size().x();
	}

	return fx_halftone_dot(source,fx.on_g(),pos,pixel_size,angle,threshold);
}




// test
public PGraphics fx_halftone_dot(PImage source, boolean on_g) {
	vec2 pos = vec2(mouseX,mouseY);
	float threshold = .95f;
	float size = 30;
	float pixel_size = (abs(sin(frameCount *.01f))) *size +1;
	float angle = sin(frameCount *.001f) *TAU;

	return fx_halftone_dot(source,on_g,pos,pixel_size,angle,threshold);
}




// main
PShader fx_halftone;
PGraphics result_halftone_dot;
public PGraphics fx_halftone_dot(PImage source, boolean on_g, vec2 pos, float size, float angle, float threshold) {
	if(!on_g && (result_halftone_dot == null 
								|| (source.width != result_halftone_dot.width 
								&& source.height != result_halftone_dot.height))) {
		result_halftone_dot = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_halftone == null) {
		String path = get_fx_post_path()+"halftone_dot.glsl";
		if(fx_post_rope_path_exists) {
			fx_halftone = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_halftone,source);
		fx_halftone.set("texture_source",source);
		fx_halftone.set("resolution_source",source.width,source.height);

		// external parameter
		fx_halftone.set("angle",angle);
    pos.div(source.width,source.height);
    if(graphics_is(source).equals("PGraphics")) {
    	pos.y(1.0f -pos.y);
    }
    fx_halftone.set("position",pos.x,pos.y);

		
		fx_halftone.set("size",size);
		fx_halftone.set("threshold",threshold);

		render_shader(fx_halftone,result_halftone_dot,source,on_g);

	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_halftone_dot; 
	}
}










/**
* halftone line
* v 0.0.7
* 2018-2019
*/
// use setting
public PGraphics fx_halftone_line(PImage source, FX fx) {
	vec2 pos = vec2(source.width/2,source.height/2);
	if(fx.get_pos() != null) {
		pos = vec2(fx.get_pos().x,fx.get_pos().y);
	}

	vec3 angle = vec3();
	if(fx.get_angle() != null) {
		angle = fx.get_angle().copy();
	}

	int mode = fx.get_mode();
	int num = fx.get_num();
	float quality = fx.get_quality();

  vec3 threshold = vec3(.9f);
	if(fx.get_threshold() != null) {
		threshold = fx.get_threshold().copy();
	}
	return fx_halftone_line(source,fx.on_g(),pos,angle,mode,num,quality,threshold);	
}





// local test setting
public PGraphics fx_halftone_line(PImage source, boolean on_g) {
	int mode = 0; // from 0 to 6
	int num = 30; // number of line
	float quality = .5f; 
	float threshold = .2f; // good between 0.05 and 0.3
	float angle = sin(frameCount *.001f) * PI; // angle in radians
	float pos_x = map(width/2,0,width,0,1); // normal position
	float pos_y = map(height/2,0,height,0,1); // normal position
	return fx_halftone_line(source,on_g,vec2(pos_x,pos_y),vec3(angle),mode,num,quality,vec3(threshold));
}

// main
PShader fx_halftone_line;
PGraphics result_halftone_line;
public PGraphics fx_halftone_line(PImage source, boolean on_g, vec2 pos, vec3 angle, int mode, int num, float quality, vec3 threshold) {
	if(!on_g && (result_halftone_line == null 
								|| (source.width != result_halftone_line.width 
								&& source.height != result_halftone_line.height))) {
		result_halftone_line = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_halftone_line == null) {
		String path = get_fx_post_path()+"halftone_line.glsl";
		if(fx_post_rope_path_exists) {
			fx_halftone_line = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_halftone_line,source);
		fx_halftone_line.set("texture_source",source);
		fx_halftone_line.set("resolution_source",source.width,source.height);
    
    // external parameter
    fx_halftone_line.set("mode",mode);
    fx_halftone_line.set("num",num);
    fx_halftone_line.set("quality",quality);
    fx_halftone_line.set("threshold",threshold.x); // good between 0.05 and 0.3
		fx_halftone_line.set("angle",angle.x);

		if(graphics_is(source).equals("PGraphics")) {
			pos.y(1.0f -pos.y);
		}
		fx_halftone_line.set("position",pos.x,pos.y); // middle position on window

    // rendering
		render_shader(fx_halftone_line,result_halftone_line,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_halftone_line; 
	}
}



/**
* Halftone Multi
* refactoring from 
* v 0.0.2
* 2019-2019
*/
// use setting
public PGraphics fx_halftone_multi(PImage source, FX fx) {
	return fx_halftone_multi(source,fx.on_g(),vec2(fx.get_pos()),fx.get_size().x,fx.get_angle().x,fx.get_quality(),fx.get_threshold().x,fx.get_saturation(),fx.get_mode());
}


// main
PShader fx_halftone_multi;
PGraphics pg_halftone_multi;
public PGraphics fx_halftone_multi(PImage source, boolean on_g, vec2 pos, float size, float angle, float quality, float threshold, float saturation, int mode) {
	if(!on_g && (pg_halftone_multi == null 
								|| (source.width != pg_halftone_multi.width 
								&& source.height != pg_halftone_multi.height))) {
		pg_halftone_multi = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_halftone_multi == null) {
		String path = get_fx_post_path()+"halftone_multi.glsl";
		if(fx_post_rope_path_exists) {
			fx_halftone_multi = loadShader(path);
			println("load shader:",path);
		}
	} else {
    if(on_g) set_shader_flip(fx_halftone_multi,source);
		fx_halftone_multi.set("texture_source",source);
		fx_halftone_multi.set("resolution_source",source.width,source.height);
    
		// external param
		if(graphics_is(source).equals("PGraphics")) {
			pos.y(1.0f -pos.y);
		}
		fx_halftone_multi.set("position",pos.x,pos.y); // -1 to 1
		float sat = map(saturation,0,1,-1,1);
		fx_halftone_multi.set("saturation",sat); // -1 to 1
		fx_halftone_multi.set("angle",angle); // in radian
		fx_halftone_multi.set("scale",size); // from 0 to 2 is good
		fx_halftone_multi.set("divs",quality); // from 1 to 16
		fx_halftone_multi.set("sharpness",threshold); // from 0 to 2 is good
		fx_halftone_multi.set("mode",mode); // from 0 to 3 dot, circle and line

		 // rendering
    render_shader(fx_halftone_multi,pg_halftone_multi,source,on_g);
	}

	// end
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_halftone_multi; 
	}
}











/**
* IMAGE MAPPING
* 
*/
// setting by class FX
public PGraphics fx_image(PImage source, FX fx) {
	return fx_image(source,fx.on_g(),vec2(fx.get_pos()),vec2(fx.get_size()),vec3(fx.get_colour()),fx.get_cardinal(),fx.get_mode());
}


// main
PShader fx_image;
PGraphics pg_image_rendering;
public PGraphics fx_image(PImage source, boolean on_g, vec2 pos, vec2 scale, vec3 colour_background, vec4 pos_curtain, int mode) {
	if(!on_g && (pg_image_rendering == null 
								|| (source.width != pg_image_rendering.width 
								&& source.height != pg_image_rendering.height))) {
		pg_image_rendering = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_image == null) {
		String path = get_fx_post_path()+"image.glsl";
		if(fx_post_rope_path_exists) {
			fx_image = loadShader(path);
			println("load shader: image.glsl");
		}
		println("load shader:",path);
	} else {
		
		if(on_g) set_shader_flip(fx_image,source);
		// fx_image.set("flip_source",true,false);
		fx_image.set("texture_source",source);
		fx_image.set("resolution",width,height);
		fx_image.set("resolution_source",source.width,source.height); 
		
		// fx_image.set("flip_source",true,false);
		// fx_image.set("texture_source",source);
		// fx_image.set("resolution",width,height);
		// fx_image.set("resolution_source",source.width,source.height); 

    // external parameter
		if(colour_background != null) {
			println("colour",colour_background);
	    fx_image.set("colour",colour_background.x,colour_background.y,colour_background.z); // definr RGB color from 0 to 1
	  }

	  if(pos_curtain != null) {
	  	// printTempo(60,"curtain",pos_curtain);
	    fx_image.set("curtain",pos_curtain.x,pos_curtain.y,pos_curtain.z,pos_curtain.w); // definr RGB color from 0 to 1
	  }

	  if(pos != null) {
	  	if(graphics_is(source).equals("PGraphics")) {
	  		pos.y(1.0f -pos.y);
	  	}
	    fx_image.set("position",pos.x,pos.y); // from 0 to 1
	  }
	  
	  if(scale != null) {
	    fx_image.set("scale",scale.x,scale.y);
	  }
	  
	  int shader_mode = 0;
	  if(mode == CENTER) {
	    shader_mode = 0;
	  } else if(mode == SCREEN) {
	    shader_mode = 1;
	  } else if(mode == r.SCALE) {
	    shader_mode = 2;
	  }
	  // println("mode",shader_mode);
	  fx_image.set("mode",shader_mode);

    // rendering
		render_shader(fx_image,pg_image_rendering,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_image_rendering; 
	}
}






















/**
* Level
v 0.0.3
2019-2019
*/
// direct filtering
public PGraphics fx_level(PImage source, FX fx) {
	vec3 level = vec3(1);
	if(fx.get_level_source() != null) {
		level.set(fx.get_level_source());
	}
	return fx_level(source,fx.on_g(),fx.get_mode(),level.array());
}

// PGraphics filtering
public PGraphics fx_level(PImage source, boolean on_g) {
	int mode = 0;
	vec3 level = abs(vec3().sin_wave(frameCount,.01f,.02f,.04f));
	return fx_level(source,on_g,mode,level.array());
}

// main method
PShader fx_level;
PGraphics result_level;
public PGraphics fx_level(PImage source, boolean on_g, int mode, float... level) {
	if(!on_g && (result_level == null 
								|| (source.width != result_level.width 
								&& source.height != result_level.height))) {
		result_level = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_level == null) {
		String path = get_fx_post_path()+"level.glsl";
		if(fx_post_rope_path_exists) {
			fx_level = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_level,source);
		fx_level.set("texture_source",source);
		fx_level.set("resolution_source",source.width,source.height);
		if(level.length == 1) {
			fx_level.set("level_source",level[0],level[0],level[0],1);
		} else if(level.length == 2) {
			fx_level.set("level_source",level[0],level[0],level[0],level[1]);
		} else if(level.length == 3) {
			fx_level.set("level_source",level[0],level[1],level[2],1);
		} else if(level.length == 4) {
			fx_level.set("level_source",level[0],level[1],level[2],level[3]);
		} else {
			fx_level.set("level_source",1,1,1,1);
		}
		
		if(mode >= 0 && mode < 2) {
			fx_level.set("mode",mode); // 0 black / 1 white
		} 


    // rendering
		render_shader(fx_level,result_level,source,on_g);

	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_level; 
	}
}














/**
* mix
* v 0.0.6
* 2019-2019
*
* -2 main
* -1 layer 
* 0 ?
* 1 multiply
* 2 screen
* 3 exclusion
* 4 overlay
* 5 hard_light
* 6 soft_light
* 7 color_dodge
* 8 color_burn
* 9 linear_dodge
* 10 linear_burn
* 11 vivid_light
* 12 linear_light
* 13 pin_light
* 14 hard_mix
*  15 subtract
* 16 divide
* 17 addition
* 18 difference
* 19 darken
* 20 lighten
* 21 invert
* 22 invert_rgb
* 23 main
* 24 layer
*/

// test
public PGraphics fx_mix(PImage source, PImage layer, FX fx) {
	vec3 level_source = vec3(.5f);
	if(fx.get_level_source() != null) {
		level_source = vec3(fx.get_level_source());
	}
	vec3 level_layer = vec3(.5f);
	if(fx.get_level_layer() != null) {
		level_layer = vec3(fx.get_level_layer());
	}
  return fx_mix(source,layer,true,fx.get_mode(),level_source,level_layer);
	
}

// test
public PGraphics fx_mix(PImage source, PImage layer, boolean on_g) {
	int mode = 1; // multiply
	vec3 level_source = abs(vec3().sin_wave(frameCount,.01f,.025f,.05f));
	vec3 level_layer = abs(vec3().cos_wave(frameCount,.01f,.025f,.05f));
	return fx_mix(source,layer,on_g,mode,level_source,level_layer);
}


// main
PShader fx_mix;
PGraphics result_mix;
public PGraphics fx_mix(PImage source, PImage layer, boolean on_g, int mode, vec3 level_source, vec3 level_layer) {
	if(!on_g && (result_mix == null 
								|| (source.width != result_mix.width 
								&& source.height != result_mix.height))) {
		result_mix = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_mix == null) {
		String path = get_fx_post_path()+"mix.glsl";
		if(fx_post_rope_path_exists) {
			fx_mix = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_mix,source);

		fx_mix.set("texture_source",source);
		fx_mix.set("resolution_source",source.width,source.height);
		fx_mix.set("texture_layer",layer);
		
		if(graphics_is(layer).equals("PGraphics")) {
			fx_mix.set("flip_layer",0,0);
		} else {
			if(on_g) {
				fx_mix.set("flip_layer",1,0);
			}
		}
		

    // external paramer
    fx_mix.set("level_source",level_source.x,level_source.y,level_source.z);
		fx_mix.set("level_layer",level_layer.x,level_layer.y,level_layer.z);

		fx_mix.set("mode",mode); 
    
    // rendering
    render_shader(fx_mix,result_mix,source,on_g);
 
	}

	// end
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_mix; 
	}
}



















/**
* Pixel 
* v 0.0.5
* 2018-2019
*/
// setting by class FX
public PGraphics fx_pixel(PImage source, FX fx) {
	ivec2 size = ivec2(5);
	if(fx.get_size() != null) {
		size.set(fx.get_size());
	}
	vec3 level_source = vec3(0,.5f,.5f);
	if(fx.get_level_source() != null) {
		level_source.set(fx.get_level_source());
	}
	return fx_pixel(source,fx.on_g(),size,fx.get_num(),level_source,fx.get_event(0).x());
}


// test
public PGraphics fx_pixel(PImage source, boolean on_g) {
	ivec2 size = ivec2(5);
	int num = 8;
	vec3 level_source = vec3(1);
  boolean effect_is = true;
	return fx_pixel(source,on_g,size,num,level_source,effect_is);
}


// main
PShader fx_pixel;
PGraphics result_pixel;
public PGraphics fx_pixel(PImage source, boolean on_g, ivec2 size, int num, vec3 level_source, boolean effect_is) {
	if(!on_g && (result_pixel == null 
								|| (source.width != result_pixel.width 
								&& source.height != result_pixel.height))) {
		result_pixel = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_pixel == null) {
		String path = get_fx_post_path()+"pixel.glsl";
		if(fx_post_rope_path_exists) {
			fx_pixel = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_pixel,source);
		fx_pixel.set("texture_source",source);
		fx_pixel.set("resolution",source.width,source.height);
		fx_pixel.set("resolution_source",source.width,source.height);
    
		// external param
		fx_pixel.set("use_fx_color",effect_is);
		fx_pixel.set("level_source",level_source.x,level_source.y,level_source.z,1); // from 0 to 1 where
		fx_pixel.set("num",num); // from 2 to 16
    fx_pixel.set("size",size.x,size.y); // define the width and height of pixel

    // rendering
		render_shader(fx_pixel,result_pixel,source,on_g);

	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_pixel; 
	}
}
















/**
* Reaction diffusion
* v 0.0.4
* 2018-2019
*/
/**
WARNING
the g part is not not not not optimized...too slow :((((((
*/

public PGraphics fx_reaction_diffusion(PImage source, FX fx) {
	return fx_reaction_diffusion(source,fx.on_g(),fx.get_pair(0),fx.get_pair(1),vec2(fx.get_scale()),vec3(fx.get_colour()),fx.get_num(),fx.get_event(0).x());
}



// test
public PGraphics fx_reaction_diffusion(PImage source) {
	float u = 0.25f;
  float v = 0.04f;
  vec2 conc_uv = vec2(u,v);
  
  float k = 0.047f;
  float f = 0.1f;
  vec2 kf = vec2(k,f);
  
  vec2 scale = vec2(.6f);

  float r = 0;
  float g = 0;
  float b = 0;
  vec3 rgb = vec3(r,g,b);

  int iteration = 20;
  boolean event = mousePressed;
	return fx_reaction_diffusion(source,true,conc_uv,kf,scale,rgb,iteration,event);
}




// main
PShader fx_reac_diff;
PGraphics result_reac_diff;
boolean start;
PImage buffer_reac_diff;
public PGraphics fx_reaction_diffusion(PImage source, boolean on_g, vec2 conc_uv, vec2 kf, vec2 scale, vec3 rgb, int num, boolean event) {
	if(result_reac_diff == null 
								|| (source.width != result_reac_diff.width 
								&& source.height != result_reac_diff.height)) {
		result_reac_diff = createGraphics(source.width,source.height,get_renderer());
	}

	// init
	if(source != null) {
		if(fx_reac_diff == null) {
			String path = get_fx_post_path()+"reaction_diffusion.glsl";
			if(fx_post_rope_path_exists) {
				fx_reac_diff = loadShader(path);
				println("load shader:",path);
			}
		}
		if(result_reac_diff == null) {
			result_reac_diff = createGraphics(source.width,source.height,get_renderer());
			println("create feedback");
		}
	}

	// if(!texture_is) set_shader_flip(fx_reac_diff,source);
	// create buffer for g case
  	if(on_g) {
		if(buffer_reac_diff == null) {
			buffer_reac_diff = source.copy();
		} else {
			buffer_reac_diff.loadPixels();
			source.loadPixels();
			buffer_reac_diff.pixels = source.pixels;
			buffer_reac_diff.updatePixels();
		}
	}


	// reset part
	if(!start || event) {
		result_reac_diff.beginDraw();
		if(!on_g) {
			result_reac_diff.image(source,0,0,source.width,source.height);
		} else {
			result_reac_diff.image(buffer_reac_diff,0,0,source.width,source.height);
		}
		result_reac_diff.endDraw();
		start = true;
	}
  /*
	float ru = 0.25f;
	float rv = 0.04f;
	float f = 0.1f;
	float k = 0.047f;
	float red = 0;
	float green = 0;
	float blue = 0;
	 vec2 scale = vec2(.6);
	 int rd_iteration = 20;
	*/

	// effect part
	textureWrap(REPEAT);
	int rd_iteration = 20;
	if(num > 0 && num < 100) {
		rd_iteration = num;
	}
	for(int i = 0 ; i < num ; i++) {
		if(!on_g) {
			fx_reac_diff.set("texture_source",source);
		} else {
			fx_reac_diff.set("texture_source",buffer_reac_diff);
		}
		fx_reac_diff.set("texture_layer",result_reac_diff);

		fx_reac_diff.set("resolution",source.width,source.height);
		fx_reac_diff.set("resolution_source",source.width,source.height);
		fx_reac_diff.set("resolution_layer",result_reac_diff.width,result_reac_diff.height);

		// eternal param
		if(conc_uv != null) {
			fx_reac_diff.set("ru",conc_uv.u);
			fx_reac_diff.set("rv",conc_uv.v);
		} else {
			fx_reac_diff.set("ru",.25f);
			fx_reac_diff.set("rv",.04f);
		}

		// eternal param
		if(kf != null) {
			fx_reac_diff.set("k",kf.x);
			fx_reac_diff.set("f",kf.y);
		} else {
			fx_reac_diff.set("k",0.1f);
			fx_reac_diff.set("f",0.047f);
		}


		// in progress
		/*
		if(rgb != null) {
			fx_reac_diff.set("red",rgb.r);
			fx_reac_diff.set("green",rgb.g);
			fx_reac_diff.set("blue",rgb.b);
		} else {
			fx_reac_diff.set("red",0);
			fx_reac_diff.set("green",0);
			fx_reac_diff.set("blue",0);
		}
		*/


		fx_reac_diff.set("scale",scale.x,scale.y);

    // rendering
		if(result_reac_diff != null && !on_g) {
			// texture case
	  	result_reac_diff.beginDraw();
	  	result_reac_diff.shader(fx_reac_diff);
	  	result_reac_diff.image(source,0,0,source.width,source.height);
	  	result_reac_diff.resetShader();
	  	result_reac_diff.endDraw();
	  } else {
      // g case
	  	result_reac_diff.beginDraw();
	  	result_reac_diff.shader(fx_reac_diff);
	  	result_reac_diff.image(buffer_reac_diff,0,0,source.width,source.height);
	  	result_reac_diff.resetShader();
	  	result_reac_diff.endDraw();
	  	image(result_reac_diff);
	  }
	}

	// render
	if(on_g) {
		return null;
	} else {
		return result_reac_diff; 
	}
}






























/**
* split rgb
* v 0.0.6
* 2019-2019
*/
// use setting
public PGraphics fx_split_rgb(PImage source, FX fx) {
	return fx_split_rgb(source,fx.on_g(),fx.get_pair(0),fx.get_pair(1),fx.get_pair(2));
}




// main
PShader fx_split_rgb;
PGraphics result_split_rgb;
public PGraphics fx_split_rgb(PImage source, boolean on_g, vec2 offset_red, vec2 offset_green, vec2 offset_blue) {
	if(!on_g && (result_split_rgb == null 
								|| (source.width != result_split_rgb.width 
								&& source.height != result_split_rgb.height))) {
		result_split_rgb = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_split_rgb == null) {
		String path = get_fx_post_path()+"split_rgb_simple.glsl";
		if(fx_post_rope_path_exists) {
			fx_split_rgb = loadShader(path);
			println("load shader:",path);
		}
	} else {
    if(on_g) set_shader_flip(fx_split_rgb,source);
		fx_split_rgb.set("texture_source",source);
		fx_split_rgb.set("resolution_source",source.width,source.height);

		// external param
		// fx_split.set("offset",offset.x,offset.y);
		if(offset_red != null) {
			fx_split_rgb.set("offset_red",offset_red.x,offset_red.y);
		}

		if(offset_green != null) {
			fx_split_rgb.set("offset_green",offset_green.x,offset_green.y);
		}
		
		if(offset_blue != null) {
			fx_split_rgb.set("offset_blue",offset_blue.x,offset_blue.y);
		} 
		

		 // rendering
    render_shader(fx_split_rgb,result_split_rgb,source,on_g);
	}

	// end
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_split_rgb; 
	}
}







/**
* Threshold
* v 0.2.0
* 2018-2019
*/
// setting by class FX
public PGraphics fx_threshold(PImage source, FX fx) {
	return fx_threshold(source,fx.on_g(),vec3(fx.get_level_source()),fx.get_mode());	
}


// main
PShader fx_threshold;
PGraphics pg_threshold;
public PGraphics fx_threshold(PImage source, boolean on_g, vec3 level, int mode) {
	if(!on_g && (pg_threshold == null 
								|| (source.width != pg_threshold.width 
								&& source.height != pg_threshold.height))) {
		pg_threshold = createGraphics(source.width,source.height,get_renderer());
	}

	
	if(fx_threshold == null) {
		String path = get_fx_post_path()+"threshold.glsl";
		if(fx_post_rope_path_exists) {
			fx_threshold = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_threshold,source);
		fx_threshold.set("texture_source",source);
		fx_threshold.set("resolution_source",source.width,source.height);

		// external parameter
		level = map(level,0,1,.05f,1.50f);
    fx_threshold.set("level_source",level.x,level.y,level.z);
    fx_threshold.set("mode",mode); // mode 0 : gray / 1 is rgb

    // rendering
		render_shader(fx_threshold,pg_threshold,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_threshold; 
	}
}



















/**
* warp procedural line by Stan le punk
* @see http://stanlepunk.xyz
* @see https://github.com/StanLepunK/Filter
* v 0.0.5
* 2018-2019
*/
public PGraphics fx_warp_proc(PImage source, FX fx) {
	return fx_warp_proc(source,fx.on_g(),fx.get_strength().x);
}

PShader fx_warp_proc;
PGraphics result_warp_proc;
public PGraphics fx_warp_proc(PImage source, boolean on_g, float strength) {
	if(!on_g && (result_warp_proc == null 
								|| (source.width != result_warp_proc.width 
								&& source.height != result_warp_proc.height))) {
		result_warp_proc = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_warp_proc == null) {
		String path = get_fx_post_path()+"warp_proc.glsl";
		if(fx_post_rope_path_exists) {
			fx_warp_proc = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_warp_proc,source);

		fx_warp_proc.set("texture_source",source);
		fx_warp_proc.set("resolution_source",source.width,source.height);
    
    // external parameter
		fx_warp_proc.set("strength",strength);

		// rendering
		render_shader(fx_warp_proc,result_warp_proc,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return result_warp_proc; 
	}
}












/**
* warp texture type A
* v 0.2.1
* 2018-2019
*/
// use setting
public PGraphics fx_warp_tex_a(PImage source, PImage velocity, PImage direction, FX fx) {
	return fx_warp_tex_a(source,velocity,direction,fx.on_g(),fx.get_mode(),fx.get_strength().x);
}



// main
PShader fx_warp_tex_a;
PGraphics pg_warp_tex_a;
public PGraphics fx_warp_tex_a(PImage source, PImage velocity, PImage direction, boolean on_g, int mode, float strength) {
	if(!on_g && (result_warp_proc == null 
								|| (source.width != result_warp_proc.width 
								&& source.height != result_warp_proc.height))) {
		result_warp_proc = createGraphics(source.width,source.height,get_renderer());
	}
  

	if(fx_warp_tex_a == null) {
		String path = get_fx_post_path()+"warp_tex_a.glsl";
		if(fx_post_rope_path_exists) {
			fx_warp_tex_a = loadShader(path);
			println("load shader:",path);
		}
	} else {
		if(on_g) set_shader_flip(fx_warp_tex_a,source);
		fx_warp_tex_a.set("texture_source",source);
		fx_warp_tex_a.set("resolution_source",source.width,source.height);

		
		// external parameter
		// warp sources
		if(direction != null) {
			fx_warp_tex_a.set("texture_direction",direction);
		}
		if(velocity != null) {
			fx_warp_tex_a.set("texture_velocity",velocity);
		}
		//setting external param
		fx_warp_tex_a.set("strength",strength); // good for normal value 0 > 1
		fx_warp_tex_a.set("mode",mode); // mode 0 > show warp / mode 500 show texture velocity / mode 501 show texture direction

		// rendering
		render_shader(fx_warp_tex_a,pg_warp_tex_a,source,on_g);
	}

	// return
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_warp_tex_a; 
	}
}








/**
* warp texture type B
* v 0.0.1
* 2019-2019
*/
// use setting
public PGraphics fx_warp_tex_b(PImage source, PImage layer, FX fx) {
	return fx_warp_tex_b(source,layer,fx.on_g(),fx.get_strength().x);
}




// main
PShader fx_warp_tex_b;
PGraphics pg_warp_tex_b;
public PGraphics fx_warp_tex_b(PImage source, PImage layer, boolean on_g,float strength) {
	if(!on_g && (pg_warp_tex_b == null 
								|| (source.width != pg_warp_tex_b.width 
								&& source.height != pg_warp_tex_b.height))) {
		pg_warp_tex_b = createGraphics(source.width,source.height,get_renderer());
	}

	if(fx_warp_tex_b == null) {
		String path = get_fx_post_path()+"warp_tex_b.glsl";
		if(fx_post_rope_path_exists) {
			fx_warp_tex_b = loadShader(path);
			println("load shader:",path);
		}
	} else {
    if(on_g) set_shader_flip(fx_warp_tex_b,source,layer);
		fx_warp_tex_b.set("texture_source",source);
		fx_warp_tex_b.set("resolution_source",source.width,source.height);
		fx_warp_tex_b.set("texture_layer",layer);
		fx_warp_tex_b.set("resolution_layer",layer.width,layer.height);

		// external param
		fx_warp_tex_b.set("strength",strength);

		 // rendering
    render_shader(fx_warp_tex_b,pg_warp_tex_b,source,on_g);
	}

	// end
	reset_reverse_g(false);
	if(on_g) {
		return null;
	} else {
		return pg_warp_tex_b; 
	}
}


/**
* SHADER FX
* @see @stanlepunk
* @see https://github.com/StanLepunK/Shader
* v 0.8.0
* 2019-2019
*
*/
int NO_FX = -1;
// CONSTANT FX POST
int FX_TEMPLATE = 0;

int FX_BLUR_GAUSSIAN = 200;
int FX_BLUR_RADIAL = 201;
int FX_BLUR_CIRCULAR = 202;

int FX_COLOUR_CHANGE_A = 300;
int FX_COLOUR_CHANGE_B = 301;

int FX_DATAMOSH = 400;
int FX_DITHER_BAYER_8 = 408;

int FX_FLIP = 600;

int FX_GRAIN = 700;
int FX_GRAIN_SCATTER = 701;

int FX_HALFTONE_DOT = 800;
int FX_HALFTONE_LINE = 801;
int FX_HALFTONE_MULTI = 810;

int FX_IMAGE = 900;

int FX_LEVEL = 12_00;

int FX_MIX = 13_00;

int FX_PIXEL = 16_00;

int FX_REAC_DIFF = 18_00;

int FX_SPLIT_RGB = 19_50;

int FX_THRESHOLD = 20_00; // don't work
int FX_TOON = 20_20; // don't work


int FX_WARP_PROC = 23_00;

int FX_WARP_TEX_A = 23_10;
int FX_WARP_TEX_B = 23_11;


// CONSTANT FX BACKGROUND
// here we start arbitrarily at 10_000 to no conflict with FX constant arounf 1_000.

int FX_BG_TEMPLATE = 1;

int FX_BG_CELLULAR = 3_0000;

int FX_BG_HEART = 8_0000;

int FX_BG_NECKLACE = 14_0000;

int FX_BG_NEON = 14_0000;

int FX_BG_PSY = 16_0000;

int FX_BG_SNOW = 19_0000;

int FX_BG_VORONOI_HEX = 22_0000;


// get method
public FX get_fx(ArrayList<FX> fx_list, int target) {
	if(fx_list != null && target < fx_list.size()) {
		return fx_list.get(target);
	} else {
		return null;
	}
}

public FX get_fx(ArrayList<FX> fx_list, String name) {
	FX buffer = null;
	if(fx_list != null && fx_list.size() > 0) {	
		for(FX fx : fx_list) {
			if(fx.get_name().equals(name)){
				buffer = fx;
				break;
			}
		}
	} 
	return buffer;
}



// init method
public void init_fx(ArrayList<FX> fx_list, String name, int type) {
	init_fx(fx_list,name,type,-1, null, null, null,-1,null,null);
}


public void init_fx(ArrayList<FX> fx_list, String name, int type, int id, String author, String pack, String version, int revision, String [] name_slider, String [] name_button) {
	boolean exist = false;

	if(fx_list != null && fx_list.size() > 0) {
		for(FX fx : fx_list) {
			if(fx.get_name().equals(name)) {
				exist = true;
				break;
			}
		}
		if(!exist) {
			add_fx_to_manager(fx_list,name,type,id,author,pack,version,revision,name_slider,name_button);
		}
	} else {
		add_fx_to_manager(fx_list,name,type,id,author,pack,version,revision,name_slider,name_button);
	}
}


// add FX
public void add_fx_to_manager(ArrayList<FX> fx_list, String name, int type, int id, String author, String pack, String version, int revision, String [] name_slider, String [] name_button) {
	FX fx = new FX();
	fx.set_name(name);
	fx.set_type(type);
	fx.set_id(id);
	if(author != null) fx.set_author(author);
	fx.set_pack(pack);
	if(version != null) fx.set_version(version);
	fx.set_revision(revision);
	if(name_slider != null) fx.set_name_slider(name_slider);
	if(name_button != null) fx.set_name_button(name_button);
	fx_list.add(fx);
}






/**
* SELECT FX
*/

// POST FX from FX class
public void select_fx_post(PImage main, PImage layer_a, PImage layer_b, FX... fx) {
	for(int i = 0 ; i < fx.length ;i++) {
		if(fx[i] != null) {
			if(fx[i].get_type() == FX_MIX) {
				fx_mix(main,layer_a,fx[i]);
			} else if(fx[i].get_type() == FX_BLUR_GAUSSIAN) {
				fx_blur_gaussian(main,fx[i]); 
			} else if(fx[i].get_type() == FX_BLUR_CIRCULAR) {
				fx_blur_circular(main,fx[i]);
			} else if(fx[i].get_type() == FX_BLUR_RADIAL) {
				fx_blur_radial(main,fx[i]);
			} else if(fx[i].get_type() == FX_COLOUR_CHANGE_A) {
				fx_colour_change_a(main,fx[i]);
			} else if(fx[i].get_type() == FX_COLOUR_CHANGE_B) {
				fx_colour_change_b(main,fx[i]);
			} else if(fx[i].get_type() == FX_DATAMOSH) {
				fx_datamosh(main,fx[i]);
			} else if(fx[i].get_type() == FX_DITHER_BAYER_8) {
				fx_dither_bayer_8(main,fx[i]);
			} else if(fx[i].get_type() == FX_FLIP) {
				fx_flip(main,fx[i]);
			} else if(fx[i].get_type() == FX_GRAIN) {
				 fx_grain(main,fx[i]);
			} else if(fx[i].get_type() == FX_GRAIN_SCATTER) {
				fx_grain_scatter(main,fx[i]);
			} else if(fx[i].get_type() == FX_HALFTONE_DOT) {
				fx_halftone_dot(main,fx[i]);
			} else if(fx[i].get_type() == FX_HALFTONE_LINE) {
				fx_halftone_line(main,fx[i]); 
			} else if(fx[i].get_type() == FX_HALFTONE_LINE) {
				fx_halftone_line(main,fx[i]); 
			} else if(fx[i].get_type() == FX_HALFTONE_MULTI) {
				fx_halftone_multi(main,fx[i]); 
			} else if(fx[i].get_type() == FX_IMAGE) {
				fx_image(main,fx[i]);
			} else if(fx[i].get_type() == FX_PIXEL) {
				fx_pixel(main,fx[i]);
			} else if(fx[i].get_type() == FX_REAC_DIFF) {
				fx_reaction_diffusion(main,fx[i]);
			} else if(fx[i].get_type() == FX_SPLIT_RGB) {
				fx_split_rgb(main,fx[i]); 
			} else if(fx[i].get_type() == FX_THRESHOLD) {
				fx_threshold(main,fx[i]);
			} else if(fx[i].get_type() == FX_WARP_PROC) {
				fx_warp_proc(main,fx[i]); 
			} else if(fx[i].get_type() == FX_WARP_TEX_A) {
				fx_warp_tex_a(main,layer_a,layer_b,fx[i]); 
			} else if(fx[i].get_type() == FX_WARP_TEX_B) {
				fx_warp_tex_b(main,layer_a,fx[i]); 
			} else {
				printErrTempo(60,"method select_fx_post(): fx",fx[i].get_name(),fx[i].get_type(),"don't match with any fx available");
			}
		} else {
			printErrTempo(60,"method select_fx_post(): fx",i,"is",fx[i],"maybe fx need to be init or instantiate");
		}
		   
	}
}


// BACKGROUND FX from FX class
public void select_fx_background(FX fx) {
	if(fx != null) {
		if(fx.get_type() == FX_BG_TEMPLATE) {
			fx_bg_template(fx);
		} else if(fx.get_type() == FX_BG_CELLULAR) {
			fx_bg_cellular(fx);
		} else if(fx.get_type() == FX_BG_HEART) {
			fx_bg_heart(fx);
		} else if(fx.get_type() == FX_BG_NECKLACE) {
			fx_bg_necklace(fx);
		} else if(fx.get_type() == FX_BG_NEON) {
			fx_bg_neon(fx);
		} else if(fx.get_type() == FX_BG_PSY) {
			fx_bg_psy(fx);
		} else if(fx.get_type() == FX_BG_SNOW) {
			fx_bg_snow(fx);
		} else if(fx.get_type() == FX_BG_VORONOI_HEX) {
			fx_bg_voronoi_hex(fx);
		} else {
			fx_bg_template(fx);
		}
	} else {
		printErrTempo(60,"method select_fx_background(): fx is",fx,"maybe fx need to be init or instantiate");
	}
	    
}
















/**
prepare your setting
v 0.1.1
*/

// single
public void fx_set_mode(ArrayList<FX> fx_list, String name, int mode) {
	fx_set(fx_list,0,name,mode);
}

public void fx_set_num(ArrayList<FX> fx_list, String name, int num) {
	fx_set(fx_list,1,name,num);
}

public void fx_set_quality(ArrayList<FX> fx_list, String name, float quality) {
	fx_set(fx_list,2,name,quality);
}

public void fx_set_time(ArrayList<FX> fx_list, String name, float time) {
	fx_set(fx_list,3,name,time);
}

// double
public void fx_set_scale(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_2(fx_list,10,name,arg);
}

public void fx_set_resolution(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_2(fx_list,11,name,arg);
}

// triple
public void fx_set_strength(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,20,name,arg);
}

public void fx_set_angle(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,21,name,arg);
}

public void fx_set_threshold(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,22,name,arg);
}

public void fx_set_pos(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,23,name,arg);
}

public void fx_set_size(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,24,name,arg);
}

public void fx_set_offset(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,25,name,arg);
}

public void fx_set_speed(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_3(fx_list,26,name,arg);
}

// quadruple
public void fx_set_level_source(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_4(fx_list,30,name,arg);
}

public void fx_set_level_layer(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_4(fx_list,31,name,arg);
}

public void fx_set_colour(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_4(fx_list,32,name,arg);
}

public void fx_set_cardinal(ArrayList<FX> fx_list, String name, float... arg) {
	set_fx_float_4(fx_list,33,name,arg);
}

// single
public void fx_set_hue(ArrayList<FX> fx_list, String name, float hue) {
	fx_set(fx_list,200,name,hue);
}

public void fx_set_saturation(ArrayList<FX> fx_list, String name, float saturation) {
	fx_set(fx_list,201,name,saturation);
}

public void fx_set_brightness(ArrayList<FX> fx_list, String name, float brightness) {
	fx_set(fx_list,202,name,brightness);
}

public void fx_set_red(ArrayList<FX> fx_list, String name, float red) {
	fx_set(fx_list,300,name,red);
}

public void fx_set_green(ArrayList<FX> fx_list, String name, float green) {
	fx_set(fx_list,301,name,green);
}

public void fx_set_blue(ArrayList<FX> fx_list, String name, float blue) {
	fx_set(fx_list,302,name,blue);
}

public void fx_set_alpha(ArrayList<FX> fx_list, String name, float alpha) {
	fx_set(fx_list,400,name,alpha);
}


// modulair param
// triple
public void fx_set_matrix(ArrayList<FX> fx_list, String name, int target, float... arg) {
	int which = 40+target;
	set_fx_float_3(fx_list,which,name,arg);
}

// double
public void fx_set_pair(ArrayList<FX> fx_list, String name, int target, float... arg) {
	int which = 50+target;
	set_fx_float_2(fx_list,which,name,arg);
}

// single boolean
public void fx_set_event(ArrayList<FX> fx_list, String name, int target, boolean... arg) {
	int which = 100+target;
	set_fx_boolean_4(fx_list,which,name,arg);
}


/**
* main setting methode
*/
public void set_fx_float_2(ArrayList<FX> fx_list, int which, String name, float... arg) {
	if(arg.length == 1) {
		fx_set(fx_list,which,name,arg[0]);
	} else if(arg.length == 2) {
		fx_set(fx_list,which,name,arg[0],arg[1]);
	} else if(arg.length > 2) {
		fx_set(fx_list,which,name,arg[0],arg[1]);
	}
}

public void set_fx_float_3(ArrayList<FX> fx_list, int which, String name, float... arg) {
	if(arg.length == 1) {
		fx_set(fx_list,which,name,arg[0]);
	} else if(arg.length == 2) {
		fx_set(fx_list,which,name,arg[0],arg[1]);
	} else if(arg.length == 3) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2]);
	} else if(arg.length > 3) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2]);
	}
}

public void set_fx_float_4(ArrayList<FX> fx_list, int which, String name, float... arg) {
	if(arg.length == 1) {
		fx_set(fx_list,which,name,arg[0]);
	} else if(arg.length == 2) {
		fx_set(fx_list,which,name,arg[0],arg[1]);
	} else if(arg.length == 3) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2]);
	} else if(arg.length == 4) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2],arg[3]);
	} else if(arg.length > 4) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2],arg[3]);
	}
}



public void set_fx_boolean_4(ArrayList<FX> fx_list, int which, String name, boolean... arg) {
	if(arg.length == 1) {
		fx_set(fx_list,which,name,arg[0]);
	} else if(arg.length == 2) {
		fx_set(fx_list,which,name,arg[0],arg[1]);
	} else if(arg.length == 3) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2]);
	} else if(arg.length == 4) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2],arg[3]);
	} else if(arg.length > 4) {
		fx_set(fx_list,which,name,arg[0],arg[1],arg[2],arg[3]);
	}
}

public void fx_set(ArrayList<FX> fx_list, int which_setting, String name, Object... arg) {
	if(fx_list != null) {
		if(fx_list.size() > 0) {
			for(FX fx : fx_list) {
				if(fx.get_name().equals(name)) {
					fx.set(which_setting,arg);
				}
			}	
		} 
	}
}




































/**
* path shader
* v 0.3.1
*/
// post fx path
String fx_post_rope_path = null;
boolean fx_post_rope_path_exists = false;

public boolean fx_post_path_exist() {
	return fx_post_rope_path_exists;
}

public String get_fx_post_path() {
	if(fx_post_rope_path == null) {
		fx_post_rope_path = "shader/fx_post/";
		fx_post_rope_path_exists = true;
	} else {
		File f = new File(fx_post_rope_path);
		if(!f.exists()) {
			printErrTempo(60,"get_fx_post_path()",fx_post_rope_path,"no folder found");
		} else {
			fx_post_rope_path_exists = true;
		}

	}
	return fx_post_rope_path;
}

public void set_fx_post_path(String path) {
	fx_post_rope_path = path;
}




// background fx path
String fx_bg_rope_path = null;
boolean fx_bg_rope_path_exists = false;

public boolean fx_bg_path_exist() {
	return fx_bg_rope_path_exists;
}

public String get_fx_bg_path() {
	if(fx_bg_rope_path == null) {
		fx_bg_rope_path = "shader/fx_bg/";
		fx_bg_rope_path_exists = true;
	} else {
		File f = new File(fx_bg_rope_path);
		if(!f.exists()) {
			printErrTempo(60,"get_fx_bg_path()",fx_bg_rope_path,"no folder found");
		} else {
			fx_bg_rope_path_exists = true;
		}

	}
	return fx_bg_rope_path;
}

public void set_fx_bg_path(String path) {
	fx_bg_rope_path = path;
}
















/**
* send information to shader.glsl to flip the source in case this one is a PGraphics or PImage
* v 0.1.0
*/
public void set_shader_flip(PShader ps, PImage... img) {
	int num = img.length;
	ps.set("flip_source",1,0);
	
	if(graphics_is(img[0]).equals("PGraphics") && !reverse_g_source_is()) {
		ps.set("flip_source",0,0);
		reverse_g_source(true);
	}

	if(num == 2) {
		ps.set("flip_layer",1,0);
		if(graphics_is(img[1]).equals("PGraphics") && !reverse_g_layer_is()) {
			ps.set("flip_layer",0,0);
			reverse_g_layer(true);
		}
	}
}




public void set_shader_resolution(PShader ps, ivec2 canvas, boolean on_g) {
	if(!on_g && canvas != null) {
		ps.set("resolution",canvas.x,canvas.y);
	} else {
		ps.set("resolution",width,height);
	}
}


















/**
reverse graphics for the case is not a texture but a direct shader
*/
boolean filter_reverse_g_source;
boolean filter_reverse_g_layer;
public boolean reverse_g_source_is() {
	return filter_reverse_g_source;
}

public boolean reverse_g_layer_is() {
	return filter_reverse_g_layer;
}

public void reverse_g_source(boolean state){
	filter_reverse_g_source = state;
}

public void reverse_g_layer(boolean state){
	filter_reverse_g_layer = state;
}

public void reset_reverse_g(boolean state){
	filter_reverse_g_source = state;
	filter_reverse_g_layer = state;
}








/**
* render shader
* this method test if the shader must be display on the main Processing render or return a PGraphics
* v 0.0.4
*/
public void render_shader(PShader ps, PGraphics pg, PImage src, boolean on_g) {
	if(pg != null && !on_g) {
  	pg.beginDraw();
  	pg.shader(ps);
  	pg.image(src,0,0,src.width,src.height);
  	pg.resetShader();
  	pg.endDraw();
  } else {
  	filter(ps);
  }
}








/**
* ROPE FRAMEWORK IMAGE
* Rope – Romanesco Processing Environment – 
* v 0.4.2
* Copyleft (c) 2014-2019
* Processing 3.5.3
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/









/**
PATTERN GENERATOR
v 0.0.2
2018-2018
*/
public PGraphics pattern_noise(int w, int h, float... inc) {
  PGraphics pg ;
  noiseSeed((int)random(MAX_INT));
  if(w > 0 && h > 0 && inc.length > 0 && inc.length < 5) {
    pg = createGraphics(w,h);
    float offset_x [] = new float[inc.length];
    float offset_y [] = new float[inc.length];
    float component [] = new float[inc.length];
    float max [] = new float[inc.length];
    if(inc.length == 1) {
      max[0] = g.colorModeZ;
    } else if (inc.length == 2) {
      max[0] = g.colorModeZ;
      max[1] = g.colorModeA;
    } else if (inc.length == 3) {
      max[0] = g.colorModeX;
      max[1] = g.colorModeY;
      max[2] = g.colorModeZ;
    } else if (inc.length == 4) {
      max[0] = g.colorModeX;
      max[1] = g.colorModeY;
      max[2] = g.colorModeZ;
      max[3] = g.colorModeA;
    }

    
    pg.beginDraw();
    for(int i = 0 ; i < inc.length ; i++) {
      offset_y[i] = 0;
    }
    
    for(int x = 0 ; x < w ; x++) {
      for(int i = 0 ; i < inc.length ; i++) {
        offset_x[i] = 0;
      }
      for(int y = 0 ; y < h ; y++) {
        for(int i = 0 ; i < inc.length ; i++) {
          component[i] = map(noise(offset_x[i],offset_y[i]),0,1,0,max[i]);
        }
        int c = 0;
        if(inc.length == 1) c = color(component[0]);
        else if (inc.length == 2) c = color(component[0],component[1]);
        else if (inc.length == 3) c = color(component[0],component[1],component[2]);
        else if (inc.length == 4) c = color(component[0],component[1],component[2],component[3]);

        pg.set(x,y,c);
        for(int i = 0 ; i < inc.length ; i++) {
          offset_x[i] += inc[i];
        }
      }
      for(int i = 0 ; i < inc.length ; i++) {
        offset_y[i] += inc[i];
      }
    }
    pg.endDraw();
    return pg;
  } else {
    printErr("method pattern_noise(): may be problem with size:",w,h,"\nor with component color num >>>",inc.length,"<<< must be between 1 and 4");
    return null;
  }
}











/**
LAYER
v 0.1.0
2018-2018
*/
PGraphics [] rope_layer;
boolean warning_rope_layer;
int which_rope_layer = 0;

// init
public void init_layer() {
  init_layer(width,height,get_renderer(),1);
}

public void init_layer(int num) {
  init_layer(width,height,get_renderer(),num);
}

public void init_layer(int x, int y) {
  init_layer(x,y, get_renderer(),1);
}

public void init_layer(int x, int y, int num) {
  init_layer(x,y, get_renderer(),num);
}

public void init_layer(int x, int y, String type, int num) {
  rope_layer = new PGraphics[num];
  for(int i = 0 ; i < num ; i++) {
    rope_layer[i] = createGraphics(x,y,type);
  }
  
  if(!warning_rope_layer) {
    warning_rope_layer = true;
  }
  String warning = ("WARNING LAYER METHOD\nAll classical method used on the main rendering,\nwill return the PGraphics selected PGraphics layer :\nimage(), set(), get(), fill(), stroke(), rect(), ellipse(), pushMatrix(), popMatrix(), box()...\nto use those methods on the main PGraphics write g.image() for example");
  printErr(warning);
}

// begin and end draw
public void begin_layer() {
  if(get_layer() != null) {
    get_layer().beginDraw();
  }
}

public void end_layer() {
  if(get_layer() != null) {
    get_layer().endDraw();
  }
}



// num
public int get_layer_num() {
  if(rope_layer != null) {
    return  rope_layer.length ;
  } else return -1;  
}


// clear layer
public void clear_layer() {
  if(rope_layer != null && rope_layer.length > 0) {
    for(int i = 0 ; i < rope_layer.length ; i++) {
      String type = get_renderer(rope_layer[i]);
      int w = rope_layer[i].width;
      int h = rope_layer[i].height;
      rope_layer[i] = createGraphics(w,h,type);
    }
  } else {
    String warning = ("void clear_layer(): there is no layer can be clear maybe you forget to create one :)");
    printErr(warning);
  }
  
}

public void clear_layer(int target) {
  if(target > -1 && target < rope_layer.length) {
    String type = get_renderer(rope_layer[target]);
    int w = rope_layer[target].width;
    int h = rope_layer[target].height;
    rope_layer[target] = createGraphics(w,h,type);
  } else {
    String warning = ("void clear_layer(): target "+target+" is out the range of the layers available,\n no layer can be clear");
    printErr(warning);
  }
}




/**
GET LAYER
* May be the method can be improve by using a PGraphics template for buffering instead usin a calling method ????
*/
// get layer
public PGraphics get_layer() {
  return get_layer(which_rope_layer);
}


public PGraphics get_layer(int target) {
  if(rope_layer == null) {
//    printErrTempo(180,"void get_layer(): Your layer system has not been init use method init_layer() in first",frameCount);
    return g;
  } else if(target > -1 && target < rope_layer.length) {
    return rope_layer[target];
  } else {
    String warning = ("PGraphics get_layer(int target): target "+target+" is out the range of the layers available,\n instead target 0 is used");
    printErr(warning);
    return rope_layer[0];
  }
}

// select layer
public void select_layer(int target) {
  if(rope_layer != null) {
    if(target > -1 && target < rope_layer.length) {
      which_rope_layer = target;
    } else {
      which_rope_layer = 0;
      String warning = ("void select_layer(int target): target "+target+" is out the range of the layers available,\n instead target 0 is used");
      printErr(warning);
    }
  } else {
    printErrTempo(180,"void select_layer(): Your layer system has not been init use method init_layer() in first",frameCount);
  } 
}





















/**
PImage manager library
v 0.4.2
*/
class ROPImage_Manager {
  ArrayList<ROPImage> library ;
  int which_img;

  private void build() {
    if(library == null) {
      library = new ArrayList<ROPImage>();
    }
  }

  public void load(String... path_img) {
    build();
    for(int i = 0 ; i <path_img.length ; i++) {
      //Image img = loadImage(img_src[i]);
      ROPImage rop_img = new ROPImage(path_img[i]);
      //println(img.width, img_src[i]);
      library.add(rop_img);
    }  
  }

  public void add(PImage img_src) {
    build();
    ROPImage rop_img = new ROPImage(img_src);
    library.add(rop_img);
  }

  public void add(PImage img_src, String name) {
    build();
    ROPImage rop_img = new ROPImage(img_src, name);
    library.add(rop_img);
  }

  public void clear() {
    if(library != null) {
      library.clear();
    }
  }

  public ArrayList<ROPImage> list() {
    return library;
  }

  public void select(int which_one) {
    which_img = which_one ;
  }

  public void select(String target_name) {
    if(library.size() > 0) {
      for(int i = 0 ; i < library.size() ; i++) {
        if(target_name.equals(library.get(i).name)) {
          which_img = i ;
          break ;
        }
      }
    } else {
      printErr("the String target name don't match with any name of image library") ;
    }
  }


  public int size() {
    if(library != null) {
      return library.size() ;
    } else return -1 ;  
  }

  public void set(PImage src_img, int target) {
    build();
    if(target < library.size()) {
      if(src_img.width == get(target).width && src_img.height == get(target).height){
        get(target).pixels = src_img.pixels ;
        get(target).updatePixels();
      } else {
        get(target).resize(src_img.width, src_img.height);
        get(target).pixels = src_img.pixels ;
        get(target).updatePixels();
      }
    } else {
      printErr("Neither target image match with your request");
    }
  }

  public void set(PImage src_img, String target_name) {
    build();
    if(library.size() > 0) {
      if(src_img.width == get(target_name).width && src_img.height == get(target_name).height){
        get(target_name).pixels = src_img.pixels ;
        get(target_name).updatePixels();
      } else {
        get(target_name).resize(src_img.width, src_img.height);
        get(target_name).pixels = src_img.pixels ;
        get(target_name).updatePixels();
      }
    } else {
      printErr("Neither target image match with your request");
    }
  }

  public String get_name() {
    return get_name(which_img);
  }

  public String get_name(int target) {
    if(library != null && library.size() > 0) {
      if(target < library.size()) {
        return library.get(target).get_name() ;
      } else return null ;
    } else return null ;
  }



  public int get_rank(String target_name) {
    if(library != null && library.size() > 0) {
      int rank = 0 ;
      for(int i = 0 ; i < library.size() ; i++) {
        String final_name = target_name.split("/")[target_name.split("/").length -1].split("\\.")[0] ;
        if(final_name.equals(library.get(i).name) ) {
          rank = i ;
          break;
        } 
      }
      return rank;
    } else return -1;
  }


  public PImage get() {
    if(library != null && library.size() > 0 ) {
      if(which_img < library.size()) return library.get(which_img).img; 
      else return library.get(0).img; 
    } else return null ;
  }

  public PImage get(int target){
    if(library != null && target < library.size()) {
      return library.get(target).img;
    } else return null;
  }

  public PImage get(String target_name){
    if(library.size() > 0) {
      int target = 0 ;
      for(int i = 0 ; i < library.size() ; i++) {
        String final_name = target_name.split("/")[target_name.split("/").length -1].split("\\.")[0] ;
        if(final_name.equals(library.get(i).name) ) {
          target = i ;
          break;
        } 
      }
      return get(target);
    } else return null;
  }


  // private class
  private class ROPImage {
    private PImage img ;
    private String name = "no name" ;

    private ROPImage(String path) {
      this.name = path.split("/")[path.split("/").length -1].split("\\.")[0] ;
      this.img = loadImage(path);
    }

    private ROPImage(PImage img) {
      this.img = img;
    }

    private ROPImage(PImage img, String name) {
      this.img = img;
      this.name = name;
    }

    public String get_name() {
      return name ;
    }

    public PImage get_image() {
      return img ;
    }
  }
}

/**
resize image
v 0.0.2
*/
/**
* resize your picture proportionaly to the window sketch of the a specificic PGraphics
*/
public void image_resize(PImage src) {
  image_resize(src,g,true);
}

public void image_resize(PImage src, boolean fullfit) {
  image_resize(src,g,fullfit);
}

public void image_resize(PImage src, PGraphics pg, boolean fullfit) {
  float ratio_w = pg.width / (float)src.width;
  float ratio_h = pg.height / (float)src.height;
  if(!fullfit) {
    if(ratio_w > ratio_h) {
      src.resize(ceil(src.width *ratio_w), ceil(src.height *ratio_w));
    } else {
      src.resize(ceil(src.width *ratio_h), ceil(src.height *ratio_h));  
    }
  } else {
    if(ratio_w > ratio_h) {
      src.resize(ceil(src.width *ratio_h), ceil(src.height *ratio_h));
    } else {
      src.resize(ceil(src.width *ratio_w), ceil(src.height *ratio_w));  
    }
  }
}

/**
copy window
v 0.0.1
*/
public PImage image_copy_window(PImage src, int where) {
  return image_copy_window(src, g, where);
}

public PImage image_copy_window(PImage src, PGraphics pg, int where) {
  int x = 0 ;
  int y = 0 ;
  if(where == CENTER) {
    x = (src.width -pg.width) /2 ;
    y = (src.height -pg.height) /2 ;   
  } else if(where == LEFT) {
    y = (src.height -pg.height) /2 ; 
  } else if(where == RIGHT) { 
    x = src.width -pg.width ;
    y = (src.height -pg.height) /2 ;   
  } else if(where == TOP) {
    x = (src.width -pg.width) /2 ;   
  } else if(where == BOTTOM) { 
    x = (src.width -pg.width) /2 ;
    y = src.height -pg.height;   
  }  
  return src.get(x, y, pg.width, pg.height); 
}

















/**
IMAGE
v 0.2.2
2016-2018
*/
/**
* additionnal method for image
* @see other method in vec mini library
*/
public void image(PImage img) {
  if(img != null) image(img, 0, 0);
  else printErr("Object PImage pass to method image() is null");
}

public void image(PImage img, int what) {
  if(img != null) {
    float x = 0 ;
    float y = 0 ;
    int w = img.width;
    int h = img.height;
    int where = CENTER;
    if(what == r.FIT || what == LANDSCAPE || what == PORTRAIT || what == SCREEN) {
      float ratio = 1.f;
      int diff_w = width-w;
      int diff_h = height-h;


      if(what == r.FIT) {
        if(diff_w > diff_h) {
          ratio = (float)height / (float)h;
        } else {
          ratio = (float)width / (float)w;
        }
      } else if(what == SCREEN) {
        float ratio_w = (float)width / (float)w;
        float ratio_h = (float)height / (float)h;
        if(ratio_w > ratio_h) {
          ratio = ratio_w;
        } else {
          ratio = ratio_h;
        }
        /*
        if(diff_w > diff_h) {
          ratio = (float)width / (float)w;
        } else {
          ratio = (float)height/ (float)h;
        }
        */
      } else if(what == PORTRAIT) {
        ratio = (float)height / (float)h;
      } else if(what == LANDSCAPE) {
        ratio = (float)width / (float)w;
      }
      w *= ratio;
      h *= ratio;
    } else {
      where = what;
    }

    if(where == CENTER) {
      x = (width /2.f) -(w /2.f);
      y = (height /2.f) -(h /2.f);   
    } else if(where == LEFT) {
      x = 0;
      y = (height /2.f) -(h /2.f);
    } else if(where == RIGHT) {
      x = width -w;
      y = (height /2.f) -(h /2.f);
    } else if(where == TOP) {
      x = (width /2.f) -(w /2.f);
      y = 0;
    } else if(where == BOTTOM) {
      x = (width /2.f) -(w /2.f);
      y = height -h; 
    }
    image(img,x,y,w,h);
  } else {
    printErrTempo(60,"image(); no PImage has pass to the method, img is null");
  } 
}

public void image(PImage img, float coor) {
  if(img != null) image(img, coor, coor);
  else printErr("Object PImage pass to method image() is null");
}

public void image(PImage img, ivec pos) {
  if(pos instanceof ivec2) {
    image(img, vec2(pos.x, pos.y));
  } else if(pos instanceof ivec3) {
    image(img, vec3(pos.x, pos.y, pos.z));
  }
}

public void image(PImage img, ivec pos, ivec2 size) {
  if(pos instanceof ivec2) {
    image(img, vec2(pos.x, pos.y), vec2(size.x, size.y));
  } else if(pos instanceof ivec3) {
    image(img, vec3(pos.x, pos.y, pos.z), vec2(size.x, size.y));
  } 
}

public void image(PImage img, vec pos) {
  if(pos instanceof vec2) {
    vec2 p = (vec2) pos ;
    image(img, p.x, p.y) ;
  } else if(pos instanceof vec3) {
    vec3 p = (vec3) pos ;
    start_matrix() ;
    translate(p) ;
    image(img, 0,0) ;
    stop_matrix() ;
  }
}

public void image(PImage img, vec pos, vec2 size) {
  if(pos instanceof vec2) {
    vec2 p = (vec2) pos ;
    image(img, p.x, p.y, size.x, size.y) ;
  } else if(pos instanceof vec3) {
    vec3 p = (vec3) pos ;
    start_matrix() ;
    translate(p) ;
    image(img, 0,0, size.x, size.y) ;
    stop_matrix() ;
  }
}









/**
* For the future need to use shader to do that...but in the future !
*/
public PImage reverse(PImage img) {
  PImage final_img;
  final_img = createImage(img.width, img.height, RGB) ;
  for(int i = 0 ; i < img.pixels.length ; i++) {
    final_img.pixels[i] = img.pixels[img.pixels.length -i -1];
  }
  return final_img ;
}

/**
* For the future need to use shader to do that...but in the future !
*/
public PImage mirror(PImage img) {
  PImage final_img ;
  final_img = createImage(img.width, img.height, RGB) ;

  int read_head = 0 ;
  for(int i = 0 ; i < img.pixels.length ; i++) {
    if(read_head >= img.width) {
      read_head = 0 ;
    }
    int reverse_line = img.width -(read_head*2) -1 ;
    int target = i +reverse_line  ;

    if(target < 0 || target >img.pixels.length) println(i, read_head, target) ;
    final_img.pixels[i] = img.pixels[target] ;

    read_head++ ;
  }
  return final_img ;
}

public PImage paste(PImage img, int entry, int [] array_pix, boolean vertical_is) {
  if(!vertical_is) {
    return paste_vertical(img, entry, array_pix);
  } else {
    return paste_horizontal(img, entry, array_pix);
  }
}

public PImage paste_horizontal(PImage img, int entry, int [] array_pix) { 
  // println("horinzontal", frameCount, entry);
  PImage final_img ;
  final_img = img.copy() ;
  // reduce the array_pix in this one is bigger than img.pixels.length
  if(array_pix.length > final_img.pixels.length) {
     array_pix = Arrays.copyOf(array_pix,final_img.pixels.length) ;
  }

  int count = 0 ;
  int target = 0 ;
  for(int i = entry ; i < entry+array_pix.length ; i++) {
    if(i < final_img.pixels.length) {
      final_img.pixels[i] = array_pix[count];
    } else {
      target = i -final_img.pixels.length ;
      // security length outbound index
      // change the size can happen ArrayIndexOutBound,
      if(target >= final_img.pixels.length) {
        target = final_img.pixels.length -1;
      }
      if(count >= array_pix.length) {
        println("count", count, "array pix length", array_pix.length);
      }
      final_img.pixels[target] = array_pix[count];
    }
    count++ ;
  }
  return final_img ;
}


public PImage paste_vertical(PImage img, int entry, int [] array_pix) { 
  PImage final_img;
  final_img = img.copy();
  // reduce the array_pix in this one is bigger than img.pixels.length
  if(array_pix.length > final_img.pixels.length) {
     array_pix = Arrays.copyOf(array_pix,final_img.pixels.length) ;
  }

  int count = 0;
  int target = 0;
  int w = final_img.width;
  int line = 0;

  for(int i = entry ; i < entry+array_pix.length ; i++) {
    int mod = i%w ;
    // the master piece algorithm to change the direction :)
    int where =  entry +(w *(w -(w -mod))) +line;
    if(mod >= w -1) {
      line++;
    }
    if(where < final_img.pixels.length) {
      final_img.pixels[where] = array_pix[count];
    } else {
      target = where -final_img.pixels.length ;
      // security length outbound index
      // change the size can happen ArrayIndexOutBound,
      if(target >= final_img.pixels.length) {
        target = final_img.pixels.length -1;
      }
      if(count >= array_pix.length) {
        println("count", count, "array pix length", array_pix.length);
      }
      final_img.pixels[target] = array_pix[count];
    }
    count++ ;
  }
  return final_img ;
}





















/**
CANVAS
v 0.2.0
*/
PImage [] rope_canvas;
int current_canvas_rope;

// build canvas
public void new_canvas(int num) {
  rope_canvas = new PImage[num];
}

public void create_canvas(int w, int h, int type) {
  rope_canvas = new PImage[1];
  rope_canvas[0] = createImage(w, h, type);
}

public void create_canvas(int w, int h, int type, int which_one) {
  rope_canvas[which_one] = createImage(w, h, type);
}

// clean
public void clean_canvas(int which_canvas) {
  int c = color(0,0) ;
  clean_canvas(which_canvas, c) ;
}

public void clean_canvas(int which_canvas, int c) {
  if(which_canvas < rope_canvas.length) {
    select_canvas(which_canvas) ;
    for(int i = 0 ; i < get_canvas().pixels.length ; i++) {
      get_canvas().pixels[i] = c ;
    }
  } else {
    String message = ("The target: " + which_canvas + " don't match with an existing canvas");
    printErr(message);
  }
}



// misc
public int canvas_size() {
  return rope_canvas.length;
}

// select the canvas must be used for your next work
public void select_canvas(int which_one) {
  if(which_one < rope_canvas.length && which_one >= 0) {
    current_canvas_rope = which_one;
  } else {
    String message = ("void select_canvas(): Your selection " + which_one + " is not available, canvas '0' be use");
    printErr(message);
    current_canvas_rope = 0;
  }
}

// get
public PImage get_canvas(int which) {
  if(which < rope_canvas.length) {
    return rope_canvas[which];
  } else return null; 
}

public PImage get_canvas() {
  return rope_canvas[current_canvas_rope];
}

public int get_canvas_id() {
  return current_canvas_rope;
}

// update
public void update_canvas(PImage img) {
  update_canvas(img,current_canvas_rope);
}

public void update_canvas(PImage img, int which_one) {
  if(which_one < rope_canvas.length && which_one >= 0) {
    rope_canvas[which_one] = img;
  } else {
    println("void update_canvas() : Your selection" ,which_one, "is not available, canvas '0' be use");
    rope_canvas[0] = img;
  }  
}


/**
canvas event
v 0.0.1
*/
public void alpha_canvas(int target, float change) { 
  for(int i = 0 ; i < get_canvas(target).pixels.length ; i++) {
    int c = get_canvas(target).pixels[i];
    float rr = red(c);
    float gg = green(c);
    float bb = blue(c);
    float aa = alpha(c);
    aa += change ;
    if(i== 0 && target == 1 && aa < 5) {
      // println(aa, change);
    } 
    if(aa < 0 ) {
      aa = 0 ;
    }
    get_canvas(target).pixels[i] = color(rr,gg,bb,aa) ;
  }
  get_canvas(target).updatePixels() ;
}




/**
show canvas
v 0.0.4
*/
boolean fullscreen_canvas_is = false ;
ivec2 show_pos ;
/**
Add to set the center of the canvas in relation with the window
*/
int offset_canvas_x = 0 ;
int offset_canvas_y = 0 ;
public void set_show() {
  if(!fullscreen_canvas_is) {
    surface.setSize(get_canvas().width, get_canvas().height);
  } else {
    offset_canvas_x = width/2 - (get_canvas().width/2);
    offset_canvas_y = height/2 - (get_canvas().height/2);
    show_pos = ivec2(offset_canvas_x,offset_canvas_y) ;
  }
}

public ivec2 get_offset_canvas() {
  return ivec2(offset_canvas_x, offset_canvas_y);
}

public int get_offset_canvas_x() {
  return offset_canvas_x;
}

public int get_offset_canvas_y() {
  return offset_canvas_y;
}

public void show_canvas(int num) {
  if(fullscreen_canvas_is) {
    image(get_canvas(num), show_pos);
  } else {
    image(get_canvas(num));
  }  
}

























/**
* BACKGROUND
* v 0.2.3
* 2015-2019
*/
/**
Background classic processing
*/
// vec
public void background(vec4 c) {
  background(c.x,c.y,c.z,c.w) ;
}

public void background(vec3 c) {
  background(c.x,c.y,c.z) ;
}

public void background(vec2 c) {
  background(c.x,c.y) ;
}
// ivec
public void background(ivec4 c) {
  background(c.x,c.y,c.z,c.w) ;
}

public void background(ivec3 c) {
  background(c.x,c.y,c.z) ;
}

public void background(ivec2 c) {
  background(c.x,c.y) ;
}





/**
background image
*/
public void background(PImage src, int mode) {
  background_calc(src,null,null,null,null,mode);
}

public void background(PImage src, int mode, float red, float green, float blue) {
  vec3 colour_curtain = abs(vec3(red,green,blue).div(vec3(g.colorModeX,g.colorModeY,g.colorModeZ)));
  background_calc(src,null,null,colour_curtain,null,mode);
}

public void background(PImage src, float px, float py, float red, float green, float blue) {
  vec3 colour_curtain = abs(vec3(red,green,blue).div(vec3(g.colorModeX,g.colorModeY,g.colorModeZ)));
  vec2 pos = vec2(px /width, py /height);
  background_calc(src,pos,null,colour_curtain,null,r.SCALE);
}

public void background(PImage src, float px, float py, float scale_x, float red, float green, float blue) {
  vec3 colour_curtain = abs(vec3(red,green,blue).div(vec3(g.colorModeX,g.colorModeY,g.colorModeZ)));
  vec2 pos = vec2(px /width, py /height);
  vec2 scale = vec2(scale_x);
  background_calc(src,pos,scale,colour_curtain,null,r.SCALE);
}

public void background(PImage src, float px, float py, float scale_x, float red, float green, float blue, float curtain_position) {
  vec3 colour_curtain = abs(vec3(red,green,blue).div(vec3(g.colorModeX,g.colorModeY,g.colorModeZ)));
  vec2 pos = vec2(px /width, py /height);
  vec2 scale = vec2(scale_x);
  vec4 curtain_pos = vec4(curtain_position,0,curtain_position,0);
  background_calc(src,pos,scale,colour_curtain,curtain_pos,r.SCALE);
}

public void background(PImage src, vec2 pos, vec2 scale, vec3 colour_background, vec4 pos_curtain, int mode) {
  background_calc(src,pos,scale,colour_background,pos_curtain,mode);
}



PShader img_shader_calc_rope;
public void background_calc(PImage src, vec2 pos, vec2 scale, vec3 colour_background, vec4 pos_curtain, int mode) {
  if(src != null && src.width > 0 && src.height > 0) {
    if(img_shader_calc_rope == null) {
      img_shader_calc_rope = loadShader("shader/fx_post/image.glsl");
    }
    if(graphics_is(src).equals("PGraphics")) {
      img_shader_calc_rope.set("flip_source",false,false);
    } else {
      img_shader_calc_rope.set("flip_source",true,false);
    }
    
    img_shader_calc_rope.set("texture_source",src);
    img_shader_calc_rope.set("resolution",width,height);
    img_shader_calc_rope.set("resolution_source",src.width,src.height); 
    
    if(colour_background != null) {
      img_shader_calc_rope.set("colour",colour_background.x,colour_background.y,colour_background.z); // definr RGB color from 0 to 1
    }

    if(pos_curtain != null) {
      img_shader_calc_rope.set("curtain",pos_curtain.x,pos_curtain.y,pos_curtain.z,pos_curtain.w); // definr RGB color from 0 to 1
    }

    if(pos != null) {
      img_shader_calc_rope.set("position",pos.x,pos.y); // from 0 to 1
    }
    
    if(scale != null) {
      img_shader_calc_rope.set("scale",scale.x,scale.y);
    }
    
    int shader_mode = 0;
    if(mode == CENTER) {
      shader_mode = 0;
    } else if(mode == SCREEN) {
      shader_mode = 1;
    } else if(mode == r.SCALE) {
      shader_mode = 2;
    }
    img_shader_calc_rope.set("mode",shader_mode);

    filter(img_shader_calc_rope);
  }
}












/**
Normalize background
*/
public void background_norm(vec4 bg) {
  background_norm(bg.x,bg.y,bg.z,bg.w) ;
}

public void background_norm(vec3 bg) {
  background_norm(bg.x,bg.y,bg.z,1) ;
}

public void background_norm(vec2 bg) {
  background_norm(bg.x,bg.x,bg.x,bg.y) ;
}

public void background_norm(float c, float a) {
  background_norm(c,c,c,a) ;
}

public void background_norm(float c) {
  background_norm(c,c,c,1) ;
}

public void background_norm(float r,float g, float b) {
  background_norm(r,g,b,1) ;
}

// Main method
float MAX_RATIO_DEPTH = 6.9f ;
public void background_norm(float r_c, float g_c, float b_c, float a_c) {
  rectMode(CORNER) ;
  float x = map(r_c,0,1, 0, g.colorModeX) ;
  float y = map(g_c,0,1, 0, g.colorModeY) ;
  float z = map(b_c,0,1, 0, g.colorModeZ) ;
  float a = map(a_c,0,1, 0, g.colorModeA) ;
  noStroke() ;
  fill(x, y, z, a) ;
  int canvas_x = width ;
  int canvas_y = height ;
  if(renderer_P3D()) {
    canvas_x = width *100 ;
    canvas_y = height *100 ;
    int pos_x = - canvas_x /2 ;
    int pos_y = - canvas_y /2 ;
    // this problem of depth is not clarify, is must refactoring
    int pos_z = PApplet.parseInt( -height *MAX_RATIO_DEPTH) ;
    pushMatrix() ;
    translate(0,0,pos_z) ;
    rect(pos_x,pos_y,canvas_x, canvas_y) ;
    popMatrix() ;
  } else {
    rect(0,0,canvas_x, canvas_y) ;
  }
  // HSB mode
  if(g.colorMode == 3) {
    fill(0, 0, g.colorModeZ) ;
    stroke(0) ;
  // RGB MODE
  } else if (g.colorMode == 1) {
    fill(g.colorModeX, g.colorModeY, g.colorModeZ) ;
    stroke(0) ;

  }
  strokeWeight(1) ; 
}



/**
background rope
*/
public void background_rope(int c) {
  if(g.colorMode == 3) {
    background_rope(hue(c),saturation(c),brightness(c));
  } else {
    background_rope(red(c),green(c),blue(c));
  }
}

public void background_rope(int c, float w) {
  if(g.colorMode == 3) {
    background_rope(hue(c),saturation(c),brightness(c),w);
  } else {
    background_rope(red(c),green(c),blue(c),w );
  }
}

public void background_rope(float c) {
  background_rope(c,c,c);
}

public void background_rope(float c, float w) {
  background_rope(c,c,c,w);
}

public void background_rope(vec4 c) {
  background_rope(c.x,c.y,c.z,c.w);
}

public void background_rope(vec3 c) {
  background_rope(c.x,c.y,c.z);
}

public void background_rope(vec2 c) {
  background_rope(c.x,c.x,c.x,c.y);
}

// master method
public void background_rope(float x, float y, float z, float w) {
  background_norm(x/g.colorModeX, y/g.colorModeY, z/g.colorModeZ, w /g.colorModeA) ;
}

public void background_rope(float x, float y, float z) {
  background_norm(x/g.colorModeX, y/g.colorModeY, z/g.colorModeZ) ;
}























/**
GRAPHICS METHOD
v 0.3.3
*/
/**
SCREEN
*/
public void set_window(int px, int py, int sx, int sy) {
  set_window(ivec2(px,py), ivec2(sx,sy), get_screen_location(0));
}

public void set_window(int px, int py, int sx, int sy, int target) {
  set_window(ivec2(px,py), ivec2(sx,sy), get_screen_location(target));
}

public void set_window(ivec2 pos, ivec2 size) {
  set_window(pos, size, get_screen_location(0));
}

public void set_window(ivec2 pos, ivec2 size, int target) {
  set_window(pos, size, get_screen_location(target));
}

public void set_window(ivec2 pos, ivec2 size, ivec2 pos_screen) { 
  int offset_x = pos.x;
  int offset_y = pos.y;
  int dx = pos_screen.x;
  int dy = pos_screen.y;
  surface.setSize(size.x,size.y);
  surface.setLocation(offset_x +dx, offset_y +dy);
}

/**
check screen
*/
/**
screen size
*/
public ivec2 get_screen_size() {
  return get_display_size(sketchDisplay() -1);
}

public ivec2 get_screen_size(int target) {
  if(target >= get_display_num()) {
    target = 0;
    printErr("method get_screen_size(int target): target screen",target,"don't match with any screen device instead target '0' is used");
  }
  return get_display_size(target);
}

public @Deprecated
ivec2 get_display_size() {
  return get_display_size(sketchDisplay() -1);
}


public ivec2 get_display_size(int target) {
  if(target >= get_display_num()) {
    target = 0;
    printErr("method get_screen_size(int target): target screen",target,"don't match with any screen device instead target '0' is used");
  }  
  Rectangle display = get_screen(target);
  return ivec2((int)display.getWidth(), (int)display.getHeight()); 
}

/**
screen location
*/

public ivec2 get_screen_location(int target) {
  Rectangle display = get_screen(target);
  return ivec2((int)display.getX(), (int)display.getY());
}

/**
screen num
*/
public int get_screen_num() {
  return get_display_num();
}

public int get_display_num() {
  GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();
  return environment.getScreenDevices().length;
}


/**
screen
*/
public Rectangle get_screen(int target_screen) {
  GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();
  GraphicsDevice[] awtDevices = environment.getScreenDevices();
  int target = 0 ;
  if(target_screen < awtDevices.length) {
    target = target_screen ; 
  } else {
    printErr("No screen match with your request, instead we use the current screen");
    target = sketchDisplay() -1;
    if(target >= awtDevices.length) target = awtDevices.length -1;
  }
  GraphicsDevice awtDisplayDevice = awtDevices[target];
  Rectangle display = awtDisplayDevice.getDefaultConfiguration().getBounds();
  return display;
}



/**
sketch location 
0.0.2
*/
public ivec2 get_sketch_location() {
  return ivec2(get_sketch_location_x(),get_sketch_location_y());
}

public int get_sketch_location_x() {
  if(get_renderer() != P3D && get_renderer() != P2D) {
    return getJFrame(surface).getX();
  } else {
    return get_rectangle(surface).getX();

  }
  
}

public int get_sketch_location_y() {
  if(get_renderer() != P3D && get_renderer() != P2D) {
    return getJFrame(surface).getY();
  } else {
    return get_rectangle(surface).getY();
  }
}


public com.jogamp.nativewindow.util.Rectangle get_rectangle(PSurface surface) {
  com.jogamp.newt.opengl.GLWindow window = (com.jogamp.newt.opengl.GLWindow) surface.getNative();
  com.jogamp.nativewindow.util.Rectangle rectangle = window.getBounds();
  return rectangle;
}


public static final javax.swing.JFrame getJFrame(final PSurface surface) {
  return (javax.swing.JFrame)
  (
    (processing.awt.PSurfaceAWT.SmoothCanvas) surface.getNative()
  ).getFrame();
}








/**
Check renderer
*/
public boolean renderer_P3D() {
  if(get_renderer(getGraphics()).equals("processing.opengl.PGraphics3D")) return true ; else return false ;
}


public String get_renderer() {
  return get_renderer(g);
}

public String get_renderer(final PGraphics graph) {
  try {
    if (Class.forName(JAVA2D).isInstance(graph)) return JAVA2D;
    if (Class.forName(FX2D).isInstance(graph)) return FX2D;
    if (Class.forName(P2D).isInstance(graph)) return P2D;
    if (Class.forName(P3D).isInstance(graph)) return P3D;
    if (Class.forName(PDF).isInstance(graph)) return PDF;
    if (Class.forName(DXF).isInstance(graph)) return DXF;
  }

  catch (ClassNotFoundException ex) {
  }
  return "Unknown";
}






public String graphics_is(Object obj) {
  if(obj instanceof PGraphics) {
    return "PGraphics";
  } else if(obj instanceof PGraphics2D) {
    return "PGraphics";
  } else if(obj instanceof PGraphics3D) {
    return "PGraphics";
  } else if(obj instanceof processing.javafx.PGraphicsFX2D) {
    return "PGraphics";
  } else if(obj instanceof PImage) {
    return "PImage";
  } else return null;
}
/**
ROPE - Romanesco processing environment – 
* Copyleft (c) 2014-2017 
* Stan le Punk > http://stanlepunk.xyz/
Rope Motion  2015 – 2018
v 1.3.0
Rope – Romanesco Processing Environment – 
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/




/**
Method motion
v 0.2.0
*/
public vec2 follow(vec2 target, float speed) {
  vec3 f = follow(target.x,target.y,0,speed);
  return vec2(f.x,f.y);
}



public vec3 follow(vec3 target, float speed) {
  return follow(target.x,target.y,target.z,speed);
}

public vec2 follow(float tx, float ty, float speed) {
  vec3 f = follow(tx,ty,0,speed);
  return vec2(f.x,f.y);
}

/**
* master method
*Compute position vector Traveller, give the target pos and the speed to go.
*/
vec3 dest_3D_follow_rope;
public vec3 follow(float tx, float ty, float tz, float speed) {
  if(speed <= 0 || speed > 1) {
    printErrTempo(120,"vec3 follow(): float speed parameter must be a normal value between 0 and 1\n instead value 1 is attribute to speed");
    speed = 1.f;
  }
  if(dest_3D_follow_rope == null) dest_3D_follow_rope = vec3();
  // calcul X pos
  float dx = tx - dest_3D_follow_rope.x;
  if(abs(dx) != 0) {
    dest_3D_follow_rope.x += dx * speed;
  }
  // calcul Y pos
  float dy = ty - dest_3D_follow_rope.y;
  if(abs(dy) != 0) {
    dest_3D_follow_rope.y += dy * speed;
  }
  // calcul Z pos
  float dz = tz - dest_3D_follow_rope.z;
  if(abs(dz) != 0) {
    dest_3D_follow_rope.z += dz * speed;
  }
  return dest_3D_follow_rope;
}






/**
Class Motion 
v 1.1.0
2016-2018
* @author Stan le Punk
* @see https://github.com/StanLepunK/Motion
*/

class Motion {
  float vel_ref = 1.f ;
  float vel = 1.f ;
  float max_vel = 1 ;

  float acc = .01f ;
  float dec = .01f ;
  boolean  acc_is = false ;
  boolean  dec_is = true ;

  vec3 dir  ;
  int tempo = 0 ;
  private boolean tempo_is = false ;
  
  // constructor
  Motion() {
  }

  Motion(float max_vel) {
    this.max_vel = max_vel ;
  }



  // get
  public float get_velocity() {
    return vel ;
  }

  public vec3 get_direction() {
    return dir ;
  }

  public float get_acceleration() {
    return acc;
  }

  public float get_deceleration() {
    return dec;
  }

  public boolean acceleration_is() {
    return acc_is ;
  }

  public boolean deceleration_is() {
    return dec_is ;
  }

  public boolean velocity_is() {
    if(vel == 0) return false ; else return true ;
  }




  // set
  public void set_deceleration(float dec) {
    this.dec = abs(dec) ;
  }

  public void set_acceleration(float acc) {
    this.acc = abs(acc) ;
  }

  public void set_velocity(float vel) {
    this.vel = vel ;
  }

  public void set_max_velocity(float max_vel) {
    this.max_vel = max_vel ;
  }

  public void set_tempo(int tempo) {
    tempo_is = true ;
    this.tempo = tempo ;
  }

  public void reset() {
    this.vel = 0 ;
    this.vel_ref = 0 ;
    if(dir == null) {
      this.dir = vec3(0) ;
    } else {
      this.dir.set(0) ;
    }
  }




  // event
  public void stop() {
    this.vel_ref = this.vel ;
    set_velocity(0) ;
  }

  public void start() {
    set_velocity(vel_ref) ;
  }

  public void acceleration_is(boolean state) {
    acc_is = state ;
  }

  public void deceleration_is(boolean state) {
    dec_is = state ;
  }


  // motion
  // deceleration
  public void deceleration() {
    if(vel > 0) {
      vel -= dec ;
      // to stop object
      if(vel < 0) vel = 0 ;
    } else if(vel < 0 ) {
      vel += dec ;
      if(vel > 0) vel = 0 ;
    }
  }
  
  // acceleration
  public void acceleration() {
    if(vel > 0) {
      vel += acc ;
      // limit the velocity to the maximum velocity
      if(vel > max_vel) vel = max_vel ;
    } else if(vel < 0 ) {
      vel -= acc ;
      // limit the velocity to the maximum velocity
      if(abs(vel) > max_vel) vel = -max_vel ;
    }
  }







  /**
  leading 
  v 0.0.3
  */
  public vec2 leading(vec2 leading_pos, vec2 exec_pos) {
    vec3 current_pos_3D = vec3(leading_pos) ;
    vec3 my_pos_3D = vec3(exec_pos) ;
    vec3 lead = leading(current_pos_3D, my_pos_3D) ;
    return vec2(lead.x, lead.y) ;
  }


  vec3 for_vel ;
  vec3 for_dir ;

  vec3 leading_pos ;
  vec3 leading_ref ;
  boolean apply_acc = false ;

  public vec3 leading(vec3 leading_pos, vec3 exec_pos) {
    if(leading_ref == null) {
      leading_ref = vec3(exec_pos) ;
    }
    vec3 new_pos = vec3(exec_pos) ;

    vec3 velocity_xyz = apply_leading(leading_pos) ;
    if(velocity_xyz.equals(vec3(0))) {
      // follow the lead when this one move
      apply_acc = true ;
      new_pos.sub(sub(leading_ref, leading_pos)) ;
    } else {
      new_pos.add(velocity_xyz) ;
    }
    leading_ref.set(leading_pos) ;
    return new_pos ;
  }


  private vec3 apply_leading(vec3 leading_pos) {
    // init var if var is null
    if (dir == null) {
      dir = vec3() ;
    }
    if (for_vel == null) {
      for_vel = vec3() ;
    }
    if (for_dir == null) {
      for_dir = vec3() ;
    }
    if (leading_pos == null) {
      leading_pos = vec3() ;
    }


    vec3 vel_vec3 = vec3() ;
    leading_pos.set(leading_pos) ;

    if(for_vel.equals(leading_pos)) {
      // limit speed
      if (abs(vel) > max_vel) {
        if(vel < 0) {
          vel = -max_vel ;
        } else {
          vel = max_vel ;
        }
      }
      

      if(abs(vel) >= max_vel || !acc_is) {
        apply_acc = false ;
      }

      if(apply_acc && acc_is) {
        acceleration() ;
      }

      if(!apply_acc && dec_is) {
        deceleration() ;
      }

      // update position
      vel_vec3 = mult(dir, vel) ;
    } else {
      vel = dist(leading_pos, for_vel) ;
      dir = sub(leading_pos, for_dir) ;
      dir.normalize() ;
    }
    for_vel.set(leading_pos) ;

    // calcul direction
    if(!tempo_is) tempo = PApplet.parseInt(frameRate *.25f) ;
    if(tempo != 0) {
      if(frameCount%tempo == 0) {
        for_dir.set(leading_pos) ;
      } 
    }
    
    //
    return vel_vec3 ;
  }
  /**
  end leading
  */

  
}







/**
PATH
*/
class Path extends Motion {
  // list of the keypoint, use super_class Path
  ArrayList<vec3> path ;
  // distance between the keypoint and the position of the translation shape
  float dist_from_start = 0 ;
  float dist_a_b = 0 ;

  // a & b are points to calculate the direction and position of the translation to give at the shape
  // vec3 origin, target ;
  // speed ratio to adjust the speed xy according to position target
  vec3 ratio  ;
  //keypoint 
  vec3 pos ;
  

  // find a good keypoint in the ArrayList
  int n = 0 ;
  int m = 1 ;

  Path() {
    super() ;
    path = new ArrayList<vec3>() ;
    pos = vec3(MAX_INT) ;
  }
   // set
   public void set_velocity(float velocity) {
    if(vel < 0) {
      System.err.println("negative value, class Path use the abslolute value of") ;
      System.err.println(vel) ;
    }
    this.vel = abs(vel) ;
   }

  

  // next
  public void previous() {
    vec3 origin, target ;
    if (path.size() > 1 ) {
      vec3 key_a = vec3() ;
      vec3 key_b = vec3() ;
      int origin_rank = path.size() - n -1 ;
      int target_rank = path.size() - m -1 ;
      key_a = (vec3) path.get(origin_rank) ;
      key_b = (vec3) path.get(target_rank) ;

      origin = vec3(key_a) ;
      target = vec3(key_b) ;
      go(origin, target) ;

    } else if (path.size() == 1) {
      vec3 key_a = (vec3) path.get(0) ;
      origin = vec3(key_a) ;
      pos.set(origin) ;
    } else {
      pos.set(-100) ;
    }
  }






  // next
  public void next() {
    vec3 origin, target ;
    if (path.size() > 1 ) {
      vec3 key_a = vec3() ;
      vec3 key_b = vec3() ;
      key_a = (vec3) path.get(n) ;
      key_b = (vec3) path.get(m) ;

      origin = vec3(key_a) ;
      target = vec3(key_b) ;
      go(origin, target) ;

    } else if (path.size() == 1) {
      vec3 key_a = (vec3) path.get(n) ;
      origin = vec3(key_a) ;
      pos.set(origin) ;
    } else {
      pos.set(-100) ;
    }
  }




  // private method of class
  private void go(vec3 origin, vec3 target) {
    if(pos.equals(vec3(MAX_INT))) {
      pos.set(origin) ;
    }
    // distance between the keypoint a & b and the position of the translation shape
    dist_a_b = origin.dist(target) ;
    dist_from_start = pos.dist(origin) ;
    //update the position
    if (dist_from_start < dist_a_b) {
      // calcul speed ratio
      vec3 speed_ratio = sub(origin,target) ;

      // final calcul ratio
      if(ratio == null) {
        ratio = vec3() ;
      }
      ratio.x = speed_ratio.x / speed_ratio.y ;
      ratio.y = speed_ratio.y / speed_ratio.x ;
      if(abs(ratio.x) > abs(ratio.y) ) { 
        ratio.x = 1.0f ; ratio.y = abs(ratio.y) ; 
      } else { 
        ratio.x = abs(ratio.x) ; ratio.y = 1.0f ; 
      }
      
      // Give the good direction to the translation
      if (speed_ratio.x == 0) {
        pos.x += 0 ;
        if (origin.y - target.y < 0 )  {
          pos.y += vel ; 
        } else {
          pos.y -= vel ;
        }
      } 
      if (speed_ratio.y == 0) {
        pos.y += 0 ;
        if (origin.x - target.x < 0 ) {
          pos.x += vel ; 
        } else {
          pos.x -= vel ;
        }     
      }

      if (speed_ratio.x != 0 && speed_ratio.y != 0  )  {
        if (origin.x - target.x < 0 ) {
          pos.x += (vel *ratio.x) ; 
        } else {
          pos.x -= (vel *ratio.x) ;
        }
        if (origin.y - target.y < 0 ) {
          pos.y += (vel *ratio.y) ; 
        } else {
          pos.y -= (vel *ratio.y) ;
        }
      }
    } else {
      n++ ; 
      m++ ;
    }
    //change to the next keypoint 
    if (target.equals(pos)) {  
      m++ ; 
      n++ ; 
    }
    
    if (n != path.size() && m == 1) { 
      m = 1 ; 
      n = 0 ; 
    }
    
    if (m == path.size()) { 
      m = 0 ; 
    }
    
    if (n == path.size()) { 
      n = 0 ; 
    } 
  }









  // get
  public vec3 get_pos() {
    return pos ;
  }

  public int path_size() {
    return path.size() ;
  }

  public vec3 [] path() {
    vec3 [] list = new vec3[path.size()] ;
    for(int i = 0 ; i < path.size() ; i++) {
      list[i] = path.get(i).copy() ;
    }
    return list ;
  }

  public ArrayList<vec3> path_ArrayList() {
    return path ;
  }
  

  // add point to the list to make the path
  public void add(vec coord) {
    path.add(vec3(coord.x,coord.y,coord.z)) ;
  }
  public void add(int x, int y, int z) {
    path.add(vec3(x,y,z)) ;
  }

  public void add(int x, int y) {
    path.add(vec3(x,y,0)) ;
  }
}
/**
ROPE PROCESSING METHOD
v 2.4.3
* Copyleft (c) 2014-2019
* Stan le Punk > http://stanlepunk.xyz/
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
* Processing 3.5.3
*/


/**
ADVANCED GHOST METHOD
v 1.0.1
All advanced ghost push Processing method further.
Processing and vec, ivec and bvec method
the idea here is create method directly insprating from Processing to simplify the coder life
*/

/**
* colorMode(vec5 color_component)
* @param component give in order : mode, x, y, z and alpha
*/
public void colorMode(vec5 component) {
  int mode = (int)component.w;
  if(mode == HSB) {
    colorMode(HSB,component.b(),component.c(),component.d(),component.e());
  } else if(mode == RGB) {
    colorMode(RGB,component.b(),component.c(),component.d(),component.e());
  } else {
    printErr("The first component of your vec is", mode, "and don't match with any Processing colorMode, instead the current colorMode will be used");
  }
}
/**
* colorMode(int mode, vec4 color_component)
* @param mode give environment HSB or RGB
* @param color_component give in order : x, y, z and alpha
*/
public void colorMode(int mode, vec4 component) {
  if(mode == HSB) {
    colorMode(HSB,component.x,component.y,component.z,component.w);
  } else if(mode == RGB) {
    colorMode(RGB,component.x,component.y,component.z,component.w);
  } else {
    printErr("int mode", mode, "don't match with any Processing colorMode, instead the current colorMode will be used");
  }
}
/**
* colorMode(int mode, vec3 color_component)
* @param mode give environment HSB or RGB
* @param color_component give in order : x, y, z
*/
public void colorMode(int mode, vec3 component) {
  colorMode(mode, vec4(component.x,component.y,component.z,g.colorModeA));
}
/**
* colorMode(int mode, vec2 color_component)
* @param mode give environment HSB or RGB
* @param color_component give in order the x give x,y,z and y give the alpha
*/
public void colorMode(int mode, vec2 component) {
   colorMode(mode, vec4(component.x,component.x,component.x,component.y));
}







/**
floor
*/
public vec2 floor(vec2 arg) {
  return vec2(floor(arg.x),floor(arg.y));
}

public vec3 floor(vec3 arg) {
  return vec3(floor(arg.x),floor(arg.y),floor(arg.z));
}

public vec4 floor(vec4 arg) {
  return vec4(floor(arg.x),floor(arg.y),floor(arg.z),floor(arg.w));
}






/**
round
*/
public vec2 round(vec2 arg) {
  return vec2(round(arg.x),round(arg.y));
}

public vec3 round(vec3 arg) {
  return vec3(round(arg.x),round(arg.y),round(arg.z));
}

public vec4 round(vec4 arg) {
  return vec4(round(arg.x),round(arg.y),round(arg.z),round(arg.w));
}





/**
ceil
*/
public vec2 ceil(vec2 arg) {
  return vec2(ceil(arg.x),ceil(arg.y));
}

public vec3 ceil(vec3 arg) {
  return vec3(ceil(arg.x),ceil(arg.y),ceil(arg.z));
}

public vec4 ceil(vec4 arg) {
  return vec4(ceil(arg.x),ceil(arg.y),ceil(arg.z),ceil(arg.w));
}


/**
abs
*/
public vec2 abs(vec2 arg) {
  return vec2(abs(arg.x),abs(arg.y));
}

public vec3 abs(vec3 arg) {
  return vec3(abs(arg.x),abs(arg.y),abs(arg.z));
}

public vec4 abs(vec4 arg) {
  return vec4(abs(arg.x),abs(arg.y),abs(arg.z),abs(arg.w));
}

public ivec2 abs(ivec2 arg) {
  return ivec2(abs(arg.x),abs(arg.y));
}

public ivec3 abs(ivec3 arg) {
  return ivec3(abs(arg.x),abs(arg.y),abs(arg.z));
}

public ivec4 abs(ivec4 arg) {
  return ivec4(abs(arg.x),abs(arg.y),abs(arg.z),abs(arg.w));
}



/**
max
*/
public vec2 max(vec2 a, vec2 b) {
  return vec2(max(a.x,b.x),max(a.y,b.y));
}

public vec3 max(vec3 a, vec3 b) {
  return vec3(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z));
}

public vec4 max(vec4 a, vec4 b) {
  return vec4(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z),max(a.w,b.w));
}

public ivec2 max(ivec2 a, ivec2 b) {
  return ivec2(max(a.x,b.x),max(a.y,b.y));
}

public ivec3 max(ivec3 a, ivec3 b) {
  return ivec3(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z));
}

public ivec4 max(ivec4 a, ivec4 b) {
  return ivec4(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z),max(a.w,b.w));
}



/**
min
*/
public vec2 min(vec2 a, vec2 b) {
  return vec2(min(a.x,b.x),min(a.y,b.y));
}

public vec3 min(vec3 a, vec3 b) {
  return vec3(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z));
}

public vec4 min(vec4 a, vec4 b) {
  return vec4(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z),min(a.w,b.w));
}

public ivec2 min(ivec2 a, ivec2 b) {
  return ivec2(min(a.x,b.x),min(a.y,b.y));
}

public ivec3 min(ivec3 a, ivec3 b) {
  return ivec3(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z));
}

public ivec4 min(ivec4 a, ivec4 b) {
  return ivec4(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z),min(a.w,b.w));
}





/**
set
*/
public void set(ivec2 pos, int c) {
  set(pos.x, pos.y, c);
}

public void set(vec2 pos, int c) {
  set((int)pos.x, (int)pos.y, c);
}



/**
random
*/
public float random (vec2 v) {
  return random(v.x, v.y);
}

public float random (ivec2 v) {
  return random(v.x, v.y);
}




/**
Ellipse
v 0.1.1
*/
// with vec2 or ivec2
public void ellipse(vec2 p, vec s) {
  ellipse(p.x,p.y, s.x,s.y);
}

public void ellipse(vec2 p, float x, float y) {
  ellipse(p.x,p.y,x,y);
}

public void ellipse(vec2 p, float x) {
  ellipse(p.x,p.y,x,x);
}


// ivec
public void ellipse(ivec2 p, ivec s) {
  ellipse(p.x,p.y,s.x,s.y) ;
}

public void ellipse(ivec2 p, int x, int y) {
  ellipse(p.x,p.y, x,y);
}

public void ellipse(ivec2 p, int x) {
  ellipse(p.x,p.y,x,x);
}

// with vec3 or ivec3
public void ellipse(ivec3 p, int x, int y) {
  ellipse(p,ivec2(x,y));
}

public void ellipse(ivec3 p, int x) {
  ellipse(p,ivec2(x));
}

public void ellipse(ivec3 p, ivec s) {
  vec3 temp_pos = vec3((int)p.x, (int)p.y, (int)p.z);
  vec2 temp_size = vec2((int)s.x,(int)s.y);
  ellipse(temp_pos, temp_size);
}


public void ellipse(vec3 p, float x, float y) {
  ellipse(p,vec2(x,y));
}

public void ellipse(vec3 p, float x) {
  ellipse(p,vec2(x));
}

/**
main method
*/
public void ellipse(vec3 p, vec s) {
  if(renderer_P3D()) {
    start_matrix() ;
    translate(p.x, p.y, p.z);
    ellipse(0,0, s.x, s.y);
    stop_matrix() ;
  } else {
    ellipse(p.x,p.y,s.x,s.y);
  }
}







/**
Rect
*/
public void rect(vec2 p, vec2 s) {
  rect(p.x,p.y,s.x,s.y);
}
public void rect(vec3 p, vec2 s) {
  if(renderer_P3D()) {
    start_matrix();
    translate(p.x,p.y,p.z);
    rect(0,0,s.x,s.y);
    stop_matrix();
  } else rect(p.x,p.y,s.x,s.y);
}

public void rect(ivec2 p, ivec2 s) {
  rect(p.x,p.y,s.x,s.y) ;
}

public void rect(ivec3 p, ivec2 s) {
  vec3 temp_pos = vec3((int)p.x,(int)p.y,(int)p.z);
  vec2 temp_size = vec2((int)s.x,(int)s.y);
  rect(temp_pos,temp_size);
}


/**
Triangle
*/
public void triangle(ivec a, ivec b, ivec2 c) {
  triangle(vec3(a.x,a.y,a.z),vec3(b.x,b.y,b.z),vec3(c.x,c.y,c.z));
}

public void triangle(vec a, vec b, vec c) {
  if(a.z == 0 && b.z == 0 && c.z == 0) {
    triangle(a.x,a.y,b.x,b.y,c.x,c.y);
  } else {
    if(renderer_P3D()) {
      beginShape();
      vertex(a.x,a.y,a.z);
      vertex(b.x,b.y,b.z);
      vertex(c.x,c.y,c.z);
      endShape(CLOSE);
    } else {

      triangle(a.x,a.y,b.x,b.y,c.x,c.y);
    }
  }
}




/**
Box
*/
public void box(vec3 p) {
  box(p.x,p.y,p.z);
}

public void box(ivec3 p) {
  box(p.x,p.y,p.z);
}




/**
Point
*/
public void point(vec2 p) {
  point(p.x,p.y);
}
public void point(vec3 p) {
  if(renderer_P3D()) point(p.x,p.y,p.z); 
  else point(p.x,p.y) ;
}

public void point(ivec2 p) {
  point(p.x,p.y);
}
public void point(ivec3 p) {
  if(renderer_P3D()) point(p.x,p.y,p.z); 
  else point(p.x,p.y);
}




/**
Line
*/
public void line(vec2 a, vec2 b){
  line(a.x,a.y,b.x,b.y);
}
public void line(vec3 a, vec3 b){
  if(renderer_P3D()) line(a.x,a.y,a.z,b.x,b.y,b.z); 
  else line(a.x,a.y,b.x,b.y);
}

public void line(ivec2 a, ivec2 b) {
  line(a.x,a.y,b.x,b.y);
}

public void line(ivec3 a, ivec3 b) {
  if(renderer_P3D()) line(a.x,a.y,a.z,b.x,b.y,b.z); 
  else line(a.x,a.y,b.x,b.y);
}



/**
Vertex
v 0.0.2
*/
public void vertex(vec2 xy) {
  vertex(xy.x,xy.y);
}

public void vertex(vec3 xyz) {
  if(renderer_P3D()) vertex(xyz.x,xyz.y,xyz.z); 
  else vertex(xyz.x,xyz.y);
}
//
public void vertex(ivec2 xy) {
  vertex(xy.x,xy.y);
}

public void vertex(ivec3 xyz){
  if(renderer_P3D()) vertex(xyz.x,xyz.y,xyz.z); 
  else vertex(xyz.x,xyz.y);
}
//
public void vertex(vec2 xy, vec2 uv) {
  vertex(xy.x,xy.y,uv.u,uv.v);
}

public void vertex(ivec2 xy, vec2 uv) {
  vertex(xy.x,xy.y,uv.u,uv.v);
}
//
public void vertex(vec3 xyz, vec2 uv) {
  if(renderer_P3D()) vertex(xyz.x,xyz.y,xyz.z,uv.u,uv.v); 
  else vertex(xyz.x,xyz.y,uv.u,uv.v);
}

public void vertex(ivec3 xyz, vec2 uv) {
  if(renderer_P3D()) vertex(xyz.x,xyz.y,xyz.z,uv.u,uv.v); 
  else vertex(xyz.x,xyz.y,uv.u,uv.v);
}



/**
Bezier Vertex
*/
public void bezierVertex(vec2 a, vec2 b, vec2 c) {
  bezierVertex(a.x, a.y,b.x,b.y,c.x,c.y);
}

public void bezierVertex(vec3 a, vec3 b, vec3 c) {
  if(renderer_P3D()) bezierVertex(a.x,a.y,a.z,b.x,b.y,b.z,c.x,c.y,c.z); 
  else bezierVertex(a.x,a.y,b.x,b.y,c.x,c.y);
}

public void bezierVertex(ivec2 a, ivec2 b, ivec2 c) {
  bezierVertex(a.x,a.y,b.x,b.y,c.x,c.y);
}

public void bezierVertex(ivec3 a, ivec3 b, ivec3 c) {
  if(renderer_P3D()) bezierVertex(a.x,a.y,a.z,b.x,b.y,b.z,c.x,c.y,c.z); 
  else bezierVertex(a.x,a.y,b.x,b.y,c.x,c.y);
}





/**
Quadratic Vertex
*/
public void quadraticVertex(vec2 a, vec2 b) {
  quadraticVertex(a.x, a.y, b.x, b.y);
}

public void quadraticVertex(vec3 a, vec3 b) {
  if(renderer_P3D()) quadraticVertex(a.x, a.y, a.z, b.x, b.y, b.z); 
  else quadraticVertex(a.x, a.y, b.x, b.y) ;
}

public void quadraticVertex(ivec2 a, ivec2 b) {
  quadraticVertex(a.x, a.y, b.x, b.y);
}

public void quadraticVertex(ivec3 a, ivec3 b) {
  if(renderer_P3D()) quadraticVertex(a.x, a.y, a.z, b.x, b.y, b.z); 
  else quadraticVertex(a.x, a.y, b.x, b.y);
}




/**
Curve Vertex
*/
public void curveVertex(vec2 a) {
  curveVertex(a.x, a.y);
}
public void curveVertex(vec3 a){
  if(renderer_P3D()) curveVertex(a.x, a.y, a.z) ; 
  else curveVertex(a.x, a.y);
}

public void curveVertex(ivec2 a) {
  curveVertex(a.x, a.y);
}
public void curveVertex(ivec3 a){
  if(renderer_P3D()) curveVertex(a.x, a.y, a.z) ; 
  else curveVertex(a.x, a.y);
}





/**
Fill
*/
// vec
public void fill(vec2 c) {
  if( c.y > 0) fill(c.x, c.y); 
  else noFill();
}
public void fill(vec3 c) {
  fill(c.x,c.y,c.z) ;
}

public void fill(vec3 c, float a) {
  if(a > 0) fill(c.x,c.y,c.z,a); 
  else noFill();
}

public void fill(vec4 c) {
  if(c.w > 0) fill(c.x,c.y,c.z,c.w); 
  else noFill();
}

// ivec
public void fill(ivec2 c) {
  if(c.y > 0) fill(c.x,c.y); 
  else noFill();
}
public void fill(ivec3 c) {
  fill(c.x,c.y,c.z);
}

public void fill(ivec3 c, float a) {
  if(a > 0) fill(c.x,c.y,c.z,a);
  else noFill();
}

public void fill(ivec4 c) {
  if(c.w > 0) fill(c.x,c.y,c.z,c.w); 
  else noFill();
}




/**
Stroke
*/
// vec
public void stroke(vec2 c) {
  if(c.y > 0) stroke(c.x,c.y); 
  else noStroke();
}
public void stroke(vec3 c) {
  stroke(c.x,c.y,c.z);
}

public void stroke(vec3 c, float a) {
  if(a > 0) stroke(c.x,c.y,c.z,a); 
  else noStroke();
}

public void stroke(vec4 c) {
  if(c.w > 0) stroke(c.x,c.y,c.z,c.w); 
  else noStroke();
}
// ivec
public void stroke(ivec2 c) {
  if(c.y > 0) stroke(c.x,c.y); 
  else noStroke();
}
public void stroke(ivec3 c) {
  stroke(c.x, c.y, c.z);
}

public void stroke(ivec3 c, float a) {
  if(a > 0) stroke(c.x,c.y,c.z,a); 
  else noStroke();
}

public void stroke(ivec4 c) {
  if(c.w > 0) stroke(c.x,c.y,c.z,c.w); 
  else noStroke();
}



/**
text
v 0.2.0
*/
public void text(String s, vec pos) {
  if(pos instanceof vec2 && s != null) {
    vec2 p = (vec2)pos;
    text(s,p.x,p.y);
  } else if(pos instanceof vec3 && s != null) {
    vec3 p = (vec3)pos;
    text(s,p.x,p.y,p.z);
  } else {
    printErrTempo(60,"method text(): String message is null or vec is not an instance of vec3 or vec2");
  }
}

public void text(char c, vec pos) {
  if(pos instanceof vec2) {
    vec2 p = (vec2)pos;
    text(c, p.x, p.y);
  } else if(pos instanceof vec3) {
    vec3 p = (vec3)pos;
    text(c,p.x,p.y,p.z);
  }
}

public void text(int num, vec pos) {
  if(pos instanceof vec2) {
    vec2 p = (vec2)pos;
    text(num, p.x, p.y);
  } else if(pos instanceof vec3) {
    vec3 p = (vec3)pos;
    text(num,p.x,p.y,p.z);
  } 
}

public void text(float num, vec pos) {
  if(pos instanceof vec2) {
    vec2 p = (vec2) pos;
    text(num, p.x, p.y);
  } else if(pos instanceof vec3) {
    vec3 p = (vec3) pos;
    text(num,p.x,p.y,p.z);
  } 
}

// ivec
public void text(String s, ivec pos) {
  if(pos instanceof ivec2 && s != null) {
    vec2 temp_pos = vec2(pos.x,pos.y);
    text(s, temp_pos);
  } else if(pos instanceof ivec2) {
    vec3 temp_pos = vec3(pos.x,pos.y,pos.z);
    text(s, temp_pos);
  } else {
    printErrTempo(60,"method text(): String message is null or ivec is not an instance of ivec3 or ivec2");
  }  
}

public void text(char c, ivec pos) {
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x,pos.y);
    text(c, temp_pos);
  } else if(pos instanceof ivec2) {
    vec3 temp_pos = vec3(pos.x,pos.y,pos.z);
    text(c, temp_pos);
  } 
}

public void text(int num, ivec pos) {
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x,pos.y);
    text(num, temp_pos);
  } else if(pos instanceof ivec2) {
    vec3 temp_pos = vec3(pos.x,pos.y,pos.z);
    text(num, temp_pos);
  }
}

public void text(float num, ivec pos) {
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x,pos.y);
    text(num, temp_pos);
  } else if(pos instanceof ivec2) {
    vec3 temp_pos = vec3(pos.x,pos.y,pos.z);
    text(num, temp_pos);
  } 
}








/**
Translate
*/
// vec
public void translate(vec3 t) {
  if(renderer_P3D()) {
    translate(t.x,t.y,t.z); 
  } else {
    translate(t.x,t.y);
  }
}

public void translate(vec2 t){
  translate(round(t.x),round(t.y));
}

// ivec
public void translate(ivec3 t){
  if(renderer_P3D()) {
    translate(t.x,t.y,t.z); 
  } else {
    translate(t.x,t.y);
  }
}

public void translate(ivec2 t){
  translate(t.x,t.y);
}

public void translateX(float t){
  translate(t,0);
}

public void translateY(float t){
  translate(0,t);
}

public void translateZ(float t){
  translate(0,0,t);
}


/**
Rotate
*/
// vec
public void rotateXY(vec2 rot) {
  rotateX(rot.x);
  rotateY(rot.y);
}

public void rotateXZ(vec2 rot) {
  rotateX(rot.x);
  rotateZ(rot.y);
}

public void rotateYZ(vec2 rot) {
  rotateY(rot.x);
  rotateZ(rot.y);
}
public void rotateXYZ(vec3 rot) {
  rotateX(rot.x);
  rotateY(rot.y);
  rotateZ(rot.z);
}

// ivec
public void rotateXY(ivec2 rot) {
  rotateX(rot.x);
  rotateY(rot.y);
}

public void rotateXZ(ivec2 rot) {
  rotateX(rot.x);
  rotateZ(rot.y);
}

public void rotateYZ(ivec2 rot) {
  rotateY(rot.x);
  rotateZ(rot.y);
}
public void rotateXYZ(ivec3 rot) {
  rotateX(rot.x);
  rotateY(rot.y);
  rotateZ(rot.z);
}







/**
Matrix
v 0.1.0
*/
// vec
public void start_matrix_3D(vec pos, vec3 dir_cart) {
  vec3 dir = dir_cart.copy() ;
  pushMatrix() ;
  if(pos instanceof vec2) {
    vec2 p = (vec2) pos ;
    translate(p) ;
  } else if(pos instanceof vec3) {
    vec3 p = (vec3) pos ;
    translate(p) ;
  } else {
    printErr("Error in void start_matrix_3D(), vec pos is not an instance of vec2 or vec3, the matrix don't translate your object") ;
    // exit() ;
  }
  float radius = sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
  float longitude = acos(dir.x / sqrt(dir.x * dir.x + dir.y * dir.y)) * (dir.y < 0 ? -1 : 1);
  float latitude = acos(dir.z / radius) * (dir.z < 0 ? -1 : 1);
  // check NaN result
  if (Float.isNaN(longitude)) longitude = 0;
  if (Float.isNaN(latitude)) latitude = 0;
  if (Float.isNaN(radius)) radius = 0;
  rotateX(latitude);
  rotateY(longitude);
}

public void start_matrix_3D(vec pos, vec2 dir_polar) {
  if(pos instanceof vec2) {
    vec2 p = (vec2) pos;
    pushMatrix();
    translate(p);
    rotateXY(dir_polar);
  } else if(pos instanceof vec3) {
    vec3 p = (vec3) pos;
    pushMatrix();
    translate(p);
    rotateXY(dir_polar);
  } else {
    printErr("Error in void start_matrix_3D(), vec pos is not an instance of vec2 or vec3, the matrix cannot be init") ;
    // exit() ;
  }
}

public void start_matrix_2D(vec pos, float orientation) {
  if(pos instanceof vec2) {
    vec2 p = (vec2)pos;
    pushMatrix();
    translate(p);
    rotate(orientation);
  } else if(pos instanceof vec3) {
    vec3 p = (vec3)pos;
    pushMatrix();
    translate(p.x, p.y);
    rotate(orientation);
  } else {
    printErr("Error in void start_matrix_3D(), vec pos is not an instance of vec2 or vec3, the matrix cannot be init") ;
    // exit();
  }
}

// ivec
public void start_matrix_3D(ivec pos, ivec3 dir_cart) {
  vec3 temp_dir_cart = vec3(dir_cart.x, dir_cart.y, dir_cart.z);
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x, pos.y);
    start_matrix_3D(temp_pos, temp_dir_cart);
  } else if(pos instanceof ivec3) {
    vec3 temp_pos = vec3(pos.x, pos.y, pos.z);
    start_matrix_3D(temp_pos, temp_dir_cart);
  } 
}

public void start_matrix_3D(ivec pos, ivec2 dir_polar) {
  vec2 temp_dir_polar = vec2(dir_polar.x, dir_polar.y);
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x, pos.y);
    start_matrix_3D(temp_pos, temp_dir_polar);
  } else if(pos instanceof ivec3) {
    vec3 temp_pos = vec3(pos.x, pos.y, pos.z);
    start_matrix_3D(temp_pos, temp_dir_polar);
  }
}

public void start_matrix_2D(ivec pos, float orientation) {
  if(pos instanceof ivec2) {
    vec2 temp_pos = vec2(pos.x, pos.y);
    start_matrix_2D(temp_pos, orientation);
  } else if(pos instanceof ivec3) {
    vec3 temp_pos = vec3(pos.x, pos.y, pos.z);
    start_matrix_2D(temp_pos, orientation);
  }
}



// stop ans Start Matrix
public void start_matrix() {
  pushMatrix() ;
}


public void stop_matrix() {
  popMatrix() ;
}




/**
Matrix deprecated
*/
public @Deprecated
void matrix_3D_start(vec3 pos, vec3 dir_cart) {
  vec3 dir = dir_cart.copy() ;
  pushMatrix() ;
  translate(pos) ;
  float radius = sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
  float longitude = acos(dir.x / sqrt(dir.x * dir.x + dir.y * dir.y)) * (dir.y < 0 ? -1 : 1);
  float latitude = acos(dir.z / radius) * (dir.z < 0 ? -1 : 1);
  // check NaN result
  if (Float.isNaN(longitude)) longitude = 0 ;
  if (Float.isNaN(latitude)) latitude = 0 ;
  if (Float.isNaN(radius)) radius = 0 ;
  rotateX(latitude) ;
  rotateY(longitude) ;
  printErr("void matrix_3D_start() is deprecated instead use start_matrix_3D()") ;
}

public @Deprecated
void matrix_3D_start(vec3 pos, vec2 dir_polar) {
  pushMatrix() ;
  translate(pos) ;
  rotateXY(dir_polar) ;
  printErr("void matrix_3D_start() is deprecated instead use start_matrix_3D()") ;
}

public @Deprecated
void matrix_2D_start(vec2 pos, float orientation) {
  pushMatrix() ;
  translate(pos) ;
  rotate(orientation) ;
  printErr("void matrix_2D_start() is deprecated instead use start_matrix_2D()") ;
}

public @Deprecated
void matrix_end() {
  popMatrix() ;
  printErr("void matrix_end() is deprecated instead use stop_matrix()") ;
}

public @Deprecated
void matrix_start() {
  pushMatrix() ;
  printErr("void matrix_start() is deprecated instead use start_matrix()") ;
}





















































/**
GHOST METHODS for PROCESSING
2018-2018
v 0.2.2
*/
public boolean get_layer_is_correct() {
  if(get_layer() != null && get_layer().width > 0 && get_layer().height > 0) {
    return true;
  } else {
    return false;
  }
}

// colorMode
public void colorMode(int mode) {
  if(get_layer_is_correct()) {
    get_layer().colorMode(mode);
  } else {
    g.colorMode(mode);
  }
}

public void colorMode(int mode, float max) {
  if(get_layer_is_correct()) {
    get_layer().colorMode(mode,max);
  } else {
    g.colorMode(mode,max);
  } 
}


public void colorMode(int mode, float max1, float max2, float max3) {
  if(get_layer_is_correct()) {
    get_layer().colorMode(mode,max1,max2,max3);
  } else {
    g.colorMode(mode,max1,max2,max3);
  }
}
public void colorMode(int mode, float max1, float max2, float max3, float maxA) {
  if(get_layer_is_correct()) {
    get_layer().colorMode(mode,max1,max2,max3,maxA);
  } else {
    g.colorMode(mode,max1,max2,max3,maxA);
  }
}




// Processing ghost method

// position
public void translate(float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().translate(x,y);
  } else {
    g.translate(x,y);
  }
}

public void translate(float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().translate(x,y,z);
  } else {
    g.translate(x,y,z);
  }
}


// rotate
public void rotate(float arg) {
  if(get_layer_is_correct()) {
    get_layer().rotate(arg);
  } else {
    g.rotate(arg);
  }
}


public void rotateX(float arg) {
  if(get_layer_is_correct()) {
    get_layer().rotateX(arg);
  } else {
    g.rotateX(arg);
  }
}

public void rotateY(float arg) {
  if(get_layer_is_correct()) {
    get_layer().rotateY(arg);
  } else {
    g.rotateY(arg);
  }
}


public void rotateZ(float arg) {
  if(get_layer_is_correct()) {
    get_layer().rotateZ(arg);
  } else {
    g.rotateZ(arg);
  }
}

// scale
public void scale(float s) {
  if(get_layer_is_correct()) {
    get_layer().scale(s);
  } else {
    g.scale(s);
  }
}

public void scale(float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().scale(x,y);
  } else {
    g.scale(x,y);
  }
}

public void scale(float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().scale(x,y,z);
  } else {
    g.scale(x,y,z);
  }
}

// shear
public void shearX(float angle) {
  if(get_layer_is_correct()) {
    get_layer().shearX(angle);
  } else {
    g.shearX(angle);
  }
}

public void shearY(float angle) {
  if(get_layer_is_correct()) {
    get_layer().shearY(angle);
  } else {
    g.shearY(angle);
  }
}













/**
aspect
*/
// fill
public void noFill() {
  if(get_layer_is_correct()) {
    get_layer().noFill();
  } else {
    g.noFill();
  }
} 

public void fill(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().fill(rgb);
  } else {
    g.fill(rgb);
  }
}


public void fill(int rgb, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().fill(rgb,alpha);
  } else {
    g.fill(rgb,alpha);
  }
}

public void fill(float gray) {
  if(get_layer_is_correct()) {
    get_layer().fill(gray);
  } else {
    g.fill(gray);
  }
}


public void fill(float gray, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().fill(gray,alpha);
  } else {
    g.fill(gray,alpha);
  }
}

public void fill(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().fill(v1,v2,v3);
  } else {
    g.fill(v1,v2,v3);
  }
}

public void fill(float v1, float v2, float v3, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().fill(v1,v2,v3,alpha);
  } else {
    g.fill(v1,v2,v3,alpha);
  }
}

// stroke
public void noStroke() {
  if(get_layer_is_correct()) {
    get_layer().noStroke();
  } else {
    g.noStroke();
  }
} 

public void stroke(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().stroke(rgb);
  } else {
    g.stroke(rgb);
  }
}




public void stroke(int rgb, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().stroke(rgb,alpha);
  } else {
    g.stroke(rgb,alpha);
  }
}

public void stroke(float gray) {
  if(get_layer_is_correct()) {
    get_layer().stroke(gray);
  } else {
    g.stroke(gray);
  }
}


public void stroke(float gray, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().stroke(gray,alpha);
  } else {
    g.stroke(gray,alpha);
  }
}

public void stroke(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().stroke(v1,v2,v3);
  } else {
    g.stroke(v1,v2,v3);
  }
}

public void stroke(float v1, float v2, float v3, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().stroke(v1,v2,v3,alpha);
  } else {
    g.stroke(v1,v2,v3,alpha);
  }
}


// strokeWeight
public void strokeWeight(float thickness) {
  if(get_layer_is_correct()) {
    get_layer().strokeWeight(thickness);
  } else {
    g.strokeWeight(thickness);
  }
}

// strokeJoin
public void strokeJoin(int join) {
  if(get_layer_is_correct()) {
    get_layer().strokeJoin(join);
  } else {
    g.strokeJoin(join);
  }
}

// strokeJoin
public void strokeCapstrokeCap(int cap) {
  if(get_layer_is_correct()) {
    get_layer().strokeCap(cap);
  } else {
    g.strokeCap(cap);
  }
}












/**
shape
*/

public void rectMode(int mode) {
  if(get_layer_is_correct()) {
    get_layer().rectMode(mode);
  } else {
    g.rectMode(mode);
  }
}

public void ellipseMode(int mode) {
  if(get_layer_is_correct()) {
    get_layer().ellipseMode(mode);
  } else {
    g.ellipseMode(mode);
  }
}

// rect
public void rect(float px, float py, float sx, float sy) {
  if(get_layer_is_correct()) {
    get_layer().rect(px,py,sx,sy);
  } else {
    g.rect(px,py,sx,sy);
  }
}


public void rect(float  px, float py, float sx, float sy, float r) {
  if(get_layer_is_correct()) {
    get_layer().rect(px,py,sx,sy,r);
  } else {
    g.rect(px,py,sx,sy,r);
  }
}

public void rect(float px, float py, float sx, float sy, float tl, float tr, float br, float bl) {
  if(get_layer_is_correct()) {
    get_layer().rect(px,py,sx,sy,tl,tr,br,bl);
  } else {
    g.rect(px,py,sx,sy,tl,tr,br,bl);
  }
}


//arc
public void arc(float a, float b, float c, float d, float start, float stop) {
  if(get_layer_is_correct()) {
    get_layer().arc(a,b,c,d,start,stop);
  } else {
    g.arc(a,b,c,d,start,stop);
  }
}

public void arc(float a, float b, float c, float d, float start, float stop, int mode) {
  if(get_layer_is_correct()) {
    get_layer().arc(a,b,c,d,start,stop,mode);
  } else {
    g.arc(a,b,c,d,start,stop,mode);
  }
}

// ellipse
public void ellipse(int px, int py, int sx, int sy) {
  if(get_layer_is_correct()) {
    get_layer().ellipse(px,py,sx,sy);
  } else {
    g.ellipse(px,py,sx,sy);
  }
}




// box
public void box(float s) {
  if(get_layer_is_correct()) {
    get_layer().box(s,s,s);
  } else {
    g.box(s,s,s);
  }
}

public void box(float w, float h, float d) {
  if(get_layer_is_correct()) {
    get_layer().box(w,h,d);
  } else {
    g.box(w,h,d);
  }
}


// sphere
public void sphere(float r) {
  if(get_layer_is_correct()) {
    get_layer().sphere(r);
  } else {
    g.sphere(r);
    // p.sphere(r);
  }
}


// sphere detail
public void sphereDetail(int res) {
  if(get_layer_is_correct()) {
    get_layer().sphereDetail(res);
  } else {
    g.sphereDetail(res);
  }
}

public void sphereDetail(int ures, int vres) {
  if(get_layer_is_correct()) {
    get_layer().sphereDetail(ures,vres);
  } else {
    g.sphereDetail(ures,vres);
  }
}




//line
public void line(float x1, float y1, float x2, float y2) {
  if(get_layer_is_correct()) {
    get_layer().line(x1,y1,x2,y2);
  } else {
    g.line(x1,y1,x2,y2);
  }
}

public void line(float x1, float y1, float z1, float x2, float y2, float z2) {
  if(get_layer_is_correct()) {
    get_layer().line(x1,y1,z1,x2,y2,z2);
  } else {
    g.line(x1,y1,z1,x2,y2,z2);
  }
}






// point
public void point(float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().point(x,y);
  } else {
    g.point(x,y);
  }
}

public void point(float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().point(x,y,z);
  } else {
    g.point(x,y,z);
  }
}

// quad
public void quad(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) {
  if(get_layer_is_correct()) {
    get_layer().quad(x1,y1,x2,y2,x3,y3,x4,y4);
  } else {
    g.quad(x1,y1,x2,y2,x3,y3,x4,y4);
  }
}

// triangle
/*
method already use somewhere else
void triangle(float x1, float y1, float x2, float y2, float x3, float y3) {
  if(get_layer() != null) {
    get_layer().triangle(x1,y1,x2,y2,x3,y3);
  } else {
    g.triangle(x1,y1,x2,y2,x3,y3);
  }
}
*/


/**
vertex
*/
// begin
public void beginShape() {
  if(get_layer_is_correct()) {
    get_layer().beginShape();
  } else {
    g.beginShape();
  }
}

public void beginShape(int kind) {
  if(get_layer_is_correct()) {
    get_layer().beginShape(kind);
  } else {
    g.beginShape(kind);
  }
}


public void endShape() {
  if(get_layer_is_correct()) {
    get_layer().endShape();
  } else {
    g.endShape();
  }
}

public void endShape(int mode) {
  if(get_layer_is_correct()) {
    get_layer().endShape(mode);
  } else {
    g.endShape(mode);
  }
}

// shape
public void shape(PShape shape) {
  if(get_layer_is_correct()) {
    get_layer().shape(shape);
  } else {
    g.shape(shape);
  }
}

public void shape(PShape shape, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().shape(shape,x,y);
  } else {
    g.shape(shape,x,y);
  }
}

public void shape(PShape shape, float a, float b, float c, float d) {
  if(get_layer_is_correct()) {
    get_layer().shape(shape,a,b,c,d);
  } else {
    g.shape(shape,a,b,c,d);
  }
}




//vertex
public void vertex(float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().vertex(x,y);
  } else {
    g.vertex(x,y);
  }
}

public void vertex(float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().vertex(x,y,z);
  } else {
    g.vertex(x,y,z);
  }
}

public void vertex(float [] v) {
  if(get_layer_is_correct()) {
    get_layer().vertex(v);
  } else {
    g.vertex(v);
  }
}

public void vertex(float x, float y, float u, float v) {
  if(get_layer_is_correct()) {
    get_layer().vertex(x,y,u,v);
  } else {
    g.vertex(x,y,u,v);
  }
} 


public void vertex(float x, float y, float z, float u, float v) {
  if(get_layer_is_correct()) {
    get_layer().vertex(x,y,z,u,v);
  } else {
    g.vertex(x,y,z,u,v);
  }
}  


// quadratic vertex
public void quadraticVertex(float cx, float cy, float x3, float y3) {
  if(get_layer_is_correct()) {
    get_layer().quadraticVertex(cx,cy,x3,y3);
  } else {
    g.quadraticVertex(cx,cy,x3,y3);
  }
}

public void quadraticVertex(float cx, float cy, float cz, float x3, float y3, float z3) {
  if(get_layer_is_correct()) {
    get_layer().quadraticVertex(cx,cy,cz,x3,y3,z3);
  } else {
    g.quadraticVertex(cx,cy,cz,x3,y3,z3);
  }
}

// curve vertex
public void curveVertex(float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().curveVertex(x,y);
  } else {
    g.curveVertex(x,y);
  }
}

public void curveVertex(float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().curveVertex(x,y,z);
  } else {
    g.curveVertex(x,y,z);
  }
}


//bezier vertex
public void bezierVertex(float x2, float y2, float x3, float y3, float x4, float y4) {
  if(get_layer_is_correct()) {
    get_layer().bezierVertex(x2,y2,x3,y3,x4,y4);
  } else {
    g.bezierVertex(x2,y2,x3,y3,x4,y4);
  }
}


public void bezierVertex(float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {
  if(get_layer_is_correct()) {
    get_layer().bezierVertex(x2,y2,z2,x3,y3,z3,x4,y4,z4);
  } else {
    g.bezierVertex(x2,y2,z2,x3,y3,z3,x4,y4,z4);
  }
}

// bezier
public void bezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) {
  if(get_layer_is_correct()) {
    get_layer().bezier(x1,y1,x2,y2,x3,y3,x4,y4);
  } else {
    g.bezier(x1,y1,x2,y2,x3,y3,x4,y4);
  }
}

public void bezier(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {
  if(get_layer_is_correct()) {
    get_layer().bezier(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);
  } else {
    g.bezier(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);
  }
}

// bezier detail
public void bezierDetail(int detail) {
  if(get_layer_is_correct()) {
    get_layer().bezierDetail(detail);
  } else {
    g.bezierDetail(detail);
  }
}

// curve
public void curve(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) {
  if(get_layer_is_correct()) {
    get_layer().curve(x1,y1,x2,y2,x3,y3,x4,y4);
  } else {
    g.curve(x1,y1,x2,y2,x3,y3,x4,y4);
  }
}


public void curve(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4) {
  if(get_layer_is_correct()) {
    get_layer().curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);
  } else {
    g.curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);
  }
}

// curve detail
public void curveDetail(int detail) {
  if(get_layer_is_correct()) {
    get_layer().curveDetail(detail);
  } else {
    g.curveDetail(detail);
  }
}




















// light
public void lights() {
  if(get_layer_is_correct()) {
    get_layer().lights();
  } else {
    g.lights();
  }
}

public void noLights() {
  if(get_layer_is_correct()) {
    get_layer().noLights();
  } else {
    g.noLights();
  }
}

// ambient light
public void ambientLight(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().ambientLight(v1,v2,v3);
  } else {
    g.ambientLight(v1,v2,v3);
  }
}


public void ambientLight(float v1, float v2, float v3, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().ambientLight(v1,v2,v3,x,y,z);
  } else {
    g.ambientLight(v1,v2,v3,x,y,z);
  }
}


//directionalLight(v1, v2, v3, nx, ny, nz)
public void directionalLight(float v1, float v2, float v3, float nx, float ny, float nz) {
  if(get_layer_is_correct()) {
    get_layer().directionalLight(v1,v2,v3,nx,ny,nz);
  } else {
    g.directionalLight(v1,v2,v3,nx,ny,nz);
  }
}



// lightFalloff(constant, linear, quadratic)
public void lightFalloff(float constant, float linear, float quadratic) {
  if(get_layer_is_correct()) {
    get_layer().lightFalloff(constant,linear,quadratic);
  } else {
    g.lightFalloff(constant,linear,quadratic);
  }
}


// lightSpecular(v1, v2, v3) 

public void lightSpecular(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().lightSpecular(v1,v2,v3);
  } else {
    g.lightSpecular(v1,v2,v3);
  }
}

// normal(nx, ny, nz)
public void normal(float nx, float ny, float nz) {
  if(get_layer_is_correct()) {
    get_layer().normal(nx,ny,nz);
  } else {
    g.normal(nx,ny,nz);
  }
}


// pointLight(v1, v2, v3, x, y, z)
public void pointLight(float v1, float v2, float v3, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().pointLight(v1,v2,v3,x,y,z);
  } else {
    g.pointLight(v1,v2,v3,x,y,z);
  }
}

// spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration)
public void spotLight(float v1, float v2, float v3, float x, float y, float z, float nx, float ny, float nz, float angle, float concentration) {
  if(get_layer_is_correct()) {
    get_layer().spotLight(v1,v2,v3,x,y,z,nx,ny,nz,angle,concentration);
  } else {
    g.spotLight(v1,v2,v3,x,y,z,nx,ny,nz,angle,concentration);
  }
}


/**
Material properties
*/
public void ambient(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().ambient(rgb);
  } else {
    g.ambient(rgb);
  }
}

public void ambient(float gray) {
  if(get_layer_is_correct()) {
    get_layer().ambient(gray);
  } else {
    g.ambient(gray);
  }
}


public void ambient(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().ambient(v1,v2,v3);
  } else {
    g.ambient(v1,v2,v3);
  }
}


// emissive
public void emissive(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().emissive(rgb);
  } else {
    g.emissive(rgb);
  }
}

public void emissive(float gray) {
  if(get_layer_is_correct()) {
    get_layer().emissive(gray);
  } else {
    g.emissive(gray);
  }
}


public void emissive(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().emissive(v1,v2,v3);
  } else {
    g.emissive(v1,v2,v3);
  }
}


// specular
public void specular(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().specular(rgb);
  } else {
    g.specular(rgb);
  }
}

public void specular(float gray) {
  if(get_layer_is_correct()) {
    get_layer().specular(gray);
  } else {
    g.specular(gray);
  }
}


public void specular(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().specular(v1,v2,v3);
  } else {
    g.specular(v1,v2,v3);
  }
}


// shininess(shine)
public void shininess(float shine) {
  if(get_layer_is_correct()) {
    get_layer().shininess(shine);
  } else {
    g.shininess(shine);
  }
}























/**
camera ghost
*/
// camera
public void camera() {
  if(get_layer_is_correct()) {
    get_layer().camera();
  } else {
    g.camera();
  }
}

public void camera(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {
  if(get_layer_is_correct()) {
    get_layer().camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);
  } else {
    g.camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);
  }
}


public void beginCamera() {
  if(get_layer_is_correct()) {
    get_layer().beginCamera();
  } else {
    g.beginCamera();
  }
}

public void endCamera() {
  if(get_layer_is_correct()) {
    get_layer().endCamera();
  } else {
    g.endCamera();
  }
}


// frustum(left, right, bottom, top, near, far)
public void frustum(float left, float right, float bottom, float top, float near, float far) {
  if(get_layer_is_correct()) {
    get_layer().frustum(left,right,bottom,top,near,far);
  } else {
    g.frustum(left,right,bottom,top,near,far);
  }
}


// ortho
public void ortho() {
  if(get_layer_is_correct()) {
    get_layer().ortho();
  } else {
    g.ortho();
  }
}

public void ortho(float left, float right, float bottom, float top) {
  if(get_layer_is_correct()) {
    get_layer().ortho(left,right,bottom,top);
  } else {
    g.ortho(left,right,bottom,top);
  }
}


public void ortho(float left, float right, float bottom, float top, float near, float far) {
  if(get_layer_is_correct()) {
    get_layer().ortho(left,right,bottom,top,near,far);
  } else {
    g.ortho(left,right,bottom,top,near,far);
  }
}


  
// perspective
public void perspective() {
  if(get_layer_is_correct()) {
    get_layer().perspective();
  } else {
    g.perspective();
  }
}


public void perspective(float fovy, float aspect, float zNear, float zFar) {
  if(get_layer_is_correct()) {
    get_layer().perspective(fovy,aspect,zNear,zFar);
  } else {
    g.perspective(fovy,aspect,zNear,zFar);
  }
}


















/**
matrix
*/
public void pushMatrix() {
  if(get_layer_is_correct()) {
    get_layer().pushMatrix();
  } else {
    g.pushMatrix();
  }
}


public void popMatrix() {
  if(get_layer_is_correct()) {
    get_layer().popMatrix();
  } else {
    g.popMatrix();
  }
}


// apply matrix
public void applyMatrix(PMatrix source) {
  if(get_layer_is_correct()) {
    get_layer().applyMatrix(source);
  } else {
    g.applyMatrix(source);
  }
}

public void applyMatrix(float n00, float n01, float n02, float n10, float n11, float n12) {
  if(get_layer_is_correct()) {
    get_layer().applyMatrix(n00,n01,n02,n10,n11,n12);
  } else {
    g.applyMatrix(n00,n01,n02,n10,n11,n12);
  }
}

public void applyMatrix(float n00, float n01, float n02, float n03, float n10, float n11, float n12, float n13, float n20, float n21, float n22, float n23, float n30, float n31, float n32, float n33) {
  if(get_layer_is_correct()) {
    get_layer().applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);
  } else {
    g.applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);
  }
}



public void resetMatrix() {
  if(get_layer_is_correct()) {
    get_layer().resetMatrix();
  } else {
    g.resetMatrix();
  }
}


  












/**
image
*/
public void image(PImage img, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().image(img,x,y);
  } else {
    g.image(img,x,y);
  }
}

public void image(PImage img, float a, float b, float c, float d) {
  if(get_layer_is_correct()) {
    get_layer().image(img,a,b,c,d);
  } else {
    g.image(img,a,b,c,d);
  }
}














/**
get
*/
public int get(int x, int y) {
  if(get_layer_is_correct()) {
    return get_layer().get(x,y);
  } else {
    return g.get(x,y);
  }
} 


public PImage get(int x, int y, int w, int h) {
  if(get_layer_is_correct()) {
    return get_layer().get(x,y,w,h);
  } else {
    return g.get(x,y,w,h);
  }
}


public PImage get() {
  if(get_layer_is_correct()) {
    return get_layer().get();
  } else {
    return g.get();
  }
}









/**
loadPixels()
*/
public void loadPixels() {
  if(get_layer_is_correct()) {
    get_layer().loadPixels();
  } else {
    g.loadPixels();
  }
}


/**
updatePixels()
*/
public void updatePixels() {
  if(get_layer_is_correct()) {
    get_layer().updatePixels();
  } else {
    g.updatePixels();
  }
}








/**
tint
*/
public void tint(int rgb) {
  if(get_layer_is_correct()) {
    get_layer().tint(rgb);
  } else {
    g.tint(rgb);
  }
}

public void tint(int rgb, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().tint(rgb,alpha);
  } else {
    g.tint(rgb,alpha);
  }
}

public void tint(float gray) {
  if(get_layer_is_correct()) {
    get_layer().tint(gray);
  } else {
    g.tint(gray);
  }
}

public void tint(float gray, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().tint(gray,alpha);
  } else {
    g.tint(gray,alpha);
  }
}

public void tint(float v1, float v2, float v3) {
  if(get_layer_is_correct()) {
    get_layer().tint(v1,v2,v3);
  } else {
    g.tint(v1,v2,v3);
  }
}

public void tint(ivec4 v) {
  tint(v.x,v.y,v.z,v.w);
}

public void tint(ivec3 v) {
  tint(v.x,v.y,v.z,g.colorModeA);
}

public void tint(ivec2 v) {
  tint(v.x,v.x,v.x,v.y);
}

public void tint(vec4 v) {
  tint(v.x,v.y,v.z,v.w);
}

public void tint(vec3 v) {
  tint(v.x,v.y,v.z,g.colorModeA);
}

public void tint(vec2 v) {
  tint(v.x,v.x,v.x,v.y);
}

public void tint(float v1, float v2, float v3, float alpha) {
  if(get_layer_is_correct()) {
    get_layer().tint(v1,v2,v3,alpha);
  } else {
    g.tint(v1,v2,v3,alpha);
  }
}















/**
blend
*/
public void blend(int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, int mode) {
  if(get_layer_is_correct()) {
    get_layer().blend(sx,sy,sw,sh,dx,dy,dw,dh,mode);
  } else {
    g.blend(sx,sy,sw,sh,dx,dy,dw,dh,mode);
  }
}


public void blend(PImage src, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, int mode) {
  if(get_layer_is_correct()) {
    get_layer().blend(src,sx,sy,sw,sh,dx,dy,dw,dh,mode);
  } else {
    g.blend(src,sx,sy,sw,sh,dx,dy,dw,dh,mode);
  }
}













/**
filter
v 0.0.2
*/
public void filter(PShader shader) {
  if(get_layer_is_correct()) {
    get_layer().filter(shader);
  } else if (g.pixels != null) {
    g.filter(shader);
  }
}

public void filter(int kind) {
  if(get_layer_is_correct()) {
    get_layer().filter(kind);
  } else if (g.pixels != null) {
    g.filter(kind);
  }
}

public void filter(int kind, float param) {
  if(get_layer_is_correct()) {
    get_layer().filter(kind,param);
  } else if (g.pixels != null) {
    g.filter(kind,param);
  }
}













/**
set
*/
public void set(int x, int y, int c) {
  if(get_layer_is_correct()) {
    get_layer().set(x,y,c);
  } else {
    /*
    x *= displayDensity();
    y *= displayDensity();
    */
    g.set(x,y,c);
  }
}

public void set(int x, int y, PImage img) {
  if(get_layer_is_correct()) {
    get_layer().set(x,y,img);
  } else {
    /*
    x *= displayDensity();
    y *= displayDensity();
    */
    g.set(x,y,img);
  }
}














/**
text
2017-2019
v 0.1.2
*/
public void text(char c, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().text(c,x,y);
  } else {
    g.text(c,x,y);
  }
}


public void text(char c, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().text(c,x,y,z);
  } else {
    g.text(c,x,y,z);
  }
}

public void text(char [] chars, int start, int stop, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().text(chars,start,stop,x,y);
  } else {
    g.text(chars,start,stop,x,y);
  }
}


public void text(char [] chars, int start, int stop, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().text(chars,start,stop,x,y,z);
  } else {
    g.text(chars,start,stop,x,y,z);
  }
}



public void text(String str, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().text(str,x,y);
  } else {
    g.text(str,x,y);
  }
}


public void text(String str, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().text(str,x,y,z);
  } else {
    g.text(str,x,y,z);
  }
}


public void text(String str, float x1, float y1, float x2, float y2) {
  if(get_layer_is_correct()) {
    get_layer().text(str,x1,y1,x2,y2);
  } else {
    g.text(str,x1,y1,x2,y2);
  }
}

public void text(float num, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().text(num,x,y);
  } else {
    g.text(num,x,y);
  }
}


public void text(float num, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().text(num,x,y,z);
  } else {
    g.text(num,x,y,z);
  }
}


public void text(int num, float x, float y) {
  if(get_layer_is_correct()) {
    get_layer().text(num,x,y);
  } else {
    g.text(num,x,y);
  }
}


public void text(int num, float x, float y, float z) {
  if(get_layer_is_correct()) {
    get_layer().text(num,x,y,z);
  } else {
    g.text(num,x,y,z);
  }
}


// text Align
public void textAlign(int alignX) {
  if(get_layer_is_correct()) {
    get_layer().textAlign(alignX);
  } else {
    g.textAlign(alignX);
  }
}


public void textAlign(int alignX, int alignY) {
  if(get_layer_is_correct()) {
    get_layer().textAlign(alignX,alignY);
  } else {
    g.textAlign(alignX,alignY);
  }
}

// textLeading(leading)
public void textLeading(float leading) {
if(get_layer_is_correct()) {
    get_layer().textLeading(leading);
  } else {
    g.textLeading(leading);
  }
}


// textMode(mode)
public void textMode(int mode) {
  if(get_layer_is_correct()) {
    get_layer().textMode(mode);
  } else {
    g.textMode(mode);
  }
}

// text Size
public void textSize(float size) {
  if(get_layer_is_correct()) {
    get_layer().textSize(size);
  } else {
    g.textSize(size);
  }
}


// textFont
public void textFont(PFont font) {
  if(font != null) {
    if(get_layer_is_correct()) {
      get_layer().textFont(font);
    } else {
      g.textFont(font);
    }
  }
}

public void textFont(PFont font, float size) {
  if(get_layer_is_correct()) {
    if(get_layer() != null) {
      get_layer().textFont(font,size);
    } else {
      g.textFont(font,size);
    }
  }
}






  




/**
ROPE SCIENCE
v 0.7.3
* Copyleft (c) 2014-2019 
* Stan le Punk > http://stanlepunk.xyz/
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*
the sketch method tab is not included on this repository if you need
* @see https://github.com/StanLepunK/Old_code/tree/master/Science_rope_2017_12_8
* Processing 3.5.3
*/

/**
Gaussian randomize
v 0.0.2
*/
public @Deprecated
float random_gaussian(float value) {
  return random_gaussian(value, .4f) ;
}

public @Deprecated
float random_gaussian(float value, float range) {
  /*
  * It's cannot possible to indicate a value result here, this part need from the coder ?
  */
  printErrTempo(240,"float random_gaussian(); method must be improved or totaly deprecated");
  range = abs(range) ;
  float distrib = random(-1, 1) ;
  float result = 0 ;
  if(value == 0) {
    value = 1 ;
    result = (pow(distrib,5)) *(value *range) +value ;
    result-- ;
  } else {
    result = (pow(distrib,5)) *(value *range) +value ;
  }
  return result;
}



/**
Next Gaussian randomize
v 0.0.2
*/
/**
* return value from -1 to 1
* @return float
*/
Random random = new Random();
public float random_next_gaussian() {
  return random_next_gaussian(1,1);
}

public float random_next_gaussian(int n) {
  return random_next_gaussian(1,n);
}

public float random_next_gaussian(float range) {
  return random_next_gaussian(range,1);
}

public float random_next_gaussian(float range, int n) {
  float roots = (float)random.nextGaussian();
  float var = map(roots,-2.5f,2.5f,-1,1);  
  if(n > 1) {
    if(n%2 ==0 && var < 0) {
       var = -1 *pow(var,n);
     } else {
       var = pow(var,n);
     }
     return var *range ;
  } else {
    return var *range ;
  }
}


















/**
Physic Rope
v 0.0.2
*/
public double g_force(double dist, double m_1, double m_2) {
  return R_Constants.G *(dist*dist)/(m_1 *m_2);
}



/**
Math rope 
v 1.8.17
* @author Stan le Punk
* @see https://github.com/StanLepunK/Math_rope
*/
/**
Algebra utils
*/
//roots dimensions n
public float roots(float valueToRoots, int n) {
  return pow(valueToRoots, 1.0f/n) ;
}

// Decimal
// @return a specific quantity of decimal after comma
public float decimale(float var, int n) {
  float div = pow(10, abs(n)) ;
  return Math.round(var *div) / div;
}


/**
geometry util
v. 0.0.7
*/
public float perimeter_disc(int r) {
  return 2 *r *PI ;
}

public float radius_from_circle_surface(int surface) {
  return sqrt(surface/PI) ;
}


public boolean inside(ivec pos, ivec size, ivec2 target_pos) {
  return inside(vec2(pos.x,pos.y), vec2(size.x,size.y), vec2(target_pos), ELLIPSE);
}

public boolean inside(ivec pos, ivec size, ivec2 target_pos, int type) {
  return inside(vec2(pos.x,pos.y), vec2(size.x,size.y), vec2(target_pos), type);
}

public boolean inside(vec pos, vec size, vec2 target_pos) {
  return inside(pos, size, target_pos, ELLIPSE);
}

public boolean inside(vec pos, vec size, vec2 target_pos, int type) {
  if(type == ELLIPSE) {
    // this part can be improve to check the 'x' and the 'y'
    if (dist(vec2(pos.x,pos.y), target_pos) < size.x *.5f) return true ; 
    else return false ;
  } else {
    if(target_pos.x > pos.x && target_pos.x < pos.x +size.x && 
       target_pos.y > pos.y && target_pos.y < pos.y +size.y) return true ; 
      else return false ;
  } 
}






/**
GEOMETRY POLAR and CARTESIAN
*/
/**
Info
http://mathinsight.org/vectors_cartesian_coordinates_2d_3d
http://zone.ni.com/reference/en-XX/help/371361H-01/gmath/3d_cartesian_coordinate_rotation_euler/
http://www.mathsisfun.com/polar-cartesian-coordinates.html
https://en.wikipedia.org/wiki/Spherical_coordinate_system
http://stackoverflow.com/questions/20769011/converting-3d-polar-coordinates-to-cartesian-coordinates
http://www.vias.org/comp_geometry/math_coord_convert_3d.htm
http://mathworld.wolfram.com/Sphere.html
*/
/*
@return float
*/
public float longitude(float x, float range) {
  return map(x, 0,range, 0, TAU) ;
}

public float latitude(float y, float range) {
  return map(y, 0,range, 0, TAU) ;
}

/**
angle
v 0.0.2
* @return float
*/
public float angle_radians(float y, float range) {
  return map(y, 0,range, 0, TAU) ;
}

public float angle_degrees(float y, float range) {
  return map(y, 0,range, 0, 360) ;
}

public float angle(vec2 a, vec2 b) {
  return atan2(b.y -a.y, b.x -a.x);
}

public float angle(vec2 v) {
  return atan2(v.y, v.x);
}



  

/* 
return a vector info : radius,longitude, latitude
@return vec3
*/
public vec3 to_polar(vec3 cart) {
  float radius = sqrt(cart.x * cart.x + cart.y * cart.y + cart.z * cart.z);
  float phi = acos(cart.x / sqrt(cart.x * cart.x + cart.y * cart.y)) * (cart.y < 0 ? -1 : 1);
  float theta = acos(cart.z / radius) * (cart.z < 0 ? -1 : 1);
  // check NaN result
  if (Float.isNaN(phi)) phi = 0 ;
  if (Float.isNaN(theta)) theta = 0 ;
  if (Float.isNaN(radius)) radius = 0 ;
  // result
  //return new vec3(radius, longitude, latitude) ;
  return new vec3(phi, theta, radius) ;
}







// Cartesian 3D
/*
@ return vec3
return the position of point on Sphere, with longitude and latitude
*/
//If you want just the final pos
public vec3 to_cartesian_3D(vec2 pos, vec2 range, float sizeField)  {
  // vertical plan position
  float verticalY = to_cartesian_2D(pos.y, vec2(0,range.y), vec2(0,TAU), sizeField).x ;
  float verticalZ = to_cartesian_2D(pos.y, vec2(0,range.y), vec2(0,TAU), sizeField).y ; 
  vec3 posVertical = new vec3(0, verticalY, verticalZ) ;
  // horizontal plan position
  float horizontalX = to_cartesian_2D(pos.x, vec2(0,range.x), vec2(0,TAU), sizeField).x ; 
  float horizontalZ = to_cartesian_2D(pos.x, vec2(0,range.x), vec2(0,TAU), sizeField).y  ;
  vec3 posHorizontal = new vec3(horizontalX, 0, horizontalZ) ;
  
  return projection(middle(posVertical, posHorizontal), sizeField) ;
}

public vec3 to_cartesian_3D(float latitude, float longitude) {
  float radius_normal = 1 ;
  return to_cartesian_3D(latitude, longitude, radius_normal);
}

// main method
public vec3 to_cartesian_3D(float latitude, float longitude,  float radius) {
  // https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations
  

  /*
  //  Must be improve is not really good in the border versus direct polar rotation with the matrix
  */ 
  float theta = longitude%TAU ;
  float phi = latitude%PI ;

  float x = radius *sin(theta) *cos(phi);
  float y = radius *sin(theta) *sin(phi);
  float z = radius *cos(theta);
  return new vec3(x, y, z);
}
/*
vec3 to_cartesian_3D(float longitude, float latitude, float radius) {
  // https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations
  float x = radius *sin(latitude) *cos(longitude);
  float y = radius *sin(latitude) *sin(longitude);
  float z = radius *cos(latitude);
  return new vec3(x, y, z);
}
*/







// To cartesian 2D
public vec2 to_cartesian_2D (float pos, vec2 range, vec2 target_rad, float distance) {
  float rotation_plan = map(pos, range.x, range.y, target_rad.x, target_rad.y)  ;
  return to_cartesian_2D (rotation_plan, distance) ;
}


public vec2 to_cartesian_2D (float angle, float radius) {
  return to_cartesian_2D(angle).mult(radius);
}


// main method
public vec2 to_cartesian_2D (float angle) {
  float x = cos(angle);
  float y = sin(angle);
  return vec2(x,y) ;
}







/**
Projection
*/
// Cartesian projection 2D
public vec2 projection(vec2 direction) {
  return projection(direction, vec2(), 1.f) ;
}

public vec2 projection(vec2 direction, float radius) {
  return projection(direction, vec2(), radius) ;
}
public vec2 projection(vec2 direction, vec2 origin, float radius) {
  // vec3 p = point_to_project.normalize(origin) ;
  vec2 ref = direction.copy() ;
  vec2 p = ref.dir(origin) ;
  p.mult(radius) ;
  p.add(origin) ;
  return p ;
}
// polar projection 2D
public vec2 projection(float angle) {
  return projection(angle, 1) ;
}
public vec2 projection(float angle, float radius) {
  return vec2(cos(angle) *radius, sin(angle) *radius) ;
}
// cartesian projection 3D
public vec3 projection(vec3 direction) {
  return projection(direction, vec3(), 1.f) ;
}

public vec3 projection(vec3 direction, float radius) {
  return projection(direction, vec3(), radius) ;
}

public vec3 projection(vec3 direction, vec3 origin, float radius) {
  vec3 ref = direction.copy() ;
  vec3 p = ref.dir(origin) ;
  p.mult(radius) ;
  p.add(origin) ;
  return p ;
}


/**
look at 
before target direction
v 0.0.2
*/
// Target direction return the normal direction of the target from the origin
public @Deprecated
vec2 target_direction(vec2 target, vec2 my_position) {
  printErrTempo(240, "vec2 target_direction() deprecated instead use look_at(vec target, vec origin) method, becareful the result is mult by -1");
  return projection(target, my_position, 1).sub(my_position);
}

public @Deprecated
vec3 target_direction(vec3 target, vec3 my_position) {
   printErrTempo(240, "vec2 target_direction() deprecated instead use look_at(vec target, vec origin) method, becareful the result is mult by -1");
  return projection(target, my_position, 1).sub(my_position) ;
}


public vec2 look_at(vec2 target, vec2 origin) {
  return projection(target, origin, 1).sub(origin).mult(-1,1);
}

public vec3 look_at(vec3 target, vec3 origin) {
  return projection(target, origin, 1).sub(origin);
}





/**
SPHERE PROJECTION
*/
/**
FIBONACCI SPHERE PROJECTION CARTESIAN
*/
public vec3 [] list_cartesian_fibonacci_sphere (int num, float step, float root) {
  float root_sphere = root *num ;
  vec3 [] list_points = new vec3[num] ;
  for (int i = 0; i < list_points.length ; i++) list_points[i] = distribution_cartesian_fibonacci_sphere(i, num, step, root_sphere) ;
  return list_points ;
}
/*
float root_cartesian_fibonnaci(int num) {
  return random(1) *num ;
}
*/

public vec3 distribution_cartesian_fibonacci_sphere(int n, int num, float step, float root) {
  if(n<num) {
    float offset = 2.f / num ;
    float y  = (n *offset) -1 + (offset / 2.f) ;
    float r = sqrt(1 - pow(y,2)) ;
    float phi = ((n +root)%num) * step ;
    
    float x = cos(phi) *r ;
    float z = sin(phi) *r ;
    
    return vec3(x,y,z) ;
  } else return vec3() ;
}

/**
POLAR PROJECTION FIBONACCI SPHERE
*/
public vec2 [] list_polar_fibonacci_sphere(int num, float step) {
  vec2 [] list_points = new vec2[num] ;
  for (int i = 0; i < list_points.length ; i++) list_points[i] = distribution_polar_fibonacci_sphere(i, num, step) ;
  return list_points ;
}
public vec2 distribution_polar_fibonacci_sphere(int n, int num, float step) {
  if(n<num) {
    float longitude = r.PHI *TAU *n;
    longitude /= step ;
    // like a normalization of the result ?
    longitude -= floor(longitude); 
    longitude *= TAU;
    if (longitude > PI)  longitude -= TAU;
    // Convert dome height (which is proportional to surface area) to latitude
    float latitude = asin(-1 + 2*n/(float)num);
    return vec2(longitude, latitude) ;
  } else return vec2() ;

}




// normal direction 0-360 to -1, 1 PVector
public PVector normal_direction(int direction) {
  int numPoints = 360;
  float angle = TWO_PI/(float)numPoints;
  direction = 360-direction;
  direction += 180;
  return new PVector(sin(angle*direction), cos(angle*direction));
}

// degre direction from PVector direction
public float deg360 (PVector dir) {
  float deg360 ;
  deg360 = 360 -(degrees(atan2(dir.x, dir.y)) +180)   ;
  return deg360 ;
}

public float deg360 (vec2 dir) {
  float deg360 ;
  deg360 = 360 -(degrees(atan2(dir.x, dir.y)) +180)   ;
  return deg360 ;
}

/**
ROTATION
*/
//Rotation Objet
public void rotation (float angle, float posX, float posY) {
  translate(posX, posY ) ;
  rotate (radians(angle) ) ;
}
public void rotation (float angle, vec2 pos) {
  translate(pos.x, pos.y) ;
  rotate (radians(angle) ) ;
}

public vec2 rotation (vec2 ref, vec2 lattice, float angle) {
  float a = angle(lattice, ref) + angle;
  float d = lattice.dist(ref);
  float x = lattice.x + cos( a ) * d;
  float y = lattice.y + sin( a ) * d;
  return vec2(x,y);
}

/**
May be must push to deprecated
*/
public vec2 rotation_lattice(vec2 ref, vec2 lattice, float angle) {
  float a = angle( lattice, ref ) + angle;
  float d = dist( lattice, ref );
  float x = lattice.x + cos( a ) * d;
  float y = lattice.y + sin( a ) * d;
  return vec2(x,y);
}









/**
PRIMITIVE 2D
*/
/**
DISC
*/
public void disc(PVector pos, int diam, int c ) {
  for ( int i = 1 ; i < diam +1 ; i++) {
    circle(c, pos, i) ;
  }
}

public void chromatic_disc( PVector pos, int diam ) {
  for ( int i = 1 ; i < diam +1 ; i++) {
    chromatic_circle(pos, i) ;
  }
}

/**
CIRCLE
*/
public void chromatic_circle(PVector pos, int d) {
  int surface = d*d ; // surface is equale of square surface where is the cirlcke...make sens ?

  int radius = ceil(radius_from_circle_surface(surface)) ;
  int numPoints = ceil(perimeter_disc( radius)) ;
  for(int i=0; i < numPoints; i++) {
      //circle
      float stepAngle = map(i, 0, numPoints, 0, 2*PI) ; 
      float angle =  2*PI - stepAngle;
      //color
      int c = color (i, 100,100) ;
      //display
      set(PApplet.parseInt(projection(angle, radius).x + pos.x) , PApplet.parseInt(projection(angle, radius).y + pos.y), c);
  }
}


//full cirlce
public void circle(int c, PVector pos, int d) {
  int surface = d*d ; // surface is equale of square surface where is the cirlcke...make sens ?

  int radius = ceil(radius_from_circle_surface(surface)) ;
  int numPoints = ceil(perimeter_disc(radius)) ;
  for(int i=0; i < numPoints; i++) {
      float stepAngle = map(i, 0, numPoints, 0, 2*PI) ; 
      float angle =  2*PI - stepAngle;
      set(PApplet.parseInt(projection(angle, radius).x + pos.x) , PApplet.parseInt(projection(angle, radius).y + pos.y), c);
  }
}

//circle with a specific quantity points
public void circle(int c, PVector pos, int d, int num) {
  int surface = d*d ; // surface is equale of square surface where is the cirlcke...make sens ?

  int radius = ceil(radius_from_circle_surface(surface)) ;
  for(int i=0; i < num; i++) {
      float stepAngle = map(i, 0, num, 0, 2*PI) ; 
      float angle =  2*PI - stepAngle;
      set(PApplet.parseInt(projection(angle, radius).x + pos.x) , PApplet.parseInt(projection(angle, radius).y + pos.y), c);
  }
}
//circle with a specific quantity points and specific shape for each point
public void circle(PVector pos, int d, int num, PVector size, String shape) {
  int surface = d*d ; // surface is equale of square surface where is the cirlcke...make sens ?
  int whichShape = 0 ;
  if (shape.equals("point") )  whichShape = 0;
  else if (shape.equals("ellipse") )  whichShape = 1 ;
  else if (shape.equals("rect") )  whichShape = 2 ;
  else if (shape.equals("box") )  whichShape = 3 ;
  else if (shape.equals("sphere") )  whichShape = 4 ;
  else whichShape = 0 ;

  int radius = ceil(radius_from_circle_surface(surface)) ;
  for(int i=0; i < num; i++) {
    float stepAngle = map(i, 0, num, 0, 2*PI) ; 
    float angle =  2*PI - stepAngle;
    PVector newPos = new PVector(projection(angle, radius).x + pos.x, projection(angle, radius).y + pos.y) ;
    if(whichShape == 0 ) point(newPos.x, newPos.y) ;
    if(whichShape == 1 ) ellipse(newPos.x, newPos.y, size.x, size.y) ;
    if(whichShape == 2 ) rect(newPos.x, newPos.y, size.x, size.y) ;
    if(whichShape == 3 ) {
      pushMatrix() ;
      translate(newPos.x, newPos.y,0) ;
      box(size.x, size.y, size.z) ;
      popMatrix() ;
    }
    if(whichShape == 4 ) {
      pushMatrix() ;
      translate(newPos.x, newPos.y,0) ;
      int detail = (int)size.x /4 ;
      if (detail > 10 ) detail = 10 ;
      sphereDetail(detail) ;
      sphere(size.x) ;
      popMatrix() ;
    }
  }
}
// summits around the circle
public PVector [] circle (PVector pos, int d, int num) {
  PVector [] p = new PVector [num] ;
  int surface = d*d ; 
  int radius = ceil(radius_from_circle_surface(surface)) ;
  
  // choice your starting point
  float startingAnglePos = PI*.5f;
  if(num == 4) startingAnglePos = PI*.25f;
  
  for( int i=0 ; i < num ; i++) {
    float stepAngle = map(i, 0, num, 0, TAU) ; 
    float angle =  TAU - stepAngle -startingAnglePos;
    p[i] = new PVector(projection(angle, radius).x +pos.x,projection(angle, radius).y + pos.y) ;
  }
  return p ;
}

public PVector [] circle (PVector pos, int d, int num, float jitter) {
  PVector [] p = new PVector [num] ;
  int surface = d*d ; 
  int radius = ceil(radius_from_circle_surface(surface)) ;
  
  // choice your starting point
  float startingAnglePos = PI*.5f;
  if(num == 4) startingAnglePos = PI*.25f;
  
  float angleCorrection ; // this correction is cosmetic, when we'he a pair beam this one is stable for your eyes :)
  for( int i=0 ; i < num ; i++) {
    int beam = num /2 ;
    if ( beam%2 == 0 ) angleCorrection = PI / num ; else angleCorrection = 0.0f ;
    if ( num%2 == 0 ) jitter *= -1 ; else jitter *= 1 ; // the beam have two points at the top and each one must go to the opposate...
    
    float stepAngle = map(i, 0, num, 0, TAU) ;
    float jitterAngle = map(jitter, -1, 1, -PI/num, PI/num) ;
    float angle =  TAU -stepAngle +jitterAngle +angleCorrection -startingAnglePos;
    
    p[i] = new PVector(projection(angle, radius).x +pos.x, projection(angle, radius).y +pos.y) ;
  }
  return p ;
}
/**
END DISC and CIRCLE
*/



































/**
PRIMITIVE 3D
*/

/**
POLYDRON
v 0.2.0
*/
  //create Polyhedron
  /*
  "TETRAHEDRON","CUBE", "OCTOHEDRON", "DODECAHEDRON","ICOSAHEDRON","CUBOCTAHEDRON","ICOSI DODECAHEDRON",
  "TRUNCATED CUBE","TRUNCATED OCTAHEDRON","TRUNCATED DODECAHEDRON","TRUNCATED ICOSAHEDRON","TRUNCATED CUBOCTAHEDRON","RHOMBIC CUBOCTAHEDRON",
  "RHOMBIC DODECAHEDRON","RHOMBIC TRIACONTAHEDRON","RHOMBIC COSI DODECAHEDRON SMALL","RHOMBIC COSI DODECAHEDRON GREAT"
  All Polyhedrons can use "POINT" and "LINE" display mode.
  except the "TETRAHEDRON" who can also use "VERTEX" display mode.
  */
  
// MAIN VOID to create polyhedron
public void polyhedron(String type, String style, int size) {
  //This is where the actual defining of the polyhedrons takes place

  if(vec_polyhedron_list != null) {
    //clear out whatever verts are currently defined
    vec_polyhedron_list.clear();
  } else {
    vec_polyhedron_list = new ArrayList();
  }
  
  if(type.equals("TETRAHEDRON")) tetrahedron_poly(size) ;
  if(type.equals("CUBE")) cube(size) ;
  if(type.equals("OCTOHEDRON")) octohedron(size) ;
  if(type.equals("DODECAHEDRON"))dodecahedron(size) ;
  if(type.equals("ICOSAHEDRON"))icosahedron(size) ;
  if(type.equals("CUBOCTAHEDRON"))cuboctahedron(size) ;
  if(type.equals("ICOSI DODECAHEDRON"))icosi_dodecahedron(size) ;

  if(type.equals("TRUNCATED CUBE"))truncated_cube(size) ;
  if(type.equals("TRUNCATED OCTAHEDRON"))truncated_octahedron(size) ;
  if(type.equals("TRUNCATED DODECAHEDRON"))truncated_dodecahedron(size) ;
  if(type.equals("TRUNCATED ICOSAHEDRON"))truncated_icosahedron(size) ;
  if(type.equals("TRUNCATED CUBOCTAHEDRON"))truncated_cuboctahedron(size) ;
  
  if(type.equals("RHOMBIC CUBOCTAHEDRON"))rhombic_cuboctahedron(size) ;
  if(type.equals("RHOMBIC DODECAHEDRON"))rhombic_dodecahedron(size) ;
  if(type.equals("RHOMBIC TRIACONTAHEDRON"))rhombic_triacontahedron(size) ;
  if(type.equals("RHOMBIC COSI DODECAHEDRON SMALL"))rhombic_cosi_dodecahedron_small(size) ;
  if(type.equals("RHOMBIC COSI DODECAHEDRON GREAT"))rhombic_cosi_dodecahedron_great(size) ;
  
  // which method to draw
  if(style.equals("LINE")) polyhedron_draw_line(type) ;
  if(style.equals("POINT")) polyhedron_draw_point(type) ;
  if(style.equals("VERTEX")) polyhedron_draw_vertex(type) ;

}




// POLYHEDRON DETAIL 
//set up initial polyhedron
float factor_size_polyhedron ;
//some variables to hold the current polyhedron...
ArrayList<vec3>vec_polyhedron_list;
float edge_polyhedron_length;
String strName, strNotes;

// FEW POLYHEDRON
// BASIC
public void tetrahedron_poly(int size) {
  if(vec_polyhedron_list == null) vec_polyhedron_list = new ArrayList();
  vec_polyhedron_list.add(vec3(1,1,1));
  vec_polyhedron_list.add(vec3(-1,-1,1));
  vec_polyhedron_list.add(vec3(-1,1,-1));
  vec_polyhedron_list.add(vec3(1,-1,-1));
  edge_polyhedron_length = 0 ;
  factor_size_polyhedron = size /2;
}

public void cube(int size) {
  addVerts(1, 1, 1);
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size /2;
}

public void octohedron(int size) {
  addPermutations(1, 0, 0);
  edge_polyhedron_length = r.ROOT2;
  factor_size_polyhedron = size *.8f;
}

public void dodecahedron(int size) {
  addVerts(1, 1, 1);
  addPermutations(0, 1/r.PHI, r.PHI);
  edge_polyhedron_length = 2/r.PHI;
  factor_size_polyhedron = size /2.5f;
}


// SPECIAL
public void icosahedron(int size) {
  addPermutations(0,1,r.PHI);
  edge_polyhedron_length = 2.0f;
  factor_size_polyhedron = size /2.7f;
}

public void icosi_dodecahedron(int size) {
  addPermutations(0,0,2*r.PHI);
  addPermutations(1,r.PHI,sq(r.PHI));
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size/5;
}

public void cuboctahedron(int size) {
  addPermutations(1,0,1);
  edge_polyhedron_length = r.ROOT2;
  factor_size_polyhedron = size /1.9f;
}


// TRUNCATED
public void truncated_cube(int size) {
  addPermutations(r.ROOT2-1,1,1);
  edge_polyhedron_length = 2*(r.ROOT2-1);     
  factor_size_polyhedron = size /2.1f;
}

public void truncated_octahedron(int size) {
  addPermutations(0,1,2);
  addPermutations(2,1,0);
  edge_polyhedron_length = r.ROOT2;
  factor_size_polyhedron = size/3.4f;
}

public void truncated_cuboctahedron(int size) {
  addPermutations(r.ROOT2+1,2*r.ROOT2 + 1, 1);
  addPermutations(r.ROOT2+1,1,2*r.ROOT2 + 1);
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size/6.9f;
}

public void truncated_dodecahedron(int size) {
  addPermutations(0,1/r.PHI,r.PHI+2);
  addPermutations(1/r.PHI,r.PHI,2*r.PHI);
  addPermutations(r.PHI,2,sq(r.PHI));
  edge_polyhedron_length = 2*(r.PHI - 1);
  factor_size_polyhedron = size/6;
}

public void truncated_icosahedron(int size) {
  addPermutations(0,1,3*r.PHI);
  addPermutations(2,2*r.PHI+1,r.PHI);
  addPermutations(1,r.PHI+2,2*r.PHI);
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size/8;
}

// RHOMBIC
public void rhombic_dodecahedron(int size) {
  addVerts(1,1,1);
  addPermutations(0,0,2);
  edge_polyhedron_length = sqrt(3);
  factor_size_polyhedron = size /2.8f;
}

public void rhombic_triacontahedron(int size) {
  addVerts(sq(r.PHI), sq(r.PHI), sq(r.PHI));
  addPermutations(sq(r.PHI), 0, pow(r.PHI, 3));
  addPermutations(0,r.PHI, pow(r.PHI,3));
  edge_polyhedron_length = r.PHI*sqrt(r.PHI+2);
  factor_size_polyhedron = size /7.2f;
}

public void rhombic_cuboctahedron(int size) {
  addPermutations(r.ROOT2 + 1, 1, 1);
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size/4.2f;
}

public void rhombic_cosi_dodecahedron_small(int size) {
  addPermutations(1, 1, pow(r.PHI,3));
  addPermutations(sq(r.PHI),r.PHI,2*r.PHI);
  addPermutations(r.PHI+2,0,sq(r.PHI));
  edge_polyhedron_length = 2;
  factor_size_polyhedron = size/7.4f;
}

public void rhombic_cosi_dodecahedron_great(int size) {
  addPermutations(1/r.PHI,1/r.PHI,r.PHI+3);
  addPermutations(2/r.PHI,r.PHI,2*r.PHI+1);
  addPermutations(1/r.PHI, sq(r.PHI),3*r.PHI-1);
  addPermutations(2*r.PHI-1,2,r.PHI+2);
  addPermutations(r.PHI,3,2*r.PHI);
  edge_polyhedron_length = 2*r.PHI-2;
  factor_size_polyhedron = size/7.8f;
}



//Built Tetrahedron
// EASY METHOD, for direct and single drawing
// classic and easy method
public void polyhedron_draw_point(String name) {
  for (int i = 0 ; i < vec_polyhedron_list.size() ; i++) {
    vec3 point = vec_polyhedron_list.get(i);
    if(name.equals("TETRAHEDRON")) {
      pushMatrix() ;
      rotateX(TAU -1) ;
      rotateY(PI/4) ;
    }
    point(point.x *factor_size_polyhedron, point.y *factor_size_polyhedron, point.z *factor_size_polyhedron);
    if(name.equals("TETRAHEDRON")) popMatrix() ;
  }
}

public void polyhedron_draw_line(String name) {
  for (int i=0; i <vec_polyhedron_list.size(); i++) {
    for (int j=i +1; j < vec_polyhedron_list.size(); j++) {
      if (isEdge(i, j, vec_polyhedron_list) || edge_polyhedron_length == 0 ) {
        vec3 v1 = vec_polyhedron_list.get(i).copy();
        vec3 v2 = vec_polyhedron_list.get(j).copy();
        if(name.equals("TETRAHEDRON")) {
          pushMatrix() ;
          rotateX(TAU -1) ;
          rotateY(PI/4) ;
        }
        line(v1.x *factor_size_polyhedron, v1.y *factor_size_polyhedron, v1.z *factor_size_polyhedron, v2.x *factor_size_polyhedron, v2.y *factor_size_polyhedron, v2.z *factor_size_polyhedron);
        if(name.equals("TETRAHEDRON")) popMatrix() ;
      }
    }
  }
}

public void polyhedron_draw_vertex(String name) {
  // TETRAHEDRON
  if(name.equals("TETRAHEDRON")) {
    pushMatrix() ;
    rotateX(TAU -1) ;
    rotateY(PI/4) ;
    int n = 4 ; // quantity of face of Tetrahedron
    for(int i = 0 ; i < n ; i++) {
      // choice of each point
      int a = i ;
      int b = i+1 ;
      int c = i+2 ;
      if(i == n-2 ) c = 0 ;
      if(i == n-1 ) {
        b = 0 ;
        c = 1 ;
      }
      vec3 v1 = vec_polyhedron_list.get(a).copy();
      vec3 v2 = vec_polyhedron_list.get(b).copy();
      vec3 v3 = vec_polyhedron_list.get(c).copy();
      // scale the position of the points
      v1.mult(factor_size_polyhedron);
      v2.mult(factor_size_polyhedron);
      v3.mult(factor_size_polyhedron);
      
      // drawing
      beginShape() ;
      vertex(v1) ;
      vertex(v2) ;
      vertex(v3) ;
      endShape(CLOSE) ;
    }
    popMatrix() ;
  // OTHER POLYHEDRON
  } else {
    beginShape() ;
    for (int i= 0; i <vec_polyhedron_list.size(); i++) {
      for (int j= i +1; j <vec_polyhedron_list.size(); j++) {
        if (isEdge(i, j, vec_polyhedron_list) || edge_polyhedron_length == 0 ) {
          // vLine((PVector)vec_polyhedron_list.get(i), (PVector)vec_polyhedron_list.get(j));
          vec3 v1 = vec_polyhedron_list.get(i).copy();
          vec3 v2 = vec_polyhedron_list.get(j).copy();
          v1.mult(factor_size_polyhedron);
          v2.mult(factor_size_polyhedron);;
          vertex(v1);
          vertex(v2);
        }
      }
    }
    endShape(CLOSE) ;
  }
}
// END of EASY METHOD and DIRECT METHOD

 



/**
annexe draw polyhedron
*/
public boolean isEdge(int vID1, int vID2, ArrayList<vec3>listPoint) {
  //had some rounding errors that were messing things up, so I had to make it a bit more forgiving...
  int pres = 1000;
  vec3 v1 = listPoint.get(vID1).copy();
  vec3 v2 = listPoint.get(vID2).copy();
  float d = sqrt(sq(v1.x - v2.x) + sq(v1.y - v2.y) + sq(v1.z - v2.z)) + .00001f;
  return (PApplet.parseInt(d *pres)==PApplet.parseInt(edge_polyhedron_length *pres));
}






// ADD POINTS for built POLYHEDRON
/////////////////////////////////
public void addPermutations(float x, float y, float z) {
  //adds vertices for all three permutations of x, y, and z
  addVerts(x, y, z);
  addVerts(z, x, y);
  addVerts(y, z, x);
}


 
public void addVerts(float x, float y, float z) {
  //adds the requested vert and all "mirrored" verts
  vec_polyhedron_list.add (vec3(x,y,z));
  // z
  if (z != 0.0f) vec_polyhedron_list.add (vec3(x,y,-z)); 
  // y
  if (y != 0.0f) {
    vec_polyhedron_list.add (vec3(x, -y, z));
    if (z != 0.0f) vec_polyhedron_list.add(vec3(x,-y,-z));
  } 
  // x
  if (x != 0.0f) {
    vec_polyhedron_list.add (vec3(-x, y, z));
    if (z != 0.0f) vec_polyhedron_list.add(vec3(-x,y,-z));
    if (y != 0.0f) {
      vec_polyhedron_list.add(vec3(-x, -y, z));
      if (z != 0.0f) vec_polyhedron_list.add(vec3(-x,-y,-z));
    }
  }
}
/**
Rope UTILS 
v 1.56.3
* Copyleft (c) 2014-2019
Rope – Romanesco Processing Environment – 
Processing 3.5.3
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/


/**
CHECK SIZE WINDOW
return true if the window size has changed
*/
ivec2 rope_window_size;
public boolean window_change_is() {
  if(rope_window_size == null || !all(equal(ivec2(width,height),rope_window_size))) {
    check_window_size();
    return true;
  } else {
    return false;
  }
}

public void check_window_size() {
  if(rope_window_size == null) {
    rope_window_size = ivec2(width,height);
  } else {
    rope_window_size.set(width,height);
  }
}







/**
print Constants
v 0.0.3
*/
Constant_list processing_constants_list = new Constant_list(PConstants.class);
Constant_list rope_constants_list = new Constant_list(rope.core.R_Constants.class);
public void print_constants_rope() {
  if(rope_constants_list == null) {
    rope_constants_list = new Constant_list(rope.core.R_Constants.class);
  }
  println("ROPE CONSTANTS");
  for(String s: rope_constants_list.list()){
    println(s);
  }
}

public void print_constants_processing() {
  if(processing_constants_list == null) {
    processing_constants_list = new Constant_list(PConstants.class);
  }
  println("PROCESSING CONSTANTS");
  for(String s: processing_constants_list.list()) {
    println(s);
  }
} 

public void print_constants() {
  if(processing_constants_list == null) {
    processing_constants_list = new Constant_list(PConstants.class);
  }

  if(rope_constants_list == null) {
    rope_constants_list = new Constant_list(rope.core.R_Constants.class);
  }

  println("ROPE CONSTANTS");
  for(String s: rope_constants_list.list()){
    println(s);
  }
  println();
  println("PROCESSING CONSTANTS");
  for(String s: processing_constants_list.list()){
    println(s);
  }
} 

/*
* class to list the interface stuff
*/
class Constant_list {
  Field[] classFields; 
  Constant_list(Class c){
    classFields = c.getFields();
  }
  public ArrayList<String> list() {
    ArrayList<String> slist = new ArrayList();
    // for each constant
    for (Field f : classFields) {
      String s = "";
      // object type
      s = s + "(" + f.getType() + ")";
      // field name
      s = s + " " + f.getName();
      // value
      try {
        s = s + ": " + f.get(null);
      } 
      catch (IllegalAccessException e) {
      }
      // Optional special handling for field types:
      if (f.getType().equals(int.class)) {
        // ...
      }
      if (f.getType().equals(float.class)) {
        // ...
      }
      slist.add(s);
    }
    return(slist);
  }
}



















/**
FOLDER & FILE MANAGER
v 0.3.0
*/
/*
INOUT PART
*/
String selected_path_input = null;
boolean input_selected_is;

public void select_input() {
  select_input("");
}

public void select_input(String message) {
  // folder_selected_is = true ;
  selectInput(message, "input_selected");
}

public void input_selected(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
  } else {
    println("Input path is:" +selection.getAbsolutePath());
    selected_path_input = selection.getAbsolutePath();
    input_selected_is = true;
  }
}

public boolean input_selected_is() {
  return input_selected_is;
}

public void reset_input_selection() {
  input_selected_is = false;
}

public String input() {
  return selected_path_input;
}


/*
FOLDER PART
*/
String selected_path_folder = null;
boolean folder_selected_is;

public void select_folder() {
  select_folder("");
}

public void select_folder(String message) {
  selectFolder(message, "folder_selected");
}


/**
* this method is called by method select_folder(), and the method name must be the same as named
*/
public void folder_selected(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
  } else {
    println("Folder path is:" +selection.getAbsolutePath());
    selected_path_folder = selection.getAbsolutePath();
    folder_selected_is = true;
  }
}


public boolean folder_selected_is() {
  return folder_selected_is;
}

public void reset_folder_selection() {
  folder_selected_is = false;
}

public String folder() {
  return selected_path_folder;
}


// check what's happen in the selected folder
ArrayList <File> files;
int count_selection;

public void set_media_list() {
  if(files == null) files = new ArrayList<File>(); else files.clear();
}



public ArrayList<File> get_files() {
  return files ;
}


public String [] get_files_sort() {
  if(files != null) {
    String [] list = new String [files.size()];
    for(int i = 0 ; i < get_files().size() ; i++) {
      File f = get_files().get(i);
      list[i] = f.getAbsolutePath();
    }
    Arrays.sort(list);
    return list;

  } else return null ;

}

public void explore_folder(String path_folder, String... extension) {
  explore_folder(path_folder, false, extension);

}

public void explore_folder(String path, boolean check_sub_folder, String... extension) {
  if((folder_selected_is || input_selected_is) && path != ("")) {
    count_selection++ ;
    set_media_list();
 
    ArrayList allFiles = list_files(path, check_sub_folder);
  
    String fileName = "";
    int count_pertinent_file = 0 ;
  
    for (int i = 0; i < allFiles.size(); i++) {
      File f = (File) allFiles.get(i);   
      fileName = f.getName(); 
      // Add it to the list if it's not a directory
      if (f.isDirectory() == false) {
        for(int k = 0 ; k < extension.length ; k++) {
          if (extension(fileName).equals(extension[k])) {
            count_pertinent_file += 1 ;
            println(count_pertinent_file, "/", i, f.getName());
            files.add(f);
          }
        }
      }
    }
    // to don't loop with this void
    folder_selected_is = false ;
    input_selected_is = false ;
  }
}




// Method to get a list of all files in a directory and all subdirectories
public ArrayList list_files(String dir, boolean check_sub_folder) {
  ArrayList fileList = new ArrayList(); 
  if(check_sub_folder) { 
    explore_directory(fileList, dir);
  } else {
    if(folder_selected_is) {
      File file = new File(dir);
      File[] subfiles = file.listFiles();
      for(int i = 0 ; i < subfiles.length ; i++) {
        fileList.add(subfiles[i]);
      }
    } else if(input_selected_is) {
      File file = new File(dir);
      fileList.add(file);
    }
  }
  return fileList;
}

// Recursive function to traverse subdirectories
public void explore_directory(ArrayList list_file, String dir) {
  File file = new File(dir);
  if (file.isDirectory()) {
    list_file.add(file);  // include directories in the list

    File[] subfiles = file.listFiles();
    for (int i = 0; i < subfiles.length; i++) {
      // Call this function on all files in this directory
      explore_directory(list_file, subfiles[i].getAbsolutePath());
    }
  } else {
    list_file.add(file);
  }
}





























/**
SAVE LOAD  FRAME Rope
v 0.3.1
*/
/**
Save Frame
V 0.1.2
*/
public void saveFrame(String where, String filename, PImage img) {
  float compression = 1.f ;
  saveFrame(where, filename, compression, img) ;
}

public void saveFrame(String where, String filename) {
  float compression = 1.f ;
  PImage img = null;
  saveFrame(where, filename, compression, img) ;
}

public void saveFrame(String where, String filename, float compression) {
  PImage img = null;
  saveFrame(where, filename, compression, img);
}

public void saveFrame(String where, String filename, float compression, PImage img) {
  // check if the directory or folder exist, if it's not create the path
  File dir = new File(where)  ;
  dir.mkdir() ;
  // final path with file name adding
  String path = where+"/"+filename ;
  try {
    OutputStream os = new FileOutputStream(new File(path));
    loadPixels(); 
    BufferedImage buff_img;
    if(img == null) {
      printErr("method saveFrame(): the PImage is null, no save can be done");
    } else {
      buff_img = new BufferedImage(img.width, img.height, BufferedImage.TYPE_INT_RGB);
      buff_img.setRGB(0, 0, img.width, img.height, img.pixels, 0, img.width);
      if(path.contains(".bmp") || path.contains(".BMP")) {
        saveBMP(os, buff_img);
      } else if(path.contains(".jpeg") || path.contains(".jpg") || path.contains(".JPG") || path.contains(".JPEG")) {
        saveJPG(os, compression, buff_img);
      }
    } 
  }  catch (FileNotFoundException e) {
    //
  }
}

/**
SAVE JPG
v 0.0.1
*/
// classic one
public boolean saveJPG(OutputStream output, float compression,  BufferedImage buff_img) {
  compression = truncate(compression, 1);
  if(compression < 0) compression = 0.0f;
  else if(compression > 1) compression = 1.0f;

  try {
    ImageWriter writer = null;
    ImageWriteParam param = null;
    IIOMetadata metadata = null;

    if ((writer = imageioWriter("jpeg")) != null) {
      param = writer.getDefaultWriteParam();
      param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
      param.setCompressionQuality(compression);

      writer.setOutput(ImageIO.createImageOutputStream(output));
      writer.write(metadata, new IIOImage(buff_img, null, metadata), param);
      writer.dispose();
      output.flush();
      javax.imageio.ImageIO.write(buff_img, "jpg", output);
    }
    return true ;
  }
  catch(IOException e) {
    e.printStackTrace();
  }
  return false ;
}

public ImageWriter imageioWriter(String extension) {
  // code from Processing PImage.java
  Iterator<ImageWriter> iter = ImageIO.getImageWritersByFormatName(extension);
  if (iter.hasNext()) {
    return iter.next();
  }
  return null;
}


/**
SAVE BMP
v 0.3.0.1
*/
// SAVE
public boolean saveBMP(OutputStream output, BufferedImage buff_img) {
  try {
    Graphics g = buff_img.getGraphics();
    g.dispose();
    output.flush();
    
    ImageIO.write(buff_img, "bmp", output);
    return true ;
  }
  catch(IOException e) {
    e.printStackTrace();
  }
  return false ;
}

// LOAD
public PImage loadImageBMP(String fileName) {
  PImage img = null;

  try {
    InputStream is = createInput(fileName);
    BufferedImage buff_img = ImageIO.read(is);
    int[] pix = buff_img.getRGB(0, 0, buff_img.getWidth(), buff_img.getHeight(), null, 0, buff_img.getWidth());
    img = createImage(buff_img.getWidth(),buff_img.getHeight(), RGB);
    // println("Componenent", buff_img.getColorModel().getNumComponents()) ;
    img.pixels = pix;   

    // in case the picture is in grey value...to set the grey because this one is very very bad
    // I don't find any solution to solve it...
    // any idea ?
    if(buff_img.getColorModel().getNumComponents() == 1) {
      float ratio_brightness = .95f;
      for(int i = 0 ; i < img.pixels.length ; i++) {     
        colorMode(HSB);
        float b = brightness(img.pixels[i]) *ratio_brightness ;
        img.pixels[i] = color(0,0,b);
        colorMode(RGB);
      }
    }
  }
  catch(IOException e) {
  }

  if(img != null) {
    return img;
  } else {
    return null ;
  }
}































/**
TRANSLATOR 
v 0.2.0
*/
/**
primitive to byte, byte to primitive
v 0.1.0
*/



public int int_from_byte(Byte b) {
  int result = b.intValue();
  return result;
}

public Boolean boolean_from_bytes(byte... array_byte) {
  if(array_byte.length == 1) {
    if(array_byte[0] == 0) return false ; return true;
  } else {
    Boolean null_data = null;
    return null_data;
  }
}

public Character char_from_bytes(byte [] array_byte) {
  if(array_byte.length == 2) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte);
    char result = buffer.getChar();
    return result;
  } else {
    Character null_data = null;
    return null_data;
  }
}

public Short short_from_bytes(byte [] array_byte) {
  if(array_byte.length == 2) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte);
    short result = buffer.getShort();
    return result;
  } else {
    Short null_data = null;
    return null_data;
  }
}

public Integer int_from_bytes(byte [] array_byte) {
  if(array_byte.length == 4) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte) ;
    int result = buffer.getInt();
    return result;
  } else {
    Integer null_data = null;
    return null_data;
  }
}

public Long long_from_bytes(byte [] array_byte) {
  if(array_byte.length == 8) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte) ;
    long result = buffer.getLong();
    return result;
  } else {
    Long null_data = null;
    return null_data;
  }
}

public Float float_from_bytes(byte [] array_byte) {
  if(array_byte.length == 4) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte) ;
    float result = buffer.getFloat();
    return result;
  } else {
    Float null_data = null;
    return null_data;
  }
}

public Double double_from_bytes(byte [] array_byte) {
  if(array_byte.length == 8) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte) ;
    double result = buffer.getDouble();
    return result;
  } else {
    Double null_data = null;
    return null_data;
  }
}



// @Deprecated // this method return a short because it's reordering by LITTLE_ENDIAN to used by getShort()
public Integer int_from_4_bytes(byte [] array_byte, boolean little_endian) {
  if(array_byte.length == 4) {
    ByteBuffer buffer = ByteBuffer.wrap(array_byte);
    if(little_endian)buffer.order(ByteOrder.LITTLE_ENDIAN);
    int result = buffer.getShort();
    return result;
  } else {
    Integer null_data = null;
    return null_data;
  }
}



// return byte
public byte[] to_byte(Object obj) {
  if(obj instanceof Boolean) {
    boolean value = (boolean)obj;
    byte [] array = new byte[1];
    array[0] = (byte)(value?1:0);
    return array;
  } else if(obj instanceof Character) {
    char value = (char)obj;
    return ByteBuffer.allocate(2).putChar(value).array();
  } else if(obj instanceof Short) {
    short value = (short)obj;
    return ByteBuffer.allocate(2).putShort(value).array();
  } else if(obj instanceof Integer) {
    int value = (int)obj;
    return ByteBuffer.allocate(4).putInt(value).array();
  } else if(obj instanceof Long) {
    long value = (long)obj;
    return ByteBuffer.allocate(8).putLong(value).array();
  } else if(obj instanceof Float) {
    float value = (float)obj;
    return ByteBuffer.allocate(4).putFloat(value).array();
  } else if(obj instanceof Double) {
    double value = (double)obj;
    return ByteBuffer.allocate(8).putDouble(value).array();
  } else return null;
}



/**
* from ivec, vec to PVector
*/
public PVector to_PVector(Object obj) {
  if(obj instanceof vec || obj instanceof ivec) {
    if(obj instanceof vec) {
      vec v = (vec)obj;
      return new PVector(v.x,v.y,v.z);
    } else {
      ivec iv = (ivec)obj;
      return new PVector(iv.x,iv.y,iv.z);
    }
  } else {
    printErr("method to_Pvectro(): wait for Object of type vec or ivec");
    return null;
  }
}


/**
truncate a float argument
v 0.0.2
*/
public float truncate(float x) {
    return round(x *100.0f) /100.0f;
}

public float truncate(float x, int num) {
  float result = 0.0f ;
  switch(num) {
    case 0:
      result = round(x *1.0f) /1.0f;
      break;
    case 1:
      result = round(x *10.0f) /10.0f;
      break;
    case 2:
      result = round(x *100.0f) /100.0f;
      break;
    case 3:
      result = round(x *1000.0f) /1000.0f;
      break;
    case 4:
      result = round(x *10000.0f) /10000.0f;
      break;
    case 5:
      result = round(x *100000.0f) /100000.0f;
      break;
    default:
      result = x;
      break;
  }
  return result;
}

/**
Int to String
Float to String
v 0.0.3
*/
/*
@ return String
*/
public String join_int_to_String(int []data) {
  String intString ;
  String [] dataString = new String [data.length] ;
  for ( int i = 0 ; i < data.length ; i++) dataString[i] = Integer.toString(data[i]) ;
  intString = join(dataString,"/") ;
  
  return intString ;
}

//float to String with array list
public String join_float_to_String(float []data) {
  String floatString ;
  String [] dataString = new String [data.length] ;
  //for ( int i = 0 ; i < data.length ; i++) dataString[i] = Float.toString(data[i]) ;
  //we must use just one decimal after coma, to dodge the outBoundIndex blablabla
  for ( int i = 0 ; i < data.length ; i++) dataString[i] = String.format("%.1f" ,data[i]) ;
  floatString = join(dataString,"/") ;
  
  return floatString ;
}

//Translater to String
// float to String
public String float_to_String_1(float data) {
  String float_string_value ;
  float_string_value = String.format("%.1f", data ) ;
  return float_String(float_string_value) ;
}
//
public String float_to_String_2(float data) {
  String float_string_value ;
  float_string_value = String.format("%.2f", data ) ;
  return float_String(float_string_value) ;
}
//
public String float_to_String_3(float data) {
  String float_string_value ;
  float_string_value = String.format("%.3f", data ) ;
  return float_String(float_string_value) ;
}

//
public String float_to_String_4(float data) {
  String float_string_value ;
  float_string_value = String.format("%.4f", data ) ;
  return float_String(float_string_value) ;
}
// local
public String float_String(String value) {
  if(value.contains(".")) {
    return value ;
  } else {
    String [] temp = split(value, ",") ;
    value = temp[0] +"." + temp[1] ;
    return value ;
  }
}


// int to String
public String int_to_String(int data) {
  String float_string_value ;
  float_string_value = Integer.toString(data ) ;
  return float_string_value ;
}



/**
array float to vec
*/
public vec4 array_to_vec4_rgba(float... f) {
  vec4 v = vec4(1);
  if(f.length == 1) {
    v.set(f[0],f[0],f[0],1.f);
  } else if(f.length == 2) {
    v.set(f[0],f[0],f[0],f[1]);
  } else if(f.length == 3) {
    v.set(f[0],f[1],f[2],1);
  } else if(f.length > 3) {
    v.set(f[0],f[1],f[2],f[3]);
  }
  return v;
}


































/**
EXPORT FILE PDF_PNG 0.1.1
*/
String ranking_shot = "_######" ;
// PDF

boolean record_PDF;
public void start_PDF() {
  start_PDF(null,null) ;
}

public void start_PDF(String name_file) {
  start_PDF(null, name_file) ;
}
public void start_PDF(String path_folder, String name_file) {
  if(path_folder == null) path_folder = "pdf_folder";
  if(name_file == null) name_file = "pdf_file_"+ranking_shot;

  if (record_PDF && !record_PNG) {
    if(renderer_P3D()) {
      beginRaw(PDF, path_folder+"/"+name_file+".pdf"); 
    } else {
      beginRecord(PDF, path_folder+"/"+name_file+".pdf");
    }
  }
}

public void save_PDF() {
  if (record_PDF && !record_PNG) {
    if(renderer_P3D()) {
      endRaw(); 
    } else {
      endRecord() ;
    }
    println("PDF");
    record_PDF = false;
  }
}

public void event_PDF() {
  record_PDF = true;
}




// PNG
boolean record_PNG ;
boolean naming_PNG ;
String path_folder_png, name_file_png  ;
public void start_PNG(String path_folder, String name_file) {
  path_folder_png = path_folder ;
  name_file_png = name_file ;
  naming_PNG = true ;
}

public void save_PNG() {
  if(record_PNG) {
    if(!naming_PNG) {
      saveFrame("png_folder/shot_" + ranking_shot + ".png");
    } else {
      saveFrame(path_folder_png + "/" + name_file_png + ".png");
    }
    record_PNG = false ;
  }
}

public void event_PNG() {
  record_PNG = true;
}


























































/**
print
v 0.2.0
*/
// print Err
public void printErr(Object... obj) {
  System.err.println(write_message(obj));
}

// print tempo
public void printErrTempo(int tempo, Object... obj) {
  if(frameCount%tempo == 0 || frameCount <= 1) {
    String message = write_message(obj);
    System.err.println(message);
  }
}

public void printTempo(int tempo, Object... obj) {
  if(frameCount%tempo == 0 || frameCount <= 1) {
    String message = write_message(obj);
    println(message);
  }
}




public void printArrayTempo(int tempo, Object[] obj) {
  if(frameCount%tempo == 0 || frameCount <= 1) {
    printArray(obj);
  }
}

public void printArrayTempo(int tempo, float[] var) {
  if(frameCount%tempo == 0 || frameCount <= 10) {
    printArray(var);
  }
}

public void printArrayTempo(int tempo, int[] var) {
  if(frameCount%tempo == 0 || frameCount <= 10) {
    printArray(var);
  }
}

public void printArrayTempo(int tempo, String[] var) {
  if(frameCount%tempo == 0 || frameCount <= 10) {
    printArray(var);
  }
}











/**
MAP
map the value between the min and the max
@ return float
*/
public float map_cycle(float value, float min, float max) {
  max += .000001f ;
  float newValue ;
  if(min < 0 && max >= 0 ) {
    float tempMax = max +abs(min) ;
    value += abs(min) ;
    float tempMin = 0 ;
    newValue =  tempMin +abs(value)%(tempMax - tempMin)  ;
    newValue -= abs(min) ;
    return newValue ;
  } else if ( min < 0 && max < 0) {
    newValue = abs(value)%(abs(max)+min) -max ;
    return newValue ;
  } else {
    newValue = min + abs(value)%(max - min) ;
    return newValue ;
  }
}




/*
map the value between the min and the max, but this value is lock between the min and the max
@ return float
*/
public float map_locked(float value, float sourceMin, float sourceMax, float targetMin, float targetMax) {
  if(sourceMax >= targetMax ) sourceMax = targetMax ;
  if (value < sourceMin ) value = sourceMin ;
  if (value > sourceMax ) value = sourceMax ;
  float newMax = sourceMax - sourceMin ;
  float deltaTarget = targetMax - targetMin ;
  float ratio = ((value - sourceMin) / newMax ) ;
  float result = targetMin +deltaTarget *ratio;
  return result; 
}


// to map not linear, start the curve hardly to start slowly
public float map_begin(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) {
  if (value < sourceMin ) value = sourceMin ;
  if (value > sourceMax ) value = sourceMax ;
  float newMax = sourceMax - sourceMin ;
  float deltaTarget = targetMax - targetMin ;
  float ratio = ((value - sourceMin) / newMax ) ;
  ratio = pow(ratio, level) ;
  float result = targetMin +deltaTarget *ratio;
  return result;
}

// to map not linear, start the curve hardly to finish slowly
public float map_end(float value, float sourceMin, float sourceMax, float targetMin, float targetMax, int level) {
  if (value < sourceMin ) value = sourceMin ;
  if (value > sourceMax ) value = sourceMax ;
  float newMax = sourceMax - sourceMin ;
  float deltaTarget = targetMax - targetMin ;
  float ratio = ((value - sourceMin) / newMax ) ;
  ratio = pow(ratio, 1.0f/level) ;
  float result = targetMin +deltaTarget *ratio;
  return result;
}

public float map(float value, float start_1, float stop_1, float start_2, float stop_2, int begin, int end) {
  begin = abs(begin);
  end = abs(end);
  if(begin != 0 && end != 0) {
    if (value < start_1 ) value = start_1;
    if (value > stop_2 ) value = stop_2;

    float new_max = stop_2 - start_1;
    float delta = stop_2 - start_2;
    float ratio = (value - start_1) / new_max;

    ratio = map(ratio,0,1,-1,1);
    if (ratio < 0) {
      if(begin < 2) ratio = pow(ratio,begin) ;
      else ratio = pow(ratio,begin) *(-1);
      if(ratio > 0) ratio *= -1;
    } else {
      ratio = pow(ratio,end);
    }
    
    ratio = map(ratio,-1,1,0,1);
    float result = start_2 +delta *ratio;
    return result;
  } else if(begin == 0 && end != 0) {
    return map_end(value,start_1,stop_1,start_2,stop_2,end);
  } else if(end == 0 && begin != 0) {
    return map_begin(value,start_1,stop_1,start_2,stop_2,begin);
  } else {
    return map(value,start_1,stop_1,start_2,stop_2,1,1);
  }

}











/**
MISC
v 0.0.6
*/
/**
stop trhead draw by using loop and noLoop()
*/
boolean freeze_is ;
public void freeze() {
  freeze_is = (freeze_is)? false:true ;
  if (freeze_is)  {
    noLoop();
  } else {
    loop();
  }
}








/**
PIXEL UTILS
v 0.0.3
*/
public int [][] loadPixels_array_2D() {
  int [][] array_pix;
  loadPixels();
  array_pix = new int[height][width] ;
  int which_pix = 0;
  if(pixels != null) {
    for(int y = 0 ; y < height ; y++) {
      for(int x = 0 ; x < width ; x++) {
        which_pix = y *width +x ;
        array_pix[y][x] = pixels[which_pix] ;
      }
    }
  }
  if(array_pix != null) {
    return array_pix ;
  } else {
    return null ;
  }
}

































/**
CHECK
v 0.2.4
*/
/**
Check Type
v 0.0.4
*/
public String get_type(Object obj) {
  if(obj instanceof Integer) {
    return "Integer";
  } else if(obj instanceof Float) {
    return "Float";
  } else if(obj instanceof String) {
    return "String";
  } else if(obj instanceof Double) {
    return "Double";
  } else if(obj instanceof Long) {
    return "Long";
  } else if(obj instanceof Short) {
    return "Short";
  } else if(obj instanceof Boolean) {
    return "Boolean";
  } else if(obj instanceof Byte) {
    return "Byte";
  } else if(obj instanceof Character) {
    return "Character";
  } else if(obj instanceof PVector) {
    return "PVector";
  } else if(obj instanceof vec) {
    return "vec";
  } else if(obj instanceof ivec) {
    return "ivec";
  } else if(obj instanceof bvec) {
    return "bvec";
  } else if(obj == null) {
    return "null";
  } else return "Unknow" ;
}




























/**
check value in range
*/
public boolean in_range(float min, float max, float value) {
  if(value <= max && value >= min) {
    return true ; 
  } else {
    return false ;
  }
}

public boolean in_range_wheel(float min, float max, float roof_max, float value) {
  if(value <= max && value >= min) {
    return true ;
  } else {
    // wheel value
    if(max > roof_max ) {
      // test hight value
      if(value <= (max - roof_max)) {
        return true ;
      } 
    } 
    if (min < 0) {
      // here it's + min 
      if(value >= (roof_max + min)) {
        return true ;
      } 
    } 
    return false ;
  }
}














































/**
STRING UTILS
v 0.3.3
*/
public String write_message(Object... obj) {
  String mark = " ";
  return write_message_sep(mark,obj);
}
public String write_message_sep(String mark, Object... obj) {
  String m = "";
  for(int i = 0 ; i < obj.length ; i++) {
    m += write_message(obj[i], obj.length,i,mark);
  }
  return m;
}

// local method
public String write_message(Object obj, int length, int i, String mark) {
  String message = "";
  String add = "";
  if(i == length -1) { 
    if(obj == null) {
      add = "null";
    } else {
      add = obj.toString();
    }
    return message += add;
  } else {
    if(obj == null) {
      add = "null";
    } else {
      add = obj.toString();
    }
    return message += add + mark;
  }
}



//STRING SPLIT
public String [] split_text(String str, String separator) {
  String [] text = str.split(separator) ;
  return text  ;
}


//STRING COMPARE LIST SORT
//raw compare
public int longest_String(String[] string_list) {
  int finish = 0;
  if(string_list != null) finish = string_list.length;
  return longest_String(string_list, 0, finish);
}

//with starting and end keypoint in the String must be sort
public int longest_String(String[] string_list, int start, int finish) {
  int length = 0;
  if(string_list != null) {
    for ( int i = start ; i < finish ; i++) {
      if (string_list[i].length() > length ) length = string_list[i].length() ;
    }
  }
  return length;
}

/**
Longuest String with PFont
*/
public int longest_String_pixel(PFont font, String[] string_list) {
  int [] size_font = new int[1];
  size_font[0] = font.getSize();
  int finish = 0;
  if(string_list != null) finish = string_list.length;
  return longest_String_pixel(font.getName(), string_list, size_font, 0, finish);
}

public int longest_String_pixel(PFont font, String[] string_list, int... size_font) {
  int finish = 0;
  if(string_list != null) finish = string_list.length;
  return longest_String_pixel(font.getName(), string_list, size_font, 0, finish);
}

public int longest_String_pixel(PFont font, String[] string_list, int [] size_font, int start, int finish) {
  return longest_String_pixel(font.getName(), string_list, size_font, start, finish);
}

/**
Longuest String with String name Font
*/
public int longest_String_pixel(String font_name, String[] string_list, int... size_font) {
  int finish = 0;
  if(string_list != null) finish = string_list.length;
  return longest_String_pixel(font_name, string_list, size_font, 0, finish);
}

// diferrent size by line
public int longest_String_pixel(String font_name, String[] string_list, int size_font, int start, int finish) {
  int [] s_font = new int[1];
  s_font[0] = size_font;
  return longest_String_pixel(font_name, string_list, s_font, start, finish);
}

public int longest_String_pixel(String font_name, String[] string_list, int [] size_font, int start, int finish) {
  int width_pix = 0 ;
  if(string_list != null) {
    int target_size_font = 0;
    for (int i = start ; i < finish && i < string_list.length; i++) {
      if(i >= size_font.length) target_size_font = 0 ;
      if (width_String(font_name, string_list[i], size_font[target_size_font]) > width_pix) {
        width_pix = width_String(string_list[i],size_font[target_size_font]);
      }
      target_size_font++;
    }
  }
  return width_pix;
}




/**
width String
*/
public int width_String(String target, int size) {
  return width_String("defaultFont", target, size) ;
}

public int width_String(PFont pfont, String target, int size) {
  return width_String(pfont.getName(), target, size);
}

public int width_String(String font_name, String target, int size) {
  Font font = new Font(font_name, Font.BOLD, size) ;
  BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
  FontMetrics fm = img.getGraphics().getFontMetrics(font);
  if(target == null) {
    target = "";
  }
  return fm.stringWidth(target);
}




public int width_char(char target, int size) {
  return width_char("defaultFont", target, size) ;
}

public int width_char(PFont pfont, char target, int size) {
  return width_char(pfont.getName(), target, size);
}
public int width_char(String font_name, char target, int size) {
  Font font = new Font(font_name, Font.BOLD, size) ;
  BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
  FontMetrics fm = img.getGraphics().getFontMetrics(font);
  return fm.charWidth(target);
}




// Research a specific word in String
public boolean research_in_String(String research, String target) {
  boolean result = false ;
  for(int i = 0 ; i < target.length() - research.length() +1; i++) {
    result = target.regionMatches(i,research,0,research.length()) ;
    if (result) break ;
  }
  return result ;
}





/**
String file utils
2014-2018
v 0.2.0
*/
/**
* remove element of the sketch path
*/
public String sketchPath(int minus) {
  minus = abs(minus);
  String [] element = split(sketchPath(),"/");
  String new_path ="" ;
  if(minus < element.length ) {
    for(int i = 0 ; i < element.length -minus ; i++) {
      new_path +="/";
      new_path +=element[i];
    }
    return new_path; 
  } else {
    printErr("The number of path elements is lower that elements must be remove, instead a data folder is used");
    return sketchPath()+"/data";
  }  
}



// remove the path of your file
public String file_name(String s) {
  String file_name = "" ;
  String [] split_path = s.split("/") ;
  file_name = split_path[split_path.length -1] ;
  return file_name ;
}

/**
* work around extension
*/
public String extension(String filename) {
  if(filename != null) {
    if(filename.contains(".")) {
      return filename.substring(filename.lastIndexOf(".") + 1, filename.length());
    } else {
      return null;
    } 
  } else {
    return null;
  }
}

public boolean extension_is(String... data) {
  boolean is = false;
  if(data.length >= 2) {
    String extension_to_compare = extension(data[0]);
    if(extension_to_compare != null) {
      for(int i = 1 ; i < data.length ; i++) {
        if(extension_to_compare.equals(data[i])) {
          is = true;
          break;
        } else {
          is = false;
        }
      }
    } else {
      printErr("method extension_is(): [",data[0],"] this path don't have any extension");
    }
  } else {
    printErr("method extension_is() need almost two components, the first is the path and the next is extension");
  }
  return is;
}














































/**
TABLE METHOD 
v 0.0.3.1
for Table with the first COLLUMN is used for name and the next 6 for the value.
The method is used with the Class Info

*/
// table method for row sort
public void buildTable(Table table, TableRow [] tableRow, String [] col_name, String [] row_name) {
  // add col
  for(int i = 0 ; i < col_name.length ; i++) {
    table.addColumn(col_name[i]);
  }
  // add row
  tableRow = new TableRow[row_name.length] ;
  buildRow(table, row_name) ;
}

public void buildTable(Table table, String [] col_name) {
  // add col
  for(int i = 0 ; i < col_name.length ; i++) {
    table.addColumn(col_name[i]);
  }
}

public void buildRow(Table table, String [] row_name) {
  int num_row = table.getRowCount() ;
  for(int i = 0 ; i < num_row ; i++) {
    TableRow row = table.getRow(i) ;
    row.setString(table.getColumnTitle(0), row_name[i]) ; 
  }
}

public void setTable(Table table, TableRow [] rows, Info_Object... info) {
  for(int i = 0 ; i < rows.length ; i++) {
    if(rows[i] != null) {
      for(int j = 0 ; j < info.length ; j++) {
        if(info[j] != null && info[j].get_name().equals(rows[i].getString(table.getColumnTitle(0)))) {
          for(int k = 1 ; k < 7 ; k++) {
            if(table.getColumnCount() > k && info[j].catch_obj(k-1) != null)  write_row(rows[i], table.getColumnTitle(k), info[j].catch_obj(k-1)) ;
          }
        }
        
      }
    }
  }
}


public void setRow(Table table, Info_Object info) {
  TableRow result = table.findRow(info.get_name(), table.getColumnTitle(0)) ;
  if(result != null) {
    for(int k = 1 ; k < 7 ; k++) {
      if(table.getColumnCount() > k && info.catch_obj(k-1) != null)  write_row(result, table.getColumnTitle(k), info.catch_obj(k-1)) ;
    }
  }
}

public void write_row(TableRow row, String col_name, Object o) {
  if(o instanceof String) {
    String s = (String) o ;
    row.setString(col_name, s);
  } else if(o instanceof Short) {
    short sh = (Short) o ;
    row.setInt(col_name, sh);
  } else if(o instanceof Integer) {
    int in = (Integer) o ;
    row.setInt(col_name, in);
  } else if(o instanceof Float) {
    float f = (Float) o ;
    row.setFloat(col_name, f);
  } else if(o instanceof Character) {
    char c = (Character) o ;
    String s = Character.toString(c) ;
    row.setString(col_name, s);
  } else if(o instanceof Boolean) {
    boolean b = (Boolean) o ;
    String s = Boolean.toString(b) ;
    row.setString(col_name, s);
  } 
}
/**
Info_dict 
v 0.3.0.1
*/
public class Info_dict {
  ArrayList<Info> list;
  char type_list = 'o';

  Info_dict(char type_list) {
    this.type_list = type_list;
  }

  Info_dict() {
    list = new ArrayList<Info>();
  }

  // add Object
  public void add(String name, Object a) {
    Info_Object info = new Info_Object(name,a);
    list.add(info);
  }
  public void add(String name, Object a, Object b) {
    Info_Object info = new Info_Object(name,a,b);
    list.add(info);
  }
  public void add(String name, Object a, Object b, Object c) {
    Info_Object info = new Info_Object(name,a,b,c);
    list.add(info);
  }
  public void add(String name, Object a, Object b, Object c, Object d) {
    Info_Object info = new Info_Object(name,a,b,c,d);
    list.add(info);
  }
  public void add(String name, Object a, Object b, Object c, Object d, Object e) {
    Info_Object info = new Info_Object(name,a,b,c,d,e);
    list.add(info);
  }
  public void add(String name, Object a, Object b, Object c, Object d, Object e, Object f) {
    Info_Object info = new Info_Object(name,a,b,c,d,e,f);
    list.add(info);
  }
  public void add(String name, Object a, Object b, Object c, Object d, Object e, Object f, Object g) {
    Info_Object info = new Info_Object(name,a,b,c,d,e,f,g);
    list.add(info);
  }

   // size
   public int size() {
    return list.size();
   }

  // read
  public void read() {
    println("Object list");
    for(Info a : list) {
      if(a instanceof Info_Object) {
        Info_Object obj = (Info_Object)a ;
        if(obj.a != null && obj.b == null && obj.c == null && obj.d == null && obj.e == null && obj.f == null && obj.g == null) {
          println(a,get_type(obj.a));   
        }
        if(obj.a != null && obj.b != null && obj.c == null && obj.d == null && obj.e == null && obj.f == null && obj.g == null) {
          println(a,get_type(obj.a),get_type(obj.b));   
        }
        if(obj.a != null && obj.b != null && obj.c != null && obj.d == null && obj.e == null && obj.f == null && obj.g == null) {
          println(a,get_type(obj.a),get_type(obj.b),get_type(obj.c));   
        }
        if(obj.a != null && obj.b != null && obj.c != null && obj.d != null && obj.e == null && obj.f == null && obj.g == null) {
          println(a,get_type(obj.a),get_type(obj.b),get_type(obj.c),get_type(obj.d));   
        }
        if(obj.a != null && obj.b != null && obj.c != null && obj.d != null && obj.e != null && obj.f == null && obj.g == null) {
          println(a,get_type(obj.a),get_type(obj.b),get_type(obj.c),get_type(obj.d),get_type(obj.e));   
        }
        if(obj.a != null && obj.b != null && obj.c != null && obj.d != null && obj.e != null && obj.f != null && obj.g == null) {
          println(a,get_type(obj.a),get_type(obj.b),get_type(obj.c),get_type(obj.d),get_type(obj.e),get_type(obj.f));   
        }
        if(obj.a != null && obj.b != null && obj.c != null && obj.d != null && obj.e != null && obj.f != null && obj.g != null) {
          println(a,get_type(obj.a),get_type(obj.b),get_type(obj.c),get_type(obj.d),get_type(obj.e),get_type(obj.f),get_type(obj.g));   
        }      
      }
    }
  }

  // get
  public Info get(int target) {
    if(target < list.size() && target >= 0) {
      return list.get(target);
    } else return null;
  }
  
  public Info [] get(String which) {
    Info [] info;
    int count = 0;
    for(Info a : list) {
      if(a.get_name().equals(which)) {
        count++;
      }
    }
    if (count > 0 ) {
      info = new Info[count] ;
      count = 0;
      for(Info a : list) {
        if(a.get_name().equals(which)) {
          info[count] = a;
          count++;
        }
      }
    } else {
      info = new Info_String[1];
      info[0] = null;
    }
    if(info.length == 1 && info[0] == null )return null ; else return info;
  }

  // clear
  public void clear() {
    list.clear();
  }

  // remove
  public void remove(String which) {
    for(int i = 0 ; i < list.size() ; i++) {
      Info a = list.get(i);
      if(a.get_name().equals(which)) {
        list.remove(i);
      }
    }
  }
  
  public void remove(int target) {
   if(target < list.size()) {
      list.remove(target);
    }
  }
}

/**
Info_int_dict
v 0.0.2
*/

public class Info_int_dict extends Info_dict {
  ArrayList<Info_int> list_int;
  Info_int_dict() {
    super('i');
    list_int = new ArrayList<Info_int>();
  }


  // add int
  public void add(String name, int a) {
    Info_int info = new Info_int(name,a);
    list_int.add(info);
  } 
  public void add(String name, int a, int b) {
    Info_int info = new Info_int(name,a,b);
    list_int.add(info);
  } 

  public void add(String name, int a, int b, int c) {
    Info_int info = new Info_int(name,a,b,c);
    list_int.add(info);
  } 
  public void add(String name, int a, int b, int c, int d) {
    Info_int info = new Info_int(name, a,b,c,d);
    list_int.add(info);
  } 
  public void add(String name, int a, int b, int c, int d, int e) {
    Info_int info = new Info_int(name,a,b,c,d,e);
    list_int.add(info);
  } 
  public void add(String name, int a, int b, int c, int d, int e, int f) {
    Info_int info = new Info_int(name,a,b,c,d,e,f);
    list_int.add(info);
  }
  public void add(String name, int a, int b, int c, int d, int e, int f, int g) {
    Info_int info = new Info_int(name,a,b,c,d,e,f,g);
    list_int.add(info);
  }


  // size
  public int size() {
    return list_int.size() ;
  }

  // read
  public void read() {
    println("Integer list");
    for(Info a : list_int) {
      println(a,"Integer");
    }
  }
  

  // get
  public Info_int get(int target) {
    if(target < list_int.size() && target >= 0) {
      return list_int.get(target);
    } else return null;
  }
  
  public Info_int [] get(String which) {
    Info_int [] info  ;
    int count = 0;
    for(Info_int a : list_int) {
      if(a.get_name().equals(which)) {
        count++;
      }
    }
    if (count > 0 ) {
      info = new Info_int[count] ;
      count = 0 ;
      for(Info_int a : list_int) {
        if(a.get_name().equals(which)) {
          info[count] = a;
          count++;
        }
      }
    } else {
      info = new Info_int[1] ;
      info[0] = null;
    }
    if(info.length == 1 && info[0] == null )return null ; else return info ;
  }

  // clear
  public void clear() {
    list_int.clear();
  }

  // remove
  public void remove(String which) {
    for(int i = 0 ; i < list_int.size() ; i++) {
      Info_int a = list_int.get(i) ;
      if(a.get_name().equals(which)) {
        list_int.remove(i);
      }
    }
  }
  
  public void remove(int target) {
   if(target < list_int.size()) {
      list_int.remove(target);
    }
  }
}

/**
Info_float_dict
v 0.0.2
*/
public class Info_float_dict extends Info_dict {
  ArrayList<Info_float> list_float ;
  Info_float_dict() {
    super('f');
    list_float = new ArrayList<Info_float>();
  }

  // add float
  public void add(String name, float a) {
    Info_float info = new Info_float(name,a);
    list_float.add(info);
  }
  public void add(String name, float a, float b) {
    Info_float info = new Info_float(name,a,b);
    list_float.add(info);
  }
  public void add(String name, float a, float b, float c) {
    Info_float info = new Info_float(name,a,b,c);
    list_float.add(info);
  }
  public void add(String name, float a, float b, float c, float d) {
    Info_float info = new Info_float(name,a,b,c,d);
    list_float.add(info);
  }
  public void add(String name, float a, float b, float c, float d, float e) {
    Info_float info = new Info_float(name,a,b,c,d,e);
    list_float.add(info);
  }
  public void add(String name, float a, float b, float c, float d, float e, float f) {
    Info_float info = new Info_float(name,a,b,c,d,e,f);
    list_float.add(info);
  }
  public void add(String name, float a, float b, float c, float d, float e, float f, float g) {
    Info_float info = new Info_float(name,a,b,c,d,e,f,g);
    list_float.add(info);
  }

  // size
  public int size() {
    return list_float.size() ;
  }

  //read
  public void read() {
    println("Float list");
    for(Info a : list_float) {
      println(a,"Float");
    }
  }
   

  // get
  public Info_float get(int target) {
    if(target < list_float.size() && target >= 0) {
      return list_float.get(target);
    } else return null;
  }
  
  public Info_float [] get(String which) {
    Info_float [] info;
    int count = 0;
    for(Info_float a : list_float) {
      if(a.get_name().equals(which)) {
        count++;
      }
    }
    if (count > 0 ) {
      info = new Info_float[count] ;
      count = 0 ;
      for(Info_float a : list_float) {
        if(a.get_name().equals(which)) {
          info[count] = a;
          count++;
        }
      }
    } else {
      info = new Info_float[1] ;
      info[0] = null;
    }
    if(info.length == 1 && info[0] == null )return null ; else return info ;
  }

  // clear
  public void clear() {
    list_float.clear();
  }

  // remove
  public void remove(String which) {
    for(int i = 0 ; i < list_float.size() ; i++) {
      Info a = list_float.get(i) ;
      if(a.get_name().equals(which)) {
        list_float.remove(i);
      }
    }
  }
  
  public void remove(int target) {
   if(target < list_float.size()) {
      list_float.remove(target);
    }
  }
}



/**
Info_String_dict

*/
public class Info_String_dict extends Info_dict {
  ArrayList<Info_String> list_String ;
  Info_String_dict() {
    super('s');
    list_String = new ArrayList<Info_String>();
  }

  // add String
  public void add(String name, String a) {
    Info_String info = new Info_String(name,a);
    list_String.add(info);
  }
  public void add(String name, String a, String b) {
    Info_String info = new Info_String(name,a,b); 
    list_String.add(info);
  }
  public void add(String name, String a, String b, String c) {
    Info_String info = new Info_String(name,a,b,c);
    list_String.add(info);
  }
  public void add(String name, String a, String b, String c, String d) {
    Info_String info = new Info_String(name,a,b,c,d);
    list_String.add(info);
  }
  public void add(String name, String a, String b, String c, String d, String e) {
    Info_String info = new Info_String(name,a,b,c,d,e);
    list_String.add(info);
  }
  public void add(String name, String a, String b, String c, String d, String e, String f) {
    Info_String info = new Info_String(name,a,b,c,d,e,f);
    list_String.add(info);
  }
  public void add(String name, String a, String b, String c, String d, String e, String f,String g) {
    Info_String info = new Info_String(name,a,b,c,d,e,f,g);
    list_String.add(info);
  }

  // size
  public int size() {
    return list_String.size() ;
  }

  //read
  public void read() {
    println("String list");
    for(Info a : list_String) {
      println(a,"String");
    }
  }
  

  // get
  public Info_String get(int target) {
    if(target < list_String.size() && target >= 0) {
      return list_String.get(target);
    } else return null;
  }
  
  public Info_String [] get(String which) {
    Info_String [] info  ;
    int count = 0 ;
    for(Info_String a : list_String) {
      if(a.get_name().equals(which)) {
        count++;
      }
    }
    if (count > 0 ) {
      info = new Info_String[count] ;
      count = 0;
      for(Info_String a : list_String) {
        if(a.get_name().equals(which)) {
          info[count] = a;
          count++;
        }
      }
    } else {
      info = new Info_String[1];
      info[0] = null;
    }
    if(info.length == 1 && info[0] == null )return null ; else return info;
  }

  // clear
  public void clear() {
    list_String.clear();
  }

  // remove
  public void remove(String which) {
    for(int i = 0 ; i < list_String.size() ; i++) {
      Info_String a = list_String.get(i);
      if(a.get_name().equals(which)) {
        list_String.remove(i);
      }
    }
  }
  
  public void remove(int target) {
   if(target < list_String.size()) {
      list_String.remove(target);
    }
  }
}


/**
Info_vec_dict
*/
public class Info_vec_dict extends Info_dict {
  ArrayList<Info_vec> list_vec ;
  Info_vec_dict() {
    super('v') ;
    list_vec = new ArrayList<Info_vec>() ;
  }

  // add vec
  public void add(String name, vec a) {
    Info_vec info = new Info_vec(name,a);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b) {
    Info_vec info = new Info_vec(name,a,b);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b, vec c) {
    Info_vec info = new Info_vec(name,a,b,c);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b, vec c, vec d) {
    Info_vec info = new Info_vec(name,a,b,c,d);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b, vec c, vec d, vec e) {
    Info_vec info = new Info_vec(name,a,b,c,d,e);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b, vec c, vec d, vec e, vec f) {
    Info_vec info = new Info_vec(name,a,b,c,d,e,f);
    list_vec.add(info);
  }
  public void add(String name, vec a, vec b, vec c, vec d, vec e, vec f, vec g) {
    Info_vec info = new Info_vec(name,a,b,c,d,e,f,g);
    list_vec.add(info);
  }

  // size
  public int size() {
    return list_vec.size();
  }

  //read
  public void read() {
    println("vec list");
    for(Info a : list_vec) {
      println(a,"vec");
    }
  }
  

  // get
  public Info_vec get(int target) {
    if(target < list_vec.size() && target >= 0) {
      return list_vec.get(target);
    } else return null;
  }
  
  public Info_vec [] get(String which) {
    Info_vec [] info;
    int count = 0 ;
    for(Info_vec a : list_vec) {
      if(a.get_name().equals(which)) {
        count++;
      }
    }
    if (count > 0 ) {
      info = new Info_vec[count];
      count = 0 ;
      for(Info_vec a : list_vec) {
        if(a.get_name().equals(which)) {
          info[count] = a;
          count++ ;
        }
      }
    } else {
      info = new Info_vec[1];
      info[0] = null ;
    }
    if(info.length == 1 && info[0] == null )return null ; else return info;
  }

  // clear
  public void clear() {
    list_vec.clear();
  }

  // remove
  public void remove(String which) {
    for(int i = 0 ; i < list_vec.size() ; i++) {
      Info_vec a = list_vec.get(i) ;
      if(a.get_name().equals(which)) {
        list_vec.remove(i);
      }
    }
  }
  
  public void remove(int target) {
   if(target < list_vec.size()) {
      list_vec.remove(target);
    }
  }
}



/**
Info 0.1.0.2

*/
interface Info {
  public String get_name();

  public Object [] catch_all() ;
  public Object catch_obj(int arg);

  public char get_type();
}
 
abstract class Info_method implements Info {
  String name  ;
  // error message
  String error_target = "Your target is beyond of my knowledge !" ;
  String error_value_message = "This value is beyond of my power mate !" ;
  Info_method (String name) {
    this.name = name ;
  }


  public String get_name() { 
    return name ;
  }
}


/**
INFO int

*/
class Info_int extends Info_method {
  char type = 'i' ;
  int a, b, c, d, e, f, g ;
  int num_value ;  


  Info_int(String name) {
    super(name) ;
  }

  Info_int(String name, int... var) {
    super(name) ;
    if(var.length > 7 ) {
      num_value = 7 ; 
    } else {
      num_value = var.length ;
    }
    if(var.length > 0) this.a = var[0] ;
    if(var.length > 1) this.b = var[1] ;
    if(var.length > 2) this.c = var[2] ;
    if(var.length > 3) this.d = var[3] ;
    if(var.length > 4) this.e = var[4] ;
    if(var.length > 5) this.f = var[5] ;
    if(var.length > 6) this.g = var[6] ;
  }


  // get
  public int [] get() {
    int [] list = new int[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public int get(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      System.err.println(error_target) ;
      return 0 ;
    } 
  }
  
  public Object [] catch_all() {
    Object [] list = new Object[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object catch_obj(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      System.err.println(error_target) ;
      return null ;
    } 
  }
  
  public char get_type() { return type ; }

  // Print info
  public @Override String toString() {
    if(num_value == 1) {
      return "[ " + name + ": " + a + " ]";
    } else if(num_value == 2) {
      return "[ " + name + ": " + a + ", " + b + " ]";
    } else if(num_value == 3) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + " ]";
    } else if(num_value == 4) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + " ]";
    } else if(num_value == 5) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + " ]";
    } else if(num_value == 6) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + " ]";
    } else if(num_value == 7) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ", " + g +" ]";
    } else {
      System.err.println(num_value) ;
      System.err.println(error_value_message) ;
      return "hmmm hmmm there is problem with your stuff mate";
    }
  }
}

/**
INFO String
*/
class Info_String extends Info_method {
  char type = 's' ;
  String a, b, c, d, e, f, g ;
  int num_value ;  

  Info_String(String name) {
    super(name) ;
  }

  Info_String(String name, String... var) {
    super(name) ;
    if(var.length > 7 ) {
      num_value = 7 ; 
    } else {
      num_value = var.length ;
    }
    if(var.length > 0) this.a = var[0] ;
    if(var.length > 1) this.b = var[1] ;
    if(var.length > 2) this.c = var[2] ;
    if(var.length > 3) this.d = var[3] ;
    if(var.length > 4) this.e = var[4] ;
    if(var.length > 5) this.f = var[5] ;
    if(var.length > 6) this.g = var[6] ;
  }


  // get
  public String [] get() {
    String [] list = new String[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public String get(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    }else {
      System.err.println(error_target) ;
      return null ;
    }
  }
  
  public Object [] catch_all() {
    Object [] list = new Object[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object catch_obj(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    }else {
      System.err.println(error_target) ;
      return null ;
    }
  }

  public char get_type() { return type ; }


  // Print info
  public @Override String toString() {
    if(num_value == 1) {
      return "[ " + name + ": " + a + " ]";
    } else if(num_value == 2) {
      return "[ " + name + ": " + a + ", " + b + " ]";
    } else if(num_value == 3) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + " ]";
    } else if(num_value == 4) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + " ]";
    } else if(num_value == 5) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + " ]";
    } else if(num_value == 6) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + " ]";
    } else if(num_value == 7) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ", " + g + " ]";
    } else {
      System.err.println(num_value) ;
      System.err.println(error_value_message) ;
      return "hmmm hmmm there is problem with your stuff mate";
    }
  }
}

/**
INFO float
*/
class Info_float extends Info_method {
  char type = 'f' ;
  float a, b, c, d, e, f, g ;
  int num_value ; 

  Info_float(String name) {
    super(name) ;
  }

  Info_float(String name, float... var) {
    super(name) ;
    if(var.length > 7 ) {
      num_value = 7 ; 
    } else {
      num_value = var.length ;
    }
    if(var.length > 0) this.a = var[0] ;
    if(var.length > 1) this.b = var[1] ;
    if(var.length > 2) this.c = var[2] ;
    if(var.length > 3) this.d = var[3] ;
    if(var.length > 4) this.e = var[4] ;
    if(var.length > 5) this.f = var[5] ;
    if(var.length > 6) this.g = var[6] ;
  }

  // get
  public float [] get() {
    float [] list = new float[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public float get(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      System.err.println(error_target) ;
      return 0.0f ;
    }
  }
  
  public Object [] catch_all() {
    Object [] list = new Object[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object catch_obj(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      System.err.println(error_target) ;
      return null ;
    }
  }

  public char get_type() { return type ; }
  
  // Print info
  public @Override String toString() {
    if(num_value == 1) {
      return "[ " + name + ": " + a + " ]";
    } else if(num_value == 2) {
      return "[ " + name + ": " + a + ", " + b + " ]";
    } else if(num_value == 3) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + " ]";
    } else if(num_value == 4) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + " ]";
    } else if(num_value == 5) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + " ]";
    } else if(num_value == 6) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + " ]";
    } else if(num_value == 7) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ", " + g + " ]";
    } else {
      System.err.println(num_value) ;
      System.err.println(error_value_message) ;
      return "hmmm hmmm there is problem with your stuff mate";
    }
  }
}

/**
INFO vec
v 0.0.2
*/
class Info_vec extends Info_method {
  char type = 'v' ;
  vec a, b, c, d, e, f, g ;
  int num_value ;  

  Info_vec(String name) {
    super(name) ;
  }

  // vec value
  Info_vec(String name, vec... var) {
    super(name) ;
    if(var.length > 7 ) {
      num_value = 7 ; 
    } else {
      num_value = var.length ;
    }
    if(var.length > 0) this.a = var[0] ;
    if(var.length > 1) this.b = var[1] ;
    if(var.length > 2) this.c = var[2] ;
    if(var.length > 3) this.d = var[3] ;
    if(var.length > 4) this.e = var[4] ;
    if(var.length > 5) this.f = var[5] ;
    if(var.length > 6) this.g = var[6] ;
  }




  // get
  public vec [] get() {
    vec [] list = new vec[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public vec get(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    }else {
      System.err.println(error_target) ;
      return null;
    }
  }
  
  public Object [] catch_all() {
    Object [] list = new Object[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object catch_obj(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      System.err.println(error_target) ;
      return null ;
    }
  }

  public char get_type() { return type; }

  // Print info
  public @Override String toString() {
    if(num_value == 1) {
      return "[ " + name + ": " + a + " ]";
    } else if(num_value == 2) {
      return "[ " + name + ": " + a + ", " + b + " ]";
    } else if(num_value == 3) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + " ]";
    } else if(num_value == 4) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + " ]";
    } else if(num_value == 5) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + " ]";
    } else if(num_value == 6) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + " ]";
    } else if(num_value == 7) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ", " + g + " ]";
    } else {
      System.err.println(num_value) ;
      System.err.println(error_value_message) ;
      return "hmmm hmmm there is problem with your stuff mate";
    }
  }
}




/**
INFO OBJECT
v 0.0.2
*/
class Info_Object extends Info_method {
  char type = 'o' ;
  Object a, b, c, d, e, f, g ;
  int num_value ;

  Info_Object(String name) {
    super(name) ;
  }


  // Object value
  Info_Object(String name, Object... var) {
    super(name) ;
    if(var.length > 7 ) {
      num_value = 7 ; 
    } else {
      num_value = var.length ;
    }
    if(var.length > 0) this.a = var[0] ;
    if(var.length > 1) this.b = var[1] ;
    if(var.length > 2) this.c = var[2] ;
    if(var.length > 3) this.d = var[3] ;
    if(var.length > 4) this.e = var[4] ;
    if(var.length > 5) this.f = var[5] ;
    if(var.length > 6) this.g = var[6] ;
  }


  // get
  public Object [] get() {
    Object [] list = new Object []{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object get(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      printErr(error_target) ;
      return null ;
    }
  }
  
  public Object [] catch_all() {
    Object [] list = new Object[]{a,b,c,d,e,f,g} ;
    return list ;
  }

  public Object catch_obj(int which) {
    if(which == 0) {
      return a ; 
    } else if(which == 1) {
      return b ;
    } else if(which == 2) {
      return c ;
    } else if(which == 3) {
      return d ;
    } else if(which == 4) {
      return e ;
    } else if(which == 5) {
      return f ;
    } else if(which == 6) {
      return g ;
    } else {
      printErr(error_target) ;
      return null ;
    }
  }
  
  public char get_type() { return type ; }


  // Print info
  public @Override String toString() {
    if(num_value == 1) {
      return "[ " + name + ": " + a + " ]";
    } else if(num_value == 2) {
      return "[ " + name + ": " + a + ", " + b + " ]";
    } else if(num_value == 3) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + " ]";
    } else if(num_value == 4) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + " ]";
    } else if(num_value == 5) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + " ]";
    } else if(num_value == 6) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + " ]";
    } else if(num_value == 7) {
      return "[ " + name + ": " + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ", " + g + " ]";
    } else {
      printErr(num_value) ;
      printErr(error_value_message) ;
      return "hmmm hmmm there is problem with your stuff mate";
    }
  }
}
/**
END INFO LIST
*/


/**
Vec, iVec and bVec rope method
v 0.4.1
* Copyleft (c) 2018-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/




/**
Addition
v 0.0.4
*/
/**
* return the resultat of vector addition
*/
public ivec2 iadd(ivec2 a, ivec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x + b.x ;
    int y = a.y + b.y ;
    return new ivec2(x,y) ;
  }
}

public ivec3 iadd(ivec3 a, ivec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x + b.x ;
    int y = a.y + b.y ;
    int z = a.z + b.z ;
    return new ivec3(x,y,z)  ;
  }
}

public ivec4 iadd(ivec4 a, ivec4 b) {  
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x + b.x ;
    int y = a.y + b.y ;
    int z = a.z + b.z ;
    int w = a.w + b.w ;
    return new ivec4(x,y,z,w)  ;
  }
}

public ivec2 iadd(ivec2 a, int arg) {
  return iadd(a,ivec2(arg,arg));
}

public ivec3 iadd(ivec3 a, int arg) {
  return iadd(a,ivec3(arg,arg,arg));
}

public ivec4 iadd(ivec4 a, int arg) {  
  return iadd(a,ivec4(arg,arg,arg,arg));
}




/**
Multiplication
v 0.0.1
*/
/**
* return the resultat of vector multiplication
*/
public ivec2 imult(ivec2 a, ivec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x * b.x;
    int y = a.y * b.y;
    return new ivec2(x,y);
  }
}

public ivec3 imult(ivec3 a, ivec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x * b.x;
    int y = a.y * b.y;
    int z = a.z * b.z;
    return new ivec3(x,y,z);
  }
}

public ivec4 imult(ivec4 a, ivec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x * b.x;
    int y = a.y * b.y;
    int z = a.z * b.z;
    int w = a.w * b.w;
    return new ivec4(x,y,z,w);
  }
}

public ivec2 imult(ivec2 a, int arg) {
  return imult(a,ivec2(arg,arg));
}

public ivec3 imult(ivec3 a, int arg) {
  return imult(a,ivec3(arg,arg,arg));
}

public ivec4 imult(ivec4 a, int arg) {  
  return imult(a,ivec4(arg,arg,arg,arg));
}


/**
Division
v 0.0.3
*/
/**
* return the resultat of vector division
*/
public ivec2 idiv(ivec2 a, ivec2 b) {
  if(a == null || b == null) {
    return null;
  } else {
    int x = a.x / b.x;
    int y = a.y / b.y;
    return new ivec2(x,y);
  }
}

public ivec3 idiv(ivec3 a, ivec3 b) {
  if(a == null || b == null) {
    return null;
  } else {
    int x = a.x / b.x;
    int y = a.y / b.y;
    int z = a.z / b.z;
    return new ivec3(x,y,z);
  }
}

public ivec4 idiv(ivec4 a, ivec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x / b.x;
    int y = a.y / b.y;
    int z = a.z / b.z;
    int w = a.w / b.w;
    return new ivec4(x,y,z,w);
  }
}

public ivec2 idiv(ivec2 a, int arg) {
  return idiv(a,ivec2(arg,arg));
}

public ivec3 idiv(ivec3 a, int arg) {
  return idiv(a,ivec3(arg,arg,arg));
}

public ivec4 idiv(ivec4 a, int arg) {  
  return idiv(a,ivec4(arg,arg,arg,arg));
}



/**
Substraction
v 0.0.1
*/
/**
* return the resultat of vector substraction
*/
public ivec2 isub(ivec2 a, ivec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x - b.x;
    int y = a.y - b.y;
    return new ivec2(x,y);
  }
}

public ivec3 isub(ivec3 a, ivec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x - b.x;
    int y = a.y - b.y;
    int z = a.z - b.z;
    return new ivec3(x,y,z);
  }
}

public ivec4 isub(ivec4 a, ivec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    int x = a.x - b.x;
    int y = a.y - b.y;
    int z = a.z - b.z;
    int w = a.w - b.w;
    return new ivec4(x,y,z,w);
  }
}

public ivec2 isub(ivec2 a, int arg) {
  return isub(a,ivec2(arg,arg));
}

public ivec3 isub(ivec3 a, int arg) {
  return isub(a,ivec3(arg,arg,arg));
}

public ivec4 isub(ivec4 a, int arg) {  
  return isub(a,ivec4(arg,arg,arg,arg));
}




































/**
METHOD
Vec
v 1.0.0
*/
/**
Addition
v 0.0.4
*/
/**
* return the resultat of vector addition
*/
public vec2 add(vec2 a, vec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x + b.x ;
    float y = a.y + b.y ;
    return new vec2(x,y) ;
  }
}

public vec3 add(vec3 a, vec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x + b.x ;
    float y = a.y + b.y ;
    float z = a.z + b.z ;
    return new vec3(x,y,z)  ;
  }
}

public vec4 add(vec4 a, vec4 b) {  
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x + b.x ;
    float y = a.y + b.y ;
    float z = a.z + b.z ;
    float w = a.w + b.w ;
    return new vec4(x,y,z,w)  ;
  }
}
/**
* iVec arg
*/
public vec2 add(ivec2 a, ivec2 b) {
  return add(vec2(a),vec2(b));
}

public vec3 add(ivec3 a, ivec3 b) {
  return add(vec3(a),vec3(b));
}

public vec4 add(ivec4 a, ivec4 b) {  
  return add(vec4(a),vec4(b));
}
/**
* float arg
*/
public vec2 add(vec2 a, float arg) {
  return add(a,vec2(arg,arg));
}

public vec3 add(vec3 a, float arg) {
  return add(a,vec3(arg,arg,arg));
}

public vec4 add(vec4 a, float arg) {  
  return add(a,vec4(arg,arg,arg,arg));
}
/**
* iVec + float
*/

public vec2 add(ivec2 a, float arg) {
  return add(vec2(a),vec2(arg,arg));
}

public vec3 add(ivec3 a, float arg) {
  return add(vec3(a),vec3(arg,arg,arg));
}

public vec4 add(ivec4 a, float arg) {  
  return add(vec4(a),vec4(arg,arg,arg,arg));
}




/**
Multiplication
v 0.0.4
*/
/**
* return the resultat of vector multiplication
*/
public vec2 mult(vec2 a, vec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x * b.x;
    float y = a.y * b.y;
    return new vec2(x,y);
  }
}

public vec3 mult(vec3 a, vec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x * b.x;
    float y = a.y * b.y;
    float z = a.z * b.z;
    return new vec3(x,y,z);
  }
}

public vec4 mult(vec4 a, vec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x * b.x;
    float y = a.y * b.y;
    float z = a.z * b.z;
    float w = a.w * b.w;
    return new vec4(x,y,z,w);
  }
}
/**
* iVec arg
*/
public vec2 mult(ivec2 a, ivec2 b) {
  return mult(vec2(a),vec2(b));
}

public vec3 mult(ivec3 a, ivec3 b) {
  return mult(vec3(a),vec3(b));
}

public vec4 mult(ivec4 a, ivec4 b) {  
  return mult(vec4(a),vec4(b));
}

/**
* float arg
*/
public vec2 mult(vec2 a, float arg) {
  return mult(a,vec2(arg,arg));
}

public vec3 mult(vec3 a, float arg) {
  return mult(a,vec3(arg,arg,arg));
}

public vec4 mult(vec4 a, float arg) {  
  return mult(a,vec4(arg,arg,arg,arg));
}
/**
* iVec + float
*/
public vec2 mult(ivec2 a, float arg) {
  return mult(vec2(a),vec2(arg,arg));
}

public vec3 mult(ivec3 a, float arg) {
  return mult(vec3(a),vec3(arg,arg,arg));
}

public vec4 mult(ivec4 a, float arg) {  
  return mult(vec4(a),vec4(arg,arg,arg,arg));
}




/**
Division
v 0.0.4
*/
/**
* return the resultat of vector division
*/
public vec2 div(vec2 a, vec2 b) {
  if(a == null || b == null) {
    return null;
  } else {
    float x = a.x /b.x;
    float y = a.y /b.y;
    return new vec2(x,y);
  }
}

public vec3 div(vec3 a, vec3 b) {
  if(a == null || b == null) {
    return null;
  } else {
    float x = a.x /b.x;
    float y = a.y /b.y;
    float z = a.z /b.z;
    return new vec3(x,y,z);
  }
}

public vec4 div(vec4 a, vec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x /b.x;
    float y = a.y /b.y;
    float z = a.z /b.z;
    float w = a.w /b.w;
    return new vec4(x,y,z,w);
  }
}
/**
* iVec arg
*/
public vec2 div(ivec2 a, ivec2 b) {
  return div(vec2(a),vec2(b));
}

public vec3 div(ivec3 a, ivec3 b) {
  return div(vec3(a),vec3(b));
}

public vec4 div(ivec4 a, ivec4 b) {  
  return div(vec4(a),vec4(b));
}
/**
* float arg
*/
public vec2 div(vec2 a, float arg) {
  return div(a,vec2(arg,arg));
}

public vec3 div(vec3 a, float arg) {
  return div(a,vec3(arg,arg,arg));
}

public vec4 div(vec4 a, float arg) {  
  return div(a,vec4(arg,arg,arg,arg));
}
/**
* iVec + float
*/
public vec2 div(ivec2 a, float arg) {
  return div(vec2(a),vec2(arg,arg));
}

public vec3 div(ivec3 a, float arg) {
  return div(vec3(a),vec3(arg,arg,arg));
}

public vec4 div(ivec4 a, float arg) {  
  return div(vec4(a),vec4(arg,arg,arg,arg));
}


/**
Substraction
v 0.0.5
*/
/**
* return the resultat of vector substraction
*/
public vec2 sub(vec2 a, vec2 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x - b.x;
    float y = a.y - b.y;
    return new vec2(x,y);
  }
}

public vec3 sub(vec3 a, vec3 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x - b.x;
    float y = a.y - b.y;
    float z = a.z - b.z;
    return new vec3(x,y,z);
  }
}

public vec4 sub(vec4 a, vec4 b) {
  if(a == null || b == null) {
    return null ;
  } else {
    float x = a.x - b.x;
    float y = a.y - b.y;
    float z = a.z - b.z;
    float w = a.w - b.w;
    return new vec4(x,y,z,w);
  }
}
/**
* iVec arg
*/
public vec2 sub(ivec2 a, ivec2 b) {
  return sub(vec2(a),vec2(b));
}

public vec3 sub(ivec3 a, ivec3 b) {
  return sub(vec3(a),vec3(b));
}

public vec4 sub(ivec4 a, ivec4 b) {  
  return sub(vec4(a),vec4(b));
}
/**
* float arg
*/
public vec2 sub(vec2 a, float arg) {
  return sub(a,vec2(arg,arg));
}

public vec3 sub(vec3 a, float arg) {
  return sub(a,vec3(arg,arg,arg));
}

public vec4 sub(vec4 a, float arg) {  
  return sub(a,vec4(arg,arg,arg,arg));
}
/**
* iVec + float
*/
public vec2 sub(ivec2 a, float arg) {
  return sub(vec2(a),vec2(arg,arg));
}

public vec3 sub(ivec3 a, float arg) {
  return sub(vec3(a),vec3(arg,arg,arg));
}

public vec4 sub(ivec4 a, float arg) {  
  return sub(vec4(a),vec4(arg,arg,arg,arg));
}



/**
Cross
v 0.0.2
*/
public vec3 cross(vec3 v1, vec3 v2) {
  if(v1 == null ||  v2 == null) {
    return null;
  } else {
    float crossX = v1.y * v2.z - v2.y * v1.z;
    float crossY = v1.z * v2.x - v2.z * v1.x;
    float crossZ = v1.x * v2.y - v2.x * v1.y;
    return vec3(crossX, crossY, crossZ);
  }
}
/**
* @deprecated "cross(vec3 v1, vec3 v2, vec3 target), can be deprecated in the future, need to be test"
*/
public @Deprecated
vec3 cross(vec3 v1, vec3 v2, vec3 target) {
  println("cross(vec3 v1, vec3 v2, vec3 target), can be deprecated in the future, need to be test");
  if(v1 == null ||  v2 == null || target == null) {
    return null ;
  } else {
    float crossX = v1.y * v2.z - v2.y * v1.z;
    float crossY = v1.z * v2.x - v2.z * v1.x;
    float crossZ = v1.x * v2.y - v2.x * v1.y;

    if (target == null) {
      target = vec3(crossX, crossY, crossZ);
    } else {
      target.set(crossX, crossY, crossZ);
    }
    return target ;
  }  
}



/**
Equals
v 0.0.2
*/
/*
@Deprecated // use compare()
boolean equals(vec2 v_a, vec2 v_b) {
  return compare(v_a,v_b);
}

@Deprecated // use compare()
boolean equals(vec3 v_a, vec3 v_b) {
  return compare(v_a,v_b);
}

@Deprecated // use compare()
boolean equals(vec4 v_a, vec4 v_b) {
  return compare(v_a,v_b);
}

@Deprecated // use compare()
boolean equals(vec2 v_a, vec2 v_b, vec2 area) {
  return compare(v_a,v_b, area);
}

@Deprecated // use compare()
boolean equals(vec3 v_a, vec3 v_b, vec3 area) {
   return compare(v_a,v_b, area);
}

@Deprecated // use compare()
boolean equals(vec4 v_a, vec4 v_b, vec4 area) {
  return compare(v_a,v_b, area);
}
*/



/** 
* compare if the first vector is in the area of the second vector, 
* the area of the second vector is define by a Vec area, 
* that give the possibility of different size for each component
* @return boolean
* v 0.2.0
*/

public boolean compare(ivec2 a, ivec2 b) {
  return compare(vec2(a),vec2(b));
}

public boolean compare(ivec3 a, ivec3 b) {
  return compare(vec3(a),vec3(b));
}

public boolean compare(ivec4 a, ivec4 b) {
  return compare(vec4(a),vec4(b));
}


public boolean compare(vec2 a, vec2 b) {
  if(a == null || b == null) {
    println("Is not possible to compare", a, "to", b) ;
    return false ;
  } else {
    return compare(vec4(a.x,a.y,0,0),vec4(b.x,b.y,0,0)) ;
  }
}

// vec3 compare
public boolean compare(vec3 a, vec3 b) {
    if(a == null || b == null) {
    println("Is not possible to compare", a, "to", b) ;
    return false ;
  } else {
    return compare(vec4(a.x,a.y,a.z, 0),vec4(b.x,b.y,b.z, 0)) ;
  }
}
// vec4 compare
public boolean compare(vec4 a, vec4 b) {
  if(a != null && b != null ) {
    if((a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w)) {
      return true ; 
    } else {
      return false ;
    }
  } else {
    return false ;
  } 
}


/**
* compare with area
*/
public boolean compare(ivec2 a, ivec2 b, ivec2 area) {
  return compare(vec2(a),vec2(b),vec2(area));
}

public boolean compare(ivec3 a, ivec3 b, ivec3 area) {
  return compare(vec3(a),vec3(b),vec3(area));
}

public boolean compare(ivec4 a, ivec4 b, ivec4 area) {
  return compare(vec4(a),vec4(b),vec4(area));
}

public boolean compare(vec2 a, vec2 b, vec2 area) {
  if(a == null || b == null || area == null) {
    println("Is not possible to compare", a, "with", b, "with", area) ;
    return false ;
  } else {
    return compare(vec4(a.x,a.y, 0, 0),vec4(b.x,b.y, 0, 0),vec4(area.x, area.y, 0, 0)) ;
  }
}

public boolean compare(vec3 a, vec3 b, vec3 area) {
    if(a == null || b == null || area == null) {
    println("Is not possible to compare", a, "with", b, "with", area) ;
    return false ;
  } else {
    return compare(vec4(a.x,a.y,a.z, 0),vec4(b.x,b.y,b.z, 0),vec4(area.x, area.y, area.z, 0)) ;
  }
}

public boolean compare(vec4 a, vec4 b, vec4 area) {
  if(a != null && b != null && area != null ) {
    if(    (a.x >= b.x -area.x && a.x <= b.x +area.x) 
        && (a.y >= b.y -area.y && a.y <= b.y +area.y) 
        && (a.z >= b.z -area.z && a.z <= b.z +area.z) 
        && (a.w >= b.w -area.w && a.w <= b.w +area.w)) {
            return true ; 
    } else {
      return false ;
    }
  } else {
    return false ;
  }
}









/**
Map
*/
/**
* return mapping vector
* @return Vec
*/
public vec2 map(vec2 v,float minIn, float maxIn, float minOut, float maxOut) {
  if(v != null) {
    float x = map(v.x, minIn, maxIn, minOut, maxOut) ;
    float y = map(v.y, minIn, maxIn, minOut, maxOut) ;
    return new vec2(x,y) ;
  } else return null ;
}


public vec3 map(vec3 v,float minIn, float maxIn, float minOut, float maxOut) {
  if(v != null) {
    float x = map(v.x, minIn, maxIn, minOut, maxOut) ;
    float y = map(v.y, minIn, maxIn, minOut, maxOut) ;
    float z = map(v.z, minIn, maxIn, minOut, maxOut) ;
    return new vec3(x,y,z) ;
  } else return null ;
}


public vec4 map(vec4 v,float minIn, float maxIn, float minOut, float maxOut) {
  if(v != null) {
    float x = map(v.x, minIn, maxIn, minOut, maxOut) ;
    float y = map(v.y, minIn, maxIn, minOut, maxOut) ;
    float z = map(v.z, minIn, maxIn, minOut, maxOut) ;
    float w = map(v.w, minIn, maxIn, minOut, maxOut) ;
    return new vec4(x,y,z,w) ;
  } else return null ;
}


/**
Magnitude or length
*/
/**
* @return float
*/
// mag vec2
public float mag(vec2 a) {
  float x = a.x*a.x ;
  float y = a.y *a.y ;
  return sqrt(x+y) ;
}

public float mag(vec2 a, vec2 b) {
  // same result than dist
  float x = (b.x -a.x)*(b.x -a.x) ;
  float y = (b.y -a.y)*(b.y -a.y) ;
  return sqrt(x+y) ;
}
// mag vec3
public float mag(vec3 a) {
  float x = a.x*a.x ;
  float y = a.y *a.y ;
  float z = a.z *a.z ;
  return sqrt(x+y+z) ;
}

public float mag(vec3 a, vec3 b) {
  // same result than dist
  float x = (b.x -a.x)*(b.x -a.x) ;
  float y = (b.y -a.y)*(b.y -a.y) ;
  float z = (b.z -a.z)*(b.z -a.z) ;
  return sqrt(x+y+z) ;
}
// mag vec4
public float mag(vec4 a) {
  float x = a.x*a.x ;
  float y = a.y*a.y ;
  float z = a.z*a.z ;
  float w = a.w*a.w ;
  return sqrt(x+y+z+w) ;
}

public float mag(vec4 a, vec4 b) {
  // same result than dist
  float x = (b.x -a.x)*(b.x -a.x) ;
  float y = (b.y -a.y)*(b.y -a.y) ;
  float z = (b.z -a.z)*(b.z -a.z) ;
  float w = (b.w -a.w)*(b.w -a.w) ;
  return sqrt(x+y+z+w) ;
}



/**
Distance
v 0.0.2
*/
/**
* return the distance beatwen two vectors
* @return float
*/
public float dist(vec2 a, vec2 b) {
  if(a != null && b != null) {
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    return (float) Math.sqrt(dx*dx + dy*dy);
  } else return Float.NaN ;
    
}
public float dist(vec3 a, vec3 b) {
  if(a != null && b != null) {
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    float dz = a.z - b.z;
    return (float) Math.sqrt(dx*dx + dy*dy + dz*dz);
  } else return Float.NaN ;
}

public float dist(vec4 a, vec4 b) {
  if(a != null && b != null) {
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    float dz = a.z - b.z;
    float dw = a.w - b.w;
    return (float) Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
  } else return Float.NaN ;
}


/**
Deprecated Middle
*/
/**
* return the middle between two Vector
* @return Vec
*/
public vec2 middle(vec2 a, vec2 b)  {
  vec2 middle ;
  middle = add(a,b);
  middle.div(2) ;
  println("The method middle is deprecated instead use barycenter(Vec... arg)") ;
  return middle ;
}

public vec2 middle(vec2 [] list)  {
  vec2 middle = vec2() ;
  for (int i = 0 ; i < list.length ; i++) {
    middle.add(list[i]);
  }
  middle.div(list.length) ;
  println("The method middle is deprecated instead use barycenter(Vec... arg)") ;
  return middle ;
}

public vec3 middle(vec3 a, vec3 b) {
  vec3 middle ;
  middle = add(a,b);
  middle.div(2) ;
  return middle ;
}

public vec3 middle(vec3 [] list)  {
  vec3 middle = vec3() ;
  for (int i = 0 ; i < list.length ; i++) {
    middle.add(list[i]);
  }
  middle.div(list.length) ;
  println("The method middle is deprecated instead use barycenter(Vec... arg)") ;
  return middle ;
}

public vec4 middle(vec4 a, vec4 b)  {
  vec4 middle ;
  middle = add(a,b);
  middle.div(2) ;
  println("The method middle is deprecated instead use barycenter(Vec... arg)") ;
  return middle ;
}

public vec4 middle(vec4 [] list)  {
  vec4 middle = vec4() ;
  for (int i = 0 ; i < list.length ; i++) {
    middle.add(list[i]);
  }
  middle.div(list.length) ;
  println("The method middle is deprecated instead use barycenter(Vec... arg)") ;
  return middle ;
}


/**
barycenter
*/
public vec2 barycenter(vec2... v) {
  int div_num = v.length ;
  vec2 sum = vec2() ;
  for(int i = 0 ; i < div_num ; i++) {
    sum.add(v[i]) ;
  }
  return sum.div(div_num) ;
}

 
public vec3 barycenter(vec3... v) {
  int div_num = v.length ;
  vec3 sum = vec3() ;
  for(int i = 0 ; i < div_num ; i++) {
    sum.add(v[i]) ;
  }
  return sum.div(div_num) ;
}

public vec4 barycenter(vec4... v) {
  int div_num = v.length ;
  vec4 sum = vec4() ;
  for(int i = 0 ; i < div_num ; i++) {
    sum.add(v[i]) ;
  }
  return sum.div(div_num) ;
}





/**
Jitter
v 0.0.2
*/
// vec2
public vec2 jitter_2D(int range) {
  return jitter_2D(range, range) ;
}
public vec2 jitter_2D(vec2 range) {
  return jitter_2D((int)range.x, (int)range.y) ;
}
public vec2 jitter_2D(int range_x, int range_y) {
  vec2 jitter = vec2() ;
  jitter.x = random_next_gaussian(range_x, 2);
  jitter.y = random_next_gaussian(range_y, 2);
  return jitter ;
}
// vec3
public vec3 jitter_3D(int range) {
  return jitter_3D(range, range, range) ;
}
public vec3 jitter_3D(vec3 range) {
  return jitter_3D((int)range.x, (int)range.y, (int)range.z) ;
}
public vec3 jitter_3D(int range_x, int range_y, int range_z) {
  vec3 jitter = vec3() ;
  jitter.x = random_next_gaussian(range_x, 2);
  jitter.y = random_next_gaussian(range_y, 2);
  jitter.z = random_next_gaussian(range_z, 2);
  return jitter ;
}
// vec4
public vec4 jitter_4D(int range) {
  return jitter_4D(range, range, range, range) ;
}
public vec4 jitter_4D(vec4 range) {
  return jitter_4D((int)range.x, (int)range.y, (int)range.z, (int)range.w) ;
}
public vec4 jitter_4D(int range_x, int range_y, int range_z, int range_w) {
  vec4 jitter = vec4() ;
  jitter.x = random_next_gaussian(range_x, 2);
  jitter.y = random_next_gaussian(range_y, 2);
  jitter.z = random_next_gaussian(range_z, 2);
  jitter.w = random_next_gaussian(range_w, 2);
  return jitter ;
}
// END JITTER
/////////////


/**
Normalize
*/
// VEC 2 from angle
///////////////////
public vec2 norm_rad(float angle) {
  float x = (float)Math.cos(angle) ;
  float y = (float)Math.sin(angle) ;
  return vec2(x,y) ;
}

public vec2 norm_deg(float angle) {
  angle = radians(angle) ;
  float x = (float)Math.cos(angle) ;
  float y = (float)Math.sin(angle) ;
  return vec2(x,y) ;
}


// normalize direction
public vec2 norm_dir(String type, float direction) {
  float x, y = 0 ;
  if(type.equals("DEG")) {
    float angle = TWO_PI/360.f;
    direction = 360-direction;
    direction += 180;
    x = sin(angle *direction) ;
    y = cos(angle *direction);
  } else if (type.equals("RAD")) {
    x = sin(direction) ;
    y = cos(direction);
  } else {
    println("the type must be 'RAD' for radians or 'DEG' for degrees") ;
    x = 0 ;
    y = 0 ;
  }
  return new vec2(x,y) ;
}





























/**
New Vec, iVec and bVec
v 0.0.3
*/

/**
Return a new bVec
*/
/**
* @return bVec
*/
/**
bvec2
*/
public bvec2 bvec2() {
  return new bvec2(false,false) ;
}

public bvec2 bvec2(boolean b) {
  return new bvec2(b,b);
}

public bvec2 bvec2(boolean x, boolean y) { 
  return new bvec2(x,y) ;
}

public bvec2 bvec2(boolean [] array) {
  if(array.length == 1) {
    return new bvec2(array[0],array[0]);
  } else if (array.length > 1) {
    return new bvec2(array[0],array[1]);
  } else {
    return null;
  }
}

public bvec2 bvec2(bvec b) {
  if(b == null) {
    println("bVec null, instead 'false' is used to build bVec") ;
    return new bvec2(false,false) ;
  } else if(b instanceof bvec5 || b instanceof bvec6) {
    return new bvec2(b.a(),b.b()) ;
  } else {
    return new bvec2(b.x,b.y) ;
  }
}

/**
ivec3
*/
public bvec3 bvec3() {
  return new bvec3(false,false,false) ;
}

public bvec3 bvec3(boolean b) {
  return new bvec3(b,b,b);
}

public bvec3 bvec3(boolean x, boolean y, boolean z) { 
  return new bvec3(x,y,z) ;
}

public bvec3 bvec3(boolean [] array) {
  if(array.length == 1) {
    return new bvec3(array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new bvec3(array[0],array[1],false);
  } else if (array.length > 2) {
    return new bvec3(array[0],array[1],array[2]);
  } else {
    return null;
  }
}

public bvec3 bvec3(bvec b) {
  if(b == null) {
    println("bVec null, instead 'false' is used to build bVec") ;
    return new bvec3(false,false,false) ;
  } else {
    return new bvec3(b.x,b.y,b.z) ;
  }
}

/**
ivec4
*/
public bvec4 bvec4() {
  return new bvec4(false,false,false,false) ;
}

public bvec4 bvec4(boolean b) {
  return new bvec4(b,b,b,b);
}

public bvec4 bvec4(boolean x, boolean y, boolean z, boolean w) { 
  return new bvec4(x,y,z,w) ;
}

public bvec4 bvec4(boolean [] array) {
  if(array.length == 1) {
    return new bvec4(array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new bvec4(array[0],array[1],false,false);
  } else if (array.length == 3) {
    return new bvec4(array[0],array[1],array[2],false);
  } else if (array.length > 3) {
    return new bvec4(array[0],array[1],array[2],array[3]);
  } else {
    return null;
  }
}

public bvec4 bvec4(bvec b) {
  if(b == null) {
    println("bVec null, instead 'false' is used to build bVec") ;
    return new bvec4(false,false,false,false) ;
  } else {
    return new bvec4(b.x,b.y,b.z,b.w) ;
  }
}

/**
ivec5
*/
public bvec5 bvec5() {
  return new bvec5(false,false,false,false,false) ;
}

public bvec5 bvec5(boolean b) {
  return new bvec5(b,b,b,b,b);
}

public bvec5 bvec5(boolean a, boolean b, boolean c, boolean d, boolean e) { 
  return new bvec5(a,b,c,d,e) ;
}

public bvec5 bvec5(boolean [] array) {
  if(array.length == 1) {
    return new bvec5(array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new bvec5(array[0],array[1],false,false,false);
  } else if (array.length == 3) {
    return new bvec5(array[0],array[1],array[2],false,false);
  } else if (array.length == 4) {
    return new bvec5(array[0],array[1],array[2],array[3],false);
  } else if (array.length >4) {
    return new bvec5(array[0],array[1],array[2],array[3],array[4]);
  } else {
    return null;
  }
}

public bvec5 bvec5(bvec b) {
  if(b == null) {
    println("bVec null, instead 'false' is used to build bVec") ;
    return new bvec5(false,false,false,false,false) ;
  } else if(b instanceof bvec5 || b instanceof bvec6) {
    return new bvec5(b.a(),b.b(),b.c(),b.d(),b.e) ;
  } else {
    return new bvec5(b.x,b.y,b.z,b.w,false) ;
  }
}

/**
bvec6
*/
public bvec6 bvec6() {
  return new bvec6(false,false,false,false,false,false) ;
}

public bvec6 bvec6(boolean b) {
  return new bvec6(b,b,b,b,b,b);
}

public bvec6 bvec6(boolean a, boolean b, boolean c, boolean d, boolean e, boolean f) { 
  return new bvec6(a,b,c,d,e,f) ;
}

public bvec6 bvec6(boolean [] array) {
  if(array.length == 1) {
    return new bvec6(array[0],array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new bvec6(array[0],array[1],false,false,false,false);
  } else if (array.length == 3) {
    return new bvec6(array[0],array[1],array[2],false,false,false);
  } else if (array.length == 4) {
    return new bvec6(array[0],array[1],array[2],array[3],false,false);
  } else if (array.length == 5) {
    return new bvec6(array[0],array[1],array[2],array[3],array[4],false);
  }  else if (array.length > 5) {
    return new bvec6(array[0],array[1],array[2],array[3],array[4],array[5]);
  } else {
    return null;
  }
}

public bvec6 bvec6(bvec b) {
  if(b== null) {
    println("bVec null, instead 'false' is used to build bVec") ;
    return new bvec6(false,false,false,false,false,false) ;
  } else if(b instanceof bvec5 || b instanceof bvec6) {
    return new bvec6(b.a(),b.b(),b.c(),b.d(),b.e,b.f) ;
  } else {
    return new bvec6(b.x,b.y,b.z,b.w,false,false) ;
  }
}

























/**
Return a new iVec
*/
/**
ivec2
*/
public ivec2 ivec2() {
  return ivec2(0) ;
}

public ivec2 ivec2(int v) {
  return new ivec2(v,v);
}

public ivec2 ivec2(int x, int y) { 
  return new ivec2(x,y) ;
}


public ivec2 ivec2(int [] array) {
  if(array.length == 1) {
    return new ivec2(array[0],array[0]);
  } else if (array.length > 1) {
    return new ivec2(array[0],array[1]);
  } else {
    return null;
  }
}

public ivec2 ivec2(ivec p) {
  if(p == null) {
    println("iVec null, instead '0' is used to build iVec") ;
    return new ivec2(0,0) ;
  } else {
    return new ivec2(p.x,p.y) ;
  }
}

public ivec2 ivec2(float v) {
  return new ivec2(PApplet.parseInt(v),PApplet.parseInt(v));
}

public ivec2 ivec2(float x, float y) { 
  return new ivec2(PApplet.parseInt(x),PApplet.parseInt(y));
}

public ivec2 ivec2(float [] array) {
  if(array.length == 1) {
    return new ivec2(PApplet.parseInt(array[0]),PApplet.parseInt(array[0]));
  } else if (array.length > 1) {
    return new ivec2(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]));
  } else {
    return null;
  }
}

public ivec2 ivec2(vec p) {
  if(p == null) {
    println("Vec null, instead '0' is used to build iVec") ;
    return new ivec2(0,0) ;
  } else {
    return new ivec2(PApplet.parseInt(p.x),PApplet.parseInt(p.y));
  }
}


public ivec2 ivec2(PGraphics media) {
  if(media != null) {
    return new ivec2(media.width,media.height);
  } else {
    return null;
  }
}

public ivec2 ivec2(PImage media) {
  if(media != null) {
    return new ivec2(media.width,media.height);
  } else {
    return null;
  }
}

/**
ivec3
*/
public ivec3 ivec3() {
  return ivec3(0) ;
}

public ivec3 ivec3(int v) {
  return new ivec3(v,v,v);
}

public ivec3 ivec3(int x, int y, int z) { 
  return new ivec3(x,y,z) ;
}

public ivec3 ivec3(int [] array) {
  if(array.length == 1) {
    return new ivec3(array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new ivec3(array[0],array[1],0);
  } else if (array.length > 2) {
    return new ivec3(array[0],array[1],array[2]);
  } else {
    return null;
  }
}

public ivec3 ivec3(ivec p) {
  if(p == null) {
    println("iVec null, instead '0' is used to build iVec") ;
    return new ivec3(0,0,0) ;
  } else {
    return new ivec3(p.x,p.y,p.z) ;
  }
}

public ivec3 ivec3(float v) {
  return new ivec3(PApplet.parseInt(v),PApplet.parseInt(v),PApplet.parseInt(v));
}

public ivec3 ivec3(float x, float y,float z) { 
  return new ivec3(PApplet.parseInt(x),PApplet.parseInt(y),PApplet.parseInt(z));
}

public ivec3 ivec3(float [] array) {
  if(array.length == 1) {
    return new ivec3(PApplet.parseInt(array[0]),PApplet.parseInt(array[0]),PApplet.parseInt(array[0]));
  } else if (array.length == 2) {
    return new ivec3(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]),0);
  } else if (array.length > 2) {
    return new ivec3(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]),PApplet.parseInt(array[2]));
  } else {
    return null;
  }
}

public ivec3 ivec3(vec p) {
  if(p == null) {
    println("Vec null, instead '0' is used to build iVec") ;
    return new ivec3(0,0,0) ;
  } else {
    return new ivec3(PApplet.parseInt(p.x),PApplet.parseInt(p.y),PApplet.parseInt(p.z));
  }
}

/**
ivec4
*/
public ivec4 ivec4() {
  return ivec4(0) ;
}

public ivec4 ivec4(int v) {
  return new ivec4(v,v,v,v);
}

public ivec4 ivec4(int x, int y, int z, int w) { 
  return new ivec4(x,y,z,w) ;
}

public ivec4 ivec4(int [] array) {
  if(array.length == 1) {
    return new ivec4(array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new ivec4(array[0],array[1],0,0);
  } else if (array.length == 3) {
    return new ivec4(array[0],array[1],array[2],0);
  } else if (array.length > 3) {
    return new ivec4(array[0],array[1],array[2],array[3]);
  } else {
    return null;
  }
}

public ivec4 ivec4(ivec p) {
  if(p == null) {
    println("iVec null, instead '0' is used to build iVec") ;
    return new ivec4(0,0,0,0) ;
  } else {
    return new ivec4(p.x,p.y,p.z,p.w) ;
  }
}

public ivec4 ivec4(float v) {
  return new ivec4(PApplet.parseInt(v),PApplet.parseInt(v),PApplet.parseInt(v),PApplet.parseInt(v));
}

public ivec4 ivec4(float x, float y, float z, float w) { 
  return new ivec4(PApplet.parseInt(x),PApplet.parseInt(y),PApplet.parseInt(z),PApplet.parseInt(w));
}

public ivec4 ivec4(float [] array) {
  if(array.length == 1) {
    return new ivec4(PApplet.parseInt(array[0]),PApplet.parseInt(array[0]),PApplet.parseInt(array[0]),PApplet.parseInt(array[0]));
  } else if (array.length == 2) {
    return new ivec4(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]),0,0);
  } else if (array.length == 3) {
    return new ivec4(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]),PApplet.parseInt(array[2]),0);
  } else if (array.length > 3) {
    return new ivec4(PApplet.parseInt(array[0]),PApplet.parseInt(array[1]),PApplet.parseInt(array[2]),PApplet.parseInt(array[3]));
  } else {
    return null;
  }
}


public ivec4 ivec4(vec p) {
  if(p == null) {
    println("Vec null, instead '0' is used to build iVec") ;
    return new ivec4(0,0,0,0) ;
  } else {
    return new ivec4(PApplet.parseInt(p.x),PApplet.parseInt(p.y),PApplet.parseInt(p.z),PApplet.parseInt(p.w));
  }
}

/**
ivec5
*/
public ivec5 ivec5() {
  return ivec5(0) ;
}

public ivec5 ivec5(int v) {
  return new ivec5(v,v,v,v,v);
}

public ivec5 ivec5(int a, int b, int c, int d, int e) { 
  return new ivec5(a,b,c,d,e) ;
}

public ivec5 ivec5(int [] array) {
  if(array.length == 1) {
    return new ivec5(array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new ivec5(array[0],array[1],0,0,0);
  } else if (array.length == 3) {
    return new ivec5(array[0],array[1],array[2],0,0);
  } else if (array.length == 4) {
    return new ivec5(array[0],array[1],array[2],array[3],0);
  } else if (array.length > 4) {
    return new ivec5(array[0],array[1],array[2],array[3],array[4]);
  } else {
    return null;
  }
}

public ivec5 ivec5(ivec p) {
  if(p == null) {
    println("iVec null, instead '0' is used to build iVec") ;
    return new ivec5(0,0,0,0,0) ;
  } else if(p instanceof ivec5 || p instanceof ivec6) {
    return new ivec5(p.a(),p.b(),p.c(),p.d(),p.e) ;
  } else {
    return new ivec5(p.x,p.y,p.z,p.w,0) ;
  }
}

public ivec5 ivec5(vec p) {
  if(p == null) {
    println("Vec null, instead '0' is used to build iVec") ;
    return new ivec5(0,0,0,0,0) ;
  } else if(p instanceof vec5 || p instanceof vec6) {
    return new ivec5(PApplet.parseInt(p.a()),PApplet.parseInt(p.b()),PApplet.parseInt(p.c()),PApplet.parseInt(p.d()),PApplet.parseInt(p.e));
  } else {
    return new ivec5(PApplet.parseInt(p.x),PApplet.parseInt(p.y),PApplet.parseInt(p.z),PApplet.parseInt(p.w),0);
  }
}

/**
ivec6
*/
public ivec6 ivec6() {
  return ivec6(0) ;
}

public ivec6 ivec6(int v) {
  return new ivec6(v,v,v,v,v,v);
}

public ivec6 ivec6(int a, int b, int c, int d, int e, int f) { 
  return new ivec6(a,b,c,d,e,f) ;
}

public ivec6 ivec6(int [] array) {
  if(array.length == 1) {
    return new ivec6(array[0],array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new ivec6(array[0],array[1],0,0,0,0);
  } else if (array.length == 3) {
    return new ivec6(array[0],array[1],array[2],0,0,0);
  } else if (array.length == 4) {
    return new ivec6(array[0],array[1],array[2],array[3],0,0);
  } else if (array.length == 5) {
    return new ivec6(array[0],array[1],array[2],array[3],array[4],0);
  }  else if (array.length > 5) {
    return new ivec6(array[0],array[1],array[2],array[3],array[4],array[5]);
  } else {
    return null;
  }
}

public ivec6 ivec6(ivec p) {
  if(p == null) {
    println("iVec null, instead '0' is used to build iVec") ;
    return new ivec6(0,0,0,0,0,0) ;
  } else if(p instanceof ivec5 || p instanceof ivec6) {
    return new ivec6(p.a(),p.b(),p.c(),p.d(),p.e,p.f) ;
  } else {
    return new ivec6(p.x,p.y,p.z,p.w,0,0) ;
  }
}

public ivec6 ivec6(vec p) {
  if(p == null) {
    println("Vec null, instead '0' is used to build iVec") ;
    return new ivec6(0,0,0,0,0,0) ;
  } else if(p instanceof vec5 || p instanceof vec6) {
    return new ivec6(PApplet.parseInt(p.a()),PApplet.parseInt(p.b()),PApplet.parseInt(p.c()),PApplet.parseInt(p.d()),PApplet.parseInt(p.e),PApplet.parseInt(p.f));
  } else {
    return new ivec6(PApplet.parseInt(p.x),PApplet.parseInt(p.y),PApplet.parseInt(p.z),PApplet.parseInt(p.w),0,0);
  }
}
























/**
Return a new Vec
*/
/**
Vec 2
*/
public vec2 vec2() {
  return new vec2(0,0) ;
}

public vec2 vec2(float x, float y) { 
  return new vec2(x,y) ;
}

public vec2 vec2(float [] array) {
  if(array.length == 1) {
    return new vec2(array[0],array[0]);
  } else if (array.length > 1) {
    return new vec2(array[0],array[1]);
  } else {
    return null;
  }
}

public vec2 vec2(int [] array) {
  if(array.length == 1) {
    return new vec2(array[0],array[0]);
  } else if (array.length > 1) {
    return new vec2(array[0],array[1]);
  } else {
    return null;
  }
}

public vec2 vec2(float v) {
  return new vec2(v,v) ;
}

public vec2 vec2(PVector p) {
  if(p == null) {
    return new vec2(0,0);
  } else {
    return new vec2(p.x, p.y);
  }
}

public vec2 vec2(vec p) {
  if(p == null) {
    return new vec2(0,0);
  } else {
    return new vec2(p.x,p.y);
  }
}


public vec2 vec2(ivec p) {
  if(p == null) {
    return new vec2(0,0);
  } else {
    return new vec2(p.x,p.y);
  }
}




public vec2 vec2(PGraphics media) {
  if(media != null) {
    return new vec2(media.width,media.height);
  } else {
    return null;
  }
}

public vec2 vec2(PImage media) {
  if(media != null) {
    return new vec2(media.width,media.height);
  } else {
    return null;
  }
}
/**
Vec 3
*/
public vec3 vec3() {
  return new vec3(0,0,0) ;
}

public vec3 vec3(float x, float y, float z) {
  return new vec3(x,y,z);
}

public vec3 vec3(float [] array) {
  if(array.length == 1) {
    return new vec3(array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new vec3(array[0],array[1],0);
  } else if (array.length > 2) {
    return new vec3(array[0],array[1],array[2]);
  } else {
    return null;
  }
}

public vec3 vec3(int [] array) {
  if(array.length == 1) {
    return new vec3(array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new vec3(array[0],array[1],0);
  } else if (array.length > 2) {
    return new vec3(array[0],array[1],array[2]);
  } else {
    return null;
  }
}

public vec3 vec3(float v) {
  return new vec3(v,v,v);
}

public vec3 vec3(PVector p) {
  if(p == null) {
    return new vec3(0,0,0);
  } else {
    return new vec3(p.x, p.y, p.z);
  }
}

public vec3 vec3(vec p) {
  if(p == null) {
    return new vec3(0,0,0);
  } else {
    return new vec3(p.x,p.y,p.z);
  }
}

public vec3 vec3(ivec p) {
  if(p == null) {
    return new vec3(0,0,0);
  } else {
    return new vec3(p.x,p.y,p.z);
  }
}



/**
Vec 4
*/
public vec4 vec4() {
  return new vec4(0,0,0,0);
}

public vec4 vec4(float x, float y, float z, float w) {
  return new vec4(x,y,z,w);
}

public vec4 vec4(float [] array) {
  if(array.length == 1) {
    return new vec4(array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new vec4(array[0],array[1],0,0);
  } else if (array.length == 3) {
    return new vec4(array[0],array[1],array[2],0);
  } else if (array.length > 3) {
    return new vec4(array[0],array[1],array[2],array[3]);
  } else {
    return null;
  }
}

public vec4 vec4(int [] array) {
  if(array.length == 1) {
    return new vec4(array[0],array[0],array[0],array[0]);
  } else if (array.length == 2) {
    return new vec4(array[0],array[1],0,0);
  } else if (array.length == 3) {
    return new vec4(array[0],array[1],array[2],0);
  } else if (array.length > 3) {
    return new vec4(array[0],array[1],array[2],array[3]);
  } else {
    return null;
  }
}

public vec4 vec4(float v) {
  return new vec4(v,v,v,v);
}

public vec4 vec4(PVector p) {
  if(p == null) {
    return new vec4(0,0,0,0);
  } else {
    return new vec4(p.x, p.y, p.z, 0);
  }
}
// build with Vec
public vec4 vec4(vec p) {
  if(p == null) {
    return new vec4(0,0,0,0);
  } else {
    return new vec4(p.x,p.y,p.z,p.w);
  }
}

public vec4 vec4(ivec p) {
  if(p == null) {
    return new vec4(0,0,0,0);
  } else {
    return new vec4(p.x,p.y,p.z,p.w);
  }
}



/**
Vec 5
*/
public vec5 vec5() {
  return new vec5(0,0,0,0,0);
}

public vec5 vec5(float a, float b, float c, float d, float e) {
  return new vec5(a,b,c,d,e);
}

public vec5 vec5(float [] array) {
  if(array.length == 1) {
    return new vec5(array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2){
    return new vec5(array[0],array[1],0,0,0) ;
  } else if (array.length == 3){
    return new vec5(array[0],array[1],array[2],0,0) ;
  } else if (array.length == 4){
    return new vec5(array[0],array[1],array[2],array[3],0) ;
  }  else if (array.length > 4){
    return new vec5(array[0],array[1],array[2],array[3],array[4]) ;
  } else {
    return null;
  }
}

public vec5 vec5(int [] array) {
  if(array.length == 1) {
    return new vec5(array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2){
    return new vec5(array[0],array[1],0,0,0) ;
  } else if (array.length == 3){
    return new vec5(array[0],array[1],array[2],0,0) ;
  } else if (array.length == 4){
    return new vec5(array[0],array[1],array[2],array[3],0) ;
  }  else if (array.length > 4){
    return new vec5(array[0],array[1],array[2],array[3],array[4]) ;
  } else {
    return null;
  }
}

public vec5 vec5(float v) {
  return new vec5(v,v,v,v,v);
}

public vec5 vec5(PVector p) {
  if(p == null) {
    return new vec5(0,0,0,0,0);
  } else {
    return new vec5(p.x, p.y, p.z, 0,0);
  }
}
// build with Vec
public vec5 vec5(vec p) {
  if(p == null) {
    return new vec5(0,0,0,0,0);
  } else if(p instanceof vec5 || p instanceof vec6) {
    return new vec5(p.a(),p.b(),p.c(),p.d(),p.e);
  } else {
    return new vec5(p.x,p.y,p.z,p.w,p.e);
  }
}

public vec5 vec5(ivec p) {
  if(p == null) {
    return new vec5(0,0,0,0,0);
  }  else if(p instanceof ivec5 || p instanceof ivec6) {
    return new vec5(p.a(),p.b(),p.c(),p.d(),p.e);
  } else {
    return new vec5(p.x,p.y,p.z,p.w,p.e);
  }
}


/**
Vec 6
*/
public vec6 vec6() {
  return new vec6(0,0,0,0,0,0) ;
}

public vec6 vec6(float a, float b, float c, float d, float e, float f) {
  return new vec6(a,b,c,d,e,f);
}

public vec6 vec6(float [] array) {
  if(array.length == 1) {
    return new vec6(array[0],array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2){
    return new vec6(array[0],array[1],0,0,0,0) ;
  } else if (array.length == 3){
    return new vec6(array[0],array[1],array[2],0,0,0) ;
  } else if (array.length == 4){
    return new vec6(array[0],array[1],array[2],array[3],0,0) ;
  } else if (array.length == 5){
    return new vec6(array[0],array[1],array[2],array[3],array[4],0) ;
  }  else if (array.length > 5){
    return new vec6(array[0],array[1],array[2],array[3],array[4],array[5]) ;
  } else {
    return null;
  }
}

public vec6 vec6(int [] array) {
  if(array.length == 1) {
    return new vec6(array[0],array[0],array[0],array[0],array[0],array[0]);
  } else if (array.length == 2){
    return new vec6(array[0],array[1],0,0,0,0) ;
  } else if (array.length == 3){
    return new vec6(array[0],array[1],array[2],0,0,0) ;
  } else if (array.length == 4){
    return new vec6(array[0],array[1],array[2],array[3],0,0) ;
  } else if (array.length == 5){
    return new vec6(array[0],array[1],array[2],array[3],array[4],0) ;
  }  else if (array.length > 5){
    return new vec6(array[0],array[1],array[2],array[3],array[4],array[5]) ;
  } else {
    return null;
  }
}

public vec6 vec6(float v) {
  return new vec6(v,v,v,v,v,v);
}
public vec6 vec6(PVector p) {
  if(p == null) {
    return new vec6(0,0,0,0,0,0);
  } else {
    return new vec6(p.x, p.y, p.z, 0,0,0);
  }
}

// build with vec
public vec6 vec6(vec p) {
  if(p == null) {
    return new vec6(0,0,0,0,0,0);
  } else if(p instanceof vec5 || p instanceof vec6) {
    return new vec6(p.a(),p.b(),p.c(),p.d(),p.e,p.f);
  } else {
    return new vec6(p.x,p.y,p.z,p.w,p.e,p.f);
  }
}

public vec6 vec6(ivec p) {
  if(p == null) {
    return new vec6(0,0,0,0,0,0) ;
  } else if(p instanceof ivec5 || p instanceof ivec6) {
    return new vec6(p.a(),p.b(),p.c(),p.d(),p.e,p.f);
  } else {
    return new vec6(p.x,p.y,p.z,p.w,p.e,p.f);
  }
}












/**
Rope COLOUR
v 0.7.1
* Copyleft (c) 2016-2019 
* Stan le Punk > http://stanlepunk.xyz/
Rope – Romanesco Processing Environment – 
Processing 3.5.3
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*
* Pack of method to use colour, palette and method conversion
*
*/







/**
COLOUR LIST class
v 0.0.2
*/
/**
* Idea for the future add a list name for colour

* get the colour by index or name
*/
public class ROPE_colour implements rope.core.R_Constants {
	int [] c;
	public ROPE_colour(int... c) {
		this.c = new int[c.length];
		for(int i = 0; i < c.length ; i++) {
			this.c[i] = c[i];
		}
	}

	public int[] get_colour() {
		return c;
	}

	public float[] get_hue() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = hue(c[i]);
		}
		return component;
	}

	public float[] get_saturation() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = saturation(c[i]);
		}
		return component;
	}

	public float[] get_brightness() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = brightness(c[i]);
		}
		return component;
	}

	public float[] get_red() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = red(c[i]);
		}
		return component;
	}

	public float[] get_green() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = green(c[i]);
		}
		return component;
	}

	public float[] get_blue() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = blue(c[i]);
		}
		return component;
	}

	public float[] get_alpha() {
		float[] component = new float[c.length];
		for(int i = 0 ; i < c.length ; i++) {
			component[i] = blue(c[i]);
		}
		return component;
	}
}




/**
GET COLORMODE
v 0.0.2
*/
/**
* getColorMode()
* @return float array of your color environment.
* @param boolean print_info_is retrun a print about the color environment
*/
public float [] getColorMode(boolean print_info_is) {
  float colorMode = g.colorMode ;
  float x = g.colorModeX;
  float y = g.colorModeY;
  float z = g.colorModeZ;
  float a = g.colorModeA;
  float array[] = {colorMode,x,y,z,a};
  if (print_info_is && g.colorMode == HSB) {
    println("HSB",x,y,z,a);
  } else if(print_info_is && g.colorMode == RGB) {
    println("RGB",x,y,z,a);
  }
  return array;
}

public float [] getColorMode() {
  return getColorMode(false);
}

/**
camaieu 
v 0.1.1
*/
// return hue or other date in range of specific data float
public float camaieu(float max, float color_ref, float range) {
  float camaieu = 0 ;
  float which_color = random(-range, range) ;
  camaieu = color_ref +which_color ;
  if(camaieu < 0 ) camaieu = max +camaieu ;
  if(camaieu > max) camaieu = camaieu -max ;
  return camaieu ;
}







/**
color pool 
v 0.2.0
*/
// color pool vec4 RGB
public vec4 [] color_pool_RGB(int num) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  float key_hue = -1 ;
  return color_pool_RGB(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}

public vec4 [] color_pool_RGB(int num, float key_hue) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  return color_pool_RGB(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_RGB(int num, int num_group, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float key_hue = -1 ;
  return color_pool_RGB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_RGB(int num, int num_group, float key_hue, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  return color_pool_RGB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}

public vec4 [] color_pool_RGB(int num, int num_group, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  float key_hue = -1 ;
  return color_pool_RGB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_RGB(int num, int num_group, float key_hue, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  vec4 [] list = new vec4[num]  ;
  int [] c = color_pool(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
  for(int i = 0 ; i <list.length ; i++) {
    list[i] = new vec4(red(c[i]),green(c[i]),blue(c[i]),alpha(c[i])) ;
  }
  return list ;
}

// color pool vec4 HSB
public vec4 [] color_pool_HSB(int num) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  float key_hue = -1 ;
  return color_pool_HSB(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}

public vec4 [] color_pool_HSB(int num, float key_hue) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  return color_pool_HSB(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_HSB(int num, int num_group, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float key_hue = -1 ;
  return color_pool_HSB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_HSB(int num, int num_group, float key_hue, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  return color_pool_HSB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}

public vec4 [] color_pool_HSB(int num, int num_group, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  float key_hue = -1 ;
  return color_pool_HSB(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}


public vec4 [] color_pool_HSB(int num, int num_group, float key_hue, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  vec4 [] list = new vec4[num]  ;
  int [] c = color_pool(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
  for(int i = 0 ; i <list.length ; i++) {
    list[i] = new vec4(hue(c[i]),saturation(c[i]),brightness(c[i]),alpha(c[i])) ;
  }
  return list ;
}

// color pool int
public int [] color_pool(int num) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  float key_hue = -1 ;
  return color_pool(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}

public int [] color_pool(int num, float key_hue) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float range = g.colorModeX *.5f ;
  int num_group = 1 ;
  return color_pool(num, num_group, key_hue, range, sat_range, bright_range, alpha_range) ;
}

public int [] color_pool(int num, int num_group, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  float key_hue = -1 ;
  return color_pool(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}

public int [] color_pool(int num, int num_group, float key_hue, float hue_range) {
  vec2 sat_range = vec2(g.colorModeY) ;
  vec2 bright_range = vec2(g.colorModeZ) ;
  vec2 alpha_range = vec2(g.colorModeA) ;
  return color_pool(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;
}

public int [] color_pool(int num, int num_group, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  float key_hue = -1 ;
  return color_pool(num, num_group, key_hue, hue_range, sat_range, bright_range, alpha_range) ;

}

// color pool by group
public int [] color_pool(int num, int num_group, float key_hue, float hue_range, vec2 sat_range, vec2 bright_range, vec2 alpha_range) {
  int ref = g.colorMode ;
  float x = g.colorModeX ;
  float y = g.colorModeY ;
  float z = g.colorModeZ ;
  float a = g.colorModeA ;
  colorMode(HSB,360,100,100,100) ;

  float [] color_ref = new float[num_group] ;
  if(key_hue >= 0 ) {
    color_ref[0] = key_hue ;
  } else {
    color_ref[0] = random(g.colorModeX) ;
  }
  if(num_group > 1) {
    float step = g.colorModeX / num_group ;
    for(int i = 1 ; i < num_group ; i++) {
      color_ref[i] = color_ref[i -1] + step ;
      if(color_ref[i] > g.colorModeX) {
        color_ref[i] = color_ref[i] - g.colorModeX ;
      }      
    }
  }

  int [] list = new int[num] ;
  int count = 0 ;
  int step = num / num_group ;
  int next_stop = step ; ;
  for(int i = 0 ; i < list.length ; i++) {
    if(i > next_stop) {
      next_stop += step ;
    }
    float saturation = random(sat_range) ;
    float brightness = random(bright_range) ;
    float alpha = random(alpha_range) ;
    float hue = camaieu(g.colorModeX, color_ref[count], hue_range) ;
    list[i] = color(hue, saturation,brightness, alpha) ;
    count++ ;
    if(count >= color_ref.length) count = 0 ;

  }
  colorMode(ref,x,y,z,a) ;
  return list ;
}





/**
component range
*/
public boolean alpha_range(float min, float max, int colour) {
  float alpha = alpha(colour) ;
  return in_range(min, max, alpha) ;
}

public boolean red_range(float min, float max, int colour) {
  float  r = red(colour) ;
  return in_range(min, max, r) ;
}

public boolean green_range(float min, float max, int colour) {
  float  g = green(colour) ;
  return in_range(min, max, g) ;
}

public boolean blue_range(float min, float max, int colour) {
  float  b = blue(colour) ;
  return in_range(min, max, b) ;
}

public boolean saturation_range(float min, float max, int colour) {
  float  s = saturation(colour) ;
  return in_range(min, max, s) ;
}

public boolean brightness_range(float min, float max, int colour) {
  float  b = brightness(colour) ;
  return in_range(min, max, b) ;
}


public boolean hue_range(float min, float max, int colour) {
  int c_m = g.colorMode ;
  float c_x = g.colorModeX ;
  float c_y = g.colorModeY ;
  float c_z = g.colorModeZ ;
  float c_a = g.colorModeA ;
  colorMode(HSB, c_x, c_y, c_z, c_a) ;
  float  h = hue(colour) ;

  boolean result = false ;
  // test for the wheel value, hue is one of them ;
  result = in_range_wheel(min, max, c_x, h) ;
  // return to the current colorMode
  colorMode(c_m, c_x, c_y, c_z, c_a) ;
  return result ;
}












/**
convert color 0.3.0
*/
public vec3 hsb_to_rgb(float hue, float saturation, float brightness) {
  vec4 ref = vec4(g.colorModeX, g.colorModeY, g.colorModeY, g.colorModeA);
  int c = color(hue,saturation,brightness);

  colorMode(RGB,255) ;
  vec3 rgb = vec3(red(c),green(c),blue(c)) ;
  // return to the previous colorMode
  colorMode(HSB,ref.x,ref.y,ref.z,ref.w) ;
  return rgb;
}

public vec4 to_cmyk(int c) {
  return rgb_to_cmyk(red(c),green(c),blue(c));
}


public vec3 to_rgb(int c) {
  return vec3(red(c),green(c),blue(c));
}

public vec4 to_rgba(int c) {
  return vec4(red(c),green(c),blue(c),alpha(c));
}

public vec3 to_hsb(int c) {
  return vec3(hue(c),saturation(c),brightness(c));
}

public vec4 to_hsba(int c) {
  return vec4(hue(c),saturation(c),brightness(c),alpha(c));
}





public vec4 rgb_to_cmyk(float r, float g, float b) {
  // convert to 0 > 1 value
  r = r/this.g.colorModeX;
  g = g/this.g.colorModeY;
  b = b/this.g.colorModeZ;
  // RGB to CMY
  float c = 1.f-r;
  float m = 1.f-g;
  float y = 1.f-b;
  // CMY to CMYK
  float var_k = 1;
  if (c < var_k) var_k = c;
  if (m < var_k) var_k = m;
  if (y < var_k) var_k = y;
  // black only
  if (var_k == 1) { 
    c = 0;
    m = 0;
    y = 0;
  } else {
    c = (c-var_k)/(1-var_k);
    m = (m-var_k)/(1-var_k);
    y = (y-var_k)/(1-var_k);
  }
  float k = var_k; 
  return vec4(c,m,y,k);
}







public vec3 cmyk_to_rgb(float c, float m, float y, float k) {
  vec3 rgb = null;
   // cmyk value must be from 0 to 1
  if(colour_normal_range_is(c) && colour_normal_range_is(m) && colour_normal_range_is(y) && colour_normal_range_is(k)) {
    // CMYK > CMY
    c = (c *(1.f-k)+k);
    m = (m *(1.f-k)+k);
    y = (y *(1.f-k)+k);
    //CMY > RGB
    float red = (1.f- c) * g.colorModeX;
    float green = (1.f- m) * g.colorModeY;
    float blue = (1.f- y) * g.colorModeZ;
    rgb = vec3(red,green,blue);

  } else {
    printErr("method cmyk_to_rgb(): the values c,m,y,k must have value from 0 to 1.\n","yours values is cyan",c,"magenta",m,"yellow",y,"black",k);
  }
  return rgb;
  
}

public boolean colour_normal_range_is(float v) {
  if(v >= 0.f && v <= 1.f) return true; else return false;
}










// color context
/*
* good when the text is on different background
*/
public int color_context(int color_ref, int threshold, int clear, int dark) {
  int new_color ;
  if(brightness(color_ref) < threshold ) {
    new_color = clear;
  } else {
    new_color = dark ;
  }
  return new_color ;
}












/**
ROPE FRAMEWORK - Romanesco processing environment – 
* Copyleft (c) 2014-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
* ROPE core
* v 0.1.1
* 2017-2018
*/










 


























/**
Something weird, now it's not necessary to use the method init_rope()
to use the interface Rope_constants...
that's cool but that's very weird !!!!!
*/
Rope r ;
public void init_rope() {
  r = new Rope();
  println("Init ROPE: Romanesco Processing Environment - 2015-2018");
}














/**
event
v 0.0.2
*/
vec2 scroll_event;
public void scroll(MouseEvent e) {
	float scroll_x = e.getCount();
	float scroll_y = e.getCount();
	if(scroll_event == null) {
		scroll_event = vec2(scroll_x,scroll_y);
	} else {
		scroll_event.set(scroll_x,scroll_y);
	}
}


public vec2 get_scroll() {
	if(scroll_event == null) {
		scroll_event = vec2();
		return scroll_event;
	} else {
		return scroll_event;
	}
}

/**
add for the future
import java.awt.event.MouseWheelEvent;
void mouseWheelMoved(MouseWheelEvent e) {
  println(e.getWheelRotation());
  println(e.getScrollType());
  println(MouseWheelEvent.WHEEL_UNIT_SCROLL);
  println(e.getScrollAmount());
  println(e.getUnitsToScroll());
}
*/


/**
* COSTUME class
* Copyleft (c) 2019-2019
* v 0.8.1
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
* Here you finf the class Costume and all the class shape used.
* Processing 3.5.3
* Rope Library 0.5.1
*/
final int POINT_ROPE = 1;
final int ELLIPSE_ROPE = 2;
final int RECT_ROPE = 3;
final int LINE_ROPE = 4;

final int TRIANGLE_ROPE = 13;
final int SQUARE_ROPE = 14;
final int PENTAGON_ROPE = 15;
final int HEXAGON_ROPE = 16;
final int HEPTAGON_ROPE = 17;
final int OCTOGON_ROPE = 18;
final int NONAGON_ROPE = 19;
final int DECAGON_ROPE = 20;
final int HENDECAGON_ROPE = 21;
final int DODECAGON_ROPE = 22;

final int TEXT_ROPE = 26;

final int CROSS_RECT_ROPE = 52;
final int CROSS_BOX_2_ROPE = 53;
final int CROSS_BOX_3_ROPE = 54;

final int SPHERE_LOW_ROPE = 100;
final int SPHERE_MEDIUM_ROPE = 101;
final int SPHERE_HIGH_ROPE = 102;
final int TETRAHEDRON_ROPE = 103;
final int BOX_ROPE = 104;

final int PIXEL_ROPE = 800;

final int STAR_ROPE = 805;
final int STAR_3D_ROPE = 806;

final int FLOWER_ROPE = 900;

final int TETRAHEDRON_LINE_ROPE = 1001;
final int CUBE_LINE_ROPE = 1002;
final int OCTOHEDRON_LINE_ROPE = 1003;
final int RHOMBIC_COSI_DODECAHEDRON_SMALL_LINE_ROPE = 1004;
final int ICOSI_DODECAHEDRON_LINE_ROPE = 1005;

final int HOUSE_ROPE = 2000;

final int VIRUS_ROPE = 88_888_888;





















/**
class Costume 
2018-2019
v 0.3.1
*/

public class Costume {
	boolean fill_is;
	boolean stroke_is;
	int fill;
	int stroke;
	float thickness = 1.f;

	int type;
	int node;
	int summits;
	int num;
	int mutation;
  float angle;
	float [] ratio;
	float [] strength;
	vec2 [] pair;
	boolean is_3D = false;
	boolean is_vertex = true;
	R_Primitive prim;
	PApplet papplet;

	public Costume(PApplet pa) {
		this.papplet = pa;
	}

	public Costume(PApplet pa,int type) {
		this.papplet = pa;
		this.type = type;
	}
  
  // set
  public void set_type(int type) {
		this.type = type;
	}

	public void set_node(int node) {
		this.node = node;
	}

	public void set_mutation(int mutation) {
		this.mutation = mutation;
	}

	public void set_summit(int summits) {
		this.summits = summits;
	}

	public void set_num(int num) {
		this.num = num;
	}

	public void set_angle(float angle) {
		this.angle = angle;
	}

	public void set_ratio(float... ratio) {
		this.ratio = ratio;
	}

	public void set_strength(float... strength) {
		this.strength = strength;
	}

	public void set_pair(vec2... pair) {
		this.pair = pair;
	}

	public void is_3D(boolean is_3D) {
		this.is_3D = is_3D;
	}

	public void is_vertex(boolean is_vertex) {
		this.is_vertex = is_vertex;
	}



	// get
	public int get_fill() {
		return fill;
	}

	public int get_stroke() {
		return stroke;
	}

	public float get_thickness() {
		return thickness;
	}

	public int get_type() {
		return type;
	}

	public int get_node() {
		return node;
	}

	public int get_mutation() {
		return mutation;
	}

	public int get_summit() {
		return summits;
	}

	public int get_num() {
		return num;
	}

	public float get_angle() {
		return angle;
	}

	public float[] get_ratio() {
		return ratio;
	}

	public float[] get_strength() {
		return strength;
	}

	public vec2[] get_pair() {
		return pair;
	}

	public boolean is_3D() {
		return is_3D;
	}

	public boolean is_vertex() {
		return is_vertex;
	}

	public boolean fill_is() {
		return this.fill_is;
	}

	public boolean stroke_is() {
		return this.stroke_is;
	}






	// ASPECT
	public void aspect_is(boolean fill_is, boolean stroke_is) {
		this.fill_is = fill_is;
		this.stroke_is = stroke_is;
	}

	public void init_bool_aspect() {
		this.fill_is = true ;
	  this.stroke_is = true ;
	}

	public void aspect(int fill, int stroke, float thickness) {
	  //checkfill color
	  if(alpha(fill) <= 0 || !this.fill_is)  {
	    noFill(); 
	  } else {
	  	manage_fill(fill);
	  } 
	  //check stroke color
	  if(alpha(stroke) <=0 || thickness <= 0 || !this.stroke_is) {
	    noStroke();
	  } else {
	  	manage_stroke(stroke);
	    manage_thickness(thickness);
	  }
	  //
	  init_bool_aspect();
	}

	public void aspect(int fill, int stroke, float thickness, Costume costume) {
		aspect(fill,stroke,thickness,costume.get_type());
	}

	public void aspect(int fill, int stroke, float thickness, int costume) {
		if(costume == r.NULL) {
	    // 
		} else if(costume != r.NULL || costume != POINT_ROPE || costume != POINT) {
	    if(alpha(fill) <= 0 || !fill_rope_is) {
	    	noFill(); 
	    } else {
	    	manage_fill(fill);
	    }

	    if(alpha(stroke) <= 0  || thickness <= 0 || !stroke_rope_is) {
	    	noStroke(); 
	    } else {
	    	manage_stroke(stroke);
	      manage_thickness(thickness);
	    }   
	  } else {
	    if(alpha(fill) == 0) {
	    	noStroke(); 
	    } else {
	    	// case where the fill is use like a stroke, for point, pixel...
	    	manage_stroke(fill);
	    	manage_thickness(thickness);
	    }
	    noFill();   
	  }
	  //
	  init_bool_aspect();
	}



	public void aspect(vec fill, vec stroke, float thickness) {
	  //checkfill color
	  if(fill.w <=0 || !this.fill_is)  {
	    noFill() ; 
	  } else {
	    manage_fill(fill);
	  } 
	  //check stroke color
	  if(stroke.w <=0 || thickness <= 0 || !this.stroke_is) {
	    noStroke();
	  } else {
	    manage_stroke(stroke);
	    manage_thickness(thickness);
	  }
	  //
	  init_bool_aspect();
	}

	public void aspect(vec fill, vec stroke, float thickness, Costume costume) {
		aspect(fill,stroke,thickness,costume.get_type());
	}


	public void aspect(vec fill, vec stroke, float thickness, int costume) {
	  if(costume == r.NULL) {
	    // 
		} else if(costume != r.NULL || costume != POINT_ROPE || costume != POINT) {
	    if(fill.w <= 0 || !this.fill_is) {
	    	noFill() ; 
	    } else {
	    	manage_fill(fill);
	    } 
	    if(stroke.w <= 0  || thickness <= 0 || !this.stroke_is) {
	    	noStroke(); 
	    } else {
	    	manage_stroke(stroke);
	    	manage_thickness(thickness);
	    }   
	  } else {
	    if(fill.w <= 0 || !this.fill_is) {
	    	noStroke(); 
	    } else {
	    	// case where the fill is use like a stroke, for point, pixel...
	    	manage_stroke(fill); 
	    	manage_thickness(thickness);
	    }
	    noFill();   
	  }
	  //
	  init_bool_aspect();
	}


	private void manage_fill(Object arg) {
		if(arg instanceof vec2) {
			vec2 c = (vec2)arg;
			this.fill = color(c.x,c.x,c.x,c.y);
			fill(c) ;
		} else if(arg instanceof vec3) {
			vec3 c = (vec3)arg;
			this.fill = color(c.x,c.y,c.z,g.colorModeA);
			fill(c) ;
		} else if(arg instanceof vec4) {
			vec4 c = (vec4)arg;
			this.fill = color(c.x,c.y,c.z,c.w);
			fill(c);
		} else if(arg instanceof Integer) {
			int c = (int)arg;
			this.fill = c;
			fill(c);
		}
	}

	private void manage_stroke(Object arg) {
		if(arg instanceof vec2) {
			vec2 c = (vec2)arg;
			this.stroke = color(c.x,c.x,c.x,c.y);
			stroke(c);
		} else if(arg instanceof vec3) {
			vec3 c = (vec3)arg;
			this.stroke = color(c.x,c.y,c.z,g.colorModeA);
			stroke(c);
		} else if(arg instanceof vec4) {
			vec4 c = (vec4)arg;
			this.stroke = color(c.x,c.y,c.z,c.w);
			stroke(c);
		} else if(arg instanceof Integer) {
			int c = (int)arg;
			this.stroke = c;
			stroke(c);
		}
	}


	private void manage_thickness(float thickness) {
		this.thickness = thickness;
		strokeWeight(this.thickness);
	}






	public void draw(vec3 pos, vec3 size, vec rot) {
		if(rot.x != 0) costume_rotate_x();
		if(rot.y != 0) costume_rotate_y();
		if(rot.z != 0) costume_rotate_z();

		if (this.get_type() == PIXEL_ROPE) {
			set((int)pos.x,(int)pos.y,(int)get_fill_rope());
		} else if (this.get_type() == POINT_ROPE) {
	    strokeWeight(size.x);
			point(pos);
		} else if (this.get_type() == ELLIPSE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			ellipse(vec2(),size);
			stop_matrix();

		} else if (this.get_type() == RECT_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			rect(vec2(-size.x,-size.y).div(2),vec2(size.x,size.y));
			stop_matrix();

		} else if (this.get_type() == LINE_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,2);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		}

		else if (this.get_type() == TRIANGLE_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,3);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		}  else if (this.get_type() == SQUARE_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,4);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == PENTAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,5);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == HEXAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,6);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix() ;
		} else if (this.get_type() == HEPTAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,7);
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == OCTOGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,8);
			start_matrix();
			translate(pos);
			rotate_behavior(rot) ;
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == NONAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,9);
			start_matrix();
			translate(pos);
			rotate_behavior(rot) ;
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == DECAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,10);
			start_matrix();
			translate(pos);
			rotate_behavior(rot) ;
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == HENDECAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,11);
			start_matrix();
			translate(pos);
			rotate_behavior(rot) ;
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		} else if (this.get_type() == DODECAGON_ROPE) {
			if(prim == null) prim = new R_Primitive(papplet,12);
			start_matrix();
			translate(pos);
			rotate_behavior(rot) ;
			prim.size((int)size.x);
			prim.show();
			stop_matrix();
		}

		else if (this.get_type() == CROSS_RECT_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			cross_rect(ivec2(0),(int)size.y,(int)size.x);
			stop_matrix() ;
		} else if (this.get_type() == CROSS_BOX_2_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			//cross_box_2(vec2(size.x, size.y),ratio_size);
			cross_box_2(vec2(size.x, size.y));
			stop_matrix() ;
		} else if (this.get_type() == CROSS_BOX_3_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			//cross_box_3(size,ratio_size);
			cross_box_3(size);
			stop_matrix();
		}



	  else if(this.get_type() == TEXT_ROPE) {
	  	start_matrix();
	  	translate(pos);
	  	rotate_behavior(rot);
	  	textSize(size.x);
	  	if(costume_text_rope != null) {
	  		text(costume_text_rope,0,0);
	  	} else {
	  		costume_text_rope = "ROPE";
	  		text(costume_text_rope,0,0);
	  	}
	  	stop_matrix();
	  }

		else if (this.get_type() == SPHERE_LOW_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			sphereDetail(5);
			sphere(size.x);
			stop_matrix();
		} else if (this.get_type() == SPHERE_MEDIUM_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			sphereDetail(12);
			sphere(size.x);
			stop_matrix();
		} else if (this.get_type() == SPHERE_HIGH_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			sphere(size.x);
			stop_matrix();
		} else if (this.get_type() == TETRAHEDRON_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("TETRAHEDRON","VERTEX",(int)size.x);
			stop_matrix();
		} else if (this.get_type() == BOX_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			box(size);
			stop_matrix();
		}


		else if (this.get_type() == STAR_ROPE) {
			float [] ratio = {.38f};
			start_matrix();
			translate(pos);
			rotate_behavior(rot);

			star_3D_is(false);
			if(get_summit() == 0 ) set_summit(5);
			star_summits(get_summit());
			star(vec3(),size);
			stop_matrix();
		} else if (this.get_type() == STAR_3D_ROPE) {
			float [] ratio = {.38f};
			start_matrix();
			translate(pos);
			rotate_behavior(rot);

			star_3D_is(true);
			if(get_summit() == 0 ) set_summit(5);
			star_summits(get_summit());
			star(vec3(),size);
			stop_matrix();
		}


		else if (this.get_type() == FLOWER_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			// int num_petals = 3;
			// println(get_summit(),frameCount);
			if(get_summit() == 0 ) set_summit(5);
			if(get_pair() == null || get_pair().length != get_summit()*2) {
				pair = new vec2[get_summit()*2];
			}
			if(get_strength() == null || get_strength().length != get_summit()*2) {
				strength = new float[get_summit()*2];
			}

			for(int i = 0 ; i < get_summit()*2 ; i++) {
				vec2 value = vec2(.1f,.1f);
				// if(i >= get_summit()) value.set(value.yx());
				if(pair[i] == null) {
					pair[i] = vec2(value);
				} else {
					pair[i].set(value);
				}
				strength[i] = 1.f;
			}

			for(int i = 0 ; i < get_summit() ; i++) {
				flower_static(pair[i],strength[i],pair[i+get_summit()],strength[i+get_summit()]);
				//flower_wind(pair[i],strength[i],pair[i+get_summit()],strength[i+get_summit()]);
			}
			flower(vec3(),(int)size.x,get_summit());
			stop_matrix();
		}


		else if (this.get_type() == TETRAHEDRON_LINE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("TETRAHEDRON","LINE",(int)size.x);
			stop_matrix();
		} else if (this.get_type() == CUBE_LINE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("CUBE","LINE",(int)size.x);
			stop_matrix();
		} else if (this.get_type() == OCTOHEDRON_LINE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("OCTOHEDRON","LINE",(int)size.x);
			stop_matrix();
		} else if (this.get_type() == RHOMBIC_COSI_DODECAHEDRON_SMALL_LINE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("RHOMBIC COSI DODECAHEDRON SMALL","LINE",(int)size.x);
			stop_matrix();
		} else if (this.get_type() == ICOSI_DODECAHEDRON_LINE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			polyhedron("ICOSI DODECAHEDRON","LINE",(int)size.x);
			stop_matrix();
		}

		else if(this.get_type() == HOUSE_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			house(size);
			stop_matrix();
		}


	  else if(this.get_type() == VIRUS_ROPE) {
			start_matrix();
			translate(pos);
			rotate_behavior(rot);
			virus(vec3(),size,0,-1);
			stop_matrix();
		}



		else if(this.get_type() < 0) {
			start_matrix() ;
			translate(pos) ;
			rotate_behavior(rot) ;
			for(int i = 0 ; i < costume_pic_list.size() ; i++) {
				Costume_pic p = costume_pic_list.get(i);
				if(p.get_id() == this.get_type()) {
					if(p.get_type() == 1) {
						PImage img_temp = p.get_img().copy();
						if(size.x == size.y ) {
							img_temp.resize((int)size.x, 0);
						} else if (size.x != size.y) {
							img_temp.resize((int)size.x, (int)size.y);
						}
						image(img_temp,0,0);
						break ;
					} else if(p.get_type() == 2) {
						vec2 scale = vec2(1) ;
						if(size.x == size.y) {
	            scale = vec2(size.x / p.get_svg().width(), size.x / p.get_svg().width());
						} else {
							scale = vec2(size.x / p.get_svg().width(), size.y / p.get_svg().height());
						}
						
						p.get_svg().scaling(scale) ;
						p.get_svg().draw() ;
						break ;
					}		
				}
			}
			stop_matrix() ;
		}

	  // reset variable can be change the other costume, if the effect is don't use.
		ratio_costume_size = 1;
	}
}












/**
* COSTUME PIC CLASS
* v 0.0.2
* 2014-2019
*/
public class Costume_pic {
	PImage img ;
	ROPE_svg svg ;
	int type = -1 ; 
	String name ;
	int id;
	public Costume_pic(PApplet p5, String path, int id) {
		// add png
		if(path.endsWith("png") || path.endsWith("PNG")) {
			img = loadImage(path) ;
			type = 1;
		}

		// add svg
		if(path.endsWith("svg") || path.endsWith("SVG")) {
			svg = new ROPE_svg(p5,path);
			svg.mode(CENTER) ;
			svg.build() ;
			type = 2 ;
		}
		
		String [] split = path.split("/") ;
		name = split[split.length -1] ;
		name = name.substring(0,name.lastIndexOf(".")) ;
		this.id = id;
	}
  
  // get
	public int get_id() {
		return id;
	}

	public int get_type() {
		return type;
	}

	public ROPE_svg get_svg() {
		return svg;
	}

	public PImage get_img() {
		return img;
	}

	public String get_name() {
		return name;
	}
}

























/**
Class House
2019-2019
v 0.0.6
*/
public class House {
	private int fill_roof = r.BLOOD;
	private int fill_wall = r.GRAY_3;
	private int fill_ground = r.BLACK;
	private int stroke_roof = r.BLACK;
	private int stroke_wall = r.BLACK;
	private int stroke_ground = r.BLACK;
	private float thickness = 1;
	private boolean aspect_is;

	private int level;
	private vec3 pos;
	private vec3 size;
	private boolean roof_ar, roof_cr; // to draw or not the small roof side
	private vec3 offset = vec3(-.5f,0,.5f); // to center the house; 

  private vec3 [] pa;
	private vec3 [] pc;

	private int type = CENTER;
	public House() {
		build();
	}
  
  public House(float size) {
  	this.size = vec3(size);
		build();
	}

	public House(float sx, float sy, float sz) {
		this.size = vec3(sx,sy,sz);
		build();
	}

	public void mode(int type) {
		this.type = type;
	}

	public void set_pos(vec3 pos) {
		if(this.pos == null) {
			this.pos = pos.copy();
		} else {
			this.pos.set(pos);
		}
	}

	public void set_size(vec3 size) {
		if(this.size == null) {
			this.size = size.copy();
		} else {
			this.size.set(size);
		}
	}

	private void set_peak(float ra, float rc) {
		// check if this peak configuration is permitted
		if(ra + rc > 1.f) {
			if(ra>rc) {
				ra = 1.f-rc; 
			} else {
				rc = 1.f-ra;
			}
		}

		if(ra > 0.f) {
			roof_ar = true;
			if(pa != null && pa[0] != null) {
				pa[0].x = 1.f-ra+offset.x;
			}
		}

		if(rc > 0.f) {
			roof_cr = true;
			if(pc != null && pc[0] != null) {
				pc[0].x = rc+offset.x;
			}
		}
	}
  // aspect
  // fill
  public void set_fill(int c) {
  	aspect_is = true;
  	fill_roof = fill_wall = fill_ground = c;
  }

  public void set_fill_roof(int c) {
		aspect_is = true;
		fill_roof = c;
	}

	public void set_fill_wall(int c) {
		aspect_is = true;
		fill_wall = c;
	}

	public void set_fill_ground(int c) {
		aspect_is = true;
		fill_ground = c;
	}

	public void set_fill(float x, float y, float z, float a) {
		set_fill(color(x,y,z,a));
	}

	public void set_fill_roof(float x, float y, float z, float a) {
		set_fill_roof(color(x,y,z,a));
	}

	public void set_fill_wall(float x, float y, float z, float a) {
		set_fill_wall(color(x,y,z,a));
	}

	public void set_fill_ground(float x, float y, float z, float a) {
		set_fill_ground(color(x,y,z,a));
	}

  // stroke
	public void set_stroke(int c) {
  	aspect_is = true;
  	stroke_roof = stroke_wall = stroke_ground = c;
  }

  public void set_stroke_roof(int c) {
		aspect_is = true;
		stroke_roof = c;
	}

	public void set_stroke_wall(int c) {
		aspect_is = true;
		stroke_wall = c;
	}

	public void set_stroke_ground(int c) {
		aspect_is = true;
		stroke_ground = c;
	}

	public void set_stroke(float x, float y, float z, float a) {
		set_stroke(color(x,y,z,a));
	}

	public void set_stroke_roof(float x, float y, float z, float a) {
		set_stroke_roof(color(x,y,z,a));
	}

	public void set_stroke_wall(float x, float y, float z, float a) {
		set_stroke_wall(color(x,y,z,a));
	}

	public void set_stroke_ground(float x, float y, float z, float a) {
		set_stroke_ground(color(x,y,z,a));
	}

	public void set_thickness(float thickness) {
		aspect_is = true;
		this.thickness = thickness;
	}

	public void aspect_is(boolean is) {
		this.aspect_is = is;
	}

  
  // build
	private void build() {
		pa = new vec3[5];
		pc = new vec3[5];
		
		pa[0] = vec3(1,-1,-0.5f); // roof peak
		pa[1] = vec3(1,0,-1);
		pa[2] = vec3(1,1,-1);
		pa[3] = vec3(1,1,0);
		pa[4] = vec3(1,0,0);

		pc[0] = vec3(0,-1,-0.5f); // roof peak
		pc[1] = vec3(0,0,-1);
		pc[2] = vec3(0,1,-1);
		pc[3] = vec3(0,1,0);
		pc[4] = vec3(0,0,0);

		for(int i = 0 ; i < pa.length ; i++) {
			pa[i].add(offset);
			pc[i].add(offset);
		}
	}
  

	public void show() {
		float smallest_size = 0;
		for(int i = 0 ; i < 3 ; i++) {
			if(smallest_size == 0 || smallest_size > size.array()[i]) {
				smallest_size = size.array()[i];
			}
		}

    // DEFINE FINAL OFFSET
    vec3 def_pos = null;
	  if(this.type == TOP) {
	  	if(pos == null) {
	  		def_pos = vec3();
	  		def_pos.add(vec3(0,size.y*.5f,0));
	  	} else {
	  		def_pos = pos.copy();
	  		def_pos.add(vec3(0,size.y*.5f,0));		
	  	}
	  } else if(this.type == BOTTOM) {
	  	if(pos == null) {
	  		def_pos = vec3();
	  		def_pos.add(vec3(0,-size.y,0));
	  	} else {
	  		def_pos = pos.copy();
	  		def_pos.add(vec3(0,-size.y,0));		
	  	}
	  }



	  // WALL
	  if(aspect_is) {
	  	aspect(fill_wall,stroke_wall,thickness);
	  }
		// draw A : WALL > small and special side
		beginShape();
		if(def_pos == null) {
			if(!roof_ar) {
				vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
			}
			for(int i = 1 ; i < pa.length ; i++) {
				vertex(pa[i].copy().mult(size));
			}
		} else {
			if(!roof_ar) {
				vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
			}
			for(int i = 1 ; i < pa.length ; i++) {
				vertex(pa[i].copy().mult(size).add(def_pos));
			}
		}
		endShape(CLOSE);


	  // draw B : WALL > main wall
	  beginShape();
		if(def_pos == null) {
			vertex(pa[2].copy().mult(size));
			vertex(pa[1].copy().mult(size));
			vertex(pc[1].copy().mult(size));
			vertex(pc[2].copy().mult(size));
		} else {
			vertex(pa[2].copy().mult(size).add(def_pos));
			vertex(pa[1].copy().mult(size).add(def_pos));
			vertex(pc[1].copy().mult(size).add(def_pos));
			vertex(pc[2].copy().mult(size).add(def_pos));
		}
		endShape(CLOSE);

	  // draw C : WALL > small and special side
		beginShape();
		if(def_pos == null) {
			if(!roof_cr) {
				vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
			}
			for(int i = 1 ; i < pc.length ; i++) {
				vertex(pc[i].copy().mult(size));
			}
		} else {
			if(!roof_cr) {
				vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
			}
			for(int i = 1 ; i < pc.length ; i++) {
				vertex(pc[i].copy().mult(size).add(def_pos));
			}	
		}
		endShape(CLOSE);

		// draw D : WALL > main wall
		beginShape();
		if(def_pos == null) {
			vertex(pa[3].copy().mult(size));
			vertex(pa[4].copy().mult(size));
			vertex(pc[4].copy().mult(size));
			vertex(pc[3].copy().mult(size));
		} else {
			vertex(pa[3].copy().mult(size).add(def_pos));
			vertex(pa[4].copy().mult(size).add(def_pos));
			vertex(pc[4].copy().mult(size).add(def_pos));
			vertex(pc[3].copy().mult(size).add(def_pos));
		}
		endShape(CLOSE);





    // GROUND
    if(aspect_is) {
	  	aspect(fill_ground,stroke_ground,thickness);
	  }
		// draw G : GROUND
		beginShape();
		if(def_pos == null) {
			vertex(pa[2].copy().mult(size));
			vertex(pc[2].copy().mult(size));
			vertex(pc[3].copy().mult(size));
			vertex(pa[3].copy().mult(size));
		} else {
			vertex(pa[2].copy().mult(size).add(def_pos));
			vertex(pc[2].copy().mult(size).add(def_pos));
			vertex(pc[3].copy().mult(size).add(def_pos));
			vertex(pa[3].copy().mult(size).add(def_pos));
		}
		endShape(CLOSE);



    // ROOF
    if(aspect_is) {
	  	aspect(fill_roof,stroke_roof,thickness);
	  }
    // draw E : ROOF > main roof
		beginShape();
		if(def_pos == null) {
			vertex(pa[4].copy().mult(size));
			vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
			vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
			vertex(pc[4].copy().mult(size));			
		} else {
			vertex(pa[4].copy().mult(size).add(def_pos));
			vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
			vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
			vertex(pc[4].copy().mult(size).add(def_pos));
		}
		endShape(CLOSE);

		// draw F : ROOF > main roof
		beginShape();
		if(def_pos == null) {
			vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
			vertex(pa[1].copy().mult(size));
			vertex(pc[1].copy().mult(size));
			vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
		} else {
			vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
			vertex(pa[1].copy().mult(size).add(def_pos));
			vertex(pc[1].copy().mult(size).add(def_pos));
			vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
		}
		endShape(CLOSE);

		// DRAW AR  > small side roof
		if(roof_ar) {
			beginShape();
			if(def_pos == null) {
				vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
				vertex(pa[1].copy().mult(size));
				vertex(pa[4].copy().mult(size));
			} else {
				vertex(pa[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
				vertex(pa[1].copy().mult(size).add(def_pos));
				vertex(pa[4].copy().mult(size).add(def_pos));
			}
			endShape(CLOSE);
		}

		// DRAW CR > small side roof
		if(roof_cr) {
			beginShape();
			if(def_pos == null) {
				vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z))); // special point for the roof peak
				vertex(pc[1].copy().mult(size));
				vertex(pc[4].copy().mult(size));
			} else {
				vertex(pc[0].copy().mult(vec3(size.x,smallest_size,size.z)).add(def_pos)); // special point for the roof peak
				vertex(pc[1].copy().mult(size).add(def_pos));
				vertex(pc[4].copy().mult(size).add(def_pos));
			}
			endShape(CLOSE);
		}
	}
}






































/**
CLASS VIRUS
2015-2018
v 0.2.0
*/
/*
public class Virus {
	vec3 [][] branch;
	vec3 size;
	vec3 pos ;
	int node = 4;
	int num = 4;
	int mutation = 4;

	float angle = 0 ;
	public Virus() {
		size = vec3(1);
		pos = vec3(0);
		set_branch();
	}

  // set
	private void set_branch() {
		branch = new vec3 [node][num] ;
		for(int i = 0 ; i < node ; i++) {
			for(int k = 0 ; k < num ; k++) {
				vec3 dir = vec3().rand(-1,1);
				branch[i][k] = projection(dir) ;
			}
		}
	}


	public void set_node(int node) {
		this.node = node;
		set_branch();
	}

	public void set_num(int num) {
		this.num = num;
		set_branch();
	}

	public void set_mutation(int mutation) {
		this.mutation = mutation;
	}
  

  // get
	public int get_mutation() {
		return this.mutation;
	}

	public int get_node() {
		return this.node;
	}

	public int get_num() {
		return this.num;
	}



  

  // method
	public void reset() {
		for(int i = 0 ; i < node ; i++) {
			for(int k = 0 ; k < num ; k++) {
				vec3 dir = vec3().rand(-1,1);
				branch[i][k].set(projection(dir)) ;
			}
		}
	}
  
  // set
  public void set_size(vec s) {
  	vec3 final_size = vec3(1) ;
		if(s instanceof vec2) {
			vec2 size_temp = (vec2) s ;
			final_size.set(size_temp.x, size_temp.y, 1) ;
		} else if (s instanceof vec3) {
			vec3 size_temp = (vec3) s ;
			final_size.set(size_temp) ;
		}
		size.set(final_size) ;
	}

	public void set_pos(vec p) {
  	vec3 final_pos = vec3() ;
		if(p instanceof vec2) {
			vec2 pos_temp = (vec2) p ;
			final_pos.set(pos_temp.x, pos_temp.y, 1) ;
		} else if (p instanceof vec3) {
			vec3 pos_temp = (vec3) p ;
			final_pos.set(pos_temp) ;
		}
		pos.set(final_pos) ;
	}
  

  public void rotation(float angle) {
  	this.angle = angle ;
  	// System.err.println("Virus rotation() don't work must be coded for the future") ;
  }

	public vec2 angle(float angle) {
		return to_cartesian_2D(angle) ;
	}
  

  // show
  public void show() {
  	show(-1) ;
  }
	


	public void show(int close) {
		if(angle != 0) {
			start_matrix() ;
			translate(pos) ;
			rotate(angle) ;
		}
		for(int k = 0 ; k < num ; k++) {
			if(node == 2) {
				vec3 final_pos_a = branch[0][k].copy() ;
				final_pos_a.add(angle(angle)) ;
				final_pos_a.mult(size) ;
				if(angle == 0) final_pos_a.add(pos) ;

				vec3 final_pos_b = branch[1][k].copy() ;
				final_pos_b.mult(size) ;
				if(angle == 0) final_pos_b.add(pos) ;
				line(final_pos_a, final_pos_b) ;
			} else if( node > 2) {
				beginShape() ;
				for(int m = 0 ; m < node ; m++) {
					vec3 final_pos = branch[m][k].copy() ;
					final_pos.mult(size) ;
					if(angle == 0) final_pos.add(pos) ;
					vertex(final_pos) ;
				}
				if(close == CLOSE) endShape(CLOSE) ; else endShape() ;
			} else {
				vec3 final_pos = branch[0][k].copy() ;
				//final_pos.add(angle(angle)) ;
				final_pos.mult(size) ;
				if(angle == 0) final_pos.add(pos) ;
				point(final_pos) ;
			}
		}
		if(angle != 0) stop_matrix() ;
	}
  
  // get
	public vec3 [][] get() {
		return branch ;
	}
}

*/





















/**
* Costume method
* Copyleft (c) 2014-2019
* v 1.8.1
* processing 3.5.3
* Rope Library 0.5.1
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/




/**
SHOW
*/
/**
Costume selection in shape catalogue
*/
public void costume(float x, float y, float sx, float sy, Object data) {
	costume(vec2(x,y),vec2(sx,sy),data);
}

public void costume(float x, float y, float z, float sx, float sy, Object data) {
	costume(vec3(x,y,z),vec2(sx,sy),data);
}

public void costume(float x, float y, float z, float sx, float sy, float sz, Object data) {
	costume(vec3(x,y,z),vec3(sx,sy,sz),data);
}


public void costume(vec pos, int size_int, Object data) {
	int which_costume = 0;
	String sentence = null;
	vec3 rotation = vec3();
	vec3 size = vec3(size_int);
	if(data instanceof Costume) {
		costume_impl(pos,size,rotation,(Costume)data);
	} else if(data instanceof Integer) {
		which_costume = (int)data;
		costume_management(pos,size,rotation,which_costume,null);
	} else if(data instanceof String) {
		sentence = (String)data;
		which_costume = MAX_INT;
		costume_management(pos,size,rotation,which_costume,sentence);
	}
}

public void costume(vec pos, vec size, Object data) {
	int which_costume = 0;
	String sentence = null;
	vec3 rotation = vec3();
	if(data instanceof Costume) {
		costume_impl(pos,size,rotation,(Costume)data);
	} else if(data instanceof Integer) {
		which_costume = (int)data;
		costume_management(pos,size,rotation,which_costume,null);
	} else if(data instanceof String) {
		sentence = (String)data;
		which_costume = MAX_INT;
		costume_management(pos,size,rotation,which_costume,sentence);
	}
}

public void costume(vec pos, vec size, float rot, Object data) {
	int which_costume = 0;
	String sentence = null;
	vec3 rotation = vec3(0,0,rot);
	if(data instanceof Costume) {
		costume_impl(pos,size,rotation,(Costume)data);
	} else if(data instanceof Integer) {
		which_costume = (int)data;
		costume_management(pos,size,rotation,which_costume,null);
	} else if(data instanceof String) {
		sentence = (String)data;
		which_costume = MAX_INT;
		costume_management(pos,size,rotation,which_costume,sentence);
	}

}

public void costume(vec pos, vec size, vec rotation, Object data) {
	int which_costume = 0;
	String sentence = null;
	if(data instanceof Costume) {
		costume_impl(pos,size,rotation,(Costume)data);
	} else if(data instanceof Integer) {
		which_costume = (int)data;
		costume_management(pos,size,rotation,which_costume,null);
	} else if(data instanceof String) {
		sentence = (String)data;
		which_costume = MAX_INT;
		costume_management(pos,size,rotation,which_costume,sentence);
	}
}









/**
managing costume rope method
*/
public @Deprecated
void costume_management(vec pos, vec size, vec rotation, int which_costume, String sentence) {
  vec3 pos_final = vec3(0) ;
  vec3 size_final = vec3(1) ;
	if((pos instanceof vec2 || pos instanceof vec3) 
			&& (size instanceof vec2 || size instanceof vec3)
			&& (rotation instanceof vec2 || rotation instanceof vec3)) {
		// pos
		if(pos instanceof vec2) {
			vec2 temp_pos = (vec2)pos;
			pos_final.set(temp_pos.x, temp_pos.y, 0);
		} else if(pos instanceof vec3) {
			vec3 temp_pos = (vec3)pos;
			pos_final.set(temp_pos);
		}
		//size
		if(size instanceof vec2) {
			vec2 temp_size = (vec2)size;
			size_final.set(temp_size.x, temp_size.y, 1);
		} else if(size instanceof vec3) {
			vec3 temp_size = (vec3)size;
			size_final.set(temp_size);
		}
		//send
		if(sentence == null ) {
			costume_impl(pos_final,size_final,rotation,which_costume);
		} else {
			costume_impl(pos_final,size_final,rotation,sentence);
		}		
	} else {
		printErrTempo(180,"vec pos or vec size if not an instanceof vec2 or vec3, it's not possible to process costume_rope()");
	}
}






/**
MAIN METHOD 
String COSTUME
v 0.2.0
Change the method for method with 
case and which_costume
and 
break
*/
public void costume_impl(vec3 pos, vec3 size, vec rot, String sentence) {
	if(rot.x != 0) costume_rotate_x();
	if(rot.y != 0) costume_rotate_y();
	if(rot.z != 0) costume_rotate_z();

	start_matrix();
	translate(pos);
	rotate_behavior(rot);
  text(sentence,0,0);
	stop_matrix();
}

/**
method to pass costume to class costume
*/
Costume costume_rope_buffer;
public void costume_impl(vec3 pos, vec3 size, vec rot, int which_costume) {
	if(costume_rope_buffer == null) {
		costume_rope_buffer = new Costume(this,which_costume);
	} else {
		costume_rope_buffer.set_type(which_costume);
	}
	costume_rope_buffer.draw(pos,size,rot);
}

public void costume_impl(vec pos, vec size, vec rot, Costume costume) {
	costume.draw(vec3(pos),vec3(size),rot);
}





















































/**
ASPECT ROPE 2016-2018
v 0.1.3
*/
public void aspect_is(boolean fill_is, boolean stroke_is) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_rope.aspect_is(fill_is,stroke_is);
	fill_rope_is = aspect_rope.fill_is();
	stroke_rope_is = aspect_rope.stroke_is();
}

public void init_bool_aspect() {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_rope.aspect_is(true,true);
}

public void aspect(int fill, int stroke, float thickness) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness);
}

public void aspect(int fill, int stroke, float thickness, Costume costume) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness,costume.get_type());
}

public void aspect(int fill, int stroke, float thickness, int costume) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness,costume);
}

public void aspect(vec fill, vec stroke, float thickness) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness);
}

public void aspect(vec fill, vec stroke, float thickness, Costume costume) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness,costume.get_type());
}


public void aspect(vec fill, vec stroke, float thickness, int costume) {
	if(aspect_rope == null) aspect_rope = new Costume(this);
	aspect_is(aspect_rope.fill_is(),aspect_rope.stroke_is());
	aspect_rope.aspect(fill,stroke,thickness,costume);
}







public int get_fill_rope() {
	if(aspect_rope != null) {
		return aspect_rope.get_fill();
	} else {
		return color(g.colorModeX);
	}
}

public int get_stroke_rope() {
	if(aspect_rope != null) {
		return aspect_rope.get_stroke();
	} else {
		return color(0);
	}
}

public float get_thickness_rope() {
	if(aspect_rope != null) {
		return aspect_rope.get_thickness();
	} else {
		return 1.f;
	}
}













































/**
COSTUME
v 0.0.1
*/
/**
simple text 
v 0.0.1
*/
public void costume_text(String s) {
	costume_text_rope = s ;
}


/**
rotate behavior
v 0.1.0
*/
boolean costume_rot_x;
boolean costume_rot_y;
boolean costume_rot_z;

public void costume_rotate_x() {
	costume_rot_x = true;
}

public void costume_rotate_y() {
	costume_rot_y = true;
}

public void costume_rotate_z() {
	costume_rot_z = true;
}

public void rotate_behavior(vec rotate) {
	if(costume_rot_x && rotate.x != 0) {
		rotateX(rotate.x);
		costume_rot_x = false;
	}
	if(costume_rot_y && rotate.y != 0) {
		rotateY(rotate.y);
		costume_rot_y = false;
	}
	if(costume_rot_z && rotate.z != 0) {
		rotateZ(rotate.z);
		costume_rot_z = false;
	}
}


/**
ratio size costume
*/
float ratio_costume_size = 1;
public void set_ratio_costume_size(float ratio) {
	ratio_costume_size = ratio;
}




























/**
add pic 
v 0.0.1
*/
ArrayList <Costume_pic> costume_pic_list = new ArrayList<Costume_pic>() ;

public void load_costume_pic(String path) {
	if(path.endsWith("png") || path.endsWith("PNG") || path.endsWith("svg") || path.endsWith("SVG")) {
		int new_ID = costume_pic_list.size() * (-1) ;
		new_ID -= 1 ;
		Costume_pic c = new Costume_pic(this, path, new_ID) ;
		costume_pic_list.add(c) ; ;
		println("ID pic:", new_ID) ;
	}
}














































/**
house method
*/
House house_costume_rope;
public void house(vec3 size) {
	if(house_costume_rope != null) {
		house_costume_rope.set_size(size);
		house_costume_rope.show();
	} else {
		house_costume_rope = new House();
	}
}





/**
* flower method
* 2019-2019
* v 0.0.2
*/


R_Circle flower_costume_rope;
public void flower(vec pos, int diam, int petals_num) {
	if(flower_costume_rope == null || flower_costume_rope.get_summit() != petals_num) {
		flower_costume_rope = new R_Circle(this,petals_num);
	} else {
		flower_costume_rope.pos(pos);
		flower_costume_rope.size(diam);
		flower_costume_rope.show();
		// if(petals_num < 3) petals_num = 3;
		
	}
}

public void flower_wind(vec2 petal_left, float strength_left, vec2 petal_right, float strength_right) {
	if(flower_costume_rope != null) {
		for(R_Bezier b : flower_costume_rope.get_bezier()) {
	    vec2 trouble = vec2().sin_wave(frameCount,petal_left.x(),petal_left.y()).mult(strength_left);
	    b.set_a(trouble);
	    trouble = vec2().cos_wave(frameCount,petal_right.x(),petal_right.y()).mult(strength_right);
	    b.set_b(trouble);
	  }
	}
}


public void flower_static(vec2 petal_left, float strength_left, vec2 petal_right, float strength_right) {
	if(flower_costume_rope != null) {
		for(R_Bezier b : flower_costume_rope.get_bezier()) {
	    vec2 petal_show = vec2(petal_left.x(),petal_left.y()).mult(strength_left);
	    b.set_a(petal_show);
	    petal_show = vec2(petal_right.x(),petal_right.y()).mult(strength_right);
	    b.set_b(petal_show);
	  }
	}
}

/*
void flower_petals(int petals_num) {
	flower_costume_rope = new R_Circle(this,petals_num);
}
*/








































/**
ANNEXE COSTUME
SHAPE CATALOGUE
*/
/**
STAR
*/

R_Star star_costume_rope;
public void star_3D_is(boolean is_3D) {
	if(star_costume_rope != null) {
		star_costume_rope.is_3D(is_3D);
	} else {
		star_costume_rope = new R_Star(this);
	}
}


public void star_summits(int summits) {
	if(star_costume_rope != null) {
		star_costume_rope.set_summits(summits);
	} else {
		star_costume_rope = new R_Star(this);
	}
}

public void star_angle(float angle) {
	if(star_costume_rope != null) {
		star_costume_rope.set_angle(angle);
	} else {
		star_costume_rope = new R_Star(this);
	}
}

public void star_ratio(float... ratio) {
	if(star_costume_rope != null) {
		star_costume_rope.set_ratio(ratio);
	} else {
		star_costume_rope = new R_Star(this);
	}
}


public void star(vec position, vec size) {
	if(star_costume_rope != null) {
		star_costume_rope.pos(position);
		star_costume_rope.size(size);
		star_costume_rope.show();
	} else {
		star_costume_rope = new R_Star(this);
	}
}






 






















/**
CROSS
*/
public void cross_rect(ivec2 pos, int thickness, int radius) {
	float h = radius;
	float w = thickness/3;

  // verticale one
	vec2 size = vec2(w,h);
	vec2 pos_temp = vec2(pos.x, pos.y -floor(size.y/2) +(w/2));
	pos_temp.sub(w/2);
	rect(pos_temp,size);
	
	// horizontal one
	size.set(h,w);
	pos_temp.set(pos.x-floor(size.x/2) +(w/2),pos.y);
	pos_temp.sub(w/2);
	rect(pos_temp,size);
}

public void cross_box_2(vec2 size) {
	float scale_cross = size.sum() *.5f;
	float small_part = scale_cross *ratio_costume_size *.3f;

	box(size.x,small_part,small_part);
	box(small_part,size.y,small_part);
}

public void cross_box_3(vec3 size) {
	float scale_cross = size.sum() *.3f;
	float small_part = scale_cross *ratio_costume_size *.3f;
   
	box(size.x,small_part,small_part);
	box(small_part,size.y,small_part);
	box(small_part,small_part,size.z);
}
















/**
VIRUS
2015-2018
v 0.2.0
*/
public void virus(vec pos, vec size) {
	int close = -1 ;
	float angle = 0 ;
	virus(pos,size,angle,close) ;
}

public void virus(vec pos, vec size, float angle) {
	int close = -1;
	virus(pos,size,angle,close);
}


// main method

R_Virus virus_costume_rope;
boolean make_virus = true ;
public void virus(vec pos, vec size, float angle, int close) {
	if(make_virus) {
		virus_costume_rope = new R_Virus(this);
		make_virus = false ;
	}

	if(virus_costume_rope.get_mutation() > 0 && frameCount%virus_costume_rope.get_mutation() == 0) {
		virus_costume_rope.reset() ;
	}
  virus_costume_rope.rotation(angle) ;
	virus_costume_rope.pos(pos) ;
	virus_costume_rope.size(size) ;
	virus_costume_rope.show() ;	
}

public void virus_mutation(int mutation) {
	if(virus_costume_rope != null && mutation != 0 && mutation != virus_costume_rope.get_mutation()) {
		virus_costume_rope.set_mutation(abs(mutation));
	}
}

public void virus_num(int num) {
	if(virus_costume_rope != null && num != 0 && num != virus_costume_rope.get_num()) {
		virus_costume_rope.set_num(abs(num));
	}
}

public void virus_node(int node) {
	if(virus_costume_rope != null && node != 0 && node != virus_costume_rope.get_node()) {
		virus_costume_rope.set_node(abs(node));
	}
}




























/**
* COSTUME INFO
* 2016-2019
* v 0.2.0
*/
// get costume
public int get_costume(int target) {
	costume_list() ;
	if(target >= 0 && target < costume_dict.size()) {
		return costume_dict.get(target).get(0) ;
	} else {
		System.err.println("Your target is out from the list") ;
		return 0 ;
	}
}

// return size of the arrayList costume
public int costumes_size() {
	costume_list() ;
	return costume_dict.size() ;
}




Info_int_dict costume_dict = new Info_int_dict();
boolean list_costume_is_built = false ;
int ref_size_pic = -1 ;
Costume aspect_rope;
String costume_text_rope = null;
boolean fill_rope_is = true;
boolean stroke_rope_is = true;
public void costume_list() {
	if(!list_costume_is_built) {
		/* 
		* add(name, code, renderer, type)
		* code: int constante to access directly
		* render: 2 = 2D ; 3 = 3D ;
		* type : 0 = shape ; 1 = bitmap ; 2 = svg  ; 3 = shape with just stroke component ; 4 = text
		*/
		costume_dict.add("NULL",r.NULL,0,0);

		costume_dict.add("PIXEL_ROPE",PIXEL_ROPE,2,1);

		costume_dict.add("POINT_ROPE",POINT_ROPE,2,0);
		costume_dict.add("ELLIPSE_ROPE",ELLIPSE_ROPE,2,0);
		costume_dict.add("RECT_ROPE",RECT_ROPE,2,0);
		costume_dict.add("LINE_ROPE",LINE_ROPE,2,0);

		costume_dict.add("TRIANGLE_ROPE",TRIANGLE_ROPE,2,0);
		costume_dict.add("SQUARE_ROPE",SQUARE_ROPE,2,0);
		costume_dict.add("PENTAGON_ROPE",PENTAGON_ROPE,2,0);
		costume_dict.add("HEXAGON_ROPE",HEXAGON_ROPE,2,0);
		costume_dict.add("HEPTAGON_ROPE",HEPTAGON_ROPE,2,0);
		costume_dict.add("OCTOGON_ROPE",OCTOGON_ROPE,2,0);
		costume_dict.add("NONAGON_ROPE",NONAGON_ROPE,2,0);
		costume_dict.add("DECAGON_ROPE",DECAGON_ROPE,2,0);
		costume_dict.add("HENDECAGON_ROPE",HENDECAGON_ROPE,2,0);
		costume_dict.add("DODECAGON_ROPE",DODECAGON_ROPE,2,0);

		costume_dict.add("TEXT_ROPE",TEXT_ROPE,2,4);
    
    costume_dict.add("CROSS_RECT_ROPE",CROSS_RECT_ROPE,2,0);
		costume_dict.add("CROSS_BOX_2_ROPE",CROSS_BOX_2_ROPE,3,0);
		costume_dict.add("CROSS_BOX_3_ROPE",CROSS_BOX_3_ROPE,3,0);

		costume_dict.add("SPHERE_LOW_ROPE",SPHERE_LOW_ROPE,3,0);
		costume_dict.add("SPHERE_MEDIUM_ROPE",SPHERE_MEDIUM_ROPE,3,0);
		costume_dict.add("SPHERE_HIGH_ROPE",SPHERE_HIGH_ROPE,3,0);
		costume_dict.add("TETRAHEDRON_ROPE",TETRAHEDRON_ROPE,3,0);
		costume_dict.add("BOX_ROPE",BOX_ROPE,3,0);

		costume_dict.add("SPHERE_LOW_ROPE",SPHERE_LOW_ROPE,3,0);
		costume_dict.add("SPHERE_MEDIUM_ROPE",SPHERE_MEDIUM_ROPE,3,0);
		costume_dict.add("SPHERE_HIGH_ROPE",SPHERE_HIGH_ROPE,3,0);
		costume_dict.add("TETRAHEDRON_ROPE",TETRAHEDRON_ROPE,3,0);
		costume_dict.add("BOX_ROPE",BOX_ROPE,3,0);

		costume_dict.add("STAR_ROPE",STAR_ROPE,2,3);
		costume_dict.add("STAR_3D_ROPE",STAR_3D_ROPE,2,3);

		costume_dict.add("FLOWER_ROPE",FLOWER_ROPE,2,3);

		costume_dict.add("HOUSE_ROPE",HOUSE_ROPE,3,0);

		costume_dict.add("VIRUS_ROPE",VIRUS_ROPE,3,0);

		list_costume_is_built = true ;
	}

  // add costume from your SVG or PNG
	if(ref_size_pic != costume_pic_list.size()) {
		for(Costume_pic c : costume_pic_list) {
			costume_dict.add(c.name, c.get_id(), 3, c.type) ;
		}
		ref_size_pic = costume_pic_list.size() ;
	}
}


// print list costume
public void print_list_costume() {
	if(!list_costume_is_built) {
		costume_list() ;
	}
  println("Costume have " + costume_dict.size() + " costumes.") ;
	if(list_costume_is_built) {
		for(int i = 0 ; i < costume_dict.size() ; i++) {
			String type = "" ;
			if(costume_dict.get(i).get(2) == 0 ) type = "shape" ;
			else if(costume_dict.get(i).get(2) == 1 ) type = "bitmap" ;
			else if(costume_dict.get(i).get(2) == 2 ) type = "scalable vector graphics" ;
			else if(costume_dict.get(i).get(2) == 3 ) type = "shape with no fill component" ;
			println("[ Rank:", i, "][ ID:",costume_dict.get(i).get(0), "][ Name:", costume_dict.get(i).get_name(), "][ Renderer:", costume_dict.get(i).get(1)+"D ][ Picture:", type, "]") ;
		}
	}
}
























/**
ROPE GLSL METHOD
v 0.0.6
* Copyleft (c) 2019-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/

/**
transcription of few common glsl method

/**
mix
*/
public float mix(float x, float y, float a) {
  return x*(1-a)+y*a;
}

public vec2 mix(vec2 x, vec2 y, vec2 a) {
  return vec2(mix(x.x,y.x,a.x),mix(x.y,y.y,a.y));
}

public vec3 mix(vec3 x, vec3 y, vec3 a) {
  return vec3(mix(x.x,y.x,a.x),mix(x.y,y.y,a.y),mix(x.z,y.z,a.z));
}

public vec4 mix(vec4 x, vec4 y, vec4 a) {
  return vec4(mix(x.x,y.x,a.x),mix(x.y,y.y,a.y),mix(x.z,y.z,a.z),mix(x.w,y.w,a.w));
}

/**
fract
*/
public float fract(float x) {
  return x - floor(x);
}

public vec2 fract(vec2 v) {
  return vec2(fract(v.x),fract(v.y));
}

public vec3 fract(vec3 v) {
  return vec3(fract(v.x),fract(v.y),fract(v.z));
}

public vec4 fract(vec4 v) {
  return vec4(fract(v.x),fract(v.y),fract(v.z),fract(v.w));
}

/**
sign
*/
public float sign(float x) {
  if(x < 0 ) {
    return -1.f;
  } else if(x > 0) {
    return 1.f ;
  } else return 0.0f;
}

public vec2 sign(vec2 x) {
  return vec2(sign(x.x),sign(x.y));
}

public vec3 sign(vec3 x) {
  return vec3(sign(x.x),sign(x.y),sign(x.z));
}

public vec4 sign(vec4 x) {
  return vec4(sign(x.x),sign(x.y),sign(x.z),sign(x.w));
}


public int sign(int x) {
  return PApplet.parseInt(sign(PApplet.parseFloat(x)));
}

public ivec2 sign(ivec2 x) {
  return ivec2(sign(x.x),sign(x.y));
}

public ivec3 sign(ivec3 x) {
  return ivec3(sign(x.x),sign(x.y),sign(x.z));
}

public ivec4 sign(ivec4 x) {
  return ivec4(sign(x.x),sign(x.y),sign(x.z),sign(x.w));
}


/**
step
*/
public float step(float edge, float x) {
  if(x < edge) return 0; else return 1;
}

public vec2 step(vec2 edge, vec2 x) {
  return vec2(step(edge.x,x.x),step(edge.y,x.y));
}

public vec3 step(vec3 edge, vec3 x) {
  return vec3(step(edge.x,x.x),step(edge.y,x.y),step(edge.z,x.z));
}

public vec4 step(vec4 edge, vec4 x) {
  return vec4(step(edge.x,x.x),step(edge.y,x.y),step(edge.z,x.z),step(edge.w,x.w));
}


/**
smoothstep
*/
public float smoothstep(float edge0, float edge1, float x) {
  if(x <= edge0) {
    return 0; 
  } else if(x >= edge1) {
    return 1;
  } else {
    float t = clamp((x-edge0)/(edge1-edge0),0.f,1.f);
    return t*t*(3.f-2.f*t);
  }
}

public vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x) {
  return vec2(smoothstep(edge0.x,edge1.x,x.x),smoothstep(edge0.y,edge1.y,x.y));
}

public vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x) {
  return vec3(smoothstep(edge0.x,edge1.x,x.x),smoothstep(edge0.y,edge1.y,x.y),smoothstep(edge0.z,edge1.z,x.z));
}

public vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x) {
  return vec4(smoothstep(edge0.x,edge1.x,x.x),smoothstep(edge0.y,edge1.y,x.y),smoothstep(edge0.z,edge1.z,x.z),smoothstep(edge0.w,edge1.w,x.w));
}



/*
mod
*/
public float mod(float x, float y) {
  return x-y*floor(x/y);
}

public vec2 mod(vec2 x, vec2 y) {
  return vec2(mod(x.x,y.x),mod(x.y,y.y));
}

public vec3 mod(vec3 x, vec3 y) {
  return vec3(mod(x.x,y.x),mod(x.y,y.y),mod(x.z,y.z));
}

public vec4 mod(vec4 x, vec4 y) {
  return vec4(mod(x.x,y.x),mod(x.y,y.y),mod(x.z,y.z),mod(x.w,y.w));
}

public ivec2 mod(ivec2 x, ivec2 y) {
  return ivec2(mod(x.x,y.x),mod(x.y,y.y));
}

public ivec3 mod(ivec3 x, ivec3 y) {
  return ivec3(mod(x.x,y.x),mod(x.y,y.y),mod(x.z,y.z));
}

public ivec4 mod(ivec4 x, ivec4 y) {
  return ivec4(mod(x.x,y.x),mod(x.y,y.y),mod(x.z,y.z),mod(x.w,y.w));
}

/**
clamp
*/
public float clamp(float x, float min, float max) {
  return min(max(x,min),max);
}

public vec2 clamp(vec2 x, vec2 min, vec2 max) {
  return min(max(x,min),max);
}

public vec3 clamp(vec3 x, vec3 min, vec3 max) {
  return min(max(x,min),max);
}

public vec4 clamp(vec4 x, vec4 min, vec4 max) {
  return min(max(x,min),max);
}




/**
equal
*/
public boolean equal(float x, float y) {
  return x==y?true:false;
}

public boolean equal(int x, int y) {
  return equal((float)x,(float)y);
}

// with vec
public bvec2 equal(vec2 x, vec2 y) {
  if(x != null && y != null) {
    return bvec2(equal(x.x,y.x),equal(x.y,y.y));
  } else return null;
}

public bvec3 equal(vec3 x, vec3 y) {
  if(x != null && y != null) {
    return bvec3(equal(x.x,y.x),equal(x.y,y.y),equal(x.z,y.z));
  } else return null;
}

public bvec4 equal(vec4 x, vec4 y) {
  if(x != null && y != null) {
    return bvec4(equal(x.x,y.x),equal(x.y,y.y),equal(x.z,y.z),equal(x.w,y.w));
  } else return null;
}

// width ivec
public bvec2 equal(ivec2 x, ivec2 y) {
  if(x != null && y != null) {
    return bvec2(equal(x.x,y.x),equal(x.y,y.y));
  } else return null;
}

public bvec3 equal(ivec3 x, ivec3 y) {
  if(x != null && y != null) {
    return bvec3(equal(x.x,y.x),equal(x.y,y.y),equal(x.z,y.z));
  } else return null;
}

public bvec4 equal(ivec4 x, ivec4 y) {
  if(x != null && y != null) {
    return bvec4(equal(x.x,y.x),equal(x.y,y.y),equal(x.z,y.z),equal(x.w,y.w));
  } else return null;
}




/**
lessThan
*/
public boolean lessThan(float x, float y) {
  return x<y?true:false;
}

public boolean lessThan(int x, int y) {
  return lessThan((float)x,(float)y);
}

// with vec
public bvec2 lessThan(vec2 x, vec2 y) {
  if(x != null && y != null) {
    return bvec2(lessThan(x.x,y.x),lessThan(x.y,y.y));
  } else return null;
}

public bvec3 lessThan(vec3 x, vec3 y) {
  if(x != null && y != null) {
    return bvec3(lessThan(x.x,y.x),lessThan(x.y,y.y),lessThan(x.z,y.z));
  } else return null;
}

public bvec4 lessThan(vec4 x, vec4 y) {
  if(x != null && y != null) {
    return bvec4(lessThan(x.x,y.x),lessThan(x.y,y.y),lessThan(x.z,y.z),lessThan(x.w,y.w));
  } else return null;
}

// width ivec
public bvec2 lessThan(ivec2 x, ivec2 y) {
  if(x != null && y != null) {
    return bvec2(lessThan(x.x,y.x),lessThan(x.y,y.y));
  } else return null;
}

public bvec3 lessThan(ivec3 x, ivec3 y) {
  if(x != null && y != null) {
    return bvec3(lessThan(x.x,y.x),lessThan(x.y,y.y),lessThan(x.z,y.z));
  } else return null;
}

public bvec4 lessThan(ivec4 x, ivec4 y) {
  if(x != null && y != null) {
    return bvec4(lessThan(x.x,y.x),lessThan(x.y,y.y),lessThan(x.z,y.z),lessThan(x.w,y.w));
  } else return null;
}





/**
greaterThan
*/
public boolean greaterThan(float x, float y) {
  return x>y?true:false;
}

public boolean greaterThan(int x, int y) {
  return greaterThan((float)x,(float)y);
}

// with vec
public bvec2 greaterThan(vec2 x, vec2 y) {
  if(x != null && y != null) {
    return bvec2(greaterThan(x.x,y.x),greaterThan(x.y,y.y));
  } else return null; 
}

public bvec3 greaterThan(vec3 x, vec3 y) {
  if(x != null && y != null) {
    return bvec3(greaterThan(x.x,y.x),greaterThan(x.y,y.y),greaterThan(x.z,y.z));
  } else return null; 
}

public bvec4 greaterThan(vec4 x, vec4 y) {
  if(x != null && y != null) {
    return bvec4(greaterThan(x.x,y.x),greaterThan(x.y,y.y),greaterThan(x.z,y.z),greaterThan(x.w,y.w));
  } else return null; 
}

// width ivec
public bvec2 greaterThan(ivec2 x, ivec2 y) {
  if(x != null && y != null) {
    return bvec2(greaterThan(x.x,y.x),greaterThan(x.y,y.y));
  } else return null; 
}

public bvec3 greaterThan(ivec3 x, ivec3 y) {
  if(x != null && y != null) {
    return bvec3(greaterThan(x.x,y.x),greaterThan(x.y,y.y),greaterThan(x.z,y.z));
  } else return null; 
}

public bvec4 greaterThan(ivec4 x, ivec4 y) {
  if(x != null && y != null) {
    return bvec4(greaterThan(x.x,y.x),greaterThan(x.y,y.y),greaterThan(x.z,y.z),greaterThan(x.w,y.w));
  } else return null; 
}






/**
greaterThanEqual
*/
public boolean greaterThanEqual(float x, float y) {
  return x>=y?true:false;
}

public boolean greaterThanEqual(int x, int y) {
  return greaterThanEqual((float)x,(float)y);
}

// with vec
public bvec2 greaterThanEqual(vec2 x, vec2 y) {
  if(x != null && y != null) {
    return bvec2(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y));
  } else return null; 
}

public bvec3 greaterThanEqual(vec3 x, vec3 y) {
  if(x != null && y != null) {
    return bvec3(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y),greaterThanEqual(x.z,y.z));
  } else return null; 
}

public bvec4 greaterThanEqual(vec4 x, vec4 y) {
  if(x != null && y != null) {
    return bvec4(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y),greaterThanEqual(x.z,y.z),greaterThanEqual(x.w,y.w));
  } else return null; 
}

// width ivec
public bvec2 greaterThanEqual(ivec2 x, ivec2 y) {
  if(x != null && y != null) {
    return bvec2(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y));
  } else return null; 
}

public bvec3 greaterThanEqual(ivec3 x, ivec3 y) {
  if(x != null && y != null) {
    return bvec3(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y),greaterThanEqual(x.z,y.z));
  } else return null; 
}

public bvec4 greaterThanEqual(ivec4 x, ivec4 y) {
  if(x != null && y != null) {
    return bvec4(greaterThanEqual(x.x,y.x),greaterThanEqual(x.y,y.y),greaterThanEqual(x.z,y.z),greaterThanEqual(x.w,y.w));
  } else return null; 
}






/**
lessThanEqual
*/
public boolean lessThanEqual(float x, float y) {
  return x<=y?true:false;
}

public boolean lessThanEqual(int x, int y) {
  return lessThanEqual((float)x,(float)y);
}

// with vec
public bvec2 lessThanEqual(vec2 x, vec2 y) {
  if(x != null && y != null) {
    return bvec2(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y));
  } else return null; 
}

public bvec3 lessThanEqual(vec3 x, vec3 y) {
  if(x != null && y != null) {
    return bvec3(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y),lessThanEqual(x.z,y.z));
  } else return null; 
}

public bvec4 lessThanEqual(vec4 x, vec4 y) {
  if(x != null && y != null) {
    return bvec4(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y),lessThanEqual(x.z,y.z),lessThanEqual(x.w,y.w));
  } else return null; 
}

// width ivec
public bvec2 lessThanEqual(ivec2 x, ivec2 y) {
  if(x != null && y != null) {
    return bvec2(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y));
  } else return null; 
}

public bvec3 lessThanEqual(ivec3 x, ivec3 y) {
  if(x != null && y != null) {
    return bvec3(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y),lessThanEqual(x.z,y.z));
  } else return null; 
}

public bvec4 lessThanEqual(ivec4 x, ivec4 y) {
  if(x != null && y != null) {
    return bvec4(lessThanEqual(x.x,y.x),lessThanEqual(x.y,y.y),lessThanEqual(x.z,y.z),lessThanEqual(x.w,y.w));
  } else return null; 
}







/**
all
v 0.0.2
*/
public boolean all(bvec2 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = true;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == false) {
        result = false;
        break;
      }
    }
    return result;
  } else {
    printErr("method all(bvec2 b) return false because argument is",b);
    return false;
  }
}

public boolean all(bvec3 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = true;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == false) {
        result = false;
        break;
      }
    }
    return result;
  } else {
    printErr("method all(bvec3 b) return false because argument is",b);
    return false;
  }
}

public boolean all(bvec4 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = true;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == false) {
        result = false;
        break;
      }
    }
    return result;
  } else {
    printErr("method all(bvec4 b) return false because argument is",b);
    return false;
  }
}

public boolean all(bvec5 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = true;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == false) {
        result = false;
        break;
      }
    }
    return result;
  } else {
    printErr("method all(bvec5 b) return false because argument is",b);
    return false;
  }
}

public boolean all(bvec6 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = true;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == false) {
        result = false;
        break;
      }
    }
    return result;
  } else {
    printErr("method all(bvec6 b) return false because argument is",b);
    return false;
  }
}




/**
any
*/
public boolean any(bvec2 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = false;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == true) {
        result = true;
        break;
      }
    }
    return result;
  } else {
    printErr("method any() return false because argument is",b);
    return false;
  }
}

public boolean any(bvec3 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = false;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == true) {
        result = true;
        break;
      }
    }
    return result;
  } else {
    printErr("method any() return false because argument is",b);
    return false;
  }
}

public boolean any(bvec4 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = false;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == true) {
        result = true;
        break;
      }
    }
    return result;
  } else {
    printErr("method any() return false because argument is",b);
    return false;
  }
}

public boolean any(bvec5 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = false;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == true) {
        result = true;
        break;
      }
    }
    return result;
  } else {
    printErr("method any() return false because argument is",b);
    return false;
  }
}

public boolean any(bvec6 b) {
  if(b != null) {
    boolean [] list = b.array();
    boolean result = false;
    for(int i = 0 ; i < list.length ; i++) {
      if(list[i] == true) {
        result = true;
        break;
      }
    }
    return result;
  } else {
    printErr("method any() return false because argument is",b);
    return false;
  }
}


/**
* ROPE SVG
* v 1.5.0
* Copyleft (c) 2014-2019
* @author @stanlepunk
* @see https://github.com/StanLepunK/Rope_framework
*/

class ROPE_svg {
  PApplet p5  ;
  //
  PShape shape_SVG ;
  String path = "" ;
  String folder_brick_name = "brick" ;
  ArrayList<Brick_SVG> list_brick_SVG = new ArrayList<Brick_SVG>() ;
  String name = "" ;
  String header_svg = "" ;
  int ID_brick ;
  private String saved_path_bricks_svg = "" ;

  private boolean position_center = false ;
  
  private boolean bool_scale_translation ; 
  private boolean bool_pos, bool_jitter_svg, bool_scale_svg ;
  private boolean keep_change ;

  private boolean display_fill_original = true ;
  private boolean display_stroke_original = true ;
  private boolean display_thickness_original = true ;

  private boolean display_fill_custom = false ;
  private boolean display_stroke_custom = false ;
  private boolean display_thickness_custom = false ;

  private vec3 pos = vec3() ;
  private vec3 jitter_svg = vec3() ;
  private vec3 scale_svg = vec3() ;

  // Aspect default
  private String [] st ;
  private vec4 fill_custom = vec4(0,0,0,g.colorModeA) ;
  private vec4 stroke_custom = vec4(g.colorModeX,g.colorModeY,g.colorModeZ,g.colorModeA) ;
  private float thickness_custom = 1 ;

  private vec4 fill_factor = vec4(1) ;
  private vec4 stroke_factor = vec4(1) ;






  /**  
  CONSTRUCTOR

  */
  ROPE_svg (PApplet p5, String path, String folder_brick_name) {
    this.p5 = p5 ;
    this.name = file_name(path) ;
    this.folder_brick_name = folder_brick_name ;
    this.path = path ;
    saved_path_bricks_svg = "RPE_SVG/" + folder_brick_name + "/" ;
  }

  ROPE_svg (PApplet p5, String path) {
    this.p5 = p5 ;
    this.name = file_name(path) ;
    this.path = path ;
    saved_path_bricks_svg = "RPE_SVG/" + folder_brick_name + "/" ;
  }



  

  
  








  /**
  PUBLIC METHOD

  */
  public void build(String path_import, String path_brick) {
    list_brick_SVG.clear() ;
    list_ellipse_SVG.clear() ;
    list_rectangle_SVG.clear() ;
    list_vertice_SVG.clear() ;

    shape_SVG = loadShape(path_import) ;

    XML svg_info = loadXML(path_import) ;
    analyze_SVG(svg_info) ;
    save_brick_SVG() ;
    build_SVG(list_brick_SVG, path_brick) ;

  }

  public void build() {
    build(path, saved_path_bricks_svg) ;
  } 






  
  /**
  METHOD to draw all the SVG
  */
  public void draw() {
    reset() ;
    draw_SVG (pos, scale_svg, jitter_svg) ;
    change_boolean_to_false() ;
  }
  
  public void draw(int ID) {
    reset() ;
    draw_SVG (pos, scale_svg, jitter_svg, ID) ;
    change_boolean_to_false() ;
  }


  public void draw(String layer_or_group_name) {
    reset() ;
    vec3 new_pos = pos.copy() ;
    if(bool_scale_translation) {
      start_matrix() ;
      vec3 translation = vec3() ;
      translation = scale_translation(scale_svg, layer_or_group_name); 
      translate(translation) ;
    }
    draw_SVG (pos, scale_svg, jitter_svg, layer_or_group_name) ;

    if(bool_scale_translation) stop_matrix() ;

    change_boolean_to_false() ;
  }


  private vec3 scale_translation(vec3 scale_svg, String layer_name) {
    vec3 translation = vec3() ;

    int num = 0 ;
    vec3 correction = vec3() ;
    for(int i = 0 ; i < list_brick_SVG.size() ; i++) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(i) ;
      if( b.family_name.contains(layer_name)) {
        // catch position before the scaling
        for(int k = 0 ; k < list_svg_vec(b.ID).length ; k++) {
          num++ ;
          // special translate for the shape kind rect, because this one move from the corner
          if(b.kind == "rect") {
             float width_rect = b.xml_brick.getChild(0).getFloat("width") ;
             float height_rect = b.xml_brick.getChild(0).getFloat("height") ;
             correction.set(width_rect *.5f, height_rect *.5f, 0) ;
           }
        }
      }
    }

    vec3 [] list_raw = new vec3[num] ;
    for(int i = 0 ; i < list_brick_SVG.size() ; i++) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(i) ;
      if( b.family_name.contains(layer_name)) {
        // catch position before the scaling
        for(int k = 0 ; k < list_svg_vec(b.ID).length ; k++) {
          list_raw[k] = list_svg_vec(b.ID)[k].copy()  ;
        }
      }
    }

    // result
    vec3 barycenter = barycenter(list_raw) ;
    if(position_center) {
      vec3 center_pos = vec3(canvas().x,canvas().y, 0) ;
      center_pos.mult(.5f) ;
      barycenter.sub(center_pos) ;
    }
    if(!correction.equals(0)) barycenter.add(correction);
    vec3 barycenter_translated = mult(barycenter, scale_svg) ;
    translation = sub(barycenter, barycenter_translated) ;

    return translation ;
  }


  
  /**
  TEMPORARY CHANGE
  This change don't modify the original coord of point
  */

 /**
 POS
 */
  public void pos(float x) {
    bool_pos = true ;
    pos.set(x) ;
  }

  public void pos(float x, float y) {
    bool_pos = true ;
    pos.set(x,y,0) ;
  }

  public void pos(float x, float y, float z) {
    bool_pos = true ;
    pos.set(x,y,z) ;
  }

  public void pos(vec pos_raw) {
    bool_pos = true ;
    if(pos_raw instanceof vec2) {
      vec2 pos_2D = (vec2) pos_raw ;
      pos.set(pos_2D.x, pos_2D.y, 0) ;
    } else if (pos_raw instanceof vec3) {
      vec3 pos_3D = (vec3) pos_raw ;
      pos.set(pos_3D) ;
    }
  }

  /**
  SCALE
  */
  // scale_translation
  private void scaling(float x) {
    scaling(false, vec3(x,x,0)) ;
  }

  private void scaling(float x, float y) {
    scaling(false, vec3(x,y,0)) ;
  }

  private void scaling(float x, float y, float z) {
    scaling(false, vec3(x,y,z)) ;
  }

  private void scaling(vec scale_raw) {
    scaling(false, scale_raw) ;
  }

  private void scaling(boolean translation, float x) {
    scaling(translation, vec3(x,x,0)) ;
  }

  private void scaling(boolean translation, float x, float y) {
    scaling(translation, vec3(x,y,0)) ;
  }

  private void scaling(boolean translation, float x, float y, float z) {
    scaling(translation, vec3(x,y,z)) ;
  }

  private void scaling(boolean translation, vec scale_raw) {
    bool_scale_translation = translation ;
    bool_scale_svg = true ;
    if(scale_raw instanceof vec2) {
      vec2 scale = (vec2) scale_raw ;
      scale_svg.set(scale.x, scale.y, 1) ;
    } else if (scale_raw instanceof vec3) {
      vec3 scale = (vec3) scale_raw ;
      scale_svg.set(scale) ;
    }
  }



  /**
  JITEER 
  */
  public void jitter(float x) {
    bool_jitter_svg = true ;
    jitter_svg.set(x) ;
  }

  public void jitter(int x, int y) {
    bool_jitter_svg = true ;
    jitter_svg.set(x,y,0) ;
  }

  public void jitter(int x, int y, int z) {
    bool_jitter_svg = true ;
    jitter_svg.set(x,y,z) ;
  }

  public void jitter(vec jitter_raw) {
    bool_jitter_svg = true ;
    if(jitter_raw instanceof vec2) {
      vec2 jitter = (vec2) jitter_raw ;
      jitter_svg.set(jitter.x, jitter.y, 0) ;
    } else if (jitter_raw instanceof vec3) {
      vec3 jitter = (vec3) jitter_raw ;
      jitter_svg.set(jitter) ;
    }
  }

  
  
  
  /* 
  method start() & end() use in correlation with reset for the change like jitter, pos, scale...
  when the svg is using in split mode with name or ID param
  */
  public void start() {
    keep_change = true ;
  }
  public void stop() {
    keep_change = false ;
    reset() ;
  }


  /**
  ASPECT
  v 0.2.0
  */
  /**
  opacity
  */
  public void opacity(float a_fill, float a_stroke) {
    display_stroke_original = true ;
    display_stroke_custom = false ;
    display_fill_original = true ;
    display_fill_custom = false ;
    float normalize_alpha_fill = (a_fill / g.colorModeA) ;
    float normalize_alpha_stroke = (a_stroke / g.colorModeA) ;
    this.fill_factor(1, 1, 1, normalize_alpha_fill) ;
    this.stroke_factor(1, 1, 1, normalize_alpha_stroke) ;

  }

  public void opacityStroke(float a) {
    display_stroke_original = true ;
    display_stroke_custom = false ;
    float normalize_alpha = (a / g.colorModeA) ;
    this.stroke_factor(1, 1, 1, normalize_alpha) ;
  }
    public void opacityFill(float a) {
    display_fill_original = true ;
    display_fill_custom = false ;
    float normalize_alpha = (a / g.colorModeA) ;
    this.fill_factor(1, 1, 1, normalize_alpha) ;
  }
  
  /**
  fill
  */

  public void noFill() {
    display_fill_original = false ;
    display_fill_custom = true ;
    fill_custom.set(0) ;
  }
  
  public void fill(int c) {
    display_fill_original = false ;
    display_fill_custom = true;
    if(g.colorMode == 1 ) fill_custom.set(red(c),green(c),blue(c),alpha(c));
    else if(g.colorMode == 3) fill_custom.set(hue(c),saturation(c),brightness(c),alpha(c));
  }

  public void fill(float value) {
    display_fill_original = false ;
    display_fill_custom = true ;
    fill_custom.set(value,value,value, g.colorModeA) ;
  }

  public void fill(float value, float alpha) {
    display_fill_original = false ;
    display_fill_custom = true ;
    fill_custom.set(value,value,value, alpha) ;
  }

  public void fill(float x, float y, float z) {
    display_fill_original = false ;
    display_fill_custom = true ;
    fill_custom.set(x, y, z, g.colorModeA) ;
  }
  
  public void fill(float x, float y, float z, float a) {
    display_fill_original = false ;
    display_fill_custom = true ;
    fill_custom.set(x,y,z,a) ;
  }

  public void fill(vec v) {
    display_fill_original = false ;
    display_fill_custom = true ;
    if(v instanceof vec2) {
      vec2 v2 = (vec2) v ;
      fill_custom.set(v2.x, v2.x, v2.x, v2.y) ;
    } else if(v instanceof vec3) {
      vec3 v3 = (vec3) v ;
      fill_custom.set(v3.x,v3.y,v3.z, g.colorModeA) ;
    } else if(v instanceof vec3 ) {
      vec4 v4 = (vec4) v ;
      fill_custom.set(v4.x, v4.y, v4.z, v4.w) ;
    }
  }
  /**
  stroke
  */
  public void noStroke() {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    thickness_custom = 0 ;
    stroke_custom.set(0) ;
  }
  
  public void stroke(int c) {
    display_stroke_original = false ;
    display_stroke_custom = true;
    if(g.colorMode == 1 ) stroke_custom.set(red(c),green(c),blue(c),alpha(c));
    else if(g.colorMode == 3) stroke_custom.set(hue(c),saturation(c),brightness(c),alpha(c));
  }

  public void stroke(float value) {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    stroke_custom.set(value, value, value, g.colorModeA) ;
  }

  public void stroke(float value, float a) {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    stroke_custom.set(value, value, value, a) ;
  }

  public void stroke(float x, float y, float z) {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    stroke_custom.set(x, y, z, g.colorModeA) ;
  }

  public void stroke(float x, float y, float z, float a) {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    stroke_custom.set(x,y,z,a) ;
  }


  public void stroke(vec v) {
    display_stroke_original = false ;
    display_stroke_custom = true ;
    if(v instanceof vec2) {
      vec2 v2 = (vec2) v ;
      stroke_custom.set(v2.x, v2.x, v2.x, v2.y) ;
    } else if(v instanceof vec3) {
      vec3 v3 = (vec3) v ;
      stroke_custom.set(v3.x,v3.y,v3.z, g.colorModeA) ;
    } else if(v instanceof vec3 ) {
      vec4 v4 = (vec4) v ;
      stroke_custom.set(v4.x, v4.y, v4.z, v4.w) ;
    }
  }
  /**
  strokeWeight
  */
  public void strokeWeight(float x) {
    display_thickness_original = false ;
    display_thickness_custom = true ;
    thickness_custom = x ;
  }


  /**
  original style
  */
  public void original_style(boolean fill, boolean stroke) {
    display_fill_original = fill ;
    display_stroke_original = stroke ;
    display_thickness_original = stroke ;
  }

  public void original_fill(boolean fill) {
    display_fill_original = fill ;
  }

  public void original_stroke(boolean stroke) {
    display_stroke_original = stroke ;
    display_thickness_original = stroke ;
  }
  

  /**
  fill factor
  use value from '0' to '1' is better !
  */
  public void fill_factor(float x, float y, float z, float a) {
    fill_factor.set(x,y,z,a) ;
  }

  public void stroke_factor(float x, float y, float z, float a) {
    stroke_factor.set(x,y,z,a) ;
  }

  public void fill_factor(vec4 f) {
    fill_factor.set(f.x,f.y,f.z,f.w) ;
  }

  public void stroke_factor(vec4 f) {
    stroke_factor.set(f.x,f.y,f.z,f.w) ;
  }

  /**
  PERMANENTE CHANGE
  This change modify the original points
  */
  public void add_def(int target, vec3... value) {
    if(list_brick_SVG.size() > 0) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(target) ;
      if(b.kind == "polygon" || b.kind == "path" || b.kind == "polyline") {
        for(Vertices v : list_vertice_SVG) {
          if(v.ID == b.get_id()) v.add_value(value) ;
        }
      } else if(b.kind == "line") {
        for(Line l : list_line_SVG) {
          if(l.ID == b.get_id()) l.add_value(value) ;
        }
      } else if(b.kind == "circle" || b.kind == "ellipse") {
        for(Ellipse e : list_ellipse_SVG) {
          if(e.ID == b.get_id()) e.add_value(value) ;
        }
      } else if(b.kind == "rect") {
        for(Rectangle r : list_rectangle_SVG) {
          if(r.ID == b.get_id()) r.add_value(value) ;
        }
      } else if(b.kind == "text") {
        for(ROPEText t : list_text_SVG) {
          if(t.get_id() == b.get_id()) t.add_value(value) ;
        }
      } 
    } 
  }
  

  /**
  SVG info
  */

  
  /**
   return quantity of brick 
  */
  public int num_brick() {
    return list_brick_SVG.size() ;
  }
  

  /**
  list
  */
  public vec3 [] list_svg_vec(int target) {
    vec3 [] p = new vec3[1] ;
    p[0] = vec3(2147483647,2147483647,2147483647) ; // it's maximum value of int in 8 bit :)

    if(list_brick_SVG.size() > 0) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(target) ;
      if(b.kind == "polygon" || b.kind == "path" || b.kind == "polyline") {
        for(Vertices v : list_vertice_SVG) {
          if(v.ID == b.ID) return v.vertices() ;
        }
      } else if(b.kind == "line") {
        for(Line l : list_line_SVG) {
          if(l.ID == b.ID) {
            p[0] = l.pos_a ;
            p[1] = l.pos_b ;
            return p ;
          }
        }
      } else if(b.kind == "circle" || b.kind == "ellipse") {
        for(Ellipse e : list_ellipse_SVG) {
          if(e.ID == b.ID) {
            p[0] = e.pos ;
            return p ;
          }
        }
      } else if(b.kind == "rect") {
        for(Rectangle r : list_rectangle_SVG) {
          if(r.ID == b.ID) { 
            p[0] = r.pos ;
            return p ;
          }
        }
      } 
    } else return p ;
    return p ;
  }


  public PVector [] list_svg_PVector(int target) {
    PVector [] p  ;
    vec3 [] temp_list ;
    temp_list = list_svg_vec(target).clone() ;
    int num = temp_list.length ;
    p = new PVector[num] ;
    for(int i = 0 ; i < num ; i++) {
      p[i] = new PVector(temp_list[i].x, temp_list[i].y, temp_list[i].z) ;
    }
    if (p != null) return p ; else return null ;
  }





  /**
  method to return different definition about the brick
  */

  public String folder_brick_name() {
    return folder_brick_name ;
  }


  public String [] brick_name_list() {
    return name_brick_SVG(list_brick_SVG) ;
  }

  public String brick_name(int target) {
    if(list_brick_SVG.size() > 0 && target < list_brick_SVG.size()) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(target) ;
      return b.brick_name ;

    } else return "No idea for this ID !" ;
  }

  public String [] family_brick() {
    return family_brick_SVG(list_brick_SVG) ;
  }

  public String family_brick(int target) {
    if(list_brick_SVG.size() > 0 && target < list_brick_SVG.size()) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(target) ;
      return b.family_name ;

    } else return "No idea for this ID !" ;
  }

  public String [] kind_brick() {
    return kind_brick_SVG(list_brick_SVG) ;
  }
  public String kind_brick(int target) {
    if(list_brick_SVG.size() > 0 && target < list_brick_SVG.size()) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(target) ;
      return b.kind ;

    } else return "No idea for this ID !" ;
  }





  
  




  /**
  Canvas SVG
  */
  public float width() {
    if(shape_SVG != null) {
      return shape_SVG.width ; 
    } else {
      return 0 ;
    }
  }
  public float height() {
    if(shape_SVG != null) { 
      return shape_SVG.height ; 
    } else {
      return 0 ;
    }
  }
  
  public vec2 canvas() {
    if(shape_SVG != null) {
      return vec2(shape_SVG.width, shape_SVG.height) ; 
    } else { 
      return vec2() ;
    }
  }
  
  
  
  
  
  /**
  Canvas brick SVG
  */
  public float width_brick(int target) {
    if(list_brick_SVG.size() > 0 && target <list_brick_SVG.size()) {
      Brick_SVG b_svg = list_brick_SVG.get(target) ;
      return b_svg.width ; 
    } else return 0 ;
  }

  public float height_brick(int target) {
    if(list_brick_SVG.size() > 0 && target <list_brick_SVG.size()) {
      Brick_SVG b_svg = list_brick_SVG.get(target) ;
      return b_svg.height ; 
    } else return 0 ;
  }
  
  public vec2 canvas_brick(int target) {
    if(list_brick_SVG.size() > 0 && target <list_brick_SVG.size()) {
      Brick_SVG b_svg = list_brick_SVG.get(target) ;
      return vec2(b_svg.width, b_svg.height) ;
    } else return vec2() ;
  }










 /**
  SETTING
  */
  public void mode(int mode) {
    // for info CORNER = 0 / CENTER = 3 > Global variable from Processing
    if(mode == 0 ) position_center = false ;
    else if(mode == 3 ) position_center = true ;
    else position_center = false ;
  }
  /**
  // END PUBLIC METHOD


  */
  







  
  
  
  
  
  






  
  
  
  
  
  
  
  
  /**
  PRIVATE METHOD


  */

  /**
  DRAW

  */
  // reset all change to something flat and borring !
  public void reset() {
    if(!keep_change) {
      if(!bool_pos) {
        pos.set(0) ;
      }
      if(!bool_jitter_svg) {
        jitter_svg.set(0) ;
      }
      if(!bool_scale_svg) {
        scale_svg.set(1) ;
      }
    } else {
      original_style(true, true) ;
      fill_factor(1,1,1,1) ;
      stroke_factor(1,1,1,1) ;
    }
  }
  


  private void change_boolean_to_false() {
    bool_pos = false ;
    bool_scale_svg = false ;
    bool_jitter_svg = false ;
    bool_scale_translation = false ;
  }
  /**
  Draw all shape
  */
  // INTERN METHOD 2D
  private void draw_SVG(vec pos_, vec scale_, vec jitter_) {
    for(int i = 0 ; i < list_brick_SVG.size() ; i++) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(i) ;
      draw_final(pos_, scale_, jitter_, b) ;
    }
  }
 
  
  /**
  Draw shape by ID
  */
  // 2D
  private void draw_SVG (vec pos_, vec scale_, vec jitter_, int ID) {
    if(ID < list_brick_SVG.size()) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(ID) ;
      draw_final(pos_, scale_, jitter_, b) ;
    }
  }
   
  
  /**
  Draw shape by name
  */
  // draw all file from shape or group of layer
  // must be factoring is very ligth method :)
  private void draw_SVG (vec pos_, vec scale_, vec jitter_, String layer_name) {
    for(int i = 0 ; i < list_brick_SVG.size() ; i++) {
      Brick_SVG b = (Brick_SVG) list_brick_SVG.get(i) ;
      if( b.family_name.contains(layer_name)) {
        draw_final(pos_, scale_, jitter_, b) ;
      }
    }
  }

  private void draw_final(vec pos_, vec scale_, vec jitter_, Brick_SVG b) {
    if(b.font != null) textFont(b.font) ;
    if(b.size_font != MAX_INT) textSize(b.size_font) ;

    float average_scale = (scale_.x + scale_.y) *.5f ;
    aspect(b, average_scale) ;
    display_shape(b, pos_, scale_, jitter_) ;

  }
  /**
  END DRAW METHOD

  */






  /**
  ASPECT
  */
  private void aspect(Brick_SVG b, float scale_thickness) {
    aspect_original(b, scale_thickness) ;
    aspect_custom() ;
  }

  // super local
  private  void aspect_original(Brick_SVG b, float scale_thickness) {
    if(display_fill_original) {
      b.aspect_fill(fill_factor) ; 
    } else {
      p5.noFill() ;
    }
    if(display_stroke_original && display_thickness_original) {
      b.aspect_stroke(scale_thickness,stroke_factor) ; 
    } else { 
      p5.noStroke() ;
    }
  }

  private  void aspect_custom() {
    if(fill_custom.alp() > 0 && display_fill_custom && !display_fill_original) {
      p5.fill(fill_custom.red() *fill_factor.x, fill_custom.gre() *fill_factor.y, fill_custom.blu() *fill_factor.y, fill_custom.alp() *fill_factor.w) ; 
    }
    if(display_stroke_custom && !display_stroke_original) {
      if(stroke_custom.alp() > 0 || thickness_custom > 0 ) {
        p5.stroke(stroke_custom.red() *stroke_factor.x, stroke_custom.gre() *stroke_factor.y, stroke_custom.blu() *stroke_factor.z, stroke_custom.alp() *stroke_factor.w) ;
        p5.strokeWeight(thickness_custom) ;
      }
    }
    
    if(!display_fill_original && !display_fill_custom) {
      p5.noFill() ;
    }
    if(!display_stroke_original && !display_stroke_custom) {
      p5.noStroke() ;
    }
  }



  
  


































  /**
  BUILD

  */
  /**
  Main display method

  */
  private void display_shape(Brick_SVG b, vec pos_raw, vec scale_raw, vec jitter_raw) {
    if(pos_raw instanceof vec2 && scale_raw instanceof vec2 && jitter_raw instanceof vec2) {
      vec2 pos_temp = (vec2) pos_raw ;
      vec2 scale_temp = (vec2) scale_raw ;
      vec2 jitter_temp = (vec2) jitter_raw ;

      vec3 pos = vec3(pos_temp) ;
      vec3 scale = vec3(scale_temp) ;
      vec3 jitter = vec3(jitter_temp) ;
      display_shape_3D(b, pos, scale, jitter) ;
    } else if (pos_raw instanceof vec3 && scale_raw instanceof vec3 && jitter_raw instanceof vec3) {
      vec3 pos = (vec3) pos_raw ;
      vec3 scale = (vec3) scale_raw ;
      vec3 jitter = (vec3) jitter_raw ;
      display_shape_3D(b, pos, scale, jitter) ;
    }
  }

  private void display_shape_3D(Brick_SVG b, vec3 pos, vec3 scale, vec3 jitter) {
    if(b.kind == "path" || b.kind == "polygon" || b.kind == "polyline") {
      for(Vertices v : list_vertice_SVG) {
        if(v.ID == b.ID) build_path(pos, scale, jitter, v) ;
      }
    } else if(b.kind == "line") {
      for(Line l : list_line_SVG) {
        if(l.ID == b.ID) {
          build_line(pos, scale, jitter, l) ;
        }
      }
    } else if(b.kind == "ellipse" || b.kind == "circle") {
      for(Ellipse e : list_ellipse_SVG) {
        if(e.ID == b.ID) {
          build_ellipse(pos, scale, jitter, e) ;
        }
      }
    } else if(b.kind == "rect") {
      for(Rectangle r : list_rectangle_SVG) {
        if(r.ID == b.ID) {
          build_rectangle(pos, scale, jitter, r) ;
        }
      }
    } else if(b.kind == "text") {
      for(ROPEText t : list_text_SVG) {
        if(t.ID == b.ID) {
          build_text(pos, scale, jitter, t) ;
        }
      }
    }
  }



  /**

  Build SVG brick


  */
  private void build_SVG(ArrayList<Brick_SVG> list, String path_brick) {
    PShape [] children = new PShape[list.size()] ;
    for(int i = 0 ; i < list.size() ; i++) {
      PShape mother = loadShape(path_brick + folder_brick_name + "_" + i + ".svg") ;
      children = mother.getChildren() ;
      /**
      Problem here with P3D and P2D mode
      return null pointer exception with type 'text'
      println(children) ;
      */
      
      Brick_SVG b = (Brick_SVG) list.get(i) ;
      if(b.kind == "polygon" || b.kind == "path" || b.kind == "polyline")  vertex_count(children[0], mother.getName(), b.ID) ;
      if(b.kind == "line")  line_count(b.xml_brick, mother.getName(), b.ID) ;
      else if(b.kind == "circle" || b.kind == "ellipse") ellipse_count(b.xml_brick, b.ID) ;
      else if(b.kind == "rect") rectangle_count(b.xml_brick, b.ID) ;
      else if(b.kind == "text") text_count(b.xml_brick,  b.ID) ;
    }
  }
  
  /**
  TEXT
  */
  // list of group SVG
  ArrayList<ROPEText> list_text_SVG = new ArrayList<ROPEText>() ;
      
  //
  private void text_count(XML xml_shape, int ID) {
    vec6 matrix = matrix_vec(xml_shape) ;
    String sentence = xml_shape.getChild("text").getContent() ;

    ROPEText t = new ROPEText(matrix, sentence, ID) ;
    list_text_SVG.add(t) ;
  }



  

  /**
  Main method to draw text
  */
  public void build_text(vec3 pos, vec3 scale, vec3 jitter, ROPEText t) {
    vec3 temp_pos = vec3(t.pos.x, t.pos.y,0)   ;
    // the order of operation is very weird, because is not a same for the build_vertex()
    if(position_center) {
      vec3 center_pos = vec3(canvas().x,canvas().y, 0) ;
      center_pos.mult(.5f) ; 
      temp_pos.sub(center_pos) ;
    }
    if(!scale.equals(vec3(1))) {
      temp_pos.mult(scale) ; 
    }
    if(!pos.equals(vec3())) {
      temp_pos.add(pos) ;
    }

    
    if(check_matrix(t.matrix)) {
      start_matrix() ;
      matrix(t.matrix, temp_pos) ;
      text(t.sentence, 0,0) ;
      stop_matrix() ;
    } else {
      // if there is no matrix effect
      text(t.sentence, temp_pos) ;
    }
  }
  /**
  END CIRCLE & ELLIPSE
  */













  /**
  Line
  */
  // list of group SVG
  ArrayList<Line> list_line_SVG = new ArrayList<Line>() ;

  private void line_count(XML xml_shape, String geom_name, int ID) {
    float x_a = xml_shape.getChild(0).getFloat("x1") ;
    float y_a = xml_shape.getChild(0).getFloat("y1") ;
    float x_b = xml_shape.getChild(0).getFloat("x2") ;
    float y_b = xml_shape.getChild(0).getFloat("y2") ;
  
    Line l = new Line(x_a, y_a, x_b, y_b, ID) ;
    list_line_SVG.add(l) ;
  }
  

  /**
  Main method to draw ellipse
  */
  public void build_line(vec3 pos, vec3 scale, vec3 jitter, Line l) {
    vec3 temp_pos_a = vec3(l.pos_a.x, l.pos_a.y,0)  ;
    vec3 temp_pos_b = vec3(l.pos_b.x, l.pos_b.y,0)  ;

  
    // the order of operation is very weird, because is not a same for the build_vertex()
    if(position_center) {
      vec3 center_pos = vec3(canvas().x,canvas().y, 0) ;
      center_pos.mult(.5f) ; 
      temp_pos_a.sub(center_pos) ;
      temp_pos_b.sub(center_pos) ;
    }
    if(!scale.equals(vec3(1))) {
      temp_pos_a.mult(scale) ; 
      temp_pos_b.mult(scale) ; 
    }
    if(!pos.equals(vec3())) {
      temp_pos_a.add(pos) ;
      temp_pos_b.add(pos) ;
    }
  
    line(temp_pos_a.mult(scale), temp_pos_b.mult(scale)) ;
  }
  /**
  END CIRCLE & ELLIPSE
  */







  /**
  ELLIPSE & CIRCLE
  */
  // list of group SVG
  ArrayList<Ellipse> list_ellipse_SVG = new ArrayList<Ellipse>() ;

  private void ellipse_count(XML xml_shape, int ID) {
    vec6 matrix = matrix_vec(xml_shape) ;
    float r = xml_shape.getChild(0).getFloat("r") ;
    float rx = (float)xml_shape.getChild(0).getFloat("rx") ;
    float ry = (float)xml_shape.getChild(0).getFloat("ry") ;
    float cx = xml_shape.getChild(0).getFloat("cx") ;
    float cy = xml_shape.getChild(0).getFloat("cy") ;
    if(r > 0 ) rx = ry = r ;
  
    Ellipse e = new Ellipse(matrix, cx, cy, rx, ry, ID) ;
    list_ellipse_SVG.add(e) ;
  }
  

  /**
  Main method to draw ellipse
  */
  public void build_ellipse(vec3 pos, vec3 scale, vec3 jitter, Ellipse e) {
    vec3 temp_pos = vec3(e.pos.x, e.pos.y,0)  ;

  
    // the order of operation is very weird, because is not a same for the build_vertex()
    if(position_center) {
      vec3 center_pos = vec3(canvas().x,canvas().y, 0) ;
      center_pos.mult(.5f) ; 
      temp_pos.sub(center_pos) ;
    }
    if(!scale.equals(vec3(1))) temp_pos.mult(scale) ; 
    if(!pos.equals(vec3())) temp_pos.add(pos) ;
  
    vec2 temp_size = e.size.copy() ;

    if(check_matrix(e.matrix)) {
      start_matrix() ;
      matrix(e.matrix, temp_pos) ;
      ellipse(vec2(0), temp_size.mult(scale.x, scale.y)) ;
      stop_matrix() ;
    } else {
      // if there is no matrix effect
      ellipse(temp_pos, temp_size.mult(scale.x, scale.y)) ;
    }

    
  }
  /**
  END CIRCLE & ELLIPSE
  */
  



  /**
  RECTANGLE
  */
  // list of group SVG
  private ArrayList<Rectangle> list_rectangle_SVG = new ArrayList<Rectangle>() ;
  
  private void rectangle_count(XML xml_shape, int ID) {
    vec6 matrix = matrix_vec(xml_shape) ;
    float x = xml_shape.getChild(0).getFloat("x") ;
    float y = xml_shape.getChild(0).getFloat("y") ;
    float width_rect = xml_shape.getChild(0).getFloat("width") ;
    float height_rect = xml_shape.getChild(0).getFloat("height") ;
  
    Rectangle r = new Rectangle(matrix, x, y, width_rect, height_rect, ID) ;
    list_rectangle_SVG.add(r) ;
  }
  
  /**
  Main method to draw ellipse
  */
  
  private void build_rectangle(vec3 pos, vec3 scale, vec3 jitter, Rectangle r) {
    vec3 temp_pos = vec3(r.pos.x, r.pos.y,0)  ;
  
    // the order of operation is very weird, because is not a same for the build_vertex()
    if(position_center) {
      vec3 center_pos = vec3(canvas().x,canvas().y, 0) ;
      center_pos.mult(.5f) ; 
      temp_pos.sub(center_pos) ;
    }
    if(!scale.equals(vec3(1))) temp_pos.mult(scale) ; 
    if(!pos.equals(vec3())) temp_pos.add(pos) ;
  
    vec2 temp_size = r.size.copy() ;

    if(check_matrix(r.matrix)) {
      start_matrix() ;
      matrix(r.matrix, temp_pos) ;
      vec2 pos_def = vec2() ;
      // pos_def.x += (temp_size.x *.5) ;
      // pos_def.y += (temp_size.y *.5) ;
      // pos_def.x += mouseX ;
      // pos_def.y += mouseY ;
      printTempo(60, pos_def) ;
      printTempo(60, "void build_rectangle()") ;
      rect(pos_def, temp_size) ;
      stop_matrix() ;
    } else {
      // if there is no matrix effect
      rect(temp_pos, temp_size.mult(scale.x, scale.y)) ;
    }
  }
  /**
  END RECTANGLE
  */
  

  











  /**
  VERTEX


  */
  /**
  Build
  */
  // list of group SVG
  private ArrayList<Vertices> list_vertice_SVG = new ArrayList<Vertices>() ;
  // here we must build few object for each group, but how ?
  private vec3 [] vert ;
  private int [] vertex_code ;
  private int code_vertex_count ;
  
  private void vertex_count(PShape geom_shape, String geom_name, int ID) {
    int num = geom_shape.getVertexCount() ;
    vertex_code = new int[num] ;
    vert = new vec3[num] ;
    vertex_code = geom_shape.getVertexCodes() ;
    code_vertex_count = geom_shape.getVertexCodeCount() ;
    
    Vertices v = new Vertices(code_vertex_count, num, geom_shape, geom_name, ID) ;
    v.build_vertices_3D(geom_shape) ;
    list_vertice_SVG.add(v) ;
  }
  /**
  END VERTEX
  */
 
  




  /**
  Draw Vertice
  adapted from Processing PShape drawPath for the vertex
  https://github.com/processing/processing/blob/master/core/src/processing/core/PShape.java
  line 1700 and the dust !
  */


  private void build_path(vec3 pos, vec3 scale, vec3 jitter, Vertices v) {
    vec3 center_pos = vec3(canvas().x,canvas().y,0) ;
    center_pos.mult(.5f) ; 
    if(!scale.equals(vec3(1))) center_pos.mult(scale) ; 
  
    if (v.vert == null) return;
  
    boolean insideContour = false;
    beginShape();
    // for the simple vertex
    if (v.code_vertex_count == 0) {  
      for (int i = 0; i <  v.vert.length; i++) {
        vec3 temp_pos_a = v.vert[i].copy() ;
        //
        if(!scale.equals(vec3(1))) temp_pos_a.mult(scale) ;
        //
        if(!jitter.equals(vec3())) {
          vec3 jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
          temp_pos_a.add(jitter_pos) ;
        }
        //
        if(position_center) temp_pos_a.sub(center_pos) ;
        //
        if(!pos.equals(vec3())) temp_pos_a.add(pos) ;
        //
        vertex(temp_pos_a);
      }
    // for the complex draw vertex, with bezier, curve...
    } else {  
      int index = 0;
      for (int j = 0; j < v.code_vertex_count; j++) {
        vec3 temp_pos_a , temp_pos_b, temp_pos_c ;
  
        switch (v.vertex_code[j]) {
          //----------
          case VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          //
          if(!scale.equals(vec3(1))) temp_pos_a.mult(scale) ;
          //
          if(!jitter.equals(vec3())) {
            vec3 jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_a.add(jitter_pos) ;
          }
          //
          if(position_center) temp_pos_a.sub(center_pos) ;
          //
          if(!pos.equals(vec3())) temp_pos_a.add(pos) ;
          //
          vertex(temp_pos_a);
          index++;
          break;
        // QUADRATIC_VERTEX
          case QUADRATIC_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          temp_pos_b = v.vert[index +1].copy() ;
          //
          if(!scale.equals(vec3(1))) {
            temp_pos_a.mult(scale) ;
            temp_pos_b.mult(scale) ;
          }
          //
          if(!jitter.equals(vec3())) {
            vec3 jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_a.add(jitter_pos) ;
            jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_b.add(jitter_pos) ;
          }
          //
          if(position_center) {
            temp_pos_a.sub(center_pos) ;
            temp_pos_b.sub(center_pos) ;
          }
          //
          if(!pos.equals(vec3())) {
            temp_pos_a.add(pos) ;
            temp_pos_b.add(pos) ;
          }
          //
          quadraticVertex(temp_pos_a, temp_pos_b);
          index += 2;
          break;
          // BEZIER_VERTEX
          case BEZIER_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          temp_pos_b = v.vert[index +1].copy() ;
          temp_pos_c = v.vert[index +2].copy() ;
          //
          if(!scale.equals(vec3(1))) {
            temp_pos_a.mult(scale) ;
            temp_pos_b.mult(scale) ;
            temp_pos_c.mult(scale) ;
          }
          //
          if(!jitter.equals(vec3())) {
            vec3 jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_a.add(jitter_pos) ;
            jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_b.add(jitter_pos) ;
            jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_c.add(jitter_pos) ;
          }
          //
          if(position_center) {
            temp_pos_a.sub(center_pos) ;
            temp_pos_b.sub(center_pos) ;
            temp_pos_c.sub(center_pos) ;
          }
          //
          if(!pos.equals(vec3())) {
            temp_pos_a.add(pos) ;
            temp_pos_b.add(pos) ;
            temp_pos_c.add(pos) ;
          }
          //
          bezierVertex(temp_pos_a, temp_pos_b, temp_pos_c);
          index += 3;
          break;
          // CURVE_VERTEX
          case CURVE_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          //
          if(!scale.equals(vec3(1))) temp_pos_a.mult(scale) ;
          //
          if(!jitter.equals(vec3())) {
            vec3 jitter_pos = vec3().jitter((int)jitter.x,(int)jitter.y,(int)jitter.z) ;
            temp_pos_a.add(jitter_pos) ;
          }
          //
          if(position_center) temp_pos_a.sub(center_pos) ;
          //
          if(!pos.equals(vec3())) temp_pos_a.add(pos) ;
          //
          curveVertex(temp_pos_a);
          index++;
          break;
          // BREAK
          case BREAK:
          if (insideContour) {
            endContour();
          }
          beginContour();
          insideContour = true;
        }
      }
    }
    if (insideContour) {
      endContour();
    }
    // endShape(CLOSE);
    endShape();
  }
  /**
  END BUILD

  */
























  /** 
  MATRIX 
  transformation

  */

  private vec6 matrix_vec(XML xml_shape) {
    if(xml_shape.getChild(0).getString("transform") != null) {
      String matrix = xml_shape.getChild(0).getString("transform") ;
      if(matrix.startsWith("matrix(")) {
        matrix = matrix.substring(6) ;
      }
      if(matrix.endsWith(")")) {
        matrix = matrix.substring(1, matrix.length() -1) ;
      }
      String [] transform = split(matrix," ") ;
      /**
      more about matrix 3x3 > 6
      https://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined
      */

      float a = Float.parseFloat(transform[0] );
      float b = Float.parseFloat(transform[1] );
      float c = Float.parseFloat(transform[2] );
      float d = Float.parseFloat(transform[3] );

      float e = Float.parseFloat(transform[4] );
      float f = Float.parseFloat(transform[5] );
      vec6 m = vec6(a,b,c,d,e,f) ;
      return m ;
    } else return null ;
  }




  private boolean check_matrix(vec6 matrix) {
    if(matrix != null) {
      float a = matrix.a();
      float b = matrix.b();
      float c = matrix.c();
      float d = matrix.d();
      if(a == 1 && b == 0 && c == 0 && d == 1) {
        return false ; 
      } else return true ;
    } else return false ;
  }



  private void matrix(vec6 matrix, vec3 pos) {
    float a = matrix.a();
    float b = matrix.b();
    float c = matrix.c();
    float d = matrix.d();
    // about matrix 
    // http://stackoverflow.com/questions/4361242/extract-rotation-scale-values-from-2d-transformation-matrix
    boolean matrix_bool = false ;
    boolean rotate_bool = false ;
    boolean scale_bool = false ;
    boolean skew_bool = false ;


    if(a == 1 && b == 0 && c == 0 && d == 1) {
      matrix_bool = false ;
      rotate_bool = false ;
      scale_bool = false ;
      skew_bool = false ;
    } else {
      // run matrix
      matrix_bool = true ;

      boolean rotate_case = false ;
      boolean scale_case = false ;
      boolean skew_case = false ;
      if(abs(a) == abs(d) && abs(c) == abs(b)) rotate_case = true ;
      if(a != 1 && b == 0 && c == 0 &&  abs(a) != abs(d)) scale_case = true ;
      if(a < 1 && b > -1 && c < 1 && d < 1) skew_case = true ;

      // rotate case
      if(rotate_case) {
        rotate_bool = true ;
        scale_bool = false ;
        skew_bool = false ;
      // scale case
      } else if(scale_case) {
        rotate_bool = false ;
        scale_bool = true ;
        skew_bool = false ;
      } else if ((a < -1 || a > 1) && (b < -1 || b > 1)) {
        scale_bool = true ;
        rotate_bool = true ;
        skew_bool = false ;
      }
      // skew case
      if(skew_case && !rotate_case && (a != 1 && b != 0 && c != 0 && d != 1) ) {
        skew_bool = true ;
      }
    }

    /**
    matrix case
    */
    if(matrix_bool) {
      float angle = atan(-matrix.b()/ matrix.a()) ; 

      // rotate
      if(rotate_bool && !scale_bool && !skew_bool) {
        translate(pos);
        if(d <= 0 ) {
          angle = angle +PI;
        }
        rotate(-angle);
      }

      // scale
      if(scale_bool && !rotate_bool && !skew_bool) {
        float sx = sqrt((a * a) + (c * c)) ;
        if(a < 0 || c < 0) {
          sx *= -1;
        }
        float sy = sqrt((b * b) + (d * d)) ;
        if(b < 0 || d < 0) {
          sy *= -1 ;
        }

        translate(pos.x,pos.y);
        scale(sx, sy);
      }

      // scale and rotate
      if(scale_bool && rotate_bool && !skew_bool) {
        // rotation
        if(d <= 0 ) {
          angle += PI;
        }
        // scale
        float sx_1 = a /cos(angle);
        float sx_2 = -c /sin(angle);
        float sy_1 = b /sin(angle);
        float sy_2 = d /cos(angle);
        
        translate(pos);
        rotate(-angle);
        scale(sx_1,sy_2);
      }
      
      // SKEW
      // skew / shear is rotate/scale and skew in same time 
      // skew take the lead on every thing, I believe but not sure
      
      // this alpgorithm is not really good, very approximative :(
      
      if(skew_bool && !rotate_bool && !scale_bool) {
        // calcule the angle for skew-scaling
        // scale
        float sx_1 = a /cos(angle);
        float sx_2 = -c /sin(angle);
        float sy_1 = b /sin(angle);
        float sy_2 = d /cos(angle);

        translate(pos);

        shearX(c);
        shearY(b);
        scale(sx_1,sy_2);
        
      }
    }
  }

  /**

  END MATRIX

  */
























  /**
  EXTRACT POINT
  
  */
  
  private void extract(Vertices v) {
    if (v.vert == null) return;
    if (v.code_vertex_count == 0) {  
      for (int i = 0; i <  v.vert.length; i++) {
        vec3 temp_pos_a = v.vert[i].copy() ;
        vertex(temp_pos_a);
      }
    // for the complex draw vertex, with bezier, curve...
    } else {  
      int index = 0;
      for (int j = 0; j < v.code_vertex_count; j++) {
        vec3 temp_pos_a , temp_pos_b, temp_pos_c ;
        switch (v.vertex_code[j]) {
          case VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          vertex(temp_pos_a);
          index++;
          break;
          // QUADRATIC_VERTEX
          case QUADRATIC_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          temp_pos_b = v.vert[index +1].copy() ;
          //
          quadraticVertex(temp_pos_a, temp_pos_b);
          index += 2;
          break;
          // BEZIER_VERTEX
          case BEZIER_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          temp_pos_b = v.vert[index +1].copy() ;
          temp_pos_c = v.vert[index +2].copy() ;
          //
          bezierVertex(temp_pos_a, temp_pos_b, temp_pos_c);
          index += 3;
          break;
          // CURVE_VERTEX
          case CURVE_VERTEX:
          temp_pos_a = v.vert[index].copy() ;
          curveVertex(temp_pos_a);
          index++;
          break;
          // BREAK
          case BREAK:
        }
      }
    }
  }






  /**
  INFO

  */
  public String [] name_brick_SVG (ArrayList<Brick_SVG> list_brick) {
    String [] list ;
    if(list_brick.size() > 0 ) {
      list = new String[list_brick.size()] ;
      for (int i = 0 ; i < list.length ; i++) {
        Brick_SVG b_svg = list_brick.get(i) ;
        list[i] = b_svg.brick_name ;
      }
      return list ;
    } else {
      list = new String[1] ;
      list[0] = "no item in the list" ;
      return list ;
    }
  }
  
  public String [] kind_brick_SVG (ArrayList<Brick_SVG> list_brick) {
    String [] list ;
    if(list_brick.size() > 0 ) {
      list = new String[list_brick.size()] ;
      for (int i = 0 ; i < list.length ; i++) {
        Brick_SVG b_svg = list_brick.get(i) ;
        list[i] = b_svg.kind ;
      }
      return list ;
    } else {
      list = new String[1] ;
      list[0] = "no item in the list" ;
      return list ;
    }
  }
  
  public String [] family_brick_SVG (ArrayList<Brick_SVG> list_brick) {
    String [] list ;
    if(list_brick.size() > 0 ) {
      list = new String[list_brick.size()] ;
      for (int i = 0 ; i < list.length ; i++) {
        Brick_SVG b_svg = list_brick.get(i) ;
        list[i] = b_svg.family_name ;
      }
      return list ;
    } else {
      list = new String[1] ;
      list[0] = "no item in the list" ;
      return list ;
    }
  }
  /**
  END INFO

  */
  

  


















  
  
  /**
  ANALYZE

  */
  private void analyze_SVG(XML target) {
    // catch the header to rebuild a SVG as small as possible to use Processing build PShapeSVG of Processing engine
    header_svg = catch_header_SVG(target) ;


    ID_brick = 0 ;
    String primal_name =("") ;
    String primal_opacity = ("none") ;

    /**
    work in progress for ordering shape




    */
    
    /**



    */
    // style for SVG version 2
    XML [] svg_style = target.getChildren("style") ;

    if(svg_style.length > 0) {
      // new SVG 1.1 version 2
      build_array_style(svg_style[0]) ;
      deep_analyze_SVG(header_svg, true, target, primal_name, primal_opacity) ;

    } else {
      // old SVG
      XML no_style = new XML ("no_style") ;
      deep_analyze_SVG(header_svg, false, target, primal_name, primal_opacity) ;
    }
  }




  private void build_array_style(XML style) {
    String string_style = style.toString() ;
    String [] st_temp = split(string_style,".st") ;
    // remove the first element of the array and the first occurence of each element
    st = new String[st_temp.length -1] ;
    for(int i = 0 ; i < st.length ;i++) {
      st[i] = "st"+ st_temp[i+1] ;
      if(st[i].contains("st"+i)) {
        st[i] = st[i].replaceAll("st"+i, "") ;
      }
    }
    // remove the word style from the last array String
    if(st[st.length -1].contains("</style>")) {
      st[st.length -1] = st[st.length -1].replaceAll("</style>","") ;
    }
  }
  
  private void save_brick_SVG() {
    /* here in the future :
    Save name of SVG, width, height and other global properties
    */
    for(int i = 0 ; i < list_brick_SVG.size() ; i++) {
      Brick_SVG shape = (Brick_SVG) list_brick_SVG.get(i) ;
      saveXML(shape.xml_brick,  saved_path_bricks_svg + folder_brick_name + "_" + i + ".svg") ;
    }
  }

  
  
  
  // Local method
  int rank_analyze = 0 ;
  private void deep_analyze_SVG(String header, boolean style, XML target, String ancestral_name, String opacity_group) {
    rank_analyze ++ ;
    String ID_xml =("") ;
    ID_xml = get_kind_SVG(target) ;

    String [] children_str = target.listChildren() ;
    XML [] children_xml = target.getChildren() ;
    // split XML children



    // build brick XML
    for(int i = 0 ; i < children_xml.length ; i++) {
      if( children_str[i].equals("rect") 
          || children_str[i].equals("line") 
          || children_str[i].equals("polyline") 
          || children_str[i].equals("circle") 
          || children_str[i].equals("ellipse") 
          || children_str[i].equals("polygon") 
          || children_str[i].equals("path")
          || children_str[i].equals("text")
          ) {
        if(check_kind_SVG(children_xml[i])) {
          add_brick_SVG(header_svg, style, children_xml[i], ancestral_name, opacity_group) ;
        }
      } else if(children_str[i].equals("g") ) {
        String new_name = ancestral_name + children_xml[i].getString("id") ;
        if(!style) if(opacity_group == null || opacity_group == "none")  opacity_group = children_xml[i].getString("opacity") ;
        deep_analyze_SVG(header, style, children_xml[i], new_name, opacity_group) ;
      } 
    }
  }
  
  
  
  private void add_brick_SVG(String header, boolean style, XML target_brick, String ancestral_name, String opacity_group) {
    String name = target_brick.getName() ;
    if( name != null && ( name.equals("rect")
                         || name.equals("line")
                         || name.equals("polyline")
                         || name.equals("circle")
                         || name.equals("ellipse")
                         || name.equals("polygon")
                         || name.equals("path"))
                         || name.equals("text")
      ) {
      catch_brick_shape(header, style, target_brick, ancestral_name, opacity_group) ;
    }
  }
    




  /**
  CATCH INFO 
  */
  private String catch_header_SVG(XML target) {
    String s = "" ;
    String string_to_split = target.toString() ;
    String [] part = string_to_split.split("<") ;
    s = "<"+part[1] ;
    return s ;
  }
  
  
  private void catch_brick_shape(String header, boolean style, XML target, String ancestral_name, String opacity_group) {
    Brick_SVG new_brick = new Brick_SVG(header, style, target, ID_brick, ancestral_name, opacity_group) ;
    list_brick_SVG.add(new_brick) ;
    ID_brick++ ;
  }
  /**
  CHECK INFO
  */  
  private boolean check_kind_SVG(XML target_brick) {
    String kind_name = target_brick.getName() ;
    if(kind_name.equals("path")
       || kind_name.equals("rect") 
       || kind_name.equals("line") 
       || kind_name.equals("polyline") 
       || kind_name.equals("polygon")
       || kind_name.equals("circle")
       || kind_name.equals("ellipse")
       || kind_name.equals("text")
       ) {
      return true ;
    } else {
      return false ;
    }
  }

  private boolean check_g_shape(XML target) {
    boolean result = false ;
    if(target.getChild("g")!= null ) result = true ;
    else result = false ;
    return result ;

  }
  /**
  GET
  */
  private String get_kind_SVG(XML target) {
    String kind = "" ;
    if(target.getChild("path") != null ) kind = "path" ;
    else if(target.getChild("line")!= null ) kind = "line" ;
    else if(target.getChild("polyline")!= null ) kind = "polyline" ;
    else if(target.getChild("polygon")!= null ) kind = "polygon" ;
    else if(target.getChild("circle")!= null )kind = "circle" ;
    else if(target.getChild("ellipse")!= null ) kind = "ellipse" ;
    else if(target.getChild("rect")!= null ) kind = "rect" ;
    else if(target.getChild("text")!= null ) kind = "text" ;
    else if(target.getChild("g")!= null ) kind = "g" ;
    else kind = "no kind detected" ;
    return kind ;
  }
  /**
  END ANALYZE

  */
  
  






























  
  /**
  PRIVATE CLASS
  
  */
  /**
  class brick
  */
  private class Brick_SVG {
    private String file_name ;
    private String brick_name = "no name" ;
    private String family_name = "no name" ;
    private String kind = "" ;
    private int ID ;


    // attribut font
    /**
    may be not here but in the class Text with the build method ???
    */
    private PFont font = null  ;
    private float size_font = MAX_INT;
    private int alignment = MAX_INT ;
    // private String sentence = null ;

    private String font_str = null ;
    private String font_size_str = null ;
    private String alignment_str = null ;
    private String font_unit_str = null ;
    /**
    may be not here but in the class Text with the build method ???
    */



    // attribut colour
    private int fill, stroke ;
    private float strokeMitterlimit ;
    private float strokeWeight ;
    private float opacity, opacity_group ;
    private boolean noStroke, noFill ;

    // str
    private String fill_str = null;        
    private String stroke_str = null ;
    private String stroke_mitterlimit_str = null ;
    private String strokeWeight_str = null ;
    private String opacity_str = null ;


    private String clip_rule_str = null ;
    private String fill_rule_str = null ;



    private int width, height ;
    private XML xml_brick ;
    private boolean style ;
    private String built_svg_file = "" ;
   
    Brick_SVG(String header, boolean style, XML brick, int ID, String ancestral_name, String str_opacity_group) {
      this.style = style ;
      this.ID = ID ;
      built_svg_file = header + brick.toString() + "</svg>" ;
      xml_brick = parseXML(built_svg_file) ;
  
      brick_name = get_name(brick) ;
      family_name = ancestral_name + "_" + get_name(xml_brick) ;
      this.kind = get_kind_SVG(xml_brick) ;
      if(str_opacity_group != "none" && str_opacity_group != null) opacity_group = Float.valueOf(str_opacity_group.trim()).floatValue(); else opacity_group = 1.f ;
      set_aspect(brick) ;
    }
  
    public String get_name(XML target) {
      String name = "no name" ;
      if(target.getString("id") != null) name = target.getString("id") ;
      return name ;
    }

    public int get_id() {
      return ID;
    }

    /**
    aspect original
    */
    private void set_aspect(XML target) {
      // catch attribut
      if(style) {
        // style tag from last Illustrator CC
        catch_attribut_by_style(target) ;
      } else {
        // old data from illustrator CS
        catch_attribut(target) ;
      }
      


      // give attribut
      // font size
      if(font_size_str != null) {
        size_font = Float.parseFloat(font_size_str) ;
      }
      // font
      if(font_str != null) {
        String [] fontList = PFont.list() ;
        for(int i = 0 ; i < fontList.length ; i++) {
          if(font_str.equals(fontList[i])) {
            int size = 60 ;
            if(size_font != MAX_INT && size_font > size ) size = (int)size_font ;
            font = createFont(fontList[i], size) ;
          }
        }
      }

      // fill
      if(fill_str == null) {
        fill = 0xff000000 ; 
      } else if(fill_str.contains("none")) {
        noFill = true ;
      } else {
        String fill_temp = "" ;
        fill_temp = fill_str.substring(1) ;
        fill = unhex(fill_temp) ;
      }
      // stroke
      if(stroke_str == null) {
        stroke = MAX_INT ; 
      } else if(stroke_str.contains("none")) {
        noStroke = true ;
      } else {
        String stroke_temp = "" ;
        stroke_temp = stroke_str.substring(1) ;
        stroke = unhex(stroke_temp) ;
      }
      // strokeWeight
      if(strokeWeight_str == null  || strokeWeight_str.contains("none")) strokeWeight = 1.f ; 
      else strokeWeight = Float.valueOf(strokeWeight_str.trim()).floatValue();
      // stroke mitter
      if(stroke_mitterlimit_str == null  || stroke_mitterlimit_str.contains("none")) strokeMitterlimit = 10 ; 
      else strokeMitterlimit = Float.valueOf(stroke_mitterlimit_str.trim()).floatValue();
      // opacity
      if(opacity_str == null || opacity_str.contains("none")) opacity = 1.f ; 
      else opacity = Float.valueOf(opacity_str.trim()).floatValue();
      if(opacity == 1.f && opacity_group != 1.f) opacity = opacity_group ;
    }



    // super local method
    //
    // catch attribut classic SVG version 1
    private void catch_attribut(XML target) {
      fill_str =  target.getString("fill") ;        
      stroke_str =  target.getString("stroke") ;
      stroke_mitterlimit_str =  target.getString("stroke-mitterimit") ;
      strokeWeight_str =  target.getString("stroke-width") ;
      opacity_str =  target.getString("opacity") ;

      font_str = target.getString("font-family") ;
      font_size_str = target.getString("font-size") ;

      clip_rule_str = target.getString("clip-rule") ;
      fill_rule_str = target.getString("fill-rule") ;
    }

    // catch attribut style SVG version 2
    private void catch_attribut_by_style(XML target) {
      String style_id = target.getString("class") ;
      // catch the style in the style list
      String [] id = split(style_id, "st") ;
      // clean white space in the String array, because for the class text there is few style, and there is white space between each one.
      if(id.length > 1) {
        for(int i = 0 ; i < id.length ;i++) {
          if(id[i].contains(" ")) id[i] = id[i].replaceAll(" ", "") ;
          if(i != 0) { 
            int which_style = Integer.parseInt(id[i]) ;
            String my_style = st[which_style] ;
            if(my_style.contains("}") ) {
              my_style = my_style.replaceAll("}","") ;
            }
            if(my_style.contains("{")) {
              my_style = my_style.substring(1) ;
            }

            String [] attribut = split(my_style,";") ;
            // loop to check all component of style
            for(int k = 0 ; k < attribut.length ; k++) {
              if(attribut[k].contains("fill:")) {
                String [] final_data = attribut[k].split(":") ;
                fill_str = final_data[1] ;
              }
              if(attribut[k].contains("stroke:")) {
                String [] final_data = attribut[k].split(":") ;
                stroke_str = final_data[1] ;
              }
              if(attribut[k].contains("stroke-mitterlimit:")) {
                String [] final_data = attribut[k].split(":") ;
                stroke_mitterlimit_str = final_data[1] ;
              }
              if(attribut[k].contains("stroke-width:")) {
                String [] final_data = attribut[k].split(":") ;
                strokeWeight_str = final_data[1] ;
              }
              if(attribut[k].contains("opacity:")) {
                String [] final_data = attribut[k].split(":") ;
                opacity_str = final_data[1] ;
              }
              if(attribut[k].contains("font-family:")) {
                String [] final_data = attribut[k].split(":") ;
                font_str = final_data[1] ;
              }
              if(attribut[k].contains("font-size:")) {
                String [] final_data = attribut[k].split(":") ;
                font_size_str = final_data[1] ;
              }
              if(attribut[k].contains("clip-rule:")) {
                String [] final_data = attribut[k].split(":") ;
                clip_rule_str = final_data[1] ;
              }
              if(attribut[k].contains("fill-rule:")) {
                String [] final_data = attribut[k].split(":") ;
                fill_rule_str = final_data[1] ;
              }
            }
          }
        }
      }
      // clear
      if(font_str != null) {
        if(font_str.contains("'")) {
          font_str = font_str.replaceAll("'","") ;
        }
      } 
      
      // split size and unit type for font
      if(font_size_str != null) {
        if(font_size_str.endsWith("pt")) {
          font_unit_str = "pt" ;
          font_size_str = font_size_str.replaceAll("pt","") ; // * 1.25f;
        } else if (font_size_str.endsWith("pc")) {
          font_unit_str = "pc" ;
          font_size_str = font_size_str.replaceAll("pc","") ; // * 15;
        } else if (font_size_str.endsWith("mm")) {
          font_unit_str = "mm" ;
          font_size_str = font_size_str.replaceAll("mm","") ; // * 3.543307f;
        } else if (font_size_str.endsWith("cm")) {
          font_unit_str = "cm" ;
          font_size_str = font_size_str.replaceAll("cm","") ; // * 35.43307f;
        } else if (font_size_str.endsWith("in")) {
          font_unit_str = "in" ;
          font_size_str = font_size_str.replaceAll("in","") ; // * 90;
        } else if (font_size_str.endsWith("px")) {
          font_unit_str = "px" ;
          font_size_str = font_size_str.replaceAll("px","") ;
        } else if (font_size_str.endsWith("%")) {
          font_unit_str = "%" ;
          font_size_str = font_size_str.replaceAll("%","") ;
        }
      }
    }

    
    
    
    private void aspect_fill(vec4 factor) {
      // HSB mmode
      if(noFill) {
        p5.noFill() ;
      } else {
        if(g.colorMode == 3) {
          p5.fill(hue(fill) *factor.x, saturation(fill) *factor.y, brightness(fill) *factor.z, opacity *g.colorModeA *factor.w) ;
        // RGB mmode
        } else if( g.colorMode == 1 ) {
          float red_col = red(fill) *factor.x ;
          float alpha_col = opacity *g.colorModeA *factor.w ;
          alpha_col = opacity *g.colorModeA *factor.w  ;
          p5.fill(red_col, green(fill) *factor.y, blue(fill) *factor.z, alpha_col) ;
        }
      }
    }

    private void aspect_stroke(float scale, vec4 factor) {
      if(noStroke) {
        p5.noStroke() ;
      } else {
        float thickness = strokeWeight ;
        if(scale != 1 ) thickness *= scale ;
        // HSB mmode
        if(g.colorMode == 3) {
          if(strokeWeight <= 0 || stroke == MAX_INT )  {
            p5.noStroke() ;
          } else {
            p5.strokeWeight(thickness) ;
            p5.stroke(hue(stroke) *factor.x, saturation(stroke) *factor.y, brightness(stroke) *factor.z, opacity *g.colorModeA *factor.w) ; 
          }
        // RGB mmode
        } else if( g.colorMode == 1 ) {
          if(strokeWeight <= 0 || stroke == MAX_INT)  {
            p5.noStroke() ;
          } else {
            p5.strokeWeight(thickness) ;
            p5.stroke(red(stroke) *factor.x, green(stroke) *factor.y, blue(stroke) *factor.z, opacity *g.colorModeA *factor.w) ; 
          }
        }
      }
    }
  }
  

















  /**
  Class Text
  */

  private class ROPEText {
    String shape_name ;
    vec3 pos ;
    vec6 matrix ;
    int ID ;
    String sentence = null ;
  
    ROPEText (vec6 matrix, String sentence, int ID) {
      this.ID = ID ;
      this.pos = vec3(matrix.e, matrix.f,0) ;
      this.matrix = matrix ;

      this.sentence = sentence ;
    }
    
    public void add_value(vec3... value) {
      pos.add(value[0]) ;
    }

    public int get_id() {
      return ID;
    }
  }

  /**
  Class Line
  */
  private class Line {
    String shape_name ;
    vec3 pos_a, pos_b ;
    int ID ;
  
    Line(float x_a, float y_a,  float x_b, float y_b, int ID) {
      this.ID = ID ;
      this.pos_a = vec3(x_a, y_a,0) ;
      this.pos_b = vec3(x_b, y_b,0) ;
    }
    
    public void add_value(vec3... value) {
      pos_a.add(value[0]) ;
      pos_b.add(value[0]) ;
    }
  }



    
  
  /**
  class to build all specific group
  */
  private class Vertices {
    String shape_name = "my name is noboby" ;
    vec2 size ;
    vec3 [] vert ;
    int [] vertex_code ;
    int code_vertex_count ;
    int num ;
    int ID ;
    
    Vertices(int code_vertex_count, int num, PShape p, String mother_name, int ID) {
      this.ID = ID ;
      this.num = num ;
      // not sur we need this shape_name !
      this.shape_name = mother_name + "<>" +p.getName() ;
  
      this.code_vertex_count = code_vertex_count ;
      
      vert = new vec3[num] ;
      vertex_code = new int[num] ;
      vertex_code = p.getVertexCodes() ;
      size = vec2(p.width, p.height);
    }
    
    public void build_vertices_3D(PShape path) {
      for(int i = 0 ; i < num ; i++) {
        vert[i] = vec3(path.getVertex(i)) ;
      }
    }
    
    public vec3 [] vertices() {
      return vert ;
    }

    public void add_value(vec3... value) {
      if(value.length <= vert.length) {
        for(int i = 0 ; i < value.length ; i++) {
          vert[i].add(value[i]) ;
        }
      } else {
        for(int i = 0 ; i < vert.length ; i++) {
          vert[i].add(value[i]) ;
        }
      }
    }
  }


  /**
  Class Ellipse
  */

  private class Ellipse {
    String shape_name ;
    vec3 pos ;
    vec2 size ;
    vec6 matrix ;
    int ID ;
  
    Ellipse(vec6 matrix, float cx, float cy,  float rx, float ry, int ID) {
      this.matrix = matrix ;
      this.ID = ID ;
      this.pos = vec3(cx, cy,0) ;
      this.size = vec2(rx, ry).mult(2) ;
    }
    
    public void add_value(vec3... value) {
      pos.add(value[0]) ;
    }
  }

  /**
  Class Rectangle
  */
  private class Rectangle {
    String shape_name ;
    vec3 pos ;
    vec2 size ;
    vec6 matrix ;
    int ID ;
  
    Rectangle(vec6 matrix, float x, float y,  float width_rect, float height_rect, int ID) {
      this.matrix = matrix ;
      this.ID = ID ;
      this.pos = vec3(x, y,0) ;
      this.size = vec2(width_rect, height_rect) ;
    }
    
    public void add_value(vec3... value) {
      pos.add(value[0]) ;
    }
  }
  /**
  END OF PRIVATE CLASS

  */
}
/**
END OF MAIN CLASS

*/
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "A___rendering_33" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
